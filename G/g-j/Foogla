# Domes prepare to A=A!
$me = 4c&me;
!me and throw "no me";
$io = me.io;

=head1 #prepare to A=A

some goals!!
- efficiently educating on A passage of time
- J to take < 200ms
- not noticing anyway
- Elvising running the shower
- unpatch, failing, patch, passing in a few seconds

=head3 future of sleep: Doming
A starts works, D are their completion

   C   E
 A   D 
   C   C

A C9[C...] completes D and elvises a clone
 D commits Gs, Es swarm T (*/W/*)
  G wants the resources near-ish
  T returns to the desire resolver

D - the Aing grouping items sprout inside
  z C & A to include C/group A workload
  provide osc-like cha/continuity without osc,
    yet be the atomicness osc uses to commit,
    and load with decor/nativities to make for mediation
      R:I is now being the osc workload gatherer + commit
        which should work on >=1 'pages' of osc at a time
          eg elvising from ...
          or the whole/9er
        rolling the others,
        being able to async progress,
          do work in parallel or not...
make unities early to sleep/calculate desires better
  eg. when A is @28, the state can be considered D:early
  eg. when Jpin, S makes domes, which can then be known about
internal buzz. pages of its ground.
  get composited into D:top, C9[C...] post-osc
  which gets hoisted/elvised into J/W timespace elsewhere,
    the macro-J Doming-looking action: hosting stuff.
so to:
  make arbitrary groups
    for groups sake:
      naming stuff
      handling streams
    to stabilise/refine our sense of activity
  transport C out of time,
    so J>7 can help J<7 (sleep)
    osc-think may play with things outside of osc,
     < holds that state in a dome it hopes to pull in?
  locate them as possible actions,
    as bumping into a S-ection kinda defines it
      < more at compile time
    and elvis handlers... 1s&ein.sayeth = &acgts{
  know inputs in a tracable way
    Elvising pointing in here,
      as Teing is
    giving Desire pathways to trace processes

Domes may iterate X/V or some structure from another Dome,
  it may be important to iterate locally and do remotely,
    they become transactions
Desire might want to do something,
as a new elvis pointing into here would
 Teing is a kind of elvising
   and is the float:right upside down triangle of stuff
     the small network-edge pile coming down into
     the big contenty pile of isness
 Schemas too, float their potential/unfoldment
   down holes they start matching

#c sleep/done =head2 sleep tunnel

%slep, a Tool probe
  a way to map their changes fast and sleep
    change of container vs. the values within etc
    can give/take sy&slandige/Ry&Te_slandige
 < could be faster/lessR: callback a huge ==-ish plucker,
    50ms 3%slep could get down to 4ms?
 < unicode everywhere. plants: 💮 🌸 🌷 🌹  🌺 🌻 🌼 🥀  🎕 ⚘ 🏵 🏶  🌱 🌽 🌾  ⸙ 🌰 🌿 🍀 🍁 🍂 🍃  🌵 🌴  🎋 🎄 🌲 🌳
 < Cye takes y=o89 -> ycv=0.089
 < put sdiff and dup etc in 11-ish (dup 1189)
 < C/sc/css compressions, in Line or not
 
Tool openness
  configures injectoids and transfiguration
  < more timely %differ growing out of it
  real interesting later

< Elvisory re-slaning on %push to it?
   is the elvis delivery mechanism:
    give edifice of deliverableness
     resolve to best case or so:
   if it were a different J:
    enter it, changes input to thisJ
    decide to redome thisJ to involve that,
      or seeing our change come back to us
   Matu-ish out-of-time with %push gravitate reruns
  redo R building on changed elvisory?
  see 'rebuild %push to use e'
   %push currently injects the remote %ball%movingin
     which will not work if its asleep
     but it could be brought around about as fast if:
< Te the %moves to Elvisory/anywhere
   with a watch for completion and callback/expiry
< universal vision of rc&ha.dup,
< replace ravel with Doming and Display2
< TEST io.i z much

# another
o rebuild I via Babd ways
 o link G/ to W/G so we can update it ourselves
 o get a Lis rolling nicely
  o tests sign the version as it percolates
o rebuild jsBab in js
 o fast way changes, lots of test results if you want
 o check against jsBabz for j/2/*

o 'rebuild %push to use e'
  %checkout the tangley varieties of %push

o unify name extrusion (see names extruding)
  like X but with where/when to D,
    alt names and fuzzentations (figure name changes)
      inc. crunchable path descriptions in various datalang
    universal gone/unnoticed system

make this data pointer (Cit)
 add %doings that Cit the same way
   and can share refs perfectly,
   showing where internals began
     set free with an everything bisector

good study.
perldoc -f study
# < in general, knowing if the A is for a queue or for right now


#c=head2 Maturation

Gombulus hives elvising going in or coming out
TX
hands need to be projected

o a&z toplevel thinker
  and its localised sidecares
    like AndContinue,
      want J structure reengaged
      A might %waitingfor
  a bunch of R not expecting J overhead
  rebuilding on the Co Joinup (W of W)
    having it bring G (map of its dependencies) (see Give)
      as an %H of a different name
        once osc piles of whatever hoisting is?
          not much doc about osc hoisting:
           the W/of/t may W/what/ever/it/takes/t
           for stats/accounting
  Matu process with %ball
    mapping the mapped into a transform,
      redoing parts, remixing

o and then making a coderupper and way in-outer
  to the rest of the rennovation...
    starting a new page of html,
      built-in and W-contiguous
        the simple funtimes embedded in the page,
        if browser compatible, Wake up and do anything
    I-ing up Sevo, then placing more A-ily,

o names extruding, like X but with:
  connection to a dome:
    where/when they would have emerged (gonerism)
      eg. from the ground, or some picking of Rc&s
        done-ish by %slep
          could describe path or so
    decide once D:in !%more
      D:new == D:old to sleep, or:
      clone D:new to D:out and ...
        becomes someones D:in
          border control
    
o Display2, that goes via X instead of yup:
    traversal iterators that choose a name system to use,
      X is the given base name system

o elvising coming out or going in on the X
  and transacting the change of it
   as Domes, which have versions of Domes going into them
   an osc that keeps everything it sees would be first
    and be the wandering frontiers of change
 
o making the R an A.
  compiling ravel into throat?

fairly slow slow, need:
 more sleep (R to 1/2 and no further) (%slep)
 ongoing bisection of A

then make go fast

and then I land,
  an editor native to
 then A=A

# anyway

back to Pass...

# thursday:
  new A4,
    < starts from a single /js/ with
      one screenful of prior knowledge
    A calmly pulls in its deps, sets foot...
# saturday:
# friday:
  new I compiled fore-way,
    composited and storaged in Pass
    is a layer of tools on a type of wormhole,
     which we also need to grasp moving around
    the bunch of names, Lis
#c monday:!
W&Ha:
  bugs:
    seeI 1.2: is one of the Is Mlimits diags wrong?
    a slep inside a slep has some history issue, keeps spawning?
  W&ledges:
   tests slepology:
     specifically elvis change
   since W&edges is too large
 
 unseparated W&Ha starts taking Rc&N>1000 to check out
  its the elvising:
   < to be lv change only
   < not deLinesing to Wing, wait til Ting
  such shapes par importo A=A
  
W&large_edges:
  W&edges:
   tests slepology:
     wakes on elvis/data change
     %countlife%aTool shows if its awake
     %differ goes round in circles as data loops
   only just able to complete with the current memory leak
   step 9 shows a bunch of yReal vanishing...
   
  toomuch:
   leading to '< %run/%differ' is desire to ease
     accepting changes, to exp or Te
   are both a little far away? would be nice
     but nearly done with tests until A=R round,
     which is likely to see them built more elegant
    - exp: later %doing to bring earlier accepted change
     see %differ. little far away.
    - Te: %doing brings T/$W back if modified
     also a little far away.
     get both diffing,
     the innermost T...%ball that was ==
      cloning that over itself, 
       pointed enough to apply to later %doing
        that wants to resume that state with more
      with a diff/accept stage
       temporarily projected into the %run by %Tool
     Lines|diff must find R per diffchunk
       Bunchology with the diffchunks != new
   will be:
   < linking T/$W -> W:PuTe or W:City:
      T/$W:edges.y.owner = $W:PuTe
       and $W:edges ~ $W:PuTe/$W:edges
      T/$W:City.y.owner = $W:City,
       and $W:edges is further inside, etc
         find refs for $W:City/*
      possibly need more %Lines gathering points
       or a function to gather them on demand
   < diffing T/$W:edges <-> W:PuTe/$W:edges,
     producing R in T/$W that have the change,
      and those that are merely transporting it
        common Lis sense:
          T is species of edges, as is W:PuTe
     so we know the minimum clone-over move to make,
       and what it should be cloning over
         < lv changes later
   < being a pathy clone-in %Tool to apply to later %doings
  
  random niceups
   %testrun=2 'get ahead of %run'
    until %step with boost
   %run: inventstep clones last step
   
   < %City is noisy, we want:
     %slan to turn miniature diff on the noise
      path to the Rthing, lines changed before next Rthing
  
   < %Cit shrinkgrouping known R props
    < group them by the I producing them
     < coder than dictionaries every property you use
   < %Cit visual cues for:
     R:Dough that %Someflav=C:Dough,
       for eg Rs&C = picture of self
      or C.y.Process = R
       things R has may link back to R with typing
   
   and A=R
   
   #   the curves of this paragraph looks great up close:
   #  this is what A:s-ions will look like
   # state changes
   # with casual causla {}
   # along space wiggle
   < %run:
     < using %differ to:
      < cursor various things to keep branchy,
        and hooks to make the test reset/pause properlike
          %differ becoming the time controller,
          %push%act merely a workflow in it
      < %doing brings T/$W back if modified
        probably into $doing/$W (nab%aTool loses %H)
        causing:
      < later %doing to bring earlier accepted change
        eg. PuTe arrangement before every step,
        has the story of elvis along it
        < must be applied as an lv change,
          sensitive to overwriting anything etc.
      < storing lv changes for consecutive %doings
   
#c tuesdA:
new/old ground:
come back to A, they are like R:
  a&z (A.sc.z) are innards, like Rs&z
   only used in A:u
  a&N are innards anywhere wanting attention
   w:TuneTimeMachine gives A to 1s&N
   w:AndContinue: resumes all 3s&N
so 1 can know what A it has in progress...
 AndContinue shall come again
  building W&Lis
  ...
have R that can simply keep Ringing?
 < osc must get us back into whatever Ring:
   init: Ring@1 everything (Graze)
   then: resumes all Is&z
  the cores may fall asleep at random
   and may still percolate a Display anyway
   or lock the dome it was finishing from starting again
see I and repackage:
   A:u makes .I
     mixed from many .I,
     got from /js/
     with async for update/check
   A.4:
    has loop bits, local culture
    .I:
     is everything, mixed up with StyleHut
     .i is all StyleHut,
      figure out what we need to keep
     never goes async, is trusted to be maintained,
     .w:
      has only this %namedcode thing
   A.5:
     looks neglected
     .w:
      is the spot, y&tw for $way
       they s&dige and s&now, G&way asyncs
       want to digwaypoll them, make sync
      all scooped up by Shovel, per test run
       which can make sync prior
I.w is totally incidental,
1s&minds[uname] = A c&N[4s&mind[t]]
 u deals with W via /js/, mixes onto Normal
G&question (and other asyncers) should provide:
  ttl, ready=1 on callback
 to be useful for testing this stuff efficiently

 how it starts:
   html <script> get & eval from /thestart?step=n
    sends it A&loadI and Stylehut
     which includes HutNuts (begoin/jsung)
   G&begoin -> G&jsung,'NutMachine' cb -> G&Jinthe
     jsung looks like A:u but overwrites any A.I[t] = W:of it loads
     Jinthe sets up listeners,
      waylays NutGravy, defines function,
       waylays NutReady, more waylays.
 
 will start:
 < A&loadI a simple A:u@6 etc for basic mind mixing
   gather more mind, global functions, start loop
  should less async, and:
   be totally new ev/e hookup:
    Display:
     lose on.A
      use attr t/cv, attr sip if sJ
      and lookup to the sips of 4s somewhere global
      A.4 must always know about elvising
     lose jQuery,
      moving elements only as needed,
      text inputs not rebuilding every time
   
   ways to keep track of updates...
    make an islanding that can digwaypoll for:
      w change
      W change is regular /W/ with dige...
    know W that contain other W we are watching,
      digwaypoll for notify of W changing?
      could be wired into /W/
       not for the same socket?
     future /W/ storer is an elvising with a route,
      only then demands stringify to get across the net

#c Wednesday
water cactus
very thinning impossibleness:
< s&lv should come from the $main/A.4
   output modes are a T
< frames
 < ifr:blank.html, inject with <script> etc, save
 < the html we build able to serialise most C
   such that search engines will see it
     $Cs&W.html becomes the href=""
     going to build a lot of piles of <stylehouse>
< jsBabz should S to an indent, work in R

W:Pass %ball web surfing
 < keep openness from last time - part of:
   provide autosaved W/T from last time
    these could be tracked separately, likely to be mostly garbage
 < testbedding
   < deps: %Gounce - ghost versioning
     knowing exactly each I it ran with
     making cert to help that Gounce get places in W:Lis
 < %play%W more properly,
     see Be, can play out over time...
       minor %R-ish manage what seems to be a situation
     Rsync %gee%ball late,
      checkout fully, same Ring (T.Rq?)
       see about when %gee hits 92 before children done..?
 
    # between
    #   fio(F...) # f tv
    #   fabioty(p..., # R f is for tv
    #   Rc&X, Rs&Te
    #  we have a few ways to gravitate the elvising made
    # < ad hoc continuity:
    #  < mez&rename (now ballrename) takes Rs&Te
    #  < mez&move should takes Rc&X, in some cases?
    #    if the A of it can be trusted to resync
    # something somewhere in the equation of Waltz
    #  knows exactly why things changed,
    #  holds and spreads knowledge of the move
    #  which may be done out there as:
    #    lv with an el:9, el:6 ?
    #     6 implying recycle the last 9,
    #       or some specific one,
    #       or resurrect recently deleted...
    #      similar logic to:
    #      Lc&responsey - expect one receive per send
    #  requiring all these interations to be suspended
    #  over the judders
    
 %play%R starts:
 %Doming:
   building up how to J(.3)
    < have Swim-ish any index hoisting
       mixing/reducing
        ting Merge.js for J, with W:of
    < ting search in %Doming
      building indexes of I when they are required,
      elvising changes:
    
 ballio, Ravelvis are
 %ios:
  < %balls have io/slep sense
    for intended+not changes
   i wanting to happen
   o happened before
    desire/surprise carrier
    < slep/io <-> what Reaction, batched
      eg /seek/ -> %do_Further()
     < via Sectiona, for an atime iterator of /seek/
   quite to do with:
 < one big %ball,
    < some of it grounded
      there are C from/for Activity (osc-levitated)
      and C for being the sticks in the mineshaft
      < have a CdaR (fast) way to diff %balls to themselves
      whatever it takes
    < getting that change to Rsync %balls,
   < even out of sync, to a degree
    < these ch() comments shall Tool down to
      fleeting speechbubbles, beneath the line
    < tree -> table mode as we cross the line,
      smoky action -> seeing office mode
   
 Mwty
   rearranges modulats
   dressing %ball%fixes for being about ...
   eg the attr on a %Rom messes with the %Doming
    and gave/give each other life
 
 %JRom:
   is separating into %Doming
   
     encapsulates activity, Doming in and outs
     parts have error and (1|4)s&N plumbing
     < T plumbing (see control)
     < pausing if time/sheer Ring intensive
       could control infinite loops in the same Ring
         the first Ring inside 4 should ttl when starting Ring
       for progress, may Ring more, when theres time
         sleeping for Display meanwhile?
           Rc&X will wander, merge the eventual completion
         or osc-ing each section as it completes
           like Doming, wants recode with T sense,
            recording the set of args used, etc
     
     < R:Mapper may also have a little e/Mw on each of many,
       hanging up its thinking amongst others language
       
     < folding, taking %noDisplay off chidlren with activity
   
 %mund: de-lies fact piles
   various eg %Ghostways produce stuff
   they each become a Ghost unto further ...
   
   %Ghostways:
     your version checker
      travel agent
     historically:
   %GhodigWap:
     insures /way/$t against %mundws:digwaypoll
     < tractorbeam $Way into Ghost/Way,
       leaving the hoisting to $Way/5Iw up to mund
       this Ghosts best guess for those ways
       and providing data on dupover, etc.
       and helping lay out ref phylogen
     < G&ting/%ting forcing question/remote check
   
   sidenode:
     everything we n ... in R is really an m Rs&M ...
       unless it Cc&R: spawns R, c.* copied to sc.*
     such is a tubeending
  
   
 #c t!!
 t:
  is thing finding
  t looks up A slope of places with things
  t looks in the dome building now...
   and for A-things around the place
    as A needs to find As to A
     t learning how to traverse every index
  # now:
  G.h(acgtt) does $t subroutine (I.i.h does I.i.$t)
   therein looking for $t becomes:
    G.t(acgt'i't) to avoid infinite h<->t loop
  # future
  B/T stack sensitive
    any call may be paused by a variety of reasoning
  G&lathe,3 Babz:
      G(A,C,T,'lathe',3)
  # or perhaps inlined non-inlined sub calls (no B-stack)
      G.i.lathe(A,C,G,T,3)
  # or totally inlined: ({}-scoped lexicals?)
      s&surface-- for 1..$s;
    this will be handy for generating G&throat
     from the dimensional joint protocols the I use
     these will need variants, as me&Ring is
  
  # lots of lang shall compile to lots of G(...)
  #   anywhere we thing stuff
  G = &ACTs{
      # like G.h
      $G = this;
      $args = arguments.slice(4);
      # simply looking for a function, closest A with it
      $i = is_string s ? G.t(acgt'i',s)
          # looking for something crazy,
          #   may even take args about this call
          #    and beyond, to find the right thing
          : G.t(acgts,[M]);
      B/T stacking {
      T.return = i(A,C,G,T, ... args)
      }
      return T.return
  }
  G.t = &acgtM{
      # like G.ting
      # matches whatever W/C/c in M
      #  sequences of them usu mean by z,
      #  array of arrays for resetting cursor
      # can also mean start doing a thing,
      #  nearby doming invites it to keep state
  }
  # further future:
  Babz realising parameters on things:
  G&$Self$Ne:za,$R$s$c:limin,%vang
  packs in the:
    G.t s={Self,Ne} c={R,s,c} 
     looking for (s) $Self and $Ne
      knowing the act (c) if that helps?
       or would it get confused with more itemology
        spose G could decide on the first being WHERE,
         the others being some extra into
         seems like something for doing subroutine calls remotely
    running it %vang mode with named arguments
     %vang could specify output form,
      a style to apply on something inside (G&tsc)
      some T-condition, error/async continance
      or name the object created
       t looks in the dome building now...
  T-condition,
   check it every B-stack (soon to be a lot of them
   error/async continance
=cut
#c bal/modulat
# %ball suggested into/assumed from s)R%ball
#  how processes create/sync their limbs
#  the s storable, the R waking
me.bal = &acgttsc{
    $R ||= Cy&R;
    isC(s) and $gaveC = 1
    else { c = s; s = null }
    c ||= {};
    typeof c == 'string' and c = G&peel,c
    c.R and R = c.R
    
    # r may exist
    $r = me&ioty,R,'ball',t [0];
    if (r) {
        # < resolve through JRom
        $z = rc&s;
        #z && zs&J and debugger;
        #rs&Inner and debugger
        #r = rs&Inner;
    }
    # will not work <3
    if (c.dropempty && r && !me&ioty,r,'ball' .length) {
        i Rc&s/-rc&s
        return
    }
    
    # create s
    if (!r && !c.dropempty &&
        (!c.maydo || me&rolltog,R,{maydo:t},0 )) {
        # if Acv < ball@3, no r%ball will be there yet
        !c.eph && Rs&ball and s ||= (Rc&s.sc.z||[]).filter(n=>n.t == t)[0]
        # rolling s if !r the next time, eg c.eph unattached
        s ||= me&rollbsc,R,'bal_tw_s/'+t;
    }
    
    if (s && !r) {
        delete c.dropempty;
        ex(c,{t:t,s:s,ball:1,tightly:1});
        r = me&Ret,R,c;
        if (Rs&ball && !c.eph && !Rc&s.sc.z.includes(rc&s)) {
            me&input,R,rc&s
            # < i $R/$r
            # < with ballio
        }
        rc&dupl = 5;
        me&zN,r;
    }
    else {
        ex(r.sc,c)
    }
    if (r && gaveC) {
        R.sc[t] = r;
    }
    
    if (r) {
        ac(R,'balz',r);
        # sort ss&z to order of me&likez
        $li = Rs&balz.indexOf(r);
        $ro = Rs&balz[li-1];
        ro and me&zaft,Rs&z,ro,r
    }
    return r
};

# Rs&z moves t after r
#  if not already somewhere after it
me.zaft = &acgtzor{
    $roi = z.indexOf(o);
    $ri = z.indexOf(r);
    if (roi > ri) {
        z.splice(ri,1);
        z.splice(roi,0,r);
        z[roi] != r and throw "yos"
    }
}

# r moves into modulat n
me.zuct = &acgtnr{
    rs&zuctedto = n;
    # represents s
    delete nc&s;
    fio(n,r);
};
# n (modulat) lifted from some ground into C:t
# < combine with zuck/mez/polify for all-regrouping?
me.modopt = &acgtRmn{
    !n and throw "modopt!n"
    $could = [T.Mw,null,T.nN,Rs&M];
    each it could {
        $M = isar(t) ? t : me&Mw,R,t;
        $ni = M.indexOf(n);
        ni >= 0 and break
    }
    if (ni < 0) {
        # look in named Mw too
        each tM Rs&Mw {
            $ni = M.indexOf(n);
            ni >= 0 and break
        }
    }
    if (ni < 0) {
        # and where n ... go if there's no T.nN to catch them
        M = A.ground.sc.z
        ni = M.indexOf(n);
    }
    ni < 0 and throw "n not fground", could
    M.splice(ni,1);
    return fio(m,n.t,n);
};
# me&tsc into another modulat
me.mtsc = &acgtmtsc{
    $R = Cy&R;
    $n = me&tsc,t,s,c;
    me&modopt,R,m,n;
    return n
};
# i $g/#$k/$d
me.givi = &acgtgktd{
    isC(t) and d = t; t = d.t
    $hi = fio(g,k);
    $b = fio(hi,t,0);
    if (k == 'history') {
        # puts new top on history
        b and ac(d,'z',b);
    }
    return fio(hi,t,d);
}
#c modulata groupology/Km/Kn/label, sizo
# the usual hierarchy:
# top/groupr(r(gk))/groupology()/grouping(Km)/groupthing(Kn)acgttc
# all openable
# < each a -pi some other time

# usual display case, for gy&can o,i,c
me.case = &acgtt{
    isnu(t) and $cv = sca(t); t = null
    $g = me&opeolo,t||'Z';
    gy&cv = cv || 0.7;
    gs&dis = 5;
    gy&label.sc.dis = 0;
    # this is for some css subtlety
    $p = g;
    g = gy&can('w','aving');
    gy&notifempty = &{
        !(gs&z||[]).length and p.c.not = 1;
    };
    gy&up = p;
    return g;
};

# construct some types
me.opewires = &acgtg{
    gy&can = &kyc{
        c ||= {};
        $sc = {};
        isst(c) and sc = G&peel,c
        $styling = &d{
            sc.s and dc&s = delete sc.s;
            ex(d.sc,sc);
            return d;
        };
        if (isst(k)) {
            if (y == null) {
                # make serial without title
                gy&can_i ||= 0;
                gy&can_i ++;
                y = k+'&:'+gy&can_i;
            }
            k == 'm' and return me&opeKm,g,y,c
            else
            k == 'n' and return me&opeKn,g,y,c
            # table-row
            elsif (k == 'w') {
                $d = me&opeKn,g,y,c
                ds&dis = 3;
                styling(d);
                return d
            }
            # middle floating inline-table
            elsif (k == 'r') {
                $d = me&opeKn,g,y,c
                ds&dis = 5;
                ds&va = 1;
                styling(d);
                return d
            }
            # middle floating cell
            elsif (k == 'o') {
                $d = me&opeKn,g,y,c
                ds&dis = 4;
                ds&va = 1;
                styling(d);
                return d
            }
            # cell
            elsif (k == 'c') {
                $d = me&opeKn,g,y,c
                ds&dis = 4;
                styling(d);
                return d
            }
            # symbol
            elsif (k == 'i') {
                $d = me&opeKm,g,y,c
                delete ds&bo;
                styling(dy&label);
                return d
            }
            else
            k == 'nu' and return me&openu,g,y,c
            else 
            g.sc[k] and return y (g)
        }
        else {
            # < generate something
            me&tsc,"Elvis.."
        }
    };
};
# the doctor probe
me.openu = &acgtgtsc{
    isob(t) and s = t; t = 'nu'
    $nu = me&nu,t,s;
    $gu = gy&can('n');
    me&zuct,gu,nu;
    nuy&Km = gu;
    return nu
}
# the general displayable
me.opeolo = &acgttc{
    $R = Cy&R;
    c ||= {}
    
    # t can be implied from or takes over T.Mw
    if (isob(t)) {
        # isob() allows hash that is C, isha() doesnt
        isC(t) and t = t.t
        else c = t; t = null
    }
    t ||= T.Mw || C.t
    !T.Mw and T.Mw = t
    
    c.walls ||= 1
    $g = me&opeology,t,c
    
    # puts it somewhere in particular
    c.se and ac(c.se,'z',g)
    else {
        # or just in R%M...
        me&Mw,R,T.Mw .push(g)
    }
    
    return g
};

#c groupology, openable
me.opeology = &acgttc{
    $R = Cy&R;
    c ||= {};
    $g = G&Cye,[t,2,{},'hue:30'];
    c.se and gy&up = c.se
    c.walls == 1 and c.walls = 'bd:2.2h5'
    me&applystylec,g,c,{};
    me&opelabel,g,c.label;
    me&opewires,g;
    return g;
};
# grouping (Km), openable
me.opeKm = &acgtgtc{
    $R = Cy&R;
    c ||= {};

    $Km = fio(g,t,[t,1,{},'grouping,ma:0.3,fs:8']);
    Kmy&up = g;
    me&applystylec,Km,c,{walls:'bd:1.4,hu:3'};
    me&opelabel,Km,c.label;
    me&opewires,Km;
    Kmy&up = g;
    return Km
};
# groupthing (Kn)
me.opeKn = &acgtgtc{
    $R = Cy&R;
    c ||= {};
    $Kn = fio(g,t,[t,1,{},'groupthing,ma:0.3,hue:-50']);
    Kny&up = g;
    me&applystylec,Kn,c;
    c.label and me&opelabel,Kn,c.label;
    me&opewires,Kn;
    Kny&up = g;
    return Kn
};


# applies tsc/walls as per c or d(efault)
# < use for rolltog taking .tsc, 
self.peel ||= &s{ return !s ? {} : G&peel,s }
me.applystylec = &acgtncd{
    d = ex(peel(d),peel(c))
    d.tsc and me&tsc,n,0,d.tsc
    d.walls and me&walls,n,d.walls
    # inherits
    $g = ny&up
    !g and return
    gy&togcon and ny&togcon = gy&togcon
};


me.opelabel = &acgtgc{
    c == 1 and c = {}
    c ||= {};
    c.tsc ||= 'y'
    c.opeg ||= 1;
    return gy&label = me&vlabinto,g,c
};
# vertical label in g
me.vlabinto = &acgtgc{
    $R = Cy&R;
    c ||= {};
    # qualify up g
    # see -brackology, i $g/$label
    if (gy&togcon) {
        $qc = {}
        # display name
        qc.s = c.s || g.t
        c.tsc and qc.tsc = delete c.tsc
        # q's name relativity to g:
        qc.may = 'label'
        # more name, g/q made
        q = gy&togcon(g,qc)
    }
    elsif (c.tog) {
        # GOING - from &brackope
        # < cbub(s,Rc&s) that always returns something, up to Rc&s
        $name = [];
        me.cby(g,s => name.unshift(s) && s == Rc&s)
        name = name.map(n => n.t) .join("_");
        $qc = {name,may:'label_'+name,s:c.s||g.t}
        c.tsc and qc.tsc = delete c.tsc
        q = c.tog(g,qc)
    }
    else {
        # GOING? widely not togcon yet
        # < cbub(s,Rc&s) that always returns something, up to Rc&s
        $name = [];
        me.cby(g,s => name.unshift(s) && s == Rc&s)
        name = name.map(n => n.t) .join("_");
        $qc = {name,may:'label_'+name,s:c.s||g.t}
        c.tsc and qc.tsc = delete c.tsc
        
        $ope = me&rolltog,R,qc
        q = qc.n
        qs&ope = ope
        me&modopt,R,g,q
    }
    qy&cv = 0.12;
    if (c.opeg) {
        # g/q%label%ope -> g%ope
        gs&ope = qs&ope
        # open labels enlarge the Km
        if (qs&ope) {
            $Km = me.cbub(g,'grouping');
            Km and delete Kms&fs
        }
    }
    # styles the vertical text, not the spacer it's in
    me&applystylec,qy&label||q,qc;
    me&opewires,q;
    return q
};


# size of anything control
# < link to iteration of V(iew)
me.opesizup = &acgtgc{
    c ||= {};
    c.opeif1 = 1;
    return me&sizo,g,c;
};
me.sizo = &acgtgc{
    $R = Cy&R;
    c ||= {};
    $ope = c.opeif1 && c.len == 1
        || c.opelen && c.len <= c.opelen;
    ope and ope = 1
    ope && gs&ope < ope and gs&ope = 1; return
    $t = c.t || 'size';
    $s = fio(g,t);
    ss&label = 1;
    c.len != null && c.len != 1 and sc&s = 'x'+c.len; gc&size = c.len
    return s
};

#c waits for...
# puts modulat talking of %waits
me.waits = &acgttsc{
    isC(t) and throw "&waits,t,s,c"
    $R = Cy&R;
    !s and s = t
    # < this style could be all we need
    c ||= {}
    typeof c == 'number' and c = ""+c
    if (typeof c != 'object') {
        c.length == 1 and $tsc = c; c = {}
        else
        typeof c == 'string' and c = G&peel,c
    }
    c.tsc and $tsc = delete c.tsc
    
    $n = me&tsc,t,s,tsc;
    c.waits ||= 1;
    ex(n.sc,c);
    T.act and ny&act = T.act
    $wm = Rs&waits_modopt;
    wm and me&modopt,R,wm,n
    ac(R,'waits',n);
    return n
};

# checks R's modulat talk for %waits
# < named waves of
me.beready = &acgtRk{
    $Mw = k || '';
    $N = me&Mwty,R,Mw;
    $Nx = {};

    # %acty:1 starts things, %acty:8 opens dialectic
    N = arou(N,'acty',Nx);

    # everything %waits is important
    # everything else is an error
    Nx.err = arou(N,'waits',Nx);
    delete Nx.err;

    each kv Nx {
        !v.length and delete Nx[k]
    }

    # is ready
    !(Nx.waits || Nx.err) and return 1
    # or not

    if (Nx.waits) {
        $situ = "waits("+Nx.waits.length+")";
        $ope = me&rolltog,R,{may:situ,acty:8,tsc:'y'};
    }

    if (ope || Nx.err) {
        me&zu,'Nx',Nx
        each in Nx.waits {
            me&zu,n
        }
    }
}

#c Graze
# waltzing stringpasses,
# part of A:s:C, the C way to oscillate
#    C.y.R = R:C
#   sprouts some sc to R:$gk or so
# < determine, certify version of etc involved
# we have a village's machinery for progress
# < teleporting in: knowing you want such sleep pattern
#    for vibrating values (oscillation)
me.Graze = &acgts{
    # cdar extendor
    # all of them Jround here S variously, lay out trees,
    # to mix the top based on the particulars
    $N = sc&N;
    $h = N[0];
    
    # R motif leads to P, leads to R...
    # spring forth
    # happenings by the 9 for the Cs
    $swims = {oph:0};
    $swim = &Rtc{
        # on the 9's A:of
        $V = swims[t] ||= me&Reis,h,t,null,{ov:0.18};
        # a pile of input
        $r = me&Ret,V,ex(c||{},{t:R.t});
        me&zN,r;
    };
    
    hc&s != C and throw "hcs !C"
    each iR N {
        $C = Rc&s;
        Cy&R = R;
        
        #   yonder Displayers must y&up=R also getting Displayed
        #   to hang it on the screen
        Rc&inC = R;
        
        # for originals
        each tc swims {
            $of = C.sc[t];
            !of and continue
            swim(R,t,{selfer:C})
        }
        # and via Js
        if (0) {
        each tc swims {
            continue
            $J = s&J;
            !J and return
            $op = Js&top || Jc&s;
            !op and return
            each in ops&z {
                nc&W != t and continue
                swim(R,t,{other:Rc&s})
            }
        }
        }
        
        s&unknown and me&sunknown,R
        else
        s&Cray || s&sun and me&Reis,R,'Cray',c&s
        else
        s&ravel and me&Reis,R,'ravel',C
        else
        s&rovo and me&Reis,R,'rovo',C
        else
        s&Rdeal and $r = me&Rdeal,R;
        else
        s&Ring and me&Reis,R,s&Ring,C
        
        #1s&vigua and me&sunknown,R,1s&vigua; delete 1s&vigua;
        #me&Rdealings,R,r; me&Rdealings,R,R
    }
    each ir swims {
        !r and continue
        delete rs&ov;
        me&Ring,r
    }
};
#c oph the coder
me.oph = &acgtR{ return [
    ... me&Displayingness ,
    ['selfer','2',&acgtRs{
        $h = Rc&N[0];
        $Swim = hs&Swim ||= {};
        
        s = Rs&selfer;
        $I = Swim[ss&oph] ||= {};
        $z = I[s.t] ||= [];
        s.y.cv ||= 0.1;
        # only cv sorts
        me&sortin,z,s;
        $zi = z.indexOf(s);
        if (zi-1 >= 0) {
            $ot = z[zi-1];
            if (ot.y.cv == s.y.cv) {
                Rs&overwrites = ot;
                z.splice(zi-1,1);
                me&tsc,'overwrites','<'+ot.t;
            }
        }
        Rs&selfed = 1;
        # there is also an %other for things coming via a J
        # self would always overwrite 
    },'ift,D'],
    ['Swim','3',&acgtRs{
        s&mb = 2;
        $D = G&Cye,[R.t,''];
        each fc Rs&Swim {
            $F = G&Cye,[f,{cv:0.001},{W:R.t}];
            ac(D,'z',F);
            each tz c {
                each in z {
                    ac(F,'z',n);
                }
            }
        }
        Rs&Swimb = me&Copy,R,D,{Lines:3} .c.s;
    },'ift,D'],
    ['Swimb','4',&acgtRs{
        $S = Rs&Swimb;
        me&rollbs,R,'indige';
        Rs&indige && Rs&indige == Ss&dige and me&rollbs,R,'Swum'
        if (!Rs&Swum) {
            Rs&indige = Ss&dige;
            
            # < send S to the server
            # it will W=oph and encode all this stuff
            $f = Ss&z[0].sc.z[0];
            fc&s += "\nstamp";
            
            Rs&Swum = S;
        }
        # attach to the 9
        $p = Ry&up;
        ps&task != 'C' and throw "lst"
        $s = pc&s;
        each iF Ss&z {
            $F = G&Cye,F;
            $N = delete Fs&z;
            each iD N {
                i $s/$F/$D
            }
        }
    },'ift,D'],
    ['She','7',&acgtRs{
        Rs&rowish = 1;
        
        $p = Ry&up;
        ps&task != 'C' and throw "lst"
        $s = pc&s;
        #n so  $self:s,R %sun
    },'if:h,D'],
] };
#c Be.C - group C.*.*
# see %Cit/KnowC and Pavings/CB_load
# < I, a W of qualities and how to use them
$Be = me.Be ||= {};
# < more C
Be.C = {};
Be.C.index = {
    scgk:'tw,We',
};
Be.C.Cit = {
    scgk:'Cit,fromsitop,scan',
};
Be.C.R = {
    ygk:'R',
    cgk:'d,N,X,V,refs,refR,inC',
    scgk:'X,ci',
};
Be.C.SC = {
    ygk:'supr,s',
    cgk:'',
    scgk:'',
};
Be.C.Rlimits = {
    cgk:'dupl,nl,dl,dubquiet',
    scgk:'boost',
};
Be.C.Rplay = {
    scgk:'boost,Te,playsheet,elvis',
};
Be.C.History = {
    cgk:'b,V',
};
Be.C.Display = {
    scgk:'C,Mw',
};
Be.C.fun = {
    scgk:'tightly,inheritsc',
};
Be.C.in = {
    ygk:'in,tw,tv',
    scgk:'z,Wind',
    sc: {
        Wind: {path:'t,dige'}
    },
    wanderin:'together',
};
Be.C.space = {
    ygk:'cv,ov',
    cgk:'cv,ov',
};
Be.C.W = {
    scgk: 'dige',
};
# how to include it
Be.C.inc = {
    scgk: 'el',
};
# %ting|%Pave configurables
Be.C.ting = {
    scgk: 'ting,Paving,directory,species,args,section',
    # dont need to %ting=W at the top?
    scdefault: {ting:'W'},
    # %tings nest to imply structure,
    #  these sc inherit from above
    # < cause Ravelvis to recreate if changed
    #   eg %ting must start fresh to add %directory
    scinherit: 1
};

Be.nks = 'y,c,sc'.split(',');
me.BeCload = &{
    each K,Kc Be.C {
        Kc.K = K;
        each ik Be.nks {
            k += 'gk';
            !Kc[k] || typeof Kc[k] != 'string' and continue
            Kc[k] = Kc[k].split(',');
        }
    }
};
me&BeCload;

#c Beings arrive, find C.*.*
me.Bear = &acgtRsk{
    k == 'play' and Be&plays,R,s
    else
    Rs&ball and Be&lums,R,s
    else
    Rs&fix and Be&fix,R,s
    else {
        throw "No Bearing"
    }
};

# 27%play via %playsheet
Be.plays = &acgtRs{
    Be&scan,R,s
        .map(q => Be&cutch,R,q )
        .map(D => Be&playit,R,s,D );
};
# 3%ball sprawls out
Be.lums = &acgtRs{
    Be&scan,R,s
        .map(q => Be&cutch,R,q,{ohm:1} )
        .map(D => Be&lumit,R,s,D )
};
# 3%fix is a thing
Be.fix = &acgtRs{
    $p = Ry&up;
    # Be: inherits from %ball's lumit
    #  via %BeX.xtk[$sc][$gk].exRsc.BeD = fixit's D
    #    < should also know lumit's D
    ps&BeX and Be&BeXarrive,R,s,[R.t,'fix']
    $D = Rs&BeD;
    #  or %Be[$sc][$gk] = lumit's D (GOING)
    $be = !D && Be && ps&Be;
    be and D = be[Rs&fix] && be[Rs&fix][R.t];
    # may %viewvia=ki|size to gkness
    # and %inputmode
    # < %fix%play should grow the meaning etc
    D and Be&fixit,R,s,D
};

# Be about here.*.*
Be.scan = &acgtRs{
    $M = []; # q+
    each kt Be.sc {
        !hak(s.sc,k) and continue
        M.push({tatch:t,nk:'sc',gk:k})
    }
    each kt Be.y {
        !hak(s.y,k) and continue
        M.push({tatch:t,nk:'y',gk:k})
    }
    return M
};

# makes D for q, thing attachment mode specifics
#  D also gets how to act
Be.cutch = &acgtRqc{
    $D = G&Cye,[q.tatch,5,c||{}];
    !D.t and throw "!t"
    # sc from matching
    q and ex(D.sc,q)
    # c from matched, the how
    Be[D.t] and ex(D.c,Be[D.t])
    # known properties on %ball%Be
    if (Ds&nk && Ds&gk) {
        # < Rc&X.Be.nk_gk for:   and Dc&b...
        $be = Rs&Be ||= {};
        be = be[Ds&nk] ||= {};
        be[Ds&gk] = D;
    }
    return D
};

    #c BeX getting a %ball/me&lumit's Be-ing to a %fix/me&fixit:

# set properties of children that don't exist yet
# see RbitX
Be.BeX = &acgtRsD{
    each kc Dc&BeX {
        $name = D.t+' '+k;
        k = k.split('%');
        $t = k[0];
        k = k[1];
        # cousin of R.c.X/V
        $X = Rs&BeX ||= {};
        $tk = X.xtk ||= {};
        tk[t] ||= {};
        $oX = tk[t][k] ||= {};
        # where .x=[more R.t],.xtk=[more nk/gk]
        # and non-path things apply to the arriving R
        $sc = oX.exRsc ||= {};
        # rogue generation of D
        # < use cutch, make complicated Be[t]s
        sc.BeD = G&Cye,[name,5,c];
    }
};
# X.xtk = R.t, R.sc gk
Be.BeXarrive = &acgtRsl{
    $p = Ry&up;
    $X = ps&BeX;
    !X and return
    # walk a path of x to X
    $x = X.xtk;
    each in l {
        x = x[n];
        !x and return
    }
    Rs&BeX and throw "Already at RsBeX"
    Rs&BeX = x;
    # check in
    x.z ||= [];
    x.z.indexOf(R) < 0 and x.z.push(R)
    # apply
    x.exRsc and ex(R.sc,x.exRsc);
}



#c Behave from C.*.*
# localises & applies Dinstructions

Be.playit = &acgtRsD{
    !Rs&ball and throw "What"
    Dc&play and Dc&play(A,C,G,T,R,s)
    else {
        # vaguely know it, not a c&play-er
        # < later check some Be used the %play
        # < thing's sc wants upgrading mode
        me&tsc,"!play:"
    }
};

# R%ball
Be.lumit = &acgtRsD{
    # symbol blocks the way, and leads on
    $c = {k:'clicktoplay',y:&v{
        me&introqua,R,{play:v}
    },Mw:'Be',tsc:'T',relax:1};
    me&rolltog,R,c;
    $n = c.n;
    
    nc&s = Ds&gk;
    Dc&symbol and nc&s = Dc&symbol
    nc&s.length > 5 and Dc&symbolsize ||= -5
    Dc&symbolsize and ns&fs += Dc&symbolsize
    
    # c&nofurther - stop adding R under this one
    #  recursion control
    Dc&exRc and ex(R.c,Dc&exRc);
    $p = Ry&up;
    each kc Dc&ps_Dc {
        p.sc[k] and ex(D.c,c)
    }
    Dc&BeX and Be&BeX,R,s,D
    
    # %play things tend to hide/represent in-%balls
    Dc&ohm && Dc&play and Dc&hbb ||= 1
    # otherwise it costs 1 boost
    # < consumable if Tie remembers
    !Dc&ohm || Rs&boost > 0 and 'open'
    else {
        # tend to hide every R inside...
        !Dc&hbb and Rs&nofurtherDisplay = 1
        # very high level view of what else scans interesting
        ss&z &&
        n withz  s:z %fs:14,hs:966
    }
    Dc&hbb and Rs&hideballsballs = 1
    # do more display?
    # look up for a qua ac?
};

# R%ball r%fix
Be.fixit = &acgtrsD{
    $R = ry&up;
    !rs&fix and throw "What"
    !Rs&ball and throw "What"
    # apply styles to r%fix
    $st = 'inputmode viewvia'.split(' ');
    each in st {
        !D.c[n] and continue
        r.sc[n] = D.c[n];
    }
    # < symbol's styles fitting into %fix n t
    #     might be too complex to read
    #       sprout as necessary
    if (Dc&play) {
        # can %play sometimes (via the %ball)
        # likely to show %fix t/s?
        #s == '1' and me&tsc,'onething','=1'
    }
};

#c Bersonality of C.*.*
# effect C representation
# known properties may ... (%ball%play)
Be.sc = {};
Be.y = {};

# s&H
# stored object
# < boostrap from H:1
# < know exactly where it is (/G/*)
# < know history of it across history of s
# < history of s vs. history of R, getbetween.
#   values exist somewhere fractionable in Domes,
#   pinned down every so often from various angles
#    levels and resolutions, compromises
#   simply have to play lv in reverse, watching path
#    lv must play from an el<3
#    to know it has everything in the situ,
#     which could be localised to part of the path
#     < lv requests should serve grep into paths
#       thence almost-Lines wants to end up in a database
Be.sc.H = 'sH';

# s&quiet
# eg a Js&Te doing usual work
Be.sc.quiet = 'squiet';
Be.squiet = {symbol:'q'};

# y&lv
#  boundary to a done thing that will join to us
#  eg. your %Lines hoists the s.y.lv as itself
Be.y.lv = 'ylv';
Be.ylv = {symbolsize:-2,exRc:{nofurther:1}};

# s&of
# code, generally compiles, /\n$/
Be.sc.of = 'sof';
Be.sc.js = 'sof';
# sets up openable codon on s%fix
Be.sof = {BeX:{
    's%fix':{inputmode:2,viewvia:'size'}
}};
# sets up openable codon on s%fix
Be.sc.string = 'sstring';
Be.sstring = {ohm:0,BeX:{
    'string%fix':{inputmode:2,viewvia:'size'}
}};

#c Beeple of C.*.*, proto s&R
# s&W
# < opens that Wormhole in the nearest %gee
# < located around here:
#    i ^^%gee/$W y o ^^/G/$W
#     then %gee late Rsync,
#      so openness can occur in this ev'd Ring
#   this would be the stately G&ting
#    5 could know all the W we use
#   iter `dig`
#   < hostinfo
# < as another J,
#   managing pause/sleep modes of them
Be.sc.W = 'sW';
Be.sW = {play:&acgtRs{
    # becomes signpost leading in
    $l = me.cbu(R,'gee');
    ls&openness.push(R);
}};

# s&J
# probably a J:1,
# make W from the elvisory
Be.sc.J = 'sJ';
Be.sJ = {play:&acgtRs{
    ss&J != '1' and throw "nonJ=1"
    # feeds with e
    me&Ravelvis,R,s.t;
    # < unDoming
    ac(R,'unplaycb', &{ me&Ravelvis,R,s.t,9 })
}};

# s&testrun
# does a test via W:Co
# < elvise it
Be.sc.testrun = 'stestrun';
Be.stestrun = {play:&acgtRs{
    $l = me&push,R,['/','T'],[],'run',{does:'TeCo'};
    Rs&Te && Rs&Te.sc.almost and ls&almost = 1
    me&introqua,l,'boost:2','@1'
}};

#c Beepingness
# %play engaged tasks
# Doming & Beeping will separate
#   Beeping has empirical noise,
#   particulars have idealism or more noise
#   toward being a network stack
me.Beepingness = &acgtR{ return [
    ... me&KnowCitingness ,
    ... me&Tingingness ,
    ... (me.Tongingness ? me&Tongingness : []),
    ... me&Socketingness ,
    ... me&Domingness ,
    ... (me.Fourismness ? me&Fourismness : []),
#c %garbec
=pod
garbec%R: garbage collect localStorage
 , regex for %W and %H
  < know %parent, ship everything off to a git
   < as a %Gensing?
     with an %H/differer for the current state of it
     but just be an R, opening bits of net puzzle
     posit deletables, do one last grep for their %H
   good for up to 5MB?
   %H:
     any non-W chunk, storage t=dige -> string from Lines
     must %Lines encode H:... for regex
     < Lines could have many sc, keep first clean looking
   < %H may all hoist to the top, as in w:Writer/Gversioning
     would look like %Has:0294u390;34ui902d;345u209u3;3u8490j
=cut
    # boost <0 to rescan. >0 to delete
    # < bright future of the backroom
    # < for the enclosing %gee
    ['garbec','3',&acgtRs{
        Rs&rowish = 1;
        s&bo = '1px dotted green';
        s&hue = 70;
        s&br = 1;
        
        #Rs&somehash = window.fogive ||= ex({},localStorage);
        Rs&somehash ||= localStorage;
        
        (Rs&boost||0) < 0 and 'rescan'
        else
        me&rollbs,R,'figure' and return
        n Pass  R %garbect,viaW
    },'ift,D'],
    ['garbect','3',&acgtRs{
        Rs&noDisplay = 1;
        me&tsc,'nothing';
        $k = R.t;
        $g = me.cbu(R,'garbec');
        # < use $k=Rc&s and Rc&refs to dedup
        $te = gs&garbect_t ||= {};
        te[k] and return
        te[k] = R;
        # order importo par stat hoist
        ac(g,'garbectN',R);
        # read
        $v = gs&somehash[k];
        !v and return Rs&err = "No "+k
        
        $l = v.split("\n");
        each in l {
            # < using Wm[3]: where the match started
            #   and showing the path through this place
            #   %garbect are places/storage points/gravity wells
            $Wm = n.match(/(H):(\w+)\b/);
            if (Wm) {
                $H = Wm[2];
                n $H  R %garbect
                continue
            }
            # the s&W usually 1, encodes to just 'W'
            #  otherwise it's a different W this one must accompany
            #  eg %of is required (eventually) to wake up code
            $Wm = n.match(/^\s+(\w+)\t.*\t\bW(?::(.+))?\b[^\t]*$/);
            if (Wm) {
                $t = Wm[1];
                Wm[2] and continue
                # ^ of W:lobbek's %oph'ing, We thing s%W:oph/
                n $t  R %garbect,viaW
            }
        }
    },'ift,D'],
    ['garbectN','6',&acgtRs{
        $te = Rs&garbect_t;
        Rs&figure and throw "garbectN + figure"
        $d = Rs&figure = {};
        d.to = 0;
        d.total = 0;
        d.disco = [];
        d.discotal = 0;
        each kv localStorage {
            d.to++;
            d.total += v.length;
            te[k] and continue
            d.disco.push(k);
            d.discotal += v.length;
        }
        $N = Rs&garbectN.slice().reverse();
        # < size of Ws sans in-Ws?
        each ir N {
            rs&err and me&tsc,"err",r.t+"_err:"+rs&err
        }
    },'ift,D'],
    ['garbec','7',&acgtRs{
        $d = Rs&figure;
        !d and throw "!figure"
        
        each kv d {
            typeof v == 'object' and v = v.length
            n t  $s:k %hs:999
            typeof v == 'number' && v > 1000 and v = G&sca,v*0.000001 +'mb'
            n s  $s:v
            n sp  s:\n
        }
        
        # delete the disconnected
        # < check it's a %H-type key,
        #    deleting W should be harder,
        #    but we can't really tell...
        # < know what hist
        if ((Rs&boost||0) > 0) {
            delete Rs&figure
            each ik d.disco {
                # check they exist
                !Rs&somehash[k] and throw "to delete, no: "+k
            }
            each ik d.disco {
                delete Rs&somehash[k]
            }
        }
        delete Rs&Te.sc.boost;
    },'ift,D'],
#c t/%lvhashave
# test Element replacement with minimal add/remove
    ['lvhashave','3',&acgtRs{
        Rs&rowish = 1;
        s&bo = '7px dotted green';
        s&hue = -70;
        
        $td = [
            'jus fibre g/twas jus fibre g',
            'jus g/twan jus',
            's van to dich/ze van dich toat to',
            'toad transfer lich/fur lich trom toad',
            'sle sla van to dich/sla van sla dich sla toat to',
            'further towards ye goal goal/no further goal shall goal ye',
            'test data shall/test shall gall data',
            'test to nuf fla flong/fla test flo flong to nuf',
        ].map(&s{ return s.split('/').map(&s{
                return s.split(' ')
            }) });
        
        
        each in td {
            $got = n[0];
            $exp = n[1];
            
            $D = G&Cye,["case_"+i,''];
            Ds&got = got;
            Ds&exp = exp;
            Ds&V = 1;
            #exp[0] == 'fur' and V = 2;
            
            # 6
            me&lvhashave,D;
            
            # 7
            $space = ' ';
            each in Ds&cha {
                $tn = Ds&actN[i];
                tn = tn ? tn.join(' ') : "?";
                me&tsc,'elementing',n,'1b'
                me&tsc,'elementfunc','@'+space+tn,'1q'
            }
            
            
            if (!Ds&actN || Ds&fail_elementing) {
                me&tsc,'started',got.join('-'),'1d';
                me&tsc,'exp',exp.join('-'),'1p';
                me&tsc,'element',Ds&lvd.join('-'),'1b';
            }
            else {
                me&tsc,'elementingok','OK.elementing',1
            }
            
            if (!Ds&have || Ds&fail_brute) {
                me&tsc,'output',Ds&have.join('-'),'1p'
            }
            else {
                me&tsc,'outputok','OK.brute',1
            }
            
            Ds&fail and me&tsc,'%fail'
            Ds&total_change and me&tsc,'%total_change'
            
            me&tsc,'---',null,'1'
        }
        
        Rs&Sampley and me&Sampley,R
    },'ift,D'],
] };
#c func-Dome

# saves your n ... as joined c&s text
# some care to \n regularly
# < unicode embedded colours, see G&intag
me.Sampley = &acgtR{
    $s = '';
    each in T.nN {
        ns&R || nc&R and continue
        $headed = 0;
        if (n.t.includes('lv') == 0 ||
            n.t.includes('change') == 0) {
            'swathe'
        }
        else {
            s += "\n"+n.t+": ";
            headed = 1;
        }
        s.substr(-1) == "\n" and headed = 1
        ns&dis && !headed and s += "\n";
        nc&s and s += nc&s
        ns&dis and s += "\n";
    }
    s.substr(-1) != "\n" and s += "\n"
    $c = G&Cye,[R.t,'',{sample:s}];
    $l = me&Copy,R,c,{t:'Sampley_lv',ball:0,Lines:3};
    Rs&Sampley and Rs&Sampled = l
    return l
}

# like G&ind, or Rc&s=C climbing
#   returning Rc&N.map(Rc&s)
# and setting yup
me.sunN = &acgtsdl{
    d ||= 1;
    l ||= 5;
    d > l and return []
    $N = [s];
    each in ss&z {
        ny&up = s;
        N.push( ... me&sunN,n,d+1,l )
    }
    return N
};

# func Dome t
# phil somewhere rising

# G&t for this thing
me.herer = &acgtD{
    $very = arguments.slice(5);
    $s = D;
    each in very {
        typeof n != 'string' and throw "!s"
        # should know where D%in.$tv=C
        #  or D%in=in/C or D/in/C or Dc&X...
        # by the D it's in
        $v = sy&tv $n
        v ||= s.sc[n];
        s = v;
        !v and break
    }
    return s
};

#c e thingers
# e as far as ravel goes
# W: $t/R/[path] of Remote
# k: mode/act/hook of delivery
# D: the item to deliver
# we used to: e $W $D
#  and got a C that .t=$W, c&e=$D
# the k not being part of D means D can be more like ec&s:
#  the item being delivered
#   which might still be requesty, depending on k
# k:
#   M: i 1s&Tes&M/$D
#     < io param each A.1, 1s&Te & 1s&Tes&M
#       and mean something
#   < something like me.RMount
#     similar/future bunch of things then replace
#   9: deletes Te
# < native undo:
# < when it's
#    el=1 (creation),
#    el=2 (more forceful/recreation,
#      and implies it's the only thing with that t
#    el<3 implies it's a full copy (to the next %W/H)
#    el=3 is an update
#    ...
#    el=8 keepalive or reference for ordering
#    el=9 deletes
# < how it's
#    coming from a process writing down its deps
#    something output from osc,
#     maybe wanting to include those deps ^
#      as it fits into the store's system
# < doing all of its procedural thinking via elvis,
#     and cX state as transactions
# < everything believed goes through elvis,
#     then it can be natively from somewhere
# < el.y.A having 4's being-there consciousness,
#     partly workable out of frames
# 
# e async is ok, n async only if truthgap or sleep/later scheme
#   your meanings may vary that
#   eg elvising from G&ting to look up a /js/ would throw async
#    placing some W:js question,
#     which could trust cache
#     look it up in a variety of places:
#      /W/Somewhere/ju/$t.js for <script>
#      /W/Compiles/$t is W:$t inc I
#     or even build it:
#      make W/Compiles/$t from ghost,
#      elvising codes to W:js, compiles I
#        of wants to keep
me.Ravelvis = &acgtRWkDc{
    # there
    $el = typeof W == 'object' ? me&introqua,W
        : me&stackTe,[W];
    # lives (async awake) (if $Elvisory/$el)
    els&J = 1;
    
    # may be sc
    c and ex(el.sc,c)
    # then cc&el
    c ||= {};
    c.c ||= {};
    # hook
    k == null and 'nothing doing, just async awake'
    elsif (k == '9') {
        i 4s&elvisory/-#$W
    }
    elsif (k == 'M') {
        if (els&M) {
            me&yfuture,els&M;
            els&M.indexOf(D) >= 0 and cc&el = 8
        }
        ac(el,'M',D)
    }
    else {
        throw "elvis?"
    }
};
#c Domingness mund ravelabhion straight curvy cellvey
# < goneRbitX as savepoints
# < regroup... me&Rom, etc, ways to do things
#  elvising, everything sleeping until laters wake em,
#  doming as the flow of signal/control
#  and physical space, esp code
#  general linkage to phil somewhere


# finds r = t/** at depth p
#  adds to their rs&Mw.rolltog about may:k
#  returns list of r that are on
me.iostyle = &acgttpk{
    # < p for path, [y,M] for ioty
    typeof p != 'number' and throw "Set depth p"
    $N = me&ioty,t,p;
    $M = [];
    each ir N {
        if (k == 'Look') {
            # resists mess
            $show = me&rolltog,r,{may:'Look'},0;
            !show and rs&nofurtherDisplay = 1
        }
        else {
            # Rs&$k takes the ball, once?
            $c = {may:k,once:1};
            #k == 'Upload' and delete c.once;
            $doing = me&rolltog,r,c,0;
            doing and M.push(r);
        }
    }
    return M
};

# i $v/@s o $r/*
#  complicatedly, using polify/ate
# can clone-over but keep certain children etc
#  eg. %Elvisave iostyle's for things to move,
#   combines them with where they're going,
#   and uses this to avoid storing/restoring unwanted stuff
#    eg its own Elvising
# Elvisoir > mez&clone < e ...
# the clone-over (or not) usuality,
#  no taking the top level
# < pass D to R:Copy to save it needless work
me.polout = &acgtvr{
    $R = Cy&R;
    $D = G&Cye,['apolout',{R:R}];
    ac(R,'polout_z',D);
    
    $mez = me&ballio,R;

    # r/* is a land cloning into v/*
    me&polify,D,v,r;
    me&ioty,r,'%ball' .map(&s{
        ac(D,'cloned_z',s);
        # < check in to D, do el4/9 better
        $S = mez&clone,v,s;
        ac(D,'clone_z',S);
        me&Rsync,v
    });
    me&polifate,D;
};

# r/**%balls N=['path','somewhere']
me.fabioty = &acgtrN{
    return me&ioty,r,N.length,{st:N,zvia:'s'};
};
me.ishad = &acgttN{
    # < partial matches
    N = me&fabioty,t,N;
    N.length < 1 and return
    N.length > 1 and throw "many"
    $f = {r:t,N:N};
    # they to where they had it
    f.row = me.cby(N[0],&r{ return r == t });
    return f
};
#c polify
# i $h/* y o $t/*
# where anyone can have policies for ...
# eg keeping $t/Elvisforthis only in $t
# < discover any overlap, hardwire decisions
me.polify = &acgtDvr{
    Dy&R != Cy&R and throw "D!R";
    !vs&ball and throw "delt!ball"
    !rs&ball and throw "dealing!ball"
    $vr = [v,r];


    each ih vr {
        $t = h == r ? v : r;
        $po = h;
        each kc pos&pol {
            # po always h(ere), where polcify applies
            # h is v going in, r going out
            #   me&clone,v,r flows <--
            # t(heir) is the other
            # has is for h, have for t

            # check for path
            #  hooks may depend on finding stuff here or there
            $fort = c.forTepath.slice();
            $inwhat = '('+fort.join('/');

            # later referred to as f
            $has = me&ishad,h,fort;
            $have = (c.either || c.their) && me&ishad,t,fort;

            !(has || have) and continue

            # adds a polification
            $lo = G&Cye,[k,1,c];
            c&pi = 'polify';
            ac(D,'z',lo);
            # builds an act, for in/around cloning
            # f (has|have), el=s, r? (if!=f.r), callback?
            $sync = me&polsync,lo;

            los&here = h;
            los&has = has;

            los&their = t;
            los&have = have;

            h == r and los&leaving = 1

            if (los&leaving) {
                # have something, protect them from it?
            if (loc&nonleaving) {
                # < avoid cloning out things that don't move
                #   Copy untils, to catch the same tving sesh
                # they might have something to preserve
                have && sync(have,4)
                ||
                # climb has there and delete
                has && sync(has,9,t);
            }
            }
            else {
                # given something, protect us from it?
            if (loc&nonoverwrite) {
                has && sync(has,4)
                ||
                have && sync(have,2,h);
            }
            }
        }
    }
};
#c polifate
me.polsync = &acgt,lo{
    return &fsry{
        loc&sync || loc&el and throw "doublesync"
        !s and throw "no el"
        loc&el = s;
        $sy = loc&sync = {f:f};
        typeof r == 'function' and y = r; r = null
        # this f/row can be tried somewhere it wasn't:
        r and sy.r = r
        y and sy.cb = y
        return 1
    }
};
# post-clonial
me.polifate = &acgtD{
    each i,lo Ds&z {
        $sy = loc&sync;
        if (sy) {
            $f = sy.f;
            $bet = f.row.slice();
            # the thing before
            $v = bet.pop();

            # < code these more positively: $t is= bet.shift()
            f.r != bet.shift() and throw "here not t", "bet.shift()"

            # the thing we change
            $r = sy.r || f.r;
            # walk almost there
            # < many f.rows
            $n = me&fabioty,r,bet.map(t=>tc&s.t) [0];
            if (!n && loc&el == 4) {
                # rebuild between r and v
                $rr = r;
                each it bet {
                    n = me&fabioty,rr,tc&s.t [0];
                    1 && n and rr = n; continue
                    # < input,rr,t recycle/refology/fork
                    n = me&input,rr,tc&s;
                    rr = n;
                }
            }
            if (n) {
                # grab what is there now
                $cs = nc&s;
                $ks = vc&s;
                # < should know it's a Copy
                $si = me&fabioty,n,[ks.t] [0];
                $is = si && sic&s;
            }

            # do something
            if (loc&el == 2) {
                ac(lo,'todo',"Accepted over nothing: "+kss&play);
            }
            elsif (loc&el == 4) {
                !n and throw "Deep 4"
                # el:4 leaves things,
                # < may move subjectiver experience
                # unoverwrite what was there
                if (is) {
                    los&removed = is;
                    i $cs/-$is
                }
                $en = me&input,n,ks;
                me&Rsync,en;
                ac(lo,'todo',"Unoverwrite: "+(is&& iss&play)+'->'+kss&play);
            }
            elsif (loc&el == 9) {
                !n and throw "Deep 9 ok?"
                # ensure v is deleted once there
                los&removed = is;
                i $cs/-$is
                me&Rsync,n;
                ac(lo,'todo',["Drops:",r,n,v]);
            }
            else {
                throw "sync el "+loc&el
            }
        }
    }
};
#c Be.sR theory - adjust raised sticks
# at %ball%play
=pod
s&R:
  how to conjoin an other:
the ground wakes up, doing a J (R for now)
from a C%ball describing the J

 %R=+Save gives %ball%Save
   < separate that kind of thing to %A
  
if no ^^4%Gens:
 R=Tool makes %ball/r%Tool
   s.sc -> r.sc
   s%z -> r%nz
     is the out %ball cluster continuing inside
       waking up into this layeR
else:
 R=Tool makes %ball/s.t%Gens%ting/r%Tool
  %Gens creates the thing with memory
   if sc&el=1
     !%ting
   else
     initialises Livec&Tool=1,
       out-s* able to form high level pictures
     Live.c also -> r.sc

%R=1-9 turns into %Doming (the slope)

< %MindInto projects R=... to make thinks into Know/**%ball
  leaving the insphere intermediacies savable

< above may have %methods to continue through our being
  %methods over slopes

%Gens:
  for/in R%ball (usually)
  wakes up R/%Gens/r with its memory
    got via %Gens%ting unless in outs-only mode (sc&el=1)
   < cautiously if no memory:
  < care to authenticate code running by it

%JRom:
  domes it if s&R>=3:
< elvising (networking)
   %ting consumes stuff from the network
    so people opening the same thing get connected
    and theres a spout for updates/locks
   for acts of change
    to have a formal place
    and they may be 
   see Ravelvis etc

%Gensing:
< from %Gens, mediates %other <-> %self
  commits a tree in either direction
    syncing pieces required for a coherent there/%other
    as eg the /W/ server would do until all %H are
  
  doing ballio
  
  setting policy
  
  learning qualities
  
  control:
    is an expression separate from data
    
    r%Doming=2, an A.2 slope, unless no ^^4
      levels have many definitions, create slopes
        are points of interest/tingingdoms
    < %whaT to overlay/inject/control
      mucking with I/anything going into it
  
  compression/difference:
    how out%ball -> in%ball
      loading our changes on top of it
      %MindInto out%ball/* are W mixing into it
        in W surfing mode, when you employ %MindInto
    how out%ball <- in%ball
      keeping a vague picture, like %species=4
      %MindInto keeps the 1C only, with $W%H,dig,v,etc
        merging with the Live, which is for notes etc
         mix-figurations

s&W/s&J eventually do this, growing from A.4/A.1
  pinning /way/s.t to define it

'doing from and growing from' will + joints

R=\d+ could mean slopality, instantiatia:
 2: should be remembered
 3: must be Domed
 4: follow children first?
   %MindInto would set this up as its iterating
 5/6: thinkingabout/supposing theyre all processes

< auto %play any %Doming=3/*%R
  supposing theyre all processes,
  not bits of a process
    the for later/someoneelse phenomenon
    the lum, line, probably to do out/in%ball
 < know boundaries, where awareness should end
   usu where %otherstuff begins, or time
   play with making it wake up too hard

< %push/%differ ~s&testrun, less remote
=cut
#c Be.sR/ballRom - adjust raised sticks!!!
Be.sc.R = 'sR';
me.ballRom = &acgtRsc{
    c ||= {};
    $sc = ex({},s.sc);
    $k = delete sc.R;
    $z = delete sc.z;
    # R=\d+ could mean slopality
    if (k) {
        k > 1 and c.Doming = k
        else {
            k == 1 and k = '1'
            typeof k != 'string' and throw "refR"
            k = k == '1' ? s.t : k;
            k = k.split('+');
            # R=+Save gives R%Save
            # R=Tool+etc makes r%Tool%etc
            k[0] == '' and k.shift(); c = R.sc
            each i,gk k {
                c[gk] = sc[gk] != null ? sc[gk] : 1
            }
            c == R.sc and return
        }
    }
    # new being
    # < namestretch over out/9er/in,
    #   making the formers harder to elvis,
    #    is checked in
    c.t = s.t;
    # who knows names
    $Gens = me.cbu(R,'Gens');
    # and history
    $Doming = me.cbu(R,'Doming');
    # s.sc -> r.sc
    ex(c,sc);
    # the outs
    c.other = s;
    # s%z -> r%nz
    ss&z and c.nz = ss&z
    # c carries through Jrom or %Gens
    !Gens and c.Doming ||= 3
    # or via %Gens waiting room
    else {
        c.Doming != 2 and c.Gens = 1
        # c = {t:c.t,Gens:c};
        # < %JRom/%Gens/... 
        c.Doming ||= 1;
        
        # < join some thinking about Doming it 
        # our %Gens%ting will find its %ting
        #  for pathinto (or not if W:thing)
        #  J would wander in and W along
        
        # < something not quite %JRom, concurrent
        # < group time Ringing inside it
        # < lots of weird ways to make callbacks whenever
    }
    
    !Doming and c.Doming = 4
    c.Doming >= 4 and c.task ||= 4s&detask||'rovo'
    if (c.Doming == 3) {
        # A.3 are sleepy if tunneling yet not awakey
        #  ie we have a specific goal but it isn't this
        #  compared to the 'everything' mode of e:V (ec&wake=1)
        # < wander differently each time, work wideness
        $e = Rs&tunneling;
        (!e || !es&beawake) && Rc&b and c.neednt = 1
    }
    
    # packdown from %play
    ac(R,'unplaycb', &{
        each in rs&unDoming {
            n()
        }
    });
    $r;
    # level of Doming...
    # blend ind
    c.Doming <3 and r = me&Ret,R,c;
    # another Ringing (Rc&N)
    # instant to the enclosing Ring
    # < unless it makes Arrangements
    # catches throws
    else {
        r = me&Rom,R,c
    }
    return rs&returns || r
};
Be.sR = {
ps_Dc:{Gens:{ohm:0}},
play: me.ballRom
};
#c Rom tries R, catches errors
# provide headings with pausibles,
#  errors and s&N coming out
#  T.* changes and chatter
# < %Reis with error handlers,
#   pausible
# < er + Ring cursor
# 'For' -> For%For=1
# 'For',c -> For%%$c
# '%For',c -> For%%$c,For=1
me.Rom = &acgtptc{
    typeof t == 'object' and c = t
    !c and c = t
    typeof c == 'string' and c = {t:c}; c[c.t] = 1
    !hak(c,'t') and c.t = t
    if (c.t.substr(0,1) == '%') {
        c.t = c.t.substr(1);
        c[c.t] = 1;
    }
    t = c.t;
    !isst(t) and throw "t not string"

    # insist on %JRom enclosure
    $oc = c;
    if (!ps&JRom) {
        c = {t:t,JRom:c};
        ex(c,c.JRom.JRomc||{});
    }
    c.task ||= 4s&detask||'rovo';
    oc.neednt and c.neednt = delete oc.neednt


    # < explore I by fraction
    c.neednt and c.wantsleep = 'neednt'
    c.impausible and delete c.wantsleep
    # c.wantsleep and c.ov = 0.279
    # before tunneling 18:
    c.wantsleep and c.ov = 0.172
    
    $cancelation = &{
        # reset X, failed R don't become b!
        rc&b and me&resetRbitX,R,r;
        
        # < packdowns for whatever can't continue,
        #   doming marked through as async?
        #    keep some, G&T/thro may resync from B stack
        
        # keep last Display (to put it in Rs&down)
        $b = rc&b;
        if (b && by&Display) {
            #  %JRom%sleeping could also do this,
            #  having already had awake inners...
            try {
                # c.sleeping doesn't visit any r/awake
                me&Display,r,{sleeping:1};
            }
            catch (err) {
                msg = '!sle! '+msg
            }
        }
    };
    $error = &msg,{
        $n = G&Cye,[Ac&sip,'',{}];
        nc&s = msg;
        ns&now = G&time;
        ns&A = A;
        ns&B = Gc&B;
        ns&p = p;
        ns&R = r;
        # to nearest dome with room to think about it
        $JR = me.cbu(p,'erN');
        $erN = JRs&erN;
        erN.push(n);
        Rs&error = n;
        return n
    }

    try {
        $cb = delete c.Recb;
        
        $r = me&Re,p,c;
        cb && cb(r);
        me&Ring,r;
        if (T.cancel) {
            # used by JRom_asyncQs to casually wait for tings
            #  could also abort pointless A:e-ing
            $n = error('cancel: '+T.cancel);
            delete T.cancel;
            cancelation();
        }
        if (rs&wantsleep) {
            if (!rc&b || !rc&b.y.Display) {
                ~>6 !sleep!b: r.t
                delete rs&ov;
                me&Ring,r
            }
            else {
                rs&sleeping = 'wanted';
                if (1) {
                    # put through the rest of itself,
                    # it may have %sleeping things to do
                    delete rs&ov;
                    me&Ring,r
                }
                else {
                    me&Display,r;
                }
                #~slept: r.t, r.sc.ci, '>2 '+haks(r.sc).join(",")
            }
        }
    }
    catch (er) {
        $msg = er.message || er+'';
        $async = msg.match(/^async/);
        
        cancelation();
        
        $n = error(msg);
        
        nc&er = er;
        # bunch of artifaces, < (t,$s)+
        er.tc and nc&M = er.tc
        
        ps&returns and throw er
    }
    return rs&returns || r
};

me.JRomingness = &acgtR{ return [
    #c %JRom - safe/pausible R,
    #  handled errors and s&N
    &{
    # photo arrays before/after event
    #  may leave Ds&watchar/$k/[new+]
    me.watchar = &acgtRDc{
        $emto = {sN1:1s&N,sn4:4s&N};
        each kv c {
            $har = Ds&watchar ||= {};
            har[k] = v ? v.slice() : [];
        }
        return &{
            each kv c {
                $har = Ds&watchar ||= {};
                $was = har[k];
                $outi = [];
                $N = [];
                each in v {
                    was.includes(n) and continue
                    outi.push(i);
                    N.push(n);
                }
                !N.length and delete har[k]; continue
                # take, for nearest JRom only
                outi.reverse().map(i => v.splice(i,1));
                har[k] = N;
            }
            !hak(Ds&watchar) and delete Ds&watchar
        };
    };
    },
    ['JRom','3',&acgtRs{
        s&dis = 1;
        #me&walla,'bd:2.1h5';
        me&domesticate,R;
        
        # 1 wave matter
        $c = Rs&JRom;
        
        # 2 self, from 
        $D = G&Cye,[R.t,1,{},{}];
        $j = me.cbu(R,'JRomD');
        $b;
        if (!j) {
            $b = me&rollbs,R,'JRomD';
        }
        else {
            j = js&JRomD;
            jy&tw ||= {};
            $b = jy&tw[R.t];
            jy&tw[R.t] = D;
        }
        Rs&JRomD = D;
        me&rollbs,R,'Pring';
        
        b and Dc&b = b
        b && by&tw and Dy&tw = by&tw
        Ds&amongst = b && bs&amongst || [];
        Ds&amongst.unshift(D);
        Ds&count = (b && bs&count || 0) + 1;
        D.t = ''+Ds&count;
        
        # 3 what doing
        if (c.Peace && me&rolltog,R,{k:'reset',once:1} ) {
            Rs&boost = -2
            $r = 4s&mainthing
            $z = r && rc&s
            z and 4s&gonemainthing_s = z
        }
        if ((Rs&boost||0) < -1) {
            delete Rs&Te.sc.boost;
            me&tsc,'JRom-reset','reset','6';
            delete c.wantsleep;
            delete c.tunneling;
            s&boc = '858';
            c.igV = 1;
            # < starting tunneled
            G&yl:3,&{ me&elvis,R,'resetya',{wake:Ry&up} };
            return
        }
        elsif (!c.impausible &&
            ((Rs&boost||0) < 0 || c.pause)) {
            $pa = me&tsc,'JRom-paused','⏸','6';
            pas&po = 1;
            pas&fs = 22;
            pas&left = 0;
            #
            s&boc = '888';
            s&bg = '#002';
            Rs&play and c.hidey = 1;
            Dc&b and c.wantsleep = 1
        }
        c.hidey and s&mah = 30; s&over = 2
        
        # 4 map matters for before/after
        #  similar to elvoids, push A to a queue
        #   to async with ambience
        # < down to the next J? should know them all
        $watchar = me&watchar,R,D,{sN1:1s&N,sN4:4s&N};
        
        
        # 5 partition explosion collection
        $erN = Rs&erN = [];
        
        # 6 do innard
        $began = Gtime();
        
        $r = me&Rom,R,'Rom',c;
        #c out me&Rom returns in me&Rom
        if (0 && c.wantsleep) {
            # from before JRom paused
            if (!me&rollbs,R,'returns' ) {
                throw "cant return !sleeping"
            }
        }
        else {
            # may have become %sleeping (eg tunneling 18)
            Rs&returns = r;
        }
        
        # pause if slow!
        $max = rs&timetopause || 6.5;
        $delta = Gtime(began);
        each tn Dy&tw {
            # JRom not tunneled this time
            !Rc&N.includes(ns&JRom) and continue
            ns&delta and delta -= ns&delta
        }
        if (delta > max) {
            me&tsc,"("+delta+">"+max+")";
            #me&introqua,R,{boost:-1};
            4s&unplugbugcb && 4s&unplugbugcb.push(&{
                me&introqua,R,{boost:0};
            });
        }
        delta < 0 and ~>3 -delta: R.t, delta
        delta < 0 and delta = 0
        Ds&delta = delta;
        Ds&JRom = R;
        Ds&R = r;
        # no colour for the paused
        c.wantsleep and s&sat = 0
        
        # 7
        watchar()
        erN.length and Ds&erN = erN;
        
        # all but topmost should tend to sleep...
        $dc = {s:Ds&amongst,NzR:'Domed',glamp:9};
        me&Rom,R,'Domeds',dc;
        
        # < A-ing slowly: order then consciousness
        #   for summary up the top
        Rs&down && Rs&down.reverse();
    },'ift,D'],
    #c Domed visually Jing R
    # < froth away lots of %balls
    ['Domed','3',&acgtRs{
        ah(R,'reawakens','Domed',{});
        me&walla,0,'b:3.1';
        $t = me&domesticate,R;
        ts&hs = '635';
        Rs&sym = "";
        $p = Ry&up;
        # p%NzR cs=[D%Domed+]
        $D = s;
        $r = Ds&R;
        # 3 gauge of gauge
        # only latest or Te'd open
        if (Rs&glampi != null &&
            Rs&glampi > 0 && !Rs&Te.c) {
            $b = Rc&b;
            $sym = !b ? "-" : bs&sym || "?";
            tc&s = Rs&sym = sym;
             return
        }
        # boost<0 and delete (if Te.d)
        if ((Rs&boost||0) < 0) {
            $Di = pc&s.indexOf(D);
            Di < 0 and throw "Di"
            pc&s.splice(Di,1);
            n deleted  s:deleted %fs:6,hs:594
            return
        }
        if (Rs&Te.c) {
            # Te'd stops delete
            Rs&keeper = 1;
            me&tsc,'keeper','k','6';
            Rs&rowish = 1;
        }
        
        # 4 items of interest
        if (Ds&watchar) {
            # As&N we noticed grow
            Rs&sym += '^'
            each kv Ds&watchar {
                n $k  $s:v,R %NzR:Attend
            }
        }
        
        if (Ds&delta && Ds&delta > 0.04) {
            $say = G&thime,Ds&delta ;
            me&tsc,'delta',say,6
        }
        
        # errors we caught!!!
        if (Ds&erN) {
            Rs&sym += '!';
            n Errors  $s:Ds&erN,R %NzR:Error
        }
        # oberve limits
        rc&N[0] != r and throw "not h"
        rc&ha and me&zu,'rc\&ha',rc&ha
        
        rs&sleeping && rs&sleeping != 'errors' and Rs&sym += 'ᛍ'
        
        Rs&sym ||= '.'
    },'ift,D'],
    
    ['Attend','4',&acgtRs{
        ah(R,'reawakens','Attend',{});
        $Y = s;
        
        $nth = Y.t == 'n' && Y.y.cv == 0.13;
        nth && Yc&s.t == 'Pass' and Rs&nthirteen = 1
        !Rs&nthirteen and Rs&keeper = 1
        
        n Y  $self:Y %R:Cit
    },'ift,D'],
    #c Error 4
    ['Error','4',&acgtRs{
        ah(R,'reawakens','Error',{});
        # < maybe if ^^%Domed%rowish or many ^/%Error
        #Rs&rowish = 1;
        $skull = '☠';
        $bigger = me&rolltog,R,{may:skull,tsc:'D',once:1},0;
        
        me&tsc,'message',sc&s,'d';
        
        $B = ss&B;
        $w = B && Bs&way;
        w and me&tsc,'w',w.t+'#'+ws&dige
        
        $wayline = &wlc{
            if (!isnu(l)) {
                $stackline = l;
                $m = stackline.match(/:(\d+):(\d+)\)?$/);
                !m and return
                l = m[1];
                c = m[2];
            }
            l *= 1;
            c *= 1;
            # for the wrapping as a function with argumentation:
            !wc&script and l -= 1;
            # < Differ having more context sense:
            #   find line before each indent outwards and upwards,
            #   and the first line of a comment on either side
            #   < far more ideally, how the logic went!
            $context = 2;
            $from = l-context-1;
            from < 0 and from = 0
            $lines = wc&s.split("\n").slice(from,l+context);
            me&tsc,"from:"+l+":"+lines.length;
            if (!lines.length) {
                me&tsc,'invalid-lineguess' .sc.ma = 0.3;
                me&tsc,'stackend',stackline,'y' .sc.dis = 1;
                return;
            }
            $min; 
            each is lines {
                $m = s.match(/^(\s+)/);
                !m and continue
                $ind = m[1].length;
                min == null || min > ind and min = ind
            }
            min and lines = lines.map(s => s.substr(min)); c -= min;
            each is lines {
                $wasline = (l-context)+i*1;
                $n = me&tsc,'line:'+wasline,0,'y';
                ns&dis = 1;
                nc&s = '';
                me&mtsc,n,'no:',wasline+':','y';
                $ok = me&mtsc,n,'line:'+wasline,0,'p';
                
                if (wasline == l) {
                    $trouble = s.substr(c-1);
                    s = s.substr(0,c-1);
                    me&mtsc,n,'trouble',trouble,'b';
                    
                }
                okc&s = s;
            }
        };
        # locatable errors!
        $wayjs = &w{
            $args = wc&code_args ? "ar,"+wc&code_args
                : wc&argumentation || ws&args;
            !args and throw "untried w"
            $src = ['','wayjs',ws&dige,args,w.t].join('/');
            
            # window.onerror puts script.compile_errors[error]
            $script = wc&script = G&add_script,src;
            
            script.onerror = &er{
                ~>5 wayjs err: w.t
            };
            script.onload = &er{
                # if compiled or not
                $towake = me.cbu(R,'JRom');
                !towake and throw "notowake";
                me&elvis,R,'wayjs',{wake:towake};
                $name = ['w',w.t,ws&dige,args].join('__');
                name = name.replace(/\W+/g,'_');
                $y = window[name];
                !y and return ~>5 wayjs not compiling: w.t
                ~>5 wayjs loaded: w.t
                script.loaded = 1;
                # swap it in, providing the next error with line number:
                wc&code = y;
            };
        };
        # load .js, returns script if already
        $add_script = &src,cb{
            $r = me.cbu(R,'Inn');
            $r = r && rs&Inn;
            !r and throw "no way Inn"
            return rs&add_script(src,cb)
        };
        
        #c ercursion
        $er = sc&er;
        # to make location.origin+/(\/\S+):\d+:\d+\)?/
        window.regex = &{
            $N = [...arguments];
            $s = "";
            each in N {
                n.constructor == RegExp and s += n.source
                else
                isob(n) and throw "regexbit", n
                else {
                    s+= n.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1")
                }
            }
            return new RegExp(s)
        };
        $ersense = &er,erp{
            $stack = er && er.stack;
            
            if (stack) {
                # each catch throws a new error,
                #  containing the old ones in catches
                #  or at least their stack,
                #  which all seem to be the same?
                erp && stack == erp.stack and 'stack same'
                else {
                    stack = stack.split("\n");
                    $fore = stack.shift();
                    $first = stack[0];
                    $isc = regex(location.origin,/(\S+):\d+:\d+\)?/);
                    $inscript = first.match(isc);
                    if (inscript) {
                        inscript = inscript[1];
                        # get by id?
                        $script = $('body script[src="'+inscript+'"]')[0];
                        if (script) {
                            w = script.way;
                            wc&script != script and throw "mad"
                        }
                        else {
                            me&tsc,'in-not',0,'y'
                        }
                    }
                    if (script) {
                        # href in stack is better than w in Bstack
                        w = script.way;
                    }
                    # < !w may still have urls of wayjs
                    if (w) {
                        $script = wc&script;
                        if (script) {
                            me&tsc,'hadscript' .sc.ma = 0.3;
                            window.ascri = script;
                            $ers = script.compile_errors;
                            if (ers) {
                                # G&way/er still shows lies from before wayjs
                                #  since it cannot be linked into w
                                ers.length != 1 and debugger
                                $ec = ers[0];
                                ec+'' != er+'' and ~>5 differing way/wayjs compiler: ec+'', er+''
                                ec.lineNo == null and me&tsc,"nolineNo?"
                                wayline(w,ec.lineNo,ec.colNo);
                            }
                            else {
                                # < should have script src in
                                ~>5 does wayjs stack look right?:
                                #me&tsc,'stackend',first,'y' .sc.dis = 1;
                                wayline(w,first);
                            }
                        }
                        elsif (first.includes('[as code]')) {
                            # lineno is correct
                            wayline(w,first)
                        }
                        # or it could be for the last eval
                        #  (or that + lines in the eval?)
                        # < using eval as an operator not a function?
                        else {
                            $n = me&tsc,'getline',0,'p';
                            ns&ma = 0.3;
                            # < e to itself, throttles
                            # may go into tailspin
                            # errors in error handlers are danger
                            $last = 4s&erts;
                            4s&erts = Gtime();
                            if (last && Gtime(last) < 3) {
                                nc&s += "?";
                                me.nto(R,n,&{ wayjs(w) });
                            }
                            else {
                                nc&s += '...';
                                wayjs(w);
                            }
                        }
                    }
                    else {
                        me&tsc,'!w',0,'p'
                    }
                }
            }
            (er.catches||[]).map(erd => ersense(erd,er))
        };
        
        er and ersense(er);
        
        # extra arguments to throw
        each in sc&M {
            $n = me&zu,i+1,n;
        }
        
        (Rs&boost||0) < 1 && !bigger and return
        me&introqua,R,{boost:1}
        
        s&fs = 13
        
        me&nu,'self',s
        me&rolltog,R,'loger' and console.log(sc&er);
        
    },'ift,D'],
    
    #c Domed misc NzR, expirez
    # spread Rc&s=N[n+] to many rc&s=n
    #  they have a type that helps NzR or the thing above it
    #  do expirez
    ['NzR','4',&acgtRs{
        ah(R,'reawakens','NzR',{});
        Rs&dubquiet = 1;
        # trims to 30s timeframe, not %keepers
        Rs&glamp and Rs&expirez = 30
        $t = me&domesticate,R;
        Rs&NzR+'s' == R.t and Rs&qt = 1
        Rs&qt and t.c.not = 1
        
        $p = Ry&up;
        $outi = [];
        each iY s {
            $t = Y.y == Y ? Yc&sip : Y.t;
            $z =
            n $t  $s:Y,R
            z.sc[Rs&NzR] = 1;
            # inners like a log tail
            Rs&glamp and zs&glampi = i;
        }
        outi.reverse().map(Yi => s.splice(Yi,1));
        
        !z and ts&fs = 7
        0 < i && !Rs&qt and Rs&rowish =  1
    },'ift,D'],
    
    # expiry of care about old A
    # < kind of time we can pause
    # R(cs=[n+]) with r(cs=n)+ self-cleaning
    ['expirez','7',&acgtRs{
        $outi = [];
        each in s {
            $r = Rs&z && Rs&z.filter(r=>rc&s==n)[0];
            !r and continue
            # are %keepers
            rs&keeper and continue
            
            # give %began
            rs&began = me&rollbs,r,'began' || G&time;
            $much = G&time,rs&began;
            
            # things time out or overpopulate
            $out = much - Rs&expirez;
            $over = Rs&glamp && i >= Rs&glamp;
            over && out < 0 and out = Rs&expirez
            out < 0 and continue
            
            # < relative scales into styles
            $C = rs&C;
            out < Rs&expirez/4 and s&fs = 8; s&sat = 0.4
            out < Rs&expirez/3 and s&fs = 6; s&sat = 0.2
            out < Rs&expirez/2 and continue
            
            $Yi = s.indexOf(n);
            Yi < 0 and me&tsc,'nofindY'
            else { outi.push(Yi) }
        }
        outi.reverse().map(Yi => s.splice(Yi,1));
    },'ift,D'],
    


] };
#c Domingness
me.Domingness = &acgtR{ return [
# add %Doming (slopality) and %Gens (genesising)
# to the job of %JRom (try/catch Re envelopy)
    ... me&JRomingness ,
# < is really %torun, which is really W:Pass
# have wanting uphill showing where come
# set off an experiential perspective:
# A locality of thing availability!
    ['Doming','3',&acgtRs{
        #me&walla,'bd:7.1h5,hu-7';
        if (Rs&Doming >= 3) {
            # W have packdowns
            Rs&unDoming ||= [];
        }
        T.Mw = 'Doming';
        me&tsc,"A."+Rs&Doming;
        
    },'ift,D'],
    
    #c %Gens save/make automata
    # see Be.sR
    # the part of Jing that is someone elses
    # A tracking its new self down
    ['Gens','25',&acgtRs{
        isC(s) and Rs&other ||= s
        # usu the s)%ball above that %plays
        me&introqua,R,{turnsup:1}
        $s = Rs&other;
        if (s && sc&el == 1) {
            # !%ting
            # ins pulls outs
            s = me&rollbs,R,'self';
            if (!s) {
                s = Rs&self = G&Cye,Rs&other;
                # new index at s/*
                #   modifying original others instantly
                s.y = {cv:sy&cv};
                ss&z and ss&z = ss&z.slice();
            }
        }
        else {
            me&rollbs,R,'self';
            # comes from:
            Rs&ting ||= 1;
            # < make toW default behaviour
            #   sproutes have their reason
            Rs&toW = 1;
        }
    },'ift,D'],
    
    ['Gens+ting','31',&acgtRs{
        $Q = Rs&Q;
        $P = Qs&P;
        # download
        if (Qc&el < 3) {
            !P and return me&tsc,'wait%Q%P-only'
            Rs&self = me&Copy,R,Pc&s .c.s;
        }
        if (!Rs&self) {
            if (Qc&el == 9) {
                # creation
                Rs&self = G&Cye,[R.t,'',{},{}];
            }
            else {
                me&tsc,'wait%ting','...'
            }
        }
        Rs&self and Rs&Save = 1
    },'ift,D'],
    
    # %Gens%Here = R:$self%ball
    ['Gens+self','31',&acgtRs{
        $s = Rs&self;
        !s and return
        $c = Rs&Gens;
        c == 1 and c = {ball:1,tightly:1}
        typeof c != 'object' and throw "Gens?"
        c.t = s.t;
        $t = delete c.t;
        c.s and throw "Gens.s!"
        
        $h = Rs&Here =
        n $t  $s:s,R
        # configure inside from out%ball,
        #   which %played s&R, creating us
        #    perhaps with big Doming beforehand
        ex(h.sc,c);
        # set freer
        delete Rc&dubquiet;
        Rc&dupl = 3;
    },'ift,D'],
    
    # general out/in%ball negiator
    ['Gens+Here','4',&acgtRs{
        me&rolltog,R,'%Gensing?',0 &&
            n Gensing  R %Gensing
    },'ift,D'],
    
    ['Gensing','7',&acgtRs{
        $p = Ry&up;
        $N = me&ioty,p
        me&tsc,"Yep"
        me&zu,"GeNN",p
    },'ift,D'],
    
    #c %Save
    # Rs&Q is for saving Rs&Here, which Liness
    ['Save','5',&acgtRs{
        !Rs&Here and return me&tsc,'noHere','!h','B'
        $h = Rs&Here = me&yfuture,Rs&Here;
        
        # want to have a %ting
        if (!Rs&Saveting) {
        Rs&Saveting =
            # %ting%Save itself
            Rs&ting ? R :
            # %Save/%ting
            n $R.t  R %ting:W
        }
        
        Rs&atstage = &s{
            $v = Rs&ForZave ? Rs&Save : (Rs&boost||0)+1;
            return v >= s;
        };
        !Rs&atstage(2) and return
        Rs&noHereEncode and return
        
        # check in
        if (!hs&ball) {
            # the non-%ball process defines another
            # storable in-sphere
            hs&Here and h = Rs&Here = hs&Here
            else {
                # < errors
                return me&tsc,"looking-for-in%ball","Here!ball"
            }
        }
        hs&Lines = 3
    },'ift,D'],
    ['Save','71',&acgtRs{
        !Rs&atstage(2) and return
        
        $h = Rs&Described || Rs&Here;
        if (!isC(Rs&Saveting)) {
            me&tsc,'!Sting',null,'G';
            return me&zu,"Savoir",Rs&Saveting;
        }
        $ting = Rs&Saveting = me&yfuture,Rs&Saveting;
        !ting || !tings&ting and return me&tsc,'Save!ting';
        
        $Q = tings&Q;
        $P = Qs&P;
        !P and return me&tsc,'!P'
        !Qs&ready && Qc&el != '9' and return me&tsc,'!ready'
        !h and return me&tsc,'!here'
        
        #me&zu,'here',h;
        #me&zu,'their',P;
        
        !hs&string and return me&tsc,'hs!string'
        
        if (!Rs&Zave) {
            me&introqua,[R,'diff'],'boost','@1';
            me&diffya,R,'diff',h,P;
        }
        
        !Rs&atstage(3) and return
        
        if (Ps&string != hs&string &&
            !me&rollbs,R,'sent_string' ) {
            Rs&sent_string = Qs&string = hs&string;
            tings&_ting(Q,R)
        }
        if (Ps&string != hs&string) {
            !Rs&Zave and me&tsc,'pushing'
            return
        }
        !Rs&Zave and me&tsc,'pushed'
        delete Rs&Te.sc.boost
        Rs&Save = 7;
    },'ift,D'],
    
    #c %Elvisave sense grabber
    ['Elvisave','3',&acgtRs{
        Rs&rowish = 1;
        delete Rc&dubquiet;
        Rc&dupl = 3;
        
        # < o ^^%Gens^^%Gens(%Te)
        #   knowing %Te can be made
        $p = Rs&upward = me.cbu(Ry&up.y.up,'Gens');
        $el = me&introqua,p;
        pp = py&up;
        !pp and throw '!pp'
        $L = me&introqua,pp;
        
        me&bal,'Their',L;
        
        me&bal,'Here',s;
    },'ift,D'],
    
    
    ['Elvisave','4',&acgtRs{
        $t = Rs&Their;
        $h = Rs&Here;
        
        # make auto keep this thing's elvising
        # Their/.../Rs&Te is coming in here,
        # make it not part of *load

        # climb atop %ball/%Gens/R, of the same t
        $r = R;
        $N = me.cby(R,&r{ return ry&up && ry&up.t != r.t });
        # then up to the R%upward(%Te -> Their) we capture
        N = me.cby(N[0],&r{ return r == Rs&upward });
        # and make it a non-overwritable,non-leaver
        ts&pol = {
            carefullyTe: {
                # this path in either t/h
                forTepath: N.map(r => r.t),
                either: 1,
                # will cause t to have
                nonleaving: 1,
                nonoverwrite: 1,
                # which could go as far as nonewt
                #  to force talking about existing things
                #  or onlynewt to make first-in locks
            }
        };
        
        # Their
        me&iostyle,t,0,'Look';
        me&iostyle,t,0,'Download' .map(&r{
            $v = me&input,h,'Thus';
            me&polout,v,r;
        });
        # Here
        me&iostyle,h,1,'Look';
        me&iostyle,h,1,'Upload' .map(&r{
            me&polout,t,r;
        });
        
        # keeps knowing last move,
        # < more via NzR
        $lo = Rs&loaded = Rs&polout_z || me&rollbs,R,'loaded',[];
        each iD lo {
            each i,lo Ds&z {
                me&zu,'lo',lo,'';
            }
        }
    },'ift,D'],
    


    
    #c %iotest sense grabber
    # < wants to store an Elvising for itself,
    #   to be revamped by %Gens
    ['iotest','3',&acgtRs{
        Rs&rowish = 1;
        
        window.iodebug = 1;
        
        $c = me&tsc,"Double"
        i $c/van
        i $c/two
        i $c/two
        $t = me&tsc,"Three"
        i $c/$t
        i $c/$t
        $t = me&tsc,"Three"
        i $c/$t
        
        window.iodebug = 0;
        
        me&zu,c;
    },'ift,D'],
    
    
    #c %WestCases
    ['WestCases','3',&acgtRs{
        me&walla,'bd:3.1h5';
        
        $n = Rs&Inn = me&Rom,R,'Search';
        Rs&_ting = ns&_ting;
        
        
        $Q = me&rollbs,R,'Quest';
        n t/lvhashave  R %ting:W,Quploadsc:Quest
        
        $c = {};
        me&rollbs,R,'Sampled';
        # while checking in, 
        me&rolltog,R,'Checkin',0 and c.Sampley = 2
        else { delete Rs&Sampled }
        Rs&Sampled and c.pause = 1; c.hidey = 1;
        
        $r = !c.pause && me&Rom,R,'%lvhashave',c;
        
        
        # r.sc will not roll when pause/sleep
        r && rs&Sampled and Rs&Sampled = rs&Sampled
        
        if (Rs&Sampled && Q) {
            $P = Qs&P;
            $h = Rs&Sampled;
            
            n here  $self:h,R %Cit
            n Pull  $self:P,R %Cit
            !P and return me&tsc,'P...'
            !h and return me&tsc,'h...'
            #me&introqua,[R,'diff'],'boost','@1';
            me&diffya,R,'diff',h,P;

            !me&rolltog,R,'Push?',0 and return

            if (!me&rollbs,R,'sent_string' ) {
                Rs&sent_string = Qs&string = hs&string;
                Rs&_ting(Q,R)
            }
            Ps&string != hs&string and return me&tsc,'pushing'
            me&tsc,'pushed';
            delete Rs&Te.sc.boost;
        }
    },'ift,D'],
    
   ##c wedness do next!
=head1
flav
   %ting:
     a search or put, any type
     explains G&ting
     < ting both sides of it:
       (/G/Wway=/W/way)/$wcs would G&way
       (/spot/ja=/W/js)/$W would /js/
       then poll Wormhole for everything
     get (< put) .4/5, highly surfable
      < unify for an area
       < become the living someone via /W/
     < are name claims, applying or retrieving
       what of/directory selfs, .t others
   everything is, look at it in stylehouse to edit
   
   < %ball format more
     all %string hidden
     < inheritable & auto Tie/roll
     < c&s protruded
     < c % sc division
   
   < merge %torun/%mund, convert %garbec
   the %mund is posting things around,
     including its own insides,
     see 'one big %ball, some of it grounded' ^
   
   tracks stored compilings, eg:
    /W/way/$w -> /W/Comp/$w
     or -> some collection of ways
       a g/(\w+)/(\d+) is such, looks like kv yaml
       is really lots of n $t  $s:... %of:way,%comment:...
   < bringing it back via G&ting /js/ or /way/
    < read our /W/Comp/$w_$dige.js
   
   primarily for:
    using %oph to build I
     < having Babz already done to blockquoted things
       by /wayz/, otherwise like /way/
     < including %Give deps, versions of way/W going into it
     < storage-specific metadata, see w:Writer
       could simply be in the local W:Office
       things to see changing out there to awake
   
   but also:
    translating old -> new ghosts:
      io.*, me.* into W with of:W but not W:of
       such are the new ghost objects
        as g/\w+/\d+ but with a 9,
        thence all of io is in one tidy packet,
        its source compiles out closer to you,
        its tests compile into Tests
      NutMachine probably wants conversion
        perl builds it atm,
         /js/j for acgts, etc
         using 1C&of=js instead of the n \'of:js'
   
   'specifically' for leaving 'GhoNut'
    !
    others involved:
 %Give - ghost versioning
   knowing exactly each I it ran with
   see W&Lis
 W&Lis
  magical W access syntax, via t
=cut
    #c ting fance, %tightly
    
    ['tightly','3',&acgtRs{
        ac(R,'inheritsc','tightly')
    },'ift,D'],
    
    ['ball+tightly','3',&acgtRs{
        $p = Ry&up;
        ps&ting && ps&species and Rs&tightly = ps&species
        
        # if they s&W (%sc may be talking about sc)
        $onW = Rs&tightly == 4 && ss&sc.includes('W')
            || Rs&tightly == 5 && ss&W;
        # ting it!
        onW && me&rolltog,R,'W?',0 &&
            n $s.t  R %ting,toW
    },'ift,D'],
    
    # look through 4/5 for links
    ['inspecto','3',&acgtRs{
        me&walla;
        $p = me.cbu(R,'ting');
        each in sy&N {
            (ps&species == 5 && ny&up && ny&up.t == 'W' ||
            ps&species == 4 && ns&sc && ns&sc.includes('W')) &&
                n $n.t  $s:n,R %itemo:W
            ps&species == 4 && ns&c && ns&c.includes('W') &&
                n $n.t  $s:n,R %itemo:cW
        }
    },'ift,D'],
    
    ['itemo','3',&acgtRs{
        me&walla,0.4;
        $p = me.cbu(R,'ting');
        me&tsc,'itemo',Rs&itemo,'6' .y.cv = 0.08
        $t = me&domesticate,R;
        ts&hs = 296; # tsc'y'
        ss&zs and me&tsc,'zsize','x'+ss&zs,'b'
        
        (Rs&boost||0) < 1 and return
        
        # open it in the .1
        $wasp = p
        ps&species and p = me.cbu(py&up,'ting')
        !p and throw "!pp !species"
        p == wasp and was = null;
        $M = ps&More ||= [];
        
        if (Rs&itemo == 'W') {
            $n =
            m $s.t  R:1 %ting,toW
            wasp and ns&autospecies = wasps&species;
        }
        else {
            $es = ps&Live;
            $z = es && ess&z;
            $ok = 0;
            each in z {
                n.t != s.t and continue
                $ok = 1;
                m $n.t  $s:n,R:1 %ball,tightly
            }
            !ok and return me&tcs,'!Live/t'
        }
    },'ift,D'],
    #c %ting push/pull of C living across the boundary
    #  the question should roll+clone
    #    to transact by the dependent process?!
    ['ting','3',&acgtRs{
        Rs&rowish = 1;
        Rc&dubquiet = 1;
        # make little label as from this I
        $p = me.cbu(Ry&up,'ting');
        $lab = &ltc{
            $n = me&tsc,'%ting-'+l,t,c;
            ns&fs = 11;
            return n
        };
        T.Mw = 'ting';
        
        # more %ting:1 in the same of/directory
        # < seeing where edges of C are,
        #   pressurise to voyage
        $t = null;
        if (Rs&ting == '1') {
            !p and throw "ting:1 !p"
            # same ting, may be adding %species
            Rs&ting = ps&ting;
            ps&directory and Rs&directory ||= ps&directory
            # may to another W/$t
            t = Rs&toW ? R.t : p.t;
        }
        # the Q&of = W
        !Rs&ting and throw "!%ting";
        $n = lab('ting',Rs&ting,'G');
        ns&fs = 15;
        
        # the Q.t = directory/t/species
        t ||= R.t;
        $fullname = t;
        #   only say change in directory
        (p ? ps&directory != Rs&directory : Rs&directory) &&
            lab('directory',(Rs&directory||'/'),'B')
        p && R.t == p.t ?
            lab('t-same','^','G')
          : lab('t',t,'G')
        Rs&species and lab('species','.'+Rs&species)
        Rs&species and fullname += '/'+Rs&species
        Rs&directory and fullname = Rs&directory+fullname
        
        me&the_ting,R;
        
        $Q = me&rollbs,R,'Q';
        Q && Q.t != fullname and Q = null
        !Q and Q = Rs&Q = G&Cye,[fullname,'',{of:Rs&ting}];
        Rs&Quploadsc and Ry&up.sc[Rs&Quploadsc] = Q
        Qc&async = &{};
        # c&canwait = 1;
        Qc&ready = &CP{};
        Rs&havediges and Qs&havediges = Rs&havediges
        # < convert to c&section
        Rs&section and Qs&section = Rs&section
        Rs&args and Qc&args = Rs&args;
        # < Live should never disappear?
        $s = Rs&Live = Rs&_ting(Q,R);
        
        T.Mw = 'ting-into';
        # you may roll into 
        me&rolltog,R,{may:'Q'},0 &&
            n Q  $self:Q,R %Cit,ot
        
        !Qs&ready and me&waits,'!ready','...'
        
        Qc&el and $el = me&tsc,'elvis',""+Qc&el,'b'
        el && elc&s == 9 and els&fs = 16;
        
        !s and return
        # look in
        me&rolltog,R,{may:'L'},0 &&
            n Live  $self:s,R %Cit,ot
        
        me&rolltog,R,'toball',0 &&
            n Live  $s:s,R %ball,tightly,refpool
        
        if (Rs&species) {
            if (!Rs&toball) {
                sy&N ||= me&sunN,s;
                me&tsc,'Csize','x'+sy&N.length,'b';
                # < make part of genesising a %ting from a %tracting?
                $tracting = Rs&tracting || Rc&b && Rc&b.sc.tracting;
                $ope = !tracting;
                ope ||= me&rolltog,R,{may:'inspecto',s:'O',fs:12};
                ope &&
                    n inspecto $s:s,R %inspecto
            }
        }
        else {
            # %ting/%ting subspecies of same
            #  4 is low resolutions of the data
            #  5 is an of/t %Giveness
            Rs&autospecies and R.sc['/'+Rs&autospecies] = 1
            me&rolltog,R,'/4',0 &&
                n Hive  R %ting,species:4
            me&rolltog,R,'/5',0 &&
                n Give  R %ting,species:5
        }
    },'ift,D'],
] };
#c Search Tingingness gets domethings
# stately getting of things
# < with/via e,
#   generating more different e,
#   returning you clues or it
# < knows structuR, me.cby-like stuff
#   the old G&t worked off A.1-5 being
#    the spheres locality around A
#   

# G&c but harvested by Tool
#  as coming from this R, in/out of time,
#   talking about other R, to make acts shimmer
#  available as verbosity, debug points
#  muted when recognised
# < io-param-like + styles of message with object in
me.chatter = &acgttl{
    l.constructor != Array and throw "send array"
    each in l {
        l[i] = '>'+(3+(i*2))+':l'+i+' '+(n||'')
    }
    return G&c:'>1 '+t,l
};

# %ting is a layer upon ...
me.the_ting = &acgtR{
    # have %Search%_ting
    $r = me.cbu(R,'Inn');
    $r = r && rs&Inn;
    !r and throw "no way Inn"
    !rs&_ting and throw "no Inn _ting";
    return Rs&_ting = rs&_ting;
};

# too early to e, retry in 80ms x4
me.tooearly = &acgtkm{
    $tooearly = &T{
        $K = 'tooearly_'+k;
        T[K] ||= 0;
        T[K]++ > 3 and throw "still tooearly: "+k
    };
    if (m) {
        return &y,meanwhile{
            # to init Rs&fengi =
            return &{
                $args = [...arguments];
                # meanwhile() when stalling,
                #  may return a better T to ttl on
                tooearly(meanwhile && meanwhile(...args) || T);
                $cb = &{
                    # f = Rs&fengi (or this again)
                    $f = y ();
                    f(...args);
                };
                G&yl,80,cb;
            };
        };
    }
    tooearly(T);
    return &y{ G&yl,80,y }
};

# Guxily for thing, got via stately e
#  W it pulls in may clue changes to other W
#  per remote place, which may already have its catalogue here
me.Tingingness = &acgtR{ return [
    # the centralising of stuff going in!
    # for using thing = $of/$t on an ongoing basis
    #  gets I.$of.$t
    #  some $of (W/w/js) may network, contain more I
    # usually 
    #   is $t still $dige?
    #   its $dige, here: $s
    # we may get an el/lv/anything-known about things that change
    # the set of Questions you have:
    #   looks like Writer's .5 deps: $type/$name%details
    ['sleeping+Search','4',&acgtRs{
        # they still know the R that set them
        me&rollbs,R,'do_permanence,_ting';
    },'ift,D'],
    ['Search','4',&acgtRs{
        4s&Search = R;
        # an h call muddies T
        $Gtime = &d{ return G&time,d };
        # similar!
        $ch = &tl{ return me&chatter,t,l||[] };
        
        $Ghost = Rs&perc = me&rollbsc,R,'Ghost';
        me&introqua,[R,'Ghost'],{boost:-1},'@1';
        n Ghost  $s:Ghost,R %ball,childy
        
        # of/t=$P
        i $Ghost/In
        # of/t=$P in motion
        i $Ghost/Pulling
        
        
        $Pio = Rs&Pio = {};
        Pio.what = &tP{
            if (Pc&args) {
                o $Ghost/#$t/#Pc&of/#Pc&args/#$P:s
            }
            else {
                o $Ghost/#$t/#Pc&of/#$P:s
            }
            return ya
        };
        Pio.not = &tP{
            if (Pc&args) {
                i $Ghost/#$t/#Pc&of/#Pc&args/-#$P:s
            }
            else {
                i $Ghost/#$t/#Pc&of/-#$P:s
            }
        };
        Pio.is = &tP{
            if (Pc&args) {
                i $Ghost/#$t/#Pc&of/#Pc&args/-#$P:s
                i $Ghost/#$t/#Pc&of/#Pc&args/$P:s
            }
            else {
                i $Ghost/#$t/#Pc&of/-#$P:s
                i $Ghost/#$t/#Pc&of/$P:s
            }
        };
        
        #c _ting - a many arg'd entrypoint
        #  ting becomes the reduce for io's map
        #
        $argsy = ['wjs','peek','JaBabz']
        Rs&_ting = &stz{
            # Question - may come with ...
            $C = isC(s) ? s : G&Cye,[t,1,{of:s}];
            Cy&cv ||= 0.1;
            
            # the G.t variety?
            # if !found of a Talky of:
            
            # C in the field, P in the store
            $P = Pio.what('In',C);
            if (!P) {
                P = G&Cye,[C.t,1,{of:c&of},{}];
                if (argsy.includes(c&of)) {
                    Pc&args = Cc&args;
                    !c&args and throw "of:"+c&of+" args required"
                }
                if (c&species) {
                    # unique of/t must include species
                    !C.t.endsWith('/'+c&species) and throw "t/!species"
                    Pc&species = c&species
                }
                Pio.is('In',P);
                Ps&Want_Check = 1;
            }
            # validate cache
            if (s&Want_Check) {
                Ps&Want_Check = 1;
                delete s&Want_Check;
            }
            # Ps&listened for GhodigWaping, no ttl
            $ttl = c&el == 9 ? 3600 : 4s&Searchttl || 25;
            !Ps&listened && Ps&now && Gtime(Ps&now) > ttl and Ps&Want_Check = 1
            
            s&P && s&P != P and s&oP = delete s&P
            s&P = P;
            
            # try to have the P ready to 
            # in/out of time bit, lost in the store
            $ok = Rs&Pull_a(C,P);
            
            if (s&notsync) {
                # C is not experiencing changes,
                #  eg refreshing things out of time
                #  and Pull_a will c&ready(), leads back
                delete s&notsync;
                c&ready and ac(P,'readyingC',C)
                return
            }
            
            # < don't wait for the async check
            #   use the current, let remotes resolve async
            # Pc&s only null if never found or not decoded
            #!ok && Pc&s && !c&canwait and ok = 1
            #C.t == 'Yingmas-light' and debugger;
            
            if (!ok) {
                # go async
                s&ready = 0;
                # after, c&ready() climbs back to C time
                c&ready and ac(P,'readyingC',C)
                c&async and c&async()
                else {
                    G&TuneTimeMachine,c&of+':'+C.t
                }
            }
            else {
                # C is, Pc&s == null must be intentional
                s&ready = 1;
                
                # C <dige> P, may surprise
                # el=1/8 basically
                c&el = Pc&el;
                if (!c&el || c&el == 1) {
                    c&el = s&dige != Ps&dige ? (s&dige ? 2 : 1)
                        : 8
                }
                c&el && Py&decidedel && Py&decidedel(c&el);
                
                # < all/any sc
                s&dige = Ps&dige;
                s&section = Ps&section;
                !s&section and delete s&section
                c&s = Pc&s;
                # C never gets s&string unless it makes it

                # keeps Pc&s while update is looked for
                Pc&s && Ps&Pulling_since && c&canwait and ~waitscan
                else
                Pc&s and return Pc&s
            }
        };
        #c Pull_a
        
        Rs&Pulling_already = &P{
            $ya = Pio.what('Pulling',P);
            # don't trust stagnant Pulling
            if (ya && Gtime(yas&Pulling_since) > 5) {
                ya = Pio.not('Pulling',P);
            }
            # don't shunt Pull_a from outside its own callbacks
            ya and ch('dupreq',[Cc&of,P.t]); return
            return ya
        };
        
        # shunt P - can progress out of time
        # then returns 1 and/or calls c&ready
        Rs&Pull_a = &CP{
            # < make s&string mean write string, our thing in c&s
            if (Ps&Want_Check || s&string) {
                if (Ps&Want_Check == 2) {
                    s&string and ch("Redo+string")
                    delete s&string;
                }
                else {
                    # waiting on P
                    Rs&Pulling_already(P) and return
                    # become Pulling
                    Ps&Pulling_since ||= Gtime();
                    Pio.is('Pulling',P);
                    Pc&T = {};
                }
                $T = Pc&T;
                # shunts Pull_a when ready
                T.cb_gen = &CP{
                    if (T.redo) {
                        ch('Redoing',[P.t]);
                        Ps&Want_Check == 2 and throw "redo x2"
                        Ps&Want_Check = 2;
                        delete T.redo;
                    }
                    else {
                        delete Ps&Want_Check;
                    }
                    Rs&Pull_a(C,P);
                };
                # sends
                Rs&Pull_Check(T,C,P);
            }
            $T = Pc&T;
            !T and throw "unstarted P"
            !T.ok and return
            
            # < C gets its own decode? or Copy Pc&s on el<3
            #s&wantdecode and Ps&Want_Decode = 1
            # < modes of decode: dl/Xpath, allowing yaml code
            Ps&noDecode and delete Ps&Want_Decode
            Ps&Want_Decode and Rs&Pull_Decode(T,C,P)
            
            !T.ok and return
            delete Ps&Want_Decode;
            
            # < way getting args/wrapping/eval as Pull_Transcode?
            #   it's ting's business if things want to share
            
            Pio.not('Pulling',P);
            delete Ps&Pulling_since;
            # pulling done re. $Ghost, but not $C
            #!Pc&s and throw "no ting Pcs: "+Pc&of+'/'+P.t
            
            Py&decidedel = &n{ T.tcp && T.tcp.set('l3',n) };
            
            each iC Ps&readyingC {
                # P completed async, get back to C time
                #   no longer awaiting yon return 1
                c&ready and c&ready(C,P)
            }
            delete Ps&readyingC;
            
            return 1
        };
        #c PullCheck
        Rs&Pull_Check = &TCP{
            T.waits and throw "PullCheck while waits"
            T.ok = null;
            # they may have their own ways to use dige/v, p/P/s&P
            # Pc&get how to ask,
            # Pc&got loads response into P
            $Do = Rs&Talks[c&of];
            !Do and throw "!Talk "+c&of
            T.get = {};
            T.get.data = {};
            Do(T,C,P);
            if (T.done) {
                # sync Talk.mem, every time
                # no cb_gen, keeps Want_Check=1
                Ps&now = Gtime();
                T.ok == null and T.ok = 1
                delete T.done;
                # for Decode timer:
                #T.tcp = ch(c&of,[C.t,'.','.','.','']);
                T.aft_waits = Gtime();
                # returns to complete Pull_a
                return
            }
            !T.get.url || !T.got and throw "!Talk handlers "+c&of
            
            T.cb = &sc{
                T.aft_waits = Gtime();
                # every pulling happened now
                Ps&now = Gtime();
                # specific stuff moves from the response to P and Pc&s
                #  can !T.ok...
                T.got(P,s,c);
                # out of time plumb
                # may be stolen by got if more requests (/js)
                T.ok = 1;
                T.cb_gen and T.cb_gen(C,P)
            };
            Rs&TCP(T,C,P);
        };
        # rebuild tcp
        # < https://javascript.info/xmlhttprequest
        # < have A, so async in handler gets retried
        #    (or G&way noop deps just before handling)
        # < get or ws
        # retry, expire
        # uses T.get -> T.cb()
        Rs&TCP = &TCP{
            $tcp = T.tcp = ch("tcp",[T.get.url,'.','.','.','']);
            
            $done = &s,how,c{
                !T.waits and return
                T.waited = Gtime(T.waits);
                delete T.waits;
                tcp.set('l1',G&thime,T.waited );
                r.status != '200' and debugger; return T.status = r.status
                T.cb(s,c);
            };
            
            $r = T.r = $.ajax(T.get)
            r.done(done);
            r.error(&csm{
                # when $error makes 400
                c.responseText and m = c.responseText
                m.startsWith('{') and m = dej(m)
                m.er and m = m.er
                m = c.status+": "+m
                Ps&errors = m;
                Cs&errors = m;
            });
            T.waits = Gtime();
            
        };
        
        #c Talks/Decode
        
        Rs&Talks = {};
        Rs&Decode = {};
        Rs&Mix = {};
        # the usual way to decode a response,
        #  having a sc header for dige/of
        # Pc&s = me&Pcs,P,c,s;
        me.Pcs = &acgtPcs{
            $W = Pc&s = Cye([P.t,1]);
            s != null and Wc&s = s
            Ws&of = Pc&of;
            $sc = c && (c.getResponseHeader ?
                c.getResponseHeader('sc') : c);
            if (sc) {
                isst(sc) and sc = dej(sc)
                # < retractable, see Punready
                ex(P.sc,sc);
                ex(W.sc,sc);
            }
            return W;
        }
        # make a P look unready
        $Punready = &P{
            delete Pc&s;
            delete Ps&dige;
            delete Ps&string;
            delete Ps&section;
            delete Ps&lines;
        }
        # implant code as .js
        #  should be able to receive any ting,
        #  esp way, is more stack/debugger findable loaded like so:
        Rs&add_script = &src,cb{
            $have = $('body script[src="'+src+'"]');
            have.length and return cb(have[0])
            $s = document.createElement('script');
            s.setAttribute('src', src);
            s.setAttribute('type', 'text/javascript');
            cb and s.onload = &e{ cb(s,e) };
            document.body.appendChild(s);
            return s
        };
        
        Rs&Pull_Decode = &TCP{
            T.ok = 0;
            $type = Ps&Want_Decode;
            $de = ch('decode',[P.t,type,'','']);
            
            $Do = Rs&Decode[type];
            !Do and throw "Decode type "+type
            
            # Pc&el becomes interesting to the Client,
            #   2-3 were our will carried out
            #   6-7 to merge
            # < C may want a new set for itself, to make a mess
            #   while we are in the clone factory
            #   faster to separate with io than many readLines?
            #   but how much safer??
            
            $s = null;
            try {
                s = Do(P,C,Pc&s);
                !isC(s) and throw "didnt Decode type "+type
                s.y.P = P;
                Pc&s = s;
            }
            catch (er) {
                T.er = er;
                de.set('l2','Error!');
                de.set('l3',er);
            }
            Pc&s = s;
            s && !T.er and T.ok = 1
            
            if (T.ok && T.aft_waits) {
                T.aft_waited = Gtime(T.aft_waits);
                delete T.aft_waits;
                T.tcp && T.tcp.set('l2',G&thime,T.aft_waited );
            }
        };
        
    
        #c Talks.w|wjs
        # < w are from:
        #  the digway+/way/ (trad)
        #  the /w/ (unBabz'd way) (new)
        #    this dige might match the one from digway?
        #  the /wayz/ (Babz usual blockquotes)
        #    for use in We
        Rs&Talks.w = &TCP{
            # < Babz mode: none, normal, BQ-inclusive
            T.get.url = '/way/'+C.t;
            Ps&dige and T.get.data.have = Ps&dige
            T.got = &Psc{
                $dige = c.getResponseHeader('Dige');
                !s && Ps&dige == dige and s = Ps&string
                if (s != Ps&string) {
                    Pc&s = null;
                    Ps&dige = dige;
                    Ps&string = s;
                    Ps&Want_Decode = 'way';
                }
            };
        };
        # filling out way, more when called:
        Rs&Decode.way = &PCw{
            $w = G&Cye,[C.t,1];
            wc&s = Ps&string;
            ws&of = 'w';
            # dige is for s before compiled
            ws&dige = Ps&dige;
            return w
        };
        # Talks.wjs
        Rs&Talks.wjs = &TCP{
            # you must know how to call the way
            $args = Cc&args;
            !args and throw "untried w"
            $src = '/wjs/'+C.t+"__"+args;
            $ask = src;
            # dige not supported (just t:s store, will 404)
            c&dige and ask += "__"+c&dige
            # script src must inc dige to version
            T.get.url = ask;
            
            $cb_gen = delete T.cb_gen;
            T.got = &Psc{
                $W = me&Pcs,P,c,s;
                # not looking ready too soon, wait for Wc&code
                delete Pc&s;
                # < get the source code out of a <script src> ?
                # use our first request (to ascertain the dige)
                c&dige && Ws&dige != c&dige and throw "dige!ask"
                !Ws&dige and throw "!dige"
                src += "__"+Ws&dige+".js"
                # nest callback to <script> it
                T.ok = 0;
                T.waits = Gtime();
                $cb = &s,e{
                    Pc&s = W;
                    T.waited_script = Gtime(T.waits);
                    T.ok = 1;
                    Ps&script = s;
                    Ps&src = src;
                    Ps&Want_Decode = 'wjs';
                    G&yl,3,&{cb_gen(C,P)};
                };
                Rs&add_script(src,cb);
            };
            
        };
        # < discover compile errors (since we have args)
        Rs&Decode.wjs = &PCw{
            if (0) {
                # if compiled or not
                $towake = me.cbu(R,'JRom');
                !towake and throw "notowake";
                me&elvis,R,'wayjs',{wake:towake};
            }
            # unique name
            $name = ['w',w.t,ws&args,ws&dige].join('__');
            name = name.replace(/\W+/g,'_');
            # for the code in Ps&src
            $y = window[name];
            
            # which might have trouble
            $comperr = Ps&script.compile_errors;
            !y && !comperr and ~>5 wayjs not comperring: w.t
            if (!y) {
                Ps&error = "nocompile: "+name;
                ~>5 wayjs not compiling: w.t, name
            }
            
            #~>5 wayjs loaded: w.t
            Ps&script.loaded = 1;
            # providing the next error with line number:
            wc&code = y;
            wc&script = Ps&script;
            wc&script.way = w;
            ws&of = 'w';
            return w
        };
        #c Talks.js
        Rs&Talks.js = &TCP{
            # I in a .js script (+ a little about the 9)
            # first request: only to find the dige,
            # then we can write a unique <script src=toit>
            # < if we know what version don't do this first request
            # T would put this c&dige to wind back from bugs
            # hazardily shared P having the branch reset,
            #   put the -$dige in C.t already to have a specific P be there
            T.get.url = '/js/'+C.t+'-'+(c&dige||'head');
            # < if c&v forced/trusted (via Wover),
            #   use the exact url to add_script
            # < does the rewritten Location mean the second XHR caches?
            $cb_gen = delete T.cb_gen;
            T.got = &Psc{
                $src = c.getResponseHeader('Location');
                $m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
                $W = Pc&s = G&Cye,[m[1],1];
                Ws&I = {};
                Ws&dige = Ps&dige = m[2];
                # /js/ 
                # nest callback
                T.ok = 0;
                T.waits = Gtime();
                $callback = &s,e{
                    T.waited_script = Gtime(T.waits);
                    T.ok = 1;
                    Ps&script = s;
                    Ps&Want_Decode = 'js';
                    cb_gen(C,P);
                };
                Rs&add_script(src,callback);
            };
        };
        Rs&Decode.js = &PCW{
            $tocfunc = W.t+'_'+Ws&dige;
            !window[tocfunc] and throw "Notocfunc: "+tocfunc;
            $toc = window[tocfunc]();
            $D;
            each iv toc {
                $ind = v[0];
                $C = G&Cye,[v[1],v[2],v[3],v[4]];
                if (ind == '') {
                    D = Ws&I[C.t] = C;
                    D.y.tw = {};
                    D.y.tv = {};
                    Ds&z ||= [];
                }
                else if (ind == '  ') {
                    D.t != s&js and throw "Csjs not last D", C, D;
                    c&code = window[s&name];
                    typeof c&code != 'function' and throw "Cccode not function", C, D;
                    # grow I
                    D.y.tv[C.t] ||= {};
                    D.y.tv[C.t][C.y.cv] = C;
                    D.y.tw[C.t] = C;
                    $l = Ds&z.slice(-1);
                    l[0] and l[0].y.next = C;
                    Ds&z.push(C);
                    D.y.in ||= C;
                    if (D.t === 'i' && (C.t === 'h' || C.t === 't')) {
                        G[C.t] = c&code;
                    }
                }
                else {
                    throw "deep C: "+W+"/"+t, v
                }
            }
            return W
        }
        #c JaBabz
        Rs&Talks.JaBabz = &TCP{
            T.get.url = '/JaBabz/'+C.t;
            T.get.type = 'post';
            $d = T.get.data = {};
            d.s = s&ghost;
            d.s == null and throw "of:JaBabz!%ghost"
            d.dige = dig(s&ghost)
            
            T.got = &Psc{
                Pc&s = null;
                Ps&dige = dig(s);
                Pc&s = dej(s);
                # sanity, y&P it
                Ps&Want_Decode = 'C';
            }
        }
        # < universal string -> C is Lines (esp if tabby),
        #   Cye(dej( where ^[\{\[]
        Rs&Decode.C = &PCW{
            return W
        }
        #c Talks.W
        # replacing Pc&s (clued from headers etc) with the deLines:
        Rs&Decode.Lines = &PCW{
            !Ps&string and throw "P!%string"
            $N = G&readLines,Ps&string;
            N.length != 1 and throw "Weird tW lines", s
            return N[0]
        };
        Rs&species_Decode ||= {};
        Rs&species_Decode.js = 'string';
        Rs&Talks.W = &TCP{
            T.get.url = '/W/'+C.t;
            $d = T.get.data = {};
            $is_write = s&string != null;
            # clue them to Hobs for it we have around
            # the current HEAD:
            $haves = s&havediges || {};
            Ps&dige and haves[Ps&dige] = Ps&string
            if (hak(haves) && !is_write)
                d.have = haks(haves).join("\t")
            
            c&gitmv and d.gitmv = c&gitmv
            if (c&species) {
                d.species = c&species;
                $dec = Rs&species_Decode[c&species]
                dec and T.Want_Decode = dec
            }
            
            # the first "can you hold on to..."
            if (is_write) {
                # wants to write, '' to delete
                T.get.type = 'post';
                # the .1
                d.s = delete s&string;
                delete d.have;
                # ignore write 
                if (d.s.length && d.s == Ps&string) {
                    # just keep expecting it
                    !d.have and throw "sleeping write !Psdige"
                    delete d.s;
                }
                else {
                    # < get the average size of codes down,
                    #   mix them locally (A:u)
                    c&patch and throw "< patches"
                    # continuity check, also for deletes
                    # < d.parent=null means it should be new
                    s&P and d.parent = s&P.sc.dige
                    s&parent and d.parent = delete s&parent
                    # the .5 comes along
                    $five = delete s&fivestring;
                    five and d.fivestring = five
                }
            }
            T.got = &Psc{
                $r = dej(s);
                # dige find things we d.have
                if (r.dige && r.s == null) {
                    if (haves[r.dige]) {
                        r.s = haves[r.dige];
                        if (dig(r.s) != r.dige) {
                            is_write and throw "write dig mismatch", dig(d.s)
                            else {
                                throw "!security of anyone's Cs&havediges providing Ps&string"
                            }
                        }
                    }
                    else
                    d.s && r.dige == dig(d.s) and r.s = d.s
                    r.s == null and $nors = 1;
                }
                if (r.s && r.dige && dig(r.s) != r.dige) {
                    !C.t.match(/^spot\//) and ~>6 Nodig: C.t, dig(r.s), r.dige
                }
                $el;
                $erok = 0;
                r.ok == 'found' and el = 1
                r.ok == 'created' and el = 2
                r.ok == 'updated' and el = 3
                # 6 is 3 from beyond 5! matters
                r.ok == 'forward' and el = 6
                r.er == 'not ffwd' and el = 7; erok++
                r.ok == 'deleted' and el = 9; Ps&departs = Ps&dige
                r.er == 'not found' and el = 9; erok++
                Pc&el = el;
                r.er && !erok and throw r.er
                if (el == 9) {
                    # watch for undelete?
                    r.s and throw "what"
                    r.suggest_species and Ps&suggest_species = r.suggest_species
                    Punready(P);
                    # plumb? like an elvisory
                    return
                }
                if (nors) {
                    # < different perl/javascript dig
                    el == 3 and return T.redo = 1
                    else {
                        T.redo = 1;
                        ~>3 digeuno: C.t, r.dige
                    }
                }
                if (el == 7) {
                    # notify push failed?
                    c&rebase and c&rebase(P,r)
                    else {
                        throw "not ffwd: "+C.t, r
                    }
                }
                !el and throw "tW er", r.er, P, r
                if (r.s && r.s != Ps&string) {
                    Pc&s = null;
                    Ps&dige = r.dige;
                    Ps&string = r.s;
                    Ps&Want_Decode = T.Want_Decode || 'Lines';
                }
                if (el <= 3) {
                    $se = d.se || r.se;
                    se and Ps&section = se
                }
            };
        };
     
        #c Talks.peek
        Rs&Talks.peek = &TCP{
            T.get.url = '/peek/'+C.t;
            !c&args and throw "index req. c&args"
            c&args != 'none' and T.get.data = G&peel,c&args;
            T.got = &Psc{
                $s = dej(s);
                if (s.er) {
                    Ps&er = s.er;
                    Punready(P);
                    return
                }
                # ^ or the opposite,
                delete Ps&er;
                $W = me&Pcs,P,s.sc;
                $unk = haks(s).filter(k => k != 'sc');
                unk.length and throw "more response",unk,s
                # Ws&between may be [lengthxdige+]
            }
        };
        #c Talks.ghost,tmp,mem
        # W that is string
        Rs&Talks.ghost = &TCP{
            s&section and c&section = s&section
            s&string != null && !c&section and throw "/ghost/+ !section"
            Rs&Talks.W(T,C,P);
            T.get.url = '/ghost/'+C.t;
            $d = T.get.data;
            c&section and d.se = c&section
            T.Want_Decode = 'ghost';
        };
        # Pc&s = C (c&s = Ps&string)
        Rs&Decode.ghost = &PCW{
            $W = Rs&Decode.string(P,C,W);
            Ws&of = 'w';
            return W
        }
        Rs&Decode.string = &PCW{
            !Ps&dige and throw "P!%dige"
            !Ps&string and throw "P!%string"
            $W = Pc&s = Cye([P.t,1]);
            Wc&s = Ps&string;
            Ws&of = Pc&of;
            Ws&dige = Ps&dige;
            return W
        };
        # tmp that is string
        Rs&Talks.tmp = &TCP{
            T.Want_Decode = 'string';
            Rs&Talks.mem(T,C,P);
        };
        # mem that is Lines
        Rs&Talks.mem = &TCP{
            T.done = 1;
            $s = localStorage[C.t];
            $el = 1;
            !s and el = 9
            if (s&string != null) {
                # wants to write
                $parent;
                s&P and parent = s&P.sc.dige
                s&parent and parent = delete s&parent
                s && parent && dig(s) != parent and el = 7
                else {
                    s = localStorage[C.t] = delete s&string
                }
            }
            Pc&el = el;
            if (el == 9) {
                # watch for undelete?
                delete Pc&s;
                delete Ps&dige;
                delete Ps&string;
                # plumb? like an elvisory
                return
            }
            if (el == 7) {
                # notify push failed?
                c&rebase and c&rebase(P,C)
                else {
                    throw "not ffwd: "+C.t, r
                }
            }
            if (s && s != Ps&string) {
                Pc&s = null;
                Ps&dige = dig(s);
                Ps&string = s;
                Ps&Want_Decode = T.Want_Decode || 'Lines';
            }
        };
     
    },'ift,D'],
    
] };
#c %mundws holds an A:ws
me.Socketingness = &acgtR{ return [
    # < push/pull of C living across the boundary
    ['mundws','3',&acgtRs{
        Rs&rowish = 1;
        # < these ways to assume arguments want fibre
        $ws = me&rollbs,R,'Sock',1;
    },'ift,D'],
    
    # at LVing avail
    ['mundws','4',&acgtRs{
        Rs&rowish = 1;
        
        # current state
        $ws = Rs&Sock;
        
        # /path
        me&tsc,'mundws','ws:','b';
        me&tsc,'path',R.t
        me&tsc,'state',ws.state,'6';
        ws.state == 'closed' and Rs&Sock = 1
        
        # %Again
        $z = Rs&Opinion && Rs&Opinion.sc.z;
        $len = z && z.length;
        z and me&tsc,'Opinion.length','('+len+')';
        
        #Rs&Lving &&
        #n Lving  $self:Rs&Lving,R %Cit
    },'ift,D'],
    #c GhodigWap news from the 5 year old editor
    # one aspect of news about $ways, from g/\w+/\d+
    ['GhodigWap','3',&acgtRs{
        # replaces J:digwaypoll
        me&rolltog,R,'nodigway',1,&s{4c&nodigway=s};
        $def = location.host.match(/edit/) && 1;
        me&rolltog,R,'noGhodig',def,&s{4s&noGhodig=s};
        
        
        # $w as heard about, seekended and living (Iw)
        me&introqua,[R,'ifd','Ghost','apparently'],{boost:-1},'@1';
        me&introqua,[R,'ifd','Ghost','est'],{boost:-1},'@1';
        me&introqua,[R,'ifd','Ghost','sub'],{boost:-1},'@1';
        me&introqua,[R,'wats'],{boost:-1},'@1';
        
        # w can be trusted if listened for in digwaypoll
        # digwaypoll in/out only t + dige
        #  dige may vary in length > 6
        #  dige in merely allows Opinion to sleep
        #   when it comes out, which we could imply:
        #   < Lc&* for server's agreement with said diges
        #     they say what send() they agree up to,
        #      and we synthesize eouts to mean it
        n digwaypoll  R %mundws,Ghocoline,tinyscLines:dige,mightsctrunc:dige
        
        n ifd  R %Ghostway
        # < ^ having its own compile,
        #   your ting w/* perspective may incorporate it
        #   then another ing happens?
        
        # G&way compiled:
        n wats  $s:A.5.I.w,R %Idoubleyou,ball,childy:tw
        
    },'ift,D'],
    #c Ghostway - asks for way notifies, gets them
    # provides ein/out/ope
    #   by way of %Again/%tinyscLines
    #   for C sloshing in or out
    # knows how to talk ws:s/digwaypoll
    ['Ghostway','33',&acgtRs{
        $p = Ry&up;
        # place to talk
        $S = Rs&Upstream = ps&z[ps&z.indexOf(R)-1];
        $ch = Rs&chatter = Ss&chatter;
        # insured memories via %Again
        $g = Ss&Again = ps&z[ps&z.indexOf(R)+1];
        $Way = gc&s;
        
        # the 'here', a join
        $Ghost = 4s&Ghodig = Rs&perc = me&rollbsc,R,'Ghost';
        n Ghost  $s:Ghost,R %ball,childy
        
        # pile from both ends over time
        i s:{ Ss&Opinion=C } $Ghost/apparently:s
        # and changes go further
        i s:{ Ss&Further=C } $Ghost/seek:s
        
        # before %Upstream connects/Lvact, ein wait
        Ghosty&subscribe =
            me&tooearly,'Ghostysub','stub' (&{
                return Ghosty&subscribe
            });
        # on change, queue:
        Ss&do_Further = &{
            4s&noGhodig and return
            # /apparently/* changing creates /seek/*
            # to look it up since that dige changed
            o $Ghost/seek/*
            $seeking = ays&s;
            !seeking and return
            Rs&seeking = seeking.slice();
            each is seeking {
                o $Way/#$s
                !ya and ch("didnt know",[s.t])
                Rs&seeketh(s,ya)
            }
            return
        };
        
        # < ting many asks per question
        #   so many seekeths make one seekend
        #   is a keepalive for the first question
        Rs&seeketh = &s,was{
            ch("seeking...",[s.t]);
            #$w = G&ting,'w',s.t;
            #   currently takes old-G&t shortcut,
            #    returns way without checking ttl
            $cb = &t,ar,w{
                Rs&seekend(w,s,was);
            };
            # noop='nottl' so it renews
            G&way,s.t,{},cb,'nottl';
        };
        
        # thing is got!!!
        Rs&seekend = &w,s,was{
            Ss&sleep_Further &&
                Ss&sleep_Further(w,s);
            
            $com = [w.t,ws&dige];
            !was and com.push("@1")
            else
            if (wass&dige == ws&dige) {
                return ch("Seeksame",[w.t])
            }
            ch("Seekback",com);
            # hold latest one here
            # < of those changing rapidly
            #   rolling commits together
            #   ong branch slower, then ung
            i $Ghost/ing/$w
            # once after the batch (ish)!
            $si = Rs&seeking.indexOf(s);
            si >= 0 and Rs&seeking.slice(si,1);
            # wait up to 30ms if more might seekend
            $delay = Rs&seeking.length ? 30 : 0;
            # joining seekends near in time!!!!!!
            $cb = me&sccb,R,'seekingdone',Rs&do_ing;
            delay ? G&yl,delay,cb
                : cb();
        };
        
        #c 7 thing-got
        Ss&sleep_Further = &ws{
            4s&noGhodig and return
            if (!w) {
                # from eout that sleeps
                o $Way/#$s
                w = ya;
                !w and return ch("didn't know sleeping",[s.t])
            }
            # Iw has $w, make permanent!
            ws&now = G&time + 3600;

            i $Ghost/seek/-#$s
            # < should know time is up for this ground,
            #   get it attached via Tsome
            #n seen  $self:w %Cit
            # permanent
            i $Ghost/est/$w
        };
        
        Rs&do_ing = &{
            # things changing, code to redo!
            o $Ghost/ing/*
            $inging = ays&s;
            # < otherwise G&ting evals?
            $doers = 'Soogle Packle Coffle Foogla Fividy NutGravy Fourism'.split(' ');
            $mewrap = 'iooia'.split(' ');
            $doerd = [];
            each iw inging {
                if (mewrap.indexOf(w.t) >= 0) {
                    # me.code inits something
                    ch("Ghostwaywr",[w.t]);
                    me[w.t](w);
                }
                elsif (doers.indexOf(w.t) >= 0) {
                    # way contains me.codes
                    ch("Ghostwayer",[w.t]);
                    G&way,w.t;
                    doerd.push(w);
                }
                else {
                    ch("Ghostway",['',w.t]);
                }
                i $Ghost/ing/-$w
                # then anything dependent on the way
                #  eg I, J...
                #  diff way to wake a .Ja. is not impossible
                o $Ghost/sub/#w.t/*
                each in ays&s {
                    ns&ein && ns&ein(w)
                }
            }
            # for $w that generate $me which generate I,
            #   drop Ring's cache of me I
            $dropcache = doerd.length && 1;
            
            Rs&do_permanence(dropcache);
        };
        
        Rs&do_permanence = &dropcache,{
            # keep permanent
            # the only in-time operation
            # < scan for not in Iw
            # < dige sleep on init may not get things here:
            o $Ghost/est/*
            each iw ays&s {
                ws&now = G&time + 3600;
                if (dropcache) {
                    delete ws&makesI;
                    delete ws&makesIw;
                }
            }
        }
        
        # keepalive
        Rs&do_permanence();
        # casual shunt, in case e loses its will to carry it out
        Ss&do_Further() || Rs&do_ing();
    },'ift,D'],
    
    #c %Again (C/%ball source) -> %ein()
    # e inits some state (usually)!
    ['Again','35',&acgtRs{
        !Rs&Again.sc.ball and throw "Again!ball"
        $Ghost = 4s&Ghodig;
        Rs&Lvact = &{
            $g = Rs&Again;
            gs&ball and g = gc&s
            !gy&tw and throw R.t+"%Again!ytw";
            # load all, Ghocoline dedupes encoded
            each tC gy&tw {
                Rs&ein(C)
            }
            # for subscribing one
            gc&chin = &C{ Rs&ein(C) }
            
            # < i-hook sub/*
            $sub = fio(Ghost,'sub',0);
            sub && me&ioty,sub .map(&s{
                # the thing to name
                $C = Cye([s.t,1]);
                # subscribers might know about it
                $eg = me&ioty,s [0];
                $P = eg && egs&P;
                $s = P && Pc&s;
                Rs&ein(s||C);
            });
            Ghosty&subscribe = &C{ Rs&ein(C) };
        };
        # el=2 everything
        Rs&eope = &{ Rs&Lvact() };
        # el=2 changing
        Rs&Lving and Rs&Lvact()
        
    },'ift,D'],
    # %ein(C) to take only t and certain sc
    # %eout(C) into %Opinion
    #   and into %Further if certain sc change
    ['tinyscLines','32',&acgtRs{
        # Lving: may not make it through send() if same
        Rs&uniqsend = 1;
        # a t/dige only variety of tinyLines encoding:
        Rs&tinyLines = 1;
        
        # only certain sc taken
        $only = Rs&tinyscLines;
        only = only && only != '1' && only.split(',')
        Rs&takeonlysc = &s{
            !only and return ex({},s.sc)
            $sc = {};
            each ik only {
                s.sc[k] == null and continue
                sc[k] = s.sc[k]
            }
            return sc
        };
        
        # their Opinion arriving
        Rs&hasonlysc = &sl{
            $ks = only || haks(s.sc);
            $ok = 1;
            # checks how different it is
            each ik ks {
                $was = s.sc[k];
                $is = l.sc[k];
                $com = [l.t, k, was, '->', is];
                !is and ch('nullsc',com); return -1
                
                was != is and ok = 0
                
                if (!ok && Rs&mightsctrunc == k && was
                    && was.length > 6 && is.length > 6) {
                    ok = was.includes(is) || is.includes(was)
                }
                !ok && was and ch('scut',com)
            }
            # applies!
            each kv l.sc {
                s.sc[k] = v
            }
            return ok
        };
        
        $ch = Rs&chatter;
        Rs&ein = &n{
            !isC(n) and throw "ein !C"
            ns&ball and throw "ein%ball: "+ki(n)
            $c = {}; # L%send[D.sc
            $C = G&Cye,[n.t,1,{},Rs&takeonlysc(n)];
            # Opinion is one piled from both ends
            #   so it can come back same the first time
            i Rs&Opinion/-#$C
            i Rs&Opinion/$C
            c.toLines = C.t;
            if (haks(C.sc).length) {
                c.toLines += '%'+G&depeel,C.sc
            }
            Rs&send(n,c);
        };
        Rs&eout = &l{
            !Rs&Opinion and throw "give Opinion"
            !Rs&Further and throw "give Further"
            
            # their opinion is arriving
            i Rs&Opinion/#$l:s
            $ok = Rs&hasonlysc(ya,l);
            ok < 0 and 'said error'
            elsif (ok) {
                ch('sleep',['way',l.t]);
                Rs&sleep_Further &&
                    Rs&sleep_Further(null,l)
            }
            else {
                # changes go %Further once per receive
                ch((!ya?'new':'wake'),['way',l.t])
                i Rs&Further/$ya
                Rs&do_Further &&
                    ac(R,'Finally',Rs&do_Further)
            }
        };
    },'ift,D'],
    #c Ghocoline - C<->string envelope
    # provides %receive(), wraps %send()
    #   en/decoding some string format
    # Lving @31 logs a %send/receive[D+]
    # see 'Lving' around here, it may also:
    # < Ls&z clone C we sent them?
    #     would allow better %resumable
    #     %uniqsend dedupes for now
    # the @34 do push/pull C across a boundary stuff
    # the @32 is C<->string:
    # all Lines =~ /^[ \w"]/
    #  so there's room for some protocol in there:
    # < Lc&resumable - do you remember? rolls state:
    #   - roll Ls&send if %uniqsend, dedupes
    #   - know Ls&z and lv-sense to your app
    #   app must sleep while we try to:
    #   negotiate what they know with el=7
    #     might know our/previous Ls&sent_dige
    #       retransmit Ls&send
    #     or stuff on the ground
    #       exploratory W nature,
    #       eg check state of everything in Toys:
    #         Toys el:7%dige:358i0f
    #       may not include %dige on request,
    #         but then the server could pre-empt our:
    #           what has what become,
    #            and what can be patched
    # Lc&responsey - expect one receive per send
    #   link them, ordering if many backends
    #   responses not in requested order
    #   < slowing/Aing out time to understand message
    ['Ghocoline','32',&acgtRs{
        Rs&receive = &sD{
            typeof s != 'string' and throw "receive !string"
            $ch = Rs&chatter;
            ch and ch('receive',[ki(s,3)])
            
            Rs&tinyLines and Rs&someLines ||= 1
            Rs&someLines and Rs&contLines ||= 1
            
            if (Rs&contLines) {
                # can know how to nest another protocol
                if (!s.match(/[ \w"]/)) {
                    # tricks with Lving"
                    throw "strange"
                }
                elsif (s.match(/^ /)) {
                    # Lving -> last message's cursor
                    throw "floating start"
                }
            }
            
            # string tricks
            # decoded N everything becomes M ways in
            $l = [s];
            if (Rs&someLines) {
                # splits lines, batch of something
                # < by next Line d=0?
                l = s.split("\n");
                l.slice(-1)[0] == '' and l.pop()
            }
            
            # parsed
            $z = l.slice();
            if (Rs&tinyLines) {
                # parse Ghost%dige:4827848
                each is l {
                    $s = s.split('%');
                    s [0].split("\t").length > 1 and throw "comp"
                    z[i] = G&Cye,[s[0],'',{},s[1]]
                }
            }
            elsif (Rs&contLines) {
                throw "readLines wanted"
                # make R to deLines then ein?
                #$N = me&readLines,s;
            }
            
            # iterated
            Rs&esout and Rs&esout(z)
            else
            Rs&eout and z.map(s => Rs&eout(s,z))
            
            $Fin = delete Rs&Finally;
            Fin && Fin.map(cb=>cb());
        };
        #c send!!
        $send = Rs&send;
        !send and throw "no Ghocoline proxy send()"
        Rs&send = &sc{
            $string = s;
            # the Lving%send/$D .sc
            c ||= {};
            typeof s == 'string' and 'ok'
            else
            !isC(s) and throw "obj->string"
            else
            if (ss&ball && ss&toLines || c.toLines) {
                string = c.toLines || ss&toLines;
                c.origin = s;
                $L = Rs&Lving;
                # < Lving: repeat string/diff/compression
                #   smelting toLines' intel,
                #   what to do with lots of el:8 etc.
                if (Rs&uniqsend && Ls&send) {
                    $i = Ls&send.length-1;
                    while (Ls&send[i]) {
                        $D = Ls&send[i--];
                        !Ds&origin and continue
                        if (Ds&origin != s) {
                            # by .t?
                            Ds&origin.t != s.t and continue
                        }
                        Dc&s == string and return
                    }
                }
            }
            else
            ss&ball and throw "send R%ball!%toLines"
            else {
                throw "send R!%ball"
            }
            
            $ch = Rs&chatter;
            ch and ch('send',[ki(string,3)])
            send(string,c);
        };
        Rs&open = &{
            $L = Rs&Lving;
            L && Lc&b && Lc&resumable and 'Lvism el=7 for %sent_dige'
            Rs&eope and Rs&eope()
        };
    },'ift,D'],
    #c A%Sock <-> A:ws!
    # at both ends of the deal
    # provides Rs&Lving and Rs&send()
    # uses Rs&open() and Rs&receive()
    ['Sock','31',&acgtRs{
        $ws = Rs&Sock;
        if (ws == 1) {
            $url = 'ws://'+location.host+'/'+R.t;
            ws = Rs&Sock = new WebSocket(url);
            ws.url = url;
        }
        
        # when R el=9
        me.cbuac(R,'unDoming',&{
            ws.close(1000,'lum')
        });
        $X = window.websocks ||= {};
        X[ws.url] = ws;
        $sockdup = &{
            X[ws.url] == ws and return
            ws.close(1000,'dup');
            return 1
        };
        
        # our A:ws.c hooks
        # this should A:session
        #   reflecting a scene across it
        #   they might hold objects for us,
        #     as we talk to them
        #   or show objects we talk about
        $L = me&rollbs,R,'Lving';
        
        # try leak chatter!!!!!!
        $ch = Rs&chatter = &t,ev{
            # < io-param-like + styles of message with object in
            $l = ev.constructor == Array ?
                [R.t, ... ev] :
                [R.t,
                ws.deter('code',ev.code),
                ev.reason,
            ];
            each in l {
                l[i] = '>'+(3+(i*2))+' '+(n||'')
            }
            G&c:'>1 '+t,l
        };
        
        # L logs a %send/receive[D+]
        $roll = &tsoc{
            $L = Rs&Lving;
            !L and throw "ws:L:send!open"
            
            # accumulating dige
            $digek = t+'_dige';
            L.sc[digek] = dig((L.sc[digek]||'')+s);
            
            # point in time log
            c ||= {};
            c.now = G&time;
            # opposite direction's count
            # last in when this went out, etc.
            1 && o and c[o] = L.sc[o+"_i"]
            # < out of time n ... meaning something
            #me&tsc,t,s,c;
            $D = Cye([t,1,{s:s},c]);
            ac(L,t, D );
            
            # count
            $ik = t+'_i';
            L.sc[ik] ||= 0;
            L.sc[ik]++;
            
            return D
        };
        
        # open/close/explode
        ws.onopen = &ev,{
            ch('open', ev);
            L = me&rollbsc,R,'Lving','b,increment';
            Rs&open();
        };
        ws.onclose = &ev,{
          ch(ev.wasClean ? 'closing' : 'close', ev);
          ws.deter('code',ev.code) != 'bad' and return
          # will re-new when R wakes
          delete Rs&Sock
        };
        ws.onerror = &ev,{
          ch(ev.wasClean ? 'err' : 'errs', ev)
        };
        
        # send/receive
        Rs&send = &sc{
            $D = roll('send',s,'receive',c);
            # never fails?
            ws.send(s);
            return D
        };
        ws.onmessage = &ev,{
            sockdup() and return
            $s = ev.data;
            $D = roll('receive',s,'send');
            Rs&receive(s,D);
        };
        
        # interpret the machine
        ws.proto = {
          state: {
            0:'connecting',
            1:'open',
            2:'closing',
            3:'closed',
          },
          code: {
            1000:'closing',
            1006:'bad',
            1001:'leaving',
            1009:'toobig',
            1011:'500',
          },
        };
        ws.deter = &tk{
            k == null and return ''
            return ws.proto[t][k] || t+'?'+k
        };
        ws.state = ws.deter('state',ws.readyState);
    },'ift,D'],
] };
