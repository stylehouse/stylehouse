# lots from somewheres...
$C = G&Cye,['Elevat',2];

# the right side
$('body div.v8').remove();
A.on = $('body')[0];
$el = 4s&starlane = $('<div class="v8" style="position:absolute;'
    +'white-space:pre;font-size:70%;'
    +'top:0%;left:55%;height:20%;width:43%">')
.appendTo('body')[0];
# the left
4s&planelane = $('<div class="v9" style="position:absolute;'
    +'white-space:pre;font-size:70%;'
    +'top:0%;left:0%;width:43%">')
.appendTo('body')[0];


# to named A.4
    # GOING:
    el.A = A;
$dns = G.DNS = G.DNS || {};
$old = dns[A.4.t];
dns[A.4.t] = A.4;

# drive units
G.clon = &{ $(window).on("click", &ev,{ G&gev,ev }) };
G.keon = &{ $(window).on("keydown", &ev,{ G&gev,ev }) };
G.clof = &{ $(window).off("click") };
G.keof = &{ $(window).off("keydown") };
G.togwid = &m,fr,to{
    if ($(m).attr('togwid') == to)
        to = fr
    $(m).attr('togwid', to)
    $(m).css('width', to);
};

# says
$msgs = $(A.on).find('> #msgs')[0];
msgs ||= $("<div id='msgs' style=\"white-space: pre;position:absolute;font-size:60%;left:0em;bottom:0em;width:100%;height:28%; padding:0.2em;color:#abc;overflow:scroll;z-index:200\" onclick=\"G.keon();G.clon();G.togwid(this,'100%','5%');\"> </div>").appendTo(A.on)[0];
4s&msgs = msgs;

$originA = A.4;
# error handling
#  get A as it was last G&h
window.BamonG = &{ 
    $B = Gc&B;
    return B && Bs&A || BoriginA
};
window.onerror = &msg,url,lineNo,colNo,error{
    $A = BamonG();
    try {
    $ur = new URL(url);
    }
    catch(er){
        ~>1 er!url: ''+url
    }
    ~>1 error: msg, ''+error
    $path = ur && ur.pathname;
    if (ur && path != '/' && ur.host == location.host) {
        # .js compile errors come through here
        $have = $('body script[src="'+path+'"]')[0];
        if (have) {
            $ers = have.compile_errors ||= [];
            error.lineNo = lineNo;
            error.colNo = colNo;
            ers.push(error);
        }
    }
    
    A&ev and A&ev.preventDefault();
    A&bang and return
    A&bang = 1;
    G&Ban,error,msg,url,lineNo,colNo,error;
    delete A&bang;
    return
};


me.start = &{
    4s&NormalI = A.I;
    # in favour of dispatch table towards 4:
    # inits and continues methods on me
    # unco:
    4s&N = [];
    document.title = 'hoot';
    A.on = el;
    A.on.A = A;
    T = {y:{},c:{},sc:{}};
    #me.star(A,C,G,T);
    me.plane(A,C,G,T);
};

G.clon(); G.keon();

#c hacks
A.I.i.y.tw.way.c.code = &acgtt,ar,cb,noop{
    $w = typeof t == 'object' ? t : G&t,'w',t;
    $ttl = 4c&ttl || 5;
    !(w && ws&now && G&time,ws&now,ttl) and w = null
    noop == 'nottl' and w = null
    
    if (!w) {
        cb == 'noop' and cb = &{};
        else
        typeof cb == 'string' and throw "Cant go async: "+cb
        
        $get = '/way/'+t;
        $is_done;
        $done = &s,how,c{
            is_done = 1;
            how != 'success' and throw "Failed request: "+how, c;
            $dige = c.getResponseHeader('Dige');
            $w = G&Cye,[t,1,{s:s},{of:'w',dige:dige}];
            A.5.I ||= {};
            $D = A.5.I.w = A.5.I.w || G&Cye,['w','',{},{z:[]}];
            D.y ||= {};
            D.y.tw ||= {};
            D.y.tw[t] = w;
            ws&now = G&time;
            # i Way/$w listener for GhodigWap
            Dc&chin and Dc&chin(w)
            # < check it compiles? but we don't know its args yet,
            #   unless they are vaguely known by bumping into compile errors
            #   awaiting better field recording (MelTest frontier of)
            a&ready = 1;
            #~w!: t
            if (cb) {
                if (G&arfgunc,cb == "s") {
                    # wants its return value with given ar...
                    #~w cb s: t
                    $s = G&way,t,ar,'already_async';
                    cb(s);
                }
                else {
                    # containing a sync G&way call
                    # or a way to get the w back?
                    #~w cb: t
                    cb(t,ar,w);
                }
            }
        };
        $r = $.ajax(get);
        r.done(done);
        $checks = 5;
        $check = &{
            is_done and return;
            if (!r.statusText) {
                checks-- > 0 and return G&yl,150,check;
                console.log("Long wait going to: "+get)
                checks > -3 and return G&yl,666,check;
                return
            }
            r.statusText == 'Not Found' and throw "No way: "+t
            r.statusText != 'OK' and throw "Weird ajaxtus: "+r.statusText
            #~>57 waylo: t
            done(r.responseText, 'success', r);
        };
        check();
        #~w?: t
        !cb and G&TuneTimeMachine,'w:'+t
        return
    }
    
    ar ||= {};
    $args = G&ks,ar;
    args != wc&code_args and delete wc&code;
    # code is already JaBabz'd
    # < CoArgulate for ar, put as knowable source file?
    # < make it c.code and G&h for a B?
    if (!wc&code) {
        $name = 'w_'+w.t+'_'+ws&dige+'_'+args;
        name = name.replace(/\W+/g,'_');
        $ways = A.5.I.w;
        wayss&namedcode ||= {};
        $code = wayss&namedcode[name];
        if (code) {
            wc&code = code;
        }
        else {
            $tar = 'ar';
            args and tar += ','+args;
            # help Ban find its source
            Gc&B.sc.way = w;
            wc&argumentation = tar;
            $code = 'wc&code = function '+name+"(A,C,G,T,"+tar+"){\n"+wc&s+"\n}";
            try{
                window.code = code;
                eval(code);
            }
            catch(er){
                # eval this on the console to see source...
                window.lacode = code;
                throw er
            }
            # now compiled, we are not "in" it until run
            delete Gc&B.sc.way;
            wayss&namedcode[name] = wc&code;
        }
        args and wc&code_args = args;
    }
    noop || cb == 'noop' and return
    $arm = [];
    $ark = args.split(',');
    each ik ark {
        arm.push(k);
    }
    $so = ar[arm[0]];
    $st = ar[arm[1]];
    $sh = ar[arm[2]];
    $sf = ar[arm[3]];
    $si = ar[arm[4]];
    
    
    # help Ban find its source
    Gc&B.sc.way = w;
    if (cb) {
        # containing a sync G&way call
        #  or a way to get the w back
        return cb(t,ar,w);
    }
    return wc&code(A,C,G,T,ar,so,st,sh,sf,si);
}


me.start();

