$me = 4c&me;
!me and throw "no me";
$io = me.io;
//# new road to R without J!
    #  from me.planet instead of wobulus?
    # breaks too much just now: Teing, A.n
    #  when 1s&ein has sockets that R-times peel off
    me.Fourismo = &acgt{
        # knowing
        $El = 1s&elvisory ||= Cyeblong(['El']);
        # GOING need for J having it
        1s&Te = El;
        # GOING need to na&Teelone, El%ball
        A.n = A;
        # being that top level (not A.1.t)
        # < here only
        s&Te = El;

        s&mune = 1;

        $I = me&Resurrect,'I',1s&s;
        Iy&J = A.4;
        me&J,'Fourier','W';

        $D = me&ballRom,I,C;

        1s&s = I;
        return;
        $on = D.y.Display.sc.on;
        if (!4s&on.contains(on)) {
            ~>5 On: C.t
            on.A ||= A;
            4s&on.appendChild(on)
        }
        1s&s = I;
    };

    # NutEl
    A.I.i.y.tw.gev.c.code = &acgt,ev,J{
        ev ||= event;
        ev.target.tagName == 'H2' and return
        # locate A:top of A:4
        #debugger;
        if (!ev.target) {
            A&event_A and A = A&event_A;
        }
        elsif (ev.target == document.body) {

        }
        else {
            $S = ev.target;
            while (S && !(S.A && S.A.4)) {
                S = S.trickparentNode || S.parentNode;
            }
            # must be clicking <body>, <html>
            #   or something above .A element space
            !S and return
            A = S.A.4;
            !A and throw "out of cone";
            A&event_A = A;
        }
        if (A&event_A) {
            A&event_A != A and ~innerA: A.4.t
            A = A&event_A;
        }
        G&Aye,'ev',9,{ev:ev}
    };
//#c ambient synapse
    4c&framerate = 0.5;
    # when without G&h
    window.Gtime = &d{ return G&time,d };

    # loop comebacks between attentions
    $lastwas = 0;
    me.plane = &acgts{
        #A.on = 4s&planelane;
        A != window.A and throw "How there A"
        !A.on.ownerDocument.contains(A.on) and return ch("unplugged");
        $me = A&me;
        $starts = G&time;
        lastwas and 4s&nonms = G&time,lastwas;
        $Y = A;
        A.on.A = A;
        #A.noelvis = 1;
        $frames = 1000/A&framerate;
        frames += A&brake ||= 0;
        A&brake > 0 and ~braking: A&brake
        A&brake > 7000 and A&brake = 7000

        # < route G&gev to me.plane sometimes?
        #   they are different A.4s really
        #   and 4c&callback
        4c&callback ||= &s{ me.plane(Y,C,G,T,s) };
        $sing = 4c&callback.singly = {};
        G&yl:frames,&{ sing == 4c&callback.singly && 4c&callback() };

        4s&thinking = 1;
        try { me&planet,s }
        catch (e) {
            $async = e.message.match(/^async/);
            # assume requests complete between framerates
            if (!async) {
                # or staccato explosions
                A&brake += 2000;
                throw e, 'star'
            }
            ~Ytp: e.message
        }
        4s&thinking = 0;
        4s&current = 0;

        $ends = G&time,starts;
        4s&ms = ends;
        lastwas = G&time;
        # aim for a third of our time in the loop
        ends > (frames * 0.1) and A&brake += 200
        elsif (A&brake) { A&brake -= 100 }
        4s&busyratio = ends / frames;
        4s&busyratio < 0.001 and delete 4s&busyratio;
    };
    # cast gazet
    # this is a bag of marbles, they are free and together
    # < plane should throttle e
    me.wantpause = &acgtRs{
        $was = 4s&paused;
        $is = 4s&paused = s == 'tog' ? !4s&paused : s
        $say = is ? "off" : "on";
        was != is and ~>7 Ambient wake: '>5 '+say
        return is
    };
    me.planet = &acgts{
        4s&paused && !s and return
        $A = 4s&thinking = G&Aye,'planet';
        4s&current and ~>3 Already a planet: ki(s)
        4s&current and return
        4s&current = A;
        $B = Gc&B;
        B and 'collect?'
        B = Gc&B = G&Cye,[A.t,''];
        Bs&A = A;
        Bs&z = [];
        A&time = Gtime();
        $g = 4c&s = A.ground = G&Cye,[me.timestamp(),{},{root:1},{}];
        !me.inita.ed and me&inita

        # 1/10th attend
        A&sip.slice(-1)[0] == 0 and me&otherandcontinue

        4s&Jays = 0;

        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        #me&J,'Fourier','W'; !
        4s&Fourieronlynow and delete 4s&Fourieronlynow; throw "async Fourier only"
        s and gc&e = s
        $j = me&J,['Planet','W',{el:el},{timing:0}]
        j = js&J;
        !js&on.ownerDocument.contains(js&on) and A.on.appendChild(js&on)
        # < me.do_main does any $el/*%J
    };
    me.Ja.Planet = &acgts{
        me&Gomp;
        s&timing = 1;
        #debugger;
        n Har   %rovo:Domebegin
        #s&ab = 1;
        #s&wi = '44%';
    };

#c Elvisingness - %Slei - sleeping is possible
me.Elvisingness = &acgt{ return [
   //Slei
    ['Slei','278',&acgtRs{
        !(Rs&ball || Rs&Gens) and delete Rs&Slei; return
        ac(R,'inheritsc','Slei');
        Rs&Gens and return
        $p = Ry&up;
        Rc&timelab ||= R;
        R.t == 'Sleigh' and Rs&Flaring = 1
        ps&Flaring and Rs&Timeding = 1
        ps&Timeding and Rs&Timedin = 1
    },'ift,D'],
    ['Slei+ball','2781',&acgtRs{
        Rs&Flaring ? me&sipi,R : me&sipi,R,Ry&up
    },'ift,D,sleeping'],
    &{
    # increment protocol
    me.sipi = &acgtsf{
        if (f) {
            !fc&ip and throw "from !ip", s, f
            sc&ip = fc&ip.slice();
            fc&ipi ||= 0;
            sc&ip.push(fc&ipi++);
        }
        else {
            $was = sc&b && sc&b.c.ip;
            was && was.length > 1 and throw "ip start long"
            sc&ip = [was ? was[0]+1 : 0]
        }
        sc&sip = sc&ip.join(' ');
    };
    },

    ['Timeding','89',&acgtRs{
        $ti = {};
        each in Rs&z {
            $N = ti[n.t] ||= []
            N.push(n);
        }
        each tN ti {
            N.length == 1 and continue
            me&nu,"Dupes_in_"+R.t,N
        }
    },'ift,D,sleeping'],
    # above everything, scan scenario
    ['Flaring','89',&acgtRs{
        # to get R%sleeping to hit eg ball+sleeping
        ah(R,'reawakens','Slei',{
            rollbs:'ball,Flaring,Slei,Timeding,Timedin',
        });

        $Sl = me&ioty,R,'Timeding' [0];
        #me&nu,"Sl",Sl;
        Sls&z.length > 3 and 4s&Slsz = Sls&z.slice();
        each ir Sls&z {
            i = i+' '+(Rc&N.indexOf(r)>=0 ? "wake" : "s");
            me&tsc,i,i+":"+r.t .sc.dis = 1;
        }
    },'ift,D'],

    # the sleeper
    ['Timeding','2781',&acgtRs{
        $c = me&rollcounty,R,'lupe';
        $rfromN = &r{
            $i = Rc&N.indexOf(r);
            i < 0 and return
            Rc&N.splice(i,1);
            each in rs&z {
                rfromN(n)
            }
        };

        $fl = me&tsc,'%Codon','flar:'+cs&count,'g';
        me.nto(R,fl,&sT{
            Rs&wakinext = 1;
        });
        Rs&countis = cs&count;
        me&rollbs,R,'incount';
        Rs&incount ||= 0;
        Rs&incount++;

        if (0 && cs&count >= 4) {
            cs&count >= 5 and cs&count = 0
            Rs&sleeping = 1;
            $v = me&ollbs,R,'Vawake';
            v and me&Ret,R,{t:v.t,s:vc&s,ball:1};
            # < become %sleeping after @28
            #   is to be avoided
            #me&recycleRbitXz,R;
            each in Rs&z {
                #rfromN(n)
            }
        }
    },'ift,D'],
    ['Timeding','4',&acgtRs{
        if (me&ollbs,R,'wakinext' ) {
            $first = 1;
            me&ioty,R,'Timedin' .map(&r{
                first and first = 0; return
                me&ioty,r,'Timedin' .map(&n{
                    !ns&ball and return
                    me&elvis,R,'flarke',{wake:n}
                });
            });
        }
    },'ift,D'],
   //#c %Slei - testing
    # t =~ /^sleeping/ only if sleeping, sc either
    ['sleeping+Timeding','28',&acgtRs{
        me&rollbs,R,'lupe,countis,incount,Vawake';
    },'ift,D'],
    ['Timeding','89',&acgtRs{
        $t = Rs&sleeping ? "sleeping" : "w";
        $oc = me&ollbs,R,'countis';
        $oic = me&ollbs,R,'incount';
        #~>5 Timeding: t, oc,'->',Rs&countis, oic,'->',Rs&incount
    },'ift,D,sleeping'],

    # as child, sometimes unreached etc
    ['sleeping+Timedin','28',&acgtRs{
        me&rollbs,R,'country,luope';
    },'ift,D'],
    ['ball+Timedin','29',&acgtRs{
        ac(R,'inheritsc','Timedin');
        $c = me&rollcounty,R,'luope';
        me&tsc,'%Codon','floupe:'+cs&count,'g';

        Rs&country = me&rollbs,R,'country' || 0;
        Rs&country++;
        me&tsc,'%Codon','byb:'+Rs&country,'G';
        # cs&count == 10 and throw "wobble"

        $dat = [];
        while (dat.length < 32) { dat.push([1,2,3]) }
        #s.t == 'Vame2' and me&nu,dat

        $p = me.cbu(R,'Timeding');
        s.t == 'Vame3' and ps&Vawake = R

        if (ss&bath == Rs&country) {
            me&elvis,R,'wakuba',{wake:R}
        }
        $tun = me.cbu(R,'tunneling');
        $tune = tun && tuns&tunneling;
        tune && tune.t == 'wakuba' and me&tsc,"GOT!";
    },'ift,D'],
  
  //#c elvis()
    # see elvis()
    # put near being its own R... (SCA)

    # - R%sleeping is its b the next time,
    #    must roll everything it wants to keep
    #   the R%sleeping/** don't happen,
    #    but if they do, Display them

    # bugs:
    # ! occasional 'nonb along', why is it from thence?
    # ! can't boost right after creating a %ball
    # !? similar after R%JRom nonmain pause
    #    that's the %tunneling avoider,
    #      since Rom packages c inside a %JRom
    #    %JRom/me&Rom sleep involves a Display if r%sleeping
    #    suppose R%down will recycle if we R%sleeping
    # ! 

    # %Slei - test suite:
    # < want to replay testily,
    #   look at various angles ... while...
    #   < %Zavmo for X
    #   < show how X is when not recycled,
    #    unrecycled, errored, etc
    #   < double handling: JRom resets RbitX,
    #      Re does a little to not apply if not applyRbitX

    # other
    # < %directDisplay should force Cupon same %on
    #   small chance of new thing not being nested
    # < specify non-history-creating mode
    #   how to add futures at depth...
    #   passing X, not inflating Rs to get it
    #    might be better, a begin where sleep wakes 
    #      wasn't: throw while tunneling breaks history (later)

    &{
    # to the thing
    #  handlers generating ec&wake
    me.elvis = &acgtRecs{
        !isR(R) and throw "!R"
        isR(e) and throw "e=R"
        $E = 4s&Elvacts ||= Cye(['Elvacts',1]);
        # store time/e
        $Ein  = &c{
            $t = Cye([me.timestamp(),{y:R}]);
            ty&R = R;
            ty&A = A;
            tc&time = Gtime();
            4s&thinking and ty&F = 4s&thinking
            # < TEST remove this line (elog)
            #   take a photo of e at stages
            ex(t.sc,c||{});
            ac(E,'z',t);
            ac(t,'z',e);
        };
        if (c && c.in == 4) {
            # receptive/do mode
            T.msg =
            ~>8 e: '>3:IS','>7:pathin','>3:ts '+4c&s.t.substr(-5)
            Ein({direction:'i'});

            # slope %med=cra -> slope %elvis=Gazel
            !es&edone && ec&slope and me&slopemed,R,e
            # sort pools
            !es&edone && ec&pack and me&unpacke,R,e
            # all other unsolved elvis
            !es&edone && !ec&wake and me&domisce,R,e
            # go to it
            ec&wake and me&ewake,R,e
        }
        else {
            # making e from t,c
            isst(e) && !isC(c) and e = Cye([e,1,c||{wake:R}])
            else
            # having an e
            isC(e) and c and throw "e & c"
            else {
                throw "long form elvis plant"
            }
            isC(s) || isst(s) and ec&s = s
            else
            isar(s) and es&z = s
            else
            isob(s) and e.sc = s
            
            # current Ring act
            es&act = T.act;
            es&R = R;
            # probably waking itself
            !haks(e.c) and ec&wake = R

            Ein({direction:'o'});
            # ^ should check it gets attended,
            # returns without usual attendance:
            ec&ret and delete ec&ret; return e
            
            if (4s&thinking) {
                # messages want collecting
                $JR = me.cbu(Ry&up,'JRom');
                ac(JR,'elvoids',e);
            }
            else {
                # message delivered
                G&yl,0.001,&{4c&callback(e)};
            }
        }
    };
    },
  
  //#c elvoids unpacke from/to depths
    # JRoms hoist elvising
    ['JRom+elvoids','314',&acgtRs{
        # < cancellable everything
        Rs&error and return
        $e = Cye(['elvoids',8,{pack:R}]);
        es&z = Rs&elvoids.slice();
        $JR = me.cbu(Ry&up,'JRom');
        if (JR) {
            each in es&z {
                ~>7 Je: R.t, e.t
            }
            ac(JR,'elvoids',e);
        }
        else {
            ~>7 E: e.t
            G&yl,0.001,&{4c&callback(e)}
        }
    },'ift,D'],
    &{
    # the e that causes tunneling doesnt arrive e** as it goes
    # < should do, know what is for here, anywhere
    #    that +etc should be indexed on ec&X, what the e concerns, deeply
    # so we go looking from the top
    me.through_packs = &acgte{
        $M = []
        # e** until !y&pack, to the point of eg e:elIntro
        me&indo,e (&ed{
            # an enveloping, at %JRom or so..? see elvoids
            ec&pack and return
            M.push(e)
            d.not = 1
        })
        return M
    }
    # makes a tree of ec&wakes a single diverging tunnel
    # < what if outer wakes and inners wake?
    me.unpacke = &acgtRe{
        $flat = &e{
            !ec&pack and return [e]
            $N = []
            each in es&z {
                N.push(... flat(n))
            }
            return N
        };
        $N = flat(e);
        # have wakers[] (again, after unpacking)
        # name lookup, R may be branchy
        $I = me.cbu(R)
        $M = N.map(&n{
            $r = nc&wake;
            !r and debugger;
            !isR(r) and r = ns&R
            !isR(r) and throw "wake!R", n
            $j = r
            r = me&yfuture,r,null,{merged:1}
            # the s may have changed
            1 && (js&ball||js&bell||rs&ball||rs&bell)
                && rc&s && rc&s != jc&s
                && ac(e,'newsphere',r)
            $l = me.cby(r)
            $tpath = l.slice(1).map(r=>r.t)
            $path = [Ic&b, ... me&RbitXt,Ic&b,tpath ]
            $float = l.slice(hak(path))
            hak(float) and debugger
            hak(float) and ~>5 patho: float.map(t=>t.t).join('/')
            return path
        });
        each ijr M {
            #rs&Peace == 4 and ac(e,'fours',r)
        }}
        if (hak(es&fours) > 1 || 0) {
            $futurist
            each ir es&fours {
                $fu = me&yfuture,r
                each ii,j es&fours {
                    i == ii and continue
                    !(fu == j || fu == me&yfuture,fu) and continue
                    futurist = fu
                }
            }
            if (futurist) {
                each ir es&fours {
                    $old = 0
                    each ir M {
                        j == r and old = 1
                        !old and continue
                        if (old == 1) {
                            old = 2
                            
                        }
                        else {
                            $p = M[i-1]
                            $w = me&RbitXt,p,r.t
                            
                        }
                    }
                }
            }
        }
        
        es&flatup = M;
        # < io's grouping col/row
        # for the deepest JRoms first, splitting time
        #  incorporating more e from those times
        #   etc
        $dep = &jM{
            $N = [];
            $dif = [];
            # unique
            each in M {
                $r = n[j];
                !r and continue
                $ri = dif.indexOf(r);
                # < allow the occasional async here,
                #   probably at a tw-safe join, doing 
                if (ri < 0 && j == 0 && r.t == 'I') {
                    dif[0] && dif[0].t == 'I' and ri = 0
                }
                ri < 0 and ri = dif.push(r)-1
                $z = N[ri] ||= [];
                z.push(n);
            }
            # group many, inline if 1
            $path = [];
            each iz N {
                $eg = z[0][j];
                z.length > 1 && eg != z[1][j] and throw "wob"
                $ins = dep(j+1,z);
                $bit = [ me&yfuture,eg,0,{merged:1} ];
                path.push(bit);
                !ins.length and continue
                # may be a [r,r,r] or [r,[[r,r],[r,r]]]
                ins.length == 1 and bit.push(... ins[0])
                else { bit.push(ins) }
            }
            return path
        };
        $path = dep(0,M); 
        4s&Slsz = path;
        path.length > 1 and throw "unpacke multi path"
        ec&wake = path[0];



        es&edone = 'unpacke';
    }
    },
  
  //#c emisc handlers
    # < to all go in R:e,
    #   < Ring T-checker
    #   < ch() say smoke
    #  me&handelvis - %medo
    #   =modeen, play R, < dom
    # in planet/elvis():
    #  me&slopemed - %med
    #   =cra, solveR etc slope-finds %elvis
    #     =Gazel, say/boost/drag

    # generally T.wake to ec&wake
    #   after they complete (es&done=...)
    # but could be going in there to deliver the change
    #  and wait until ready to wander back to ...
    #  security of thems
    &{
    me.slopemed = &acgtRe{
        if (e.t == 'says') {
            if (ec&type == 'blur') {
                # ec&ev.relatedTarget is where it's going,
                #  for codemirror, .tagName == 'TEXTAREA'
                #  and .parentNode()+ to something we know
                if (ec&s == '') {
                    es&edone = 'sayvague';
                    Rs&sleeping = 1;
                    return
                }
            }
        }
        $sl = ec&slope.slice().reverse();
        each in sl {
            # ns&medo is handled without 4c&callback
            $m = ns&med;
            !m and continue;
            # not in C or A.
            $D = C;
            $C = e;
            $s = ec&s;
            me&$m,s;
            C = D;
            T.ok = 1;
            break
        }
        !T.ok and T.msg.set('IS','NODICE')
        else {
            delete T.ok;
            es&edone = 'med';
            T.msg.set('IS','ok')
            $w = T.wake;
            if (w) {
                # < spec in %reawakens?
                ws&Cit || ws&Cee and w = wy&up;
                ec&wake = w
            }
        }
    };
    me.domisce = &acgtRe{
        me.sheysdo && me&sheysdo,e and return Rs&sleeping = 1
        
        if (e.t == 'A') {
            me&wantpause,R,'tog' and Rs&sleeping = 1
        }
        elsif (e.t == 'C+click') {
            debugger;
            ec&wake = 1
        }
        elsif (e.t == 'Y') {
            ec&wake = 4s&mainthing
        }
        elsif (e.t == 'E') {
            ec&wake = 4s&Elvact;
        }
        elsif (e.t == 'W') {
            ec&wake = 4s&Wayout;
        }
        else {
            ~>8: Otherev: '>5 '+e.t
            # don't happen
            Rs&sleeping = 1;
        }
    };
    },
  
  //#c ewake from &elvis to tunneling
    &{
    #  to find some strategy for sneaking in
    #   past R%sleeping to the wakers
    #   re-argumenting it re strategy,
    #    in artificial generation
    #     so it gets to eg sleeping+ball @28
    #    such that it might work
    #     < could Ring-wait the outsiders until
    #       inners are certain they don't need
    #       their surroundings after doing stuff
    # reawaken gk(,gk)+
    #  if bs&$gk, roll them into %tunneling spawn
    #  should be enough to be awake or look like it to others
    me.reaw = &acgtR,gks,c{
        $k = gks.split(',')[0];
        c == 1 and c = {bg:1}
        ah(R,'reawakens',k,ex(c||{},{rollbs:gks}));
    };
    me.printpath = &acgtli{
        i != null and l = l.slice(0,i+1)
        return l.map(n=>isar(n) ? '*'+n.length : n.t).join('/');
    };
    me.ewake = &acgtRe{
        # pointer
        $r = ec&wake;
        # must hist
        !Rc&b || r == 1 and return ~>8 eQUIT: "!top b"
        
        # multipath from unpacke, already yfuture
        isar(r) and es&tunnel = r
        else {
            !isR(r) and throw "non-R ecwake"

            # the latest maybe %sleeping parents of r
            #  applyRbitX updated y&up of recycled Rs&z
            $l = me.cby(r);
            # R(c&b)+ - historical R they pointed to
            es&tunnel_raw = l;
            # Rc&b - last R to happen
            #  yfuture can climb to unapplied X.newz
            es&tunnel = l.map(n => me&yfuture,n,0,{merged:1} );
        }
        
        $l = es&tunnel
        
        # < &tunnelArrive might do this better, as a give up?
        # must hist (may not %flatup)!
        $flatup = es&flatup || [es&tunnel]
        each in es&flatup {
            $end = 0
            $la = 0
            each ir n {
                # gaps occur when some branches end
                !r and end = 1; continue
                end and debugger
                
                # take this to mean a reself of eg W:Thy
                if (rs&Peace && la) {
                    !me&RbitXt,la,r.t and return ~>8 eQuit: "Xt--", la.t, r.t, i
                }
                la = r
                if (rs&Peace == 4) {
                    # non-branching option has the unfutured things
                    if (es&tunnel_raw) {
                        $raw = es&tunnel_raw[i]
                        rawc&s != rc&s and return ~>8 eQuit: "raw ++s", r.t, i
                    }
                    if (es&newsphere && es&newsphere.includes(r)) {
                        return ~>8 eQuit: "new ++s", r.t, i
                    }
                }
                # !rc&b always on I, the very-very-top R (some A above it)
                #  indicates wanting a node that just turned up
                # if we tunnel in and find no Rc&b on the now, throw 'NOb'
            }
        }
        
        # this R
        me&tunnelArrive,R,e;

        $froml = l.slice(es&tunneli);
        es&path = me&printpath,froml;
        T.msg.set('pathin',es&path);
        # < %beawake should %edone?
        es&beawake and return

        # < J sync Te/X, jump to
        # assume tunneling between JRoms is safe
        froml.shift();
        $JR;
        each in froml {
            isar(n) and throw "multipath before JRom"
            ns&JRom and JR = n; break
        }
        l[es&tunneli+1] != JR and throw "JR!next"
        !JR and return

        # %icate() is like R:e suggesting N to do at A.4
        #   it is a Rom here with %tunneling to do
        Rs&sleeping = 1;

        Rs&icate = &{
            # make something to happen
            me&tunnelJRom,R,JR,e;
            JR.t == 'Elfor' and 4s&pathout = e
        };
        es&edone ||= "wake"
    };
    },
    # let sleeping+Utilis @28
    ['sleeping+mune+icate','3',&acgtRs{
        Rs&icate();
        # merges the branch, keeps them to Rc&b
        me&applyRbitX,R;
    },'ift,D'],
  
  //#c e 3 tunnelArrive
    # climb path
    # CONFUSION
    #  with tunneling+JRom?
    ['Elfor','13',&acgtRs{
        Rs&Timefrom = 4c&s.t.substr(-5);
    },'ift,D,sleeping'],
    &{
    me.tunnelArrive = &acgtRec{
        c ||= {};
        $l = es&tunnel;
        if (!Rc&b && Rs&Peace == 9 && Rs&igV) {
            # catching &ewake early cant see %igV coming, see newsphere
            # < can|should we still receive e in new things?
            return es&beawake ||= {igVing:R}
        }
        !Rc&b and ~>6 CANCEL tunnelArrive!b: R.t
        !Rc&b and return T.cancel = 'tunnel!b:'+R.t
        !l and throw "no l"
        $p = Ry&up;
        # %tunneling may jump through %JRom
        ps&JRom && !ps&tunneling and me&tunnelArrive,p,e,{toJR:1};

        $pat = &li{ return me&printpath,l,i };
        # start/onward ideally knowing the last R
        $li = l.indexOf(Rc&b);
        if (li < 0 && !es&tunneli) {
            # matching t from the top
            $ln = me.cby(p);
            each in ln {
                $u = l[i];
                !u and break
                isar(u) and "for u[*][0].t"
                else
                u.t != n.t and throw "not tunn in", pat(l,i), n.t
                es&tunneli = i
            }
            ~>4 nonb top: pat(l,i)
        }
        if (li < 0) {
            $lin = es&tunneli+1;
            $exp = l[lin];
            !exp and return es&beawake ||= {shortpath:R}
            # matching t)
            exp.t != R.t and throw "not tun", pat(l,i), R.t
            li = lin;
            ~>4 nonb along: pat(l,lin)
        }
        # li is decided
        es&tunneli && es&tunneli != li-1 and throw "irreg"
        es&tunneli = li;
        c.toJR and return

        # tunnel begins
        es&tunnelin == null and es&tunnelin = es&tunneli
        $next = l[es&tunneli+1];
        # tunnel ends!
        !next and return es&beawake ||= {nonpath:R}

        # %tunneling builds tunnel_now
        $ln = es&tunnel_now ||= [];
        ln[li] = R;

        !l[es&tunneli+1] and return es&beawake ||= {pathend:R}
    };
   //#c make Re,c-ipe
    me.tunnel = &acgtRc{
        $b = c.b;
        !b and throw "tunnel!b"
        Rc&N.indexOf(b) >= 0 and throw "b current"
        c.t = b.t;
        # < subtly repoint s with slep
        bc&s != null and c.s = bc&s;

        # it knows {$gk:{use}}
        # strategy for a widely held gk
        #  eg %Slei, %Codon, %ball
        # for rolling their other sc
        $aw = bs&reawakens;
        aw and c.reawakens = aw
        else {
            # others inherit if of type
            aw = me.cbu(R,'reawakens');
            aw = aw && aws&reawakens;
        }
        $auth = [];
        if (aw) {
            # see if strategy is for this R
            each tw aw {
                !b.sc[t] and continue
                # w.bg == not convincing to reawaken
                # eg %Peace is in the background of many others
                #  some main thing going on must also %reawakens
                !w.bg and auth.push(t);
                # < babz this 'each, k use.rollbs'
                w.rollbs &&
                w.rollbs.split(',').map(&k{
                    hak(b.sc,k) and c[k] = b.sc[k]
                });
                w.sc and ex(c,w.sc)
            }
            bs&ball and c.ball = 1
            bs&tightly and c.tightly = 1
            # < aw.wakeasparent for Cit?
            #aw.wake_parent && !es&tunnel[lin+1] and c.wakeasparent = 1
        }
        else {
            # %reawakens implies %tunneling to it is ok
        }
        # general
        ['Gens','Zuctto','inheritsc','inheritscif','eCsc',
         'play',].map(&k{
            b.sc[k] and c[k] = b.sc[k]
        });
        # JRom skip %tunneling
        if (bs&JRom) {
            # < to sleeping+JRom/%Domeds,
            #   as opposed to the JRom%returns
            #    see also es&beawake = {nonmain:R}
            c.JRom = bs&JRom;
        }
        else
        !c.reawakens && aw && !auth.length and c.noreawakens = 1
        return c
    }
    # make child
    me.tunnelin = &acgtRce{
        $b = delete c.b;
        if (c.JRom) {
            $r = me&tunnelJRom,R,b,e;
        }
        else {
            $r = me&Ret,R,c;
            Rs&z.filter(n => n == r).length != 1 and debugger;
            me&zN,r;
            Rc&N.filter(n => n == r).length != 1 and debugger;
        }
    }
    # make JRom child
    me.tunnelJRom = &acgtRbe{
        !bs&JRom and throw "b!%JRom"
        $c = ex({},bs&JRom);

        $l = es&tunnel;
        # beyond this R/r%JRom
        $froml = es&tunnel.slice(es&tunneli+2);
        $next = froml[0];
        # must be another JRom, or reawakens
        #  to leave tunnel mid-JRom with correct sc
        delete c.pause;
        delete c.neednt;
        if (!me&ioty,froml,'JRom' .length) {
            if (next && bs&returns && bs&returns != next
                && next != b
                && next.t != bs&returns.t) {
                # not for the main thing of the JRom
                ~>7 nonmain: next.t, bs&returns.t
                #c.JRomc = {tunneling:e}
                c.pause = 1;
            }
            elsif (!me&ioty,froml,'reawakens' .length) {
                # a !%reawakens main thing in the JRom
                es&beawake ||= {wandRom:R}
            }
        }

        !c.pause and c.tunneling = e

        c.Recb = &r{ ac(e,'JRs',r) };
        $r = me&Rom,R,c;
        return r
    };
    },
   //#c e 6 tunneling individua
    # impersonate the last awake sc fuller
    #  now that we won't be switching things on
    #  eg inheritsc can't be trusted
    ['sleeping+tunneling','94',&acgtRs{
        each kv Rc&b.sc {
            R.sc[k] ||= v;
        }
    },'ift,D'],
    # to put a JRom to sleep, such that ^ happens
    ['neednt','18',&acgtRs{
        #Rs&tunneling = Rs&neednt;
        #Rs&sleeping = 1;
        ~>5 neednt but did: R.t
    },'ift,D'],
    &{
    
    },
    ['tunneling','18',&acgtRs{
        $e = Rs&tunneling;
        Rs&sleeping and debugger;
        me&ollbs,R,'notun' and return es&beawake ||= {notun:R}
        es&beawake and return
        #Rs&Citop and return

        me&tunnelArrive,R,e;
        T.cancel and return
        es&beawake and return es&tunnelout = R

        $lin = es&tunneli+1;
        $N = es&tunnel[lin];
        # < join many involves separating the es&tunnel
        #   want to use X
        !isar(N) and N = [N]
        $M = [];
        each ib N {
            $c = {};
            c.tunneling = e;
            if (isar(b)) {
                $en = Cye(['divaw',8]);
                eny&top = ey&top || e;
                eny&up = e; ac(e,'divawz',en);
                ens&tunnel = es&tunnel.slice();
                # a tunnel[ ends in one multiplicity
                ens&tunnel.length != lin+1 and throw "multimultipath"
                ens&tunnel.splice(lin,1,...b);
                ens&tunneli = es&tunneli;
                ens&tunnelin = es&tunnelin;
                #eny&top == eny&up and debugger;
                b = b[0];
                c.tunneling = en;
            }
            c.b = b;
            me&tunnel,R,c;
            M.push(c);
            
        }
        # doing, depending on awakeness theory
        $bailifany = &k{
            $dont = M.filter(c => c[k]);
            !dont.length and return
            $l = markt(M,dont,&{ return '%'+k });
            ~>5 t5out: '>3 '+R.t, ...l
            es&tunnelout = R;
            $be = es&beawake = {};
            be[k] = R;
            return 1
        };
        $markt = &MNy{
            $l = [];
            N ||= [];
            y ||= &c{};
            each ic M {
                l.push(c.t);
                N.includes(c) and l.push('>7 '+y(c))
            }
            return l
        };

        # last yay many R should be awake sometimes
        bailifany('wakeasparent') and return
        # R wakes to generate r out of strategy
        # < other children may sleep?
        #   intervening very early (Ret?)
        #   or once they S that it is still
        #    < a mode of ambient awareness
        #   near: which parent to T.wake
        #    after A:eing something somewhere
        bailifany('noreawakens') and return

        # and doesn't
        Rs&sleeping = 1;
        # recycle before children arrive is ideal
        me&recycleRbitXz,R;

        # or inflates individuals with %tunneling
        each ic M {
            $b = c.b
            !isC(b) and debugger
            bs&ball && bc&s.y.invalide and throw "invalide"
            me&tunnelin,R,c,e
        }
    },'ift,D'],
] };

#c Wayout Fourismness Elfor=Codon|Slei
me.Fourismness = &acgt{ return [

    ... me&Zavingness ,
    ... me&Elvisingness ,
   //Domebegin etc
    ['Domebegin','278',&acgtRs{
        $C = G&Cye,['Vubd',1,{},{mune:1,impausible:1}];
        $D = me&ballRom,R,C;
    },'ift,D'],

    ['mune','278',&acgtRs{
        me&walla,'hu:7';
        Rs&Utilis = 1;
        # we may have a request
        # from 4c&callback(e) 
        $g = A.up.ground;
        $e = gc&e;
        !e and return
        $c = {in:4};
        me&elvis,R,e,c;
    },'ift,D'],

    ['mune','3',&acgtRs{
        # Codon or ...!!
        $abil = location.search || "?Elfor";
        
        $t = abil.substr(1);
        $l = t.split('/',2);
        $c = {t: l[0]};
        c[c.t] = 1;
        l[1] != null and c.into = l[1]
        me&Rom,R,t,c;
    },'ift,D'],

    ['Elfor','291',&acgtRs{
        # write code
        n Flar  R %Codon,ting:W,Gens
        # lingo patch panel
        #n ForThe  R %ting:W,Gens,tingspot
        # test sleep
        #n Sleigh  R %Slei,ting:W,Gens,tingspot
    },'ift,D'],
    &{
    # ensure a bunch of ways are ready,
    #  call them or wake R
    me.wayel = &acgtRt,ar{
        $all_ready = &{
            each tv Rs&wayel {
                !v and return
            }
            return 1;
        };
        # checking the bunch
        !t and return all_ready()
        
        # adding to the bunch
        ah(R,'wayel',t,0);
        # way cb happens asap, per ghost state!
        $sync = 1;
        $cb = &{
            ah(R,'wayel',t,1);
            sync and return
            !all_ready() and return
            ~>3 wayel+: R.t, t
            me&elvis,R,'wayelup';
        };
        G&way,t,ar,cb;
        sync = 0;
    };
    },
    ['Wayout','291',&acgtRs{
        4s&Wayout = R;
        Rs&rowish = 1;
         me&wayel,R,'Peaceness';
        me&wayel,R,'ruv';
        me&wayel,R,'Wayout',{R};
        me&wayel,R,'Pearch',{R};
        !me&wayel,R and return
        G&way,'Peaceness',{};
        G&way,'ruv',{};
        G&way,'Wayout',{R};
    },'ift,D'],
    ['Wayout+Inn','82',&acgtRs{
        $p = Ry&up;
        ps&JRom.Inn = Rs&Inn
    },'ift,D'],
   //#c unihab
    ['sleeping+Utilis','28',&acgtRs{
        if (!me&ollbs,R,'Inn' ) {
            # wake up (after error?)
            ~7 lost Inn:
            delete Rs&icate;
            delete Rs&sleeping;
            return
        }
        me&rollbs,R,'Inn,Incremento,playsheet,timetopause';
    },'ift,D'],
    ['Utilis','291',&acgtRs{
        # window/A.4 goes to sleep
        $(window).off('blur').off('focus')
        .on('blur',&{
            ~blur
            me&wantpause,R,1;
            $cb = window.whenitblurs;
            cb && cb();
        }).on('focus',&{
            ~focus
            # nothing.
            # < know about our windows, flow something
            # cb above on another window might ting us awake
        });

        # this toplevel-ish R may take ages
        Rs&timetopause = 3418;

        # spending time in/out of the callback
        $g = me&opeolo,'plane';
        $ti = gy&can('n','time');
        me&mtsc,ti,'timein',4s&ms,'6' .sc.fs = 12;
        me&mtsc,ti,'timeof','/','g'
        me&mtsc,ti,'timeout',4s&nonms,'6'

        # %ball activations (just %R -> JRom)
        Rs&playsheet = {
            ball: &acgtR{
                me&Bear,R,Rc&s,'play'
            },
            fix: &acgtR{  },
        };

        # remotes
        # news from the editor
        me&Rom,R,'GhodigWap';
        # newsroom behind all %tings
        Rs&Inn = me&Rom,R,'Search';


    },'ift,D'],
    ['Utilis','7',&acgtRs{
        # wash
        me&Rom,R,'Evelse';
        
        me&rollbs,R,'Incremento';
        Rs&Incremento = (Rs&Incremento||0)+1;
        if (Rs&Incremento == 2) {
            ['GhodigWap','Search','Evelse'].map(&t{
                $r = me&upsit,R,t;
                r && me&introqua,r,'boost:-1';
            })
        }
    },'ift,D'],
   //#c %Evelse e log
    ['Evelse','291',&acgtRs{
        Rs&rowish = 1;
        $p = Ry&up;
        if (!ps&Evelse) {
            4s&Elvact = R;
            s&mb = 20;
            # input/output piles:
            $el = 4s&Elvacts;
            !el and return
            # incase we let it build up:
            els&z.splice(100);
            $so = Rc&s = me&rollbsc,R,'sorted';
            sos&z ||= [];
            sos&inc ||= 1;

            $ftime = &Ls{
                $l = L.slice();
                if (s) {
                    # say each bit of timestamp different
                    $dif = [];
                    each id l {
                        s [i] != d || dif.length and dif.push(d)
                    }
                    l = dif;
                }
                $ms = l.pop();
                ms == null and ms = L.slice(-1)[0]
                ms.length <3 and l.push(ms); ms = null
                $times = l.slice(-3);
                $dates = l.slice(-6,-3);
                $s = "";
                dates.length and s += dates.join('-')+' '
                times.length and s += times.join(':')
                ms and s += "."+ms
                return s
            };
            # group into time
            $timegap = 4;
            me&ioty,el .map(&n{
                if (!ny&sorted) {
                    ny&sorted = so;
                    each ie ns&z {
                        # ignore e into W:Evelse
                        each ij es&JRs {
                            js&Te == Rs&Te and return
                        }
                    }

                    # i $so/%now<>nc&time<3
                    $co = sos&z.slice(-1)[0];
                    if (!co || coc&timetil+timegap < nc&time)
                        co = fio(so,"#"+sos&inc++)
                    coc&time ||= nc&time;
                    coc&timetil = nc&time;
                    $ch = fio(co,n,0);
                    if (ch) {
                        chy&seria ||= '';
                        chy&seria += 'a';
                        n.t += chy&seria;
                    }
                    fio(co,n);

                    # formatted timestamp key
                    $times = n.t.split(/\D+/).slice(0,-1);
                    if (!sos&last_time) {
                        sos&last_time = times.slice(0,-1);
                        sos&in_time = ftime(sos&last_time)
                    }
                    ns&in_time = ftime(times,sos&last_time);
                    sos&last_time = times;
                }
            });

            # header
            !sos&z.length and return

            $se = me&case,2;
            $to = sey&can('o','tooli');
            tos&dis = 3;
            $eo = toy&can('c','tools');
            $trunc = me&mtsc,eo,'trunc',0,'y'
            $truncate = &{
                # truncate elvis log
                me&ioty,el .map(&n{
                    Gtime(nc&time) > 60 and fio(el,n,9)
                });
                me&ioty,so .map(&n{
                    Gtime(nc&timetil) > 60 and fio(so,n,9)
                });
                ~>6 truncated:
            };

            me.nto(R,trunc,truncate);

            $N = me&ioty,so;
            each in N {
                n $n.t  $s:n,R %Evelse:2,Timegroup
            }
            i > 9 and truncate();
            T.nN.reverse();

            # footer
            $se = me&case,7;
            sey&can('i',sos&in_time);
            #me&tsc,'intime',sos&in_time,'G' .y.cv = 0.8;

            n Elvito  R %Tool

            #n Teing  $s:Rs&Te,R %ball,tightly
        }
        elsif (Rs&Timegroup) {
            me&domesticate,R
            if ((Rs&boost||0)<=-1) {
                $p = Ry&up;
                fio(pc&s,Rc&s,9);
                n deleted  s:deleted %fs:6,hs:594
                return
            }
            me&ioty,s .map(&m{
                n $m.t  $s:m,R %Evelse:2,Timebit
            });
            T.nN.reverse();
        }
        #c %Evelse%Timebit...
        elsif (Rs&Timebit) {
            # < Abodisish align subrows across %Timegroups
            # timestamp key
            #me&domesticate,R
            me&tsc,'in_time',ss&in_time,'b'
            me&tsc,'direction',ss&direction,'y','fs:22,lh:0.5,ma:0.2,hs:339'

            each ie ss&z {
                me&tsc,'i'+eti,e.t,'y','fs:18,lh:0.5,hue:33'

                $eti = i+':'+e.t;
                if ((Rs&boost||0)>0) {
                    n $eti  $s:e,R %Evelse:2,Elvisbit
                }
                else {
                    es&R and me&tsc,'es&R','R:'+es&R.t,'b'

                }
            }
            (Rs&boost||0)>0 &&
                n Timebit  $s:s,R %Evelse:2,Elvisgroup
        }
        elsif (Rs&Elvisgroup) {
            me&tsc,'t',R.t,'y','fs:12,lh:0.5,hue:33'
            (Rs&boost||0)<=0 and return
            sy&R and me&nu,"R",sy&R;
            me&nu,"Timebit",s
        }
        elsif (Rs&Elvisbit) {
            Rs&Elvisbit > 1 and me&walla,'b:3.2,hu:-3';
            Rs&Elvisbit > 2 and me&walla,'hu:3';
            me&tsc,'t',s.t,'y','fs:18,lh:0.5,hue:33'


            sc&type and me&tsc,'sc&type',sc&type,'g'

            sc&pack and me&tsc,'sc&pack','pack@'+sc&pack.t,'g'
            ss&act and me&tsc,'ss&act','act@'+ki(ss&act,2),'g','hs:999'
            ss&R and me&tsc,'ss&R','R:'+ss&R.t,'b'

            sc&wake && !isar(sc&wake) &&
                me&nu,'sc&wake',sc&wake
            ss&edone and me&tsc,'ss&edone',ss&edone,'g'
            each kv ss&beawake {
                me&tsc,'sc&pack','beawake:'+k+'@'+v.t,'g'
            }
            $se = me&case,'vlal';
            if (ss&flatup) {
                $fl = sey&can('i','%flatup');
                if (fls&ope) {
                    $co = sey&can('c','%flatups');
                    each iN ss&flatup {
                        $ro = sey&can('w','flat'+i);
                        each in N {
                            ss&tunnel && ss&tunnel[i*1+2] and continue
                            $ol = roy&can('c','col'+i);
                            $be = me&mtsc,ol,'tunnel'+i,n.t,'y';
                            me&walls,be,'b:3.2';
                        }
                    }

                }
            }
            sey&notifempty();

            if (ss&tunnel_now) {
                $l = (ss&tunnel||[]).slice(ss&tunneli||0);
                me&tsc,'tunnel',0,'y';
                each in ss&tunnel_now {
                    $be = me&tsc,'tunnel'+i,n.t,'y';
                    me&walls,be,'b:3.2';
                    ns&error and me&tsc,'error',ki(ns&error,2),'B'
                }
            }
            each ie ss&z {
                $eti = i+':'+e.t;
                n $eti  $s:e,R %Evelse:2,Elvisbit:2
            }
            each ie ss&divawz {
                $eti = i+':'+e.t;
                n $eti  $s:e,R %Evelse:2,Elvisbit:3
            }
            (Rs&boost||0)<=0 and return
            me&nu,"elvisy",s
        }
        else {
            me&tsc,'t',R.t,'y','fs:18,lh:0.5,hue:33'
            #me&domesticate,R
            # some time, more details
            me&nu,'detail',{s:Rc&s}

        }
        ah(R,'reawakens','Evelse',{
            rollbs:'Evelse,Timegroup,Timebit,Elvisgroup,Elvisbit',
        });
        #me&introqua,[R,'A'],{boost:1}
        #me&zu,"4s&pathout",4s&pathout;
        #me&zu,"4s&Slsz",4s&Slsz;

        #me&zu,"A",A.4;

        # %ball transfigurations (move,copy,etc)
        #n Elviso  $s:4s&elvisory %R:ball
    },'ift,D'],
   //#c func eCsc, remember, Dispon
    &{
    # one variety of walking around names
    #  climbing X, < other structures
    #  invent linguistic surface bubbler
    me.upsit = &acgtRt{
        $z = me.cby(R).reverse();
        each in z {
            $X = nc&X;
            $oX = X && X.x && X.x[t];
            oX && oX.z and return oX.z[0]
        }
    };
    # zap in css sc, so it stays there
    # also returns callback to apply css to an element
    me.eCsc = &acgtRtc,weakly{
        # they persist from the last adjustment:
        $was = Rs&eCsc && Rs&eCsc[t]
        # keep the later wave of style
        was && weakly and return
        isst(c) and c = G&peel,c
        # realise work is done
        was && heq(c,was) and return &{}
        
        ah(R,'eCsc',t,c);
        # returns hash of css
        $ctocss = &c{
            $C = Cye([t+'-style',1]);
            ex(C.sc,c)
            $st = 4s&styler ||= me&styler;
            $css = {};
            st(C,css);
            return css
        };
        return &el,{
            $css = ctocss(c);
            was and was = ctocss(was)
            each kv was {
                css[k] and continue
                $(el).css(k,'');
            }
            was = null;
            $(el).css(css)
        };
    }
    # R's element
    me.Dispon = &acgtR{
        $r = me&Disp,R;
        return r && rs&on
    };
    me.Disp = &acgtR{
        !Ry&Display && Ry&R && Ry&R != R and R = me&yfuture,R
        Ry&Display and $D = Ry&Display
        D && Ds&on and return D;
        $b = Rc&b;
        b && by&Display and $D = by&Display
        D && Ds&on and return D;
    };

    # < harness such datastructure for %Zave!
    # save/resume L%k = C(t y)+
    me.remember = &acgtLk{
        $d = L.sc[k];
        !Lc&W and throw "!cW"
        $store = 'remember/'+Lc&W+'/'+k;
        if (d) {
            delete dc&thaw;
            delete dc&prefab;
            $more = &d{
                $l = [d.t,d.y.cv];
                each in ds&z {
                    l.push(more(n))
                }
                return l
            };
            localStorage[store] = enj(more(d));
        }
        else {
            $s = localStorage[store];
            !s and return L.sc[k] = Cye([k,1,{prefab:1}])
            $more = &l{
                $d = Cye([l.shift(),l.shift()]);
                each in l {
                    fio(d,more(n))
                }
                return d
            };
            d = L.sc[k] = more(dej(s))
            dc&thaw = 1
        }
        return d
    };
    },
  
  //#c %Codon
    # < leading the way:
    #    having a few words of plan
    #    in a dozen locations, firstish

    # cloud of %Codon and related types inheriting
    ['Codon','291',&acgtRs{
        $p = Ry&up;
        # non-%Codons
        Rs&fix && ps&Code && ps&ball and Rs&Cofix = 1
        !(Rs&ball || Rs&Gens) and delete Rs&Codon; return
        ac(R,'inheritsc','Codon');
        ah(R,'reawakens','Codon',{
            rollbs:'Codon,Codo,Codoor,Codin,Code,Cofix,Codinner'
                # covered by %Peace=5 in the future:
                +',Gens,self,Here,Zaving'
        });

        !Rs&ball and return
        me&rollbs,R,'eCsc';

        $c = me&tsc,'%Codon','C','B';

        # %Codon dives:
        #  %Abodo/%Codoor/%JRom/%Codo%Gens
        #    /%Codo%Codin/%Code
        # the %JRom and %Gens are !%ball
        $Codo = me.cbub(R,&r{ return rs&Codo && rs&ball },'!Gens');
        if (!Codo) {
            $Abodo = me.cbu(R,'Abodo');
            # screenful %Codon
            !Abodo || Abodo == R and Rs&Abodo = 1
            else {
                # to JRom
                Rs&Codoor = 1
            }
        }
        else {
            # first Codo
            Codo == R and Rs&Codin = 1
            else {
                Rs&Code = 1
            }

        }
        
    },'ift,D'],
    ['Codo','2901',&acgtRs{
        # %Codon not inherited through %JRom
        Rs&Codon = 1;
        # %Codo inherited through %Gens to first %ball,
        #  leading back here to %Codon it
        Rs&Gens and ac(R,'inheritsc','Codo');
    },'ift,D'],

    # an out%ball sprouts JRom:Codo
    # < feed openness
    ['ball+Codo','33',&acgtRs{
    },'ift,D'],
    
    
    ['Codoor','296',&acgtRs{
        # the latest %ball%Codin hangs out:
        me&rollbs,R,'Codinner';
        me&rollbs,R,'incount';
        Rs&incount ||= 0;
        Rs&incount++;

        $c = {};
        c.Doming = 3;
        c.Codon = 1;
        c.Codo = 1;
        $r = me&ballRom,R,s,c;
        
        # was:
        # auto %play any %R=Codo|Code
        #  similar to $t%W=nott, nott being a pin to decode it through
        #   future is decoding W with other W
        # < use the in/out %ball for openness/thumbnailing
    },'ift,D'],

    ['Gens+Codon','293',&acgtRs{
        $c = me&tsc,'%Codon','Gedo','g';
        # %Zaving instead of Gens+ting
        Rs&Zaving = "mem,W";
        me&reaw,R,'Zaving';
        delete Rs&ting;
        s&hue = -52
        # has /*%hue=20
    },'ift,D'],
  
  //#c Abodo..Codap
   // Abodois
    ['ball+Abodo+Codon','297',&acgtRs{
        $init = !me&rollbs,R,'incount';
        Rs&incount ||= 0;
        Rs&incount++;
        $c = me&tsc,'%Codon','Abodo-'+Rs&incount,'g';
        
        n Codap  R %Abodis,Codap
    },'ift,D'],
    
    # Codap extends Abodis, animal of these handlers
    # accumulating to f.*, which we receive
    #  f.hatch($t,$arg) may be used to call them
    # or if f isnt around, eg from nto:
    #  Rs&fengi($otherT,$t,$arg) entrances
    # the f.o.* are hatched along the feng()
    #   able to T.waits to break

    # 
    # < static specificity of this J,
    #   would be at the compile of this code
    #   to set a bunch of lexicals (icon, etc)
    ['Abodis+Codap','38',&acgtRs{
        $dish = &{ah(R,'Abodis',...arguments) };
        # < TEST why such extravagant memory loss
        #   without this %reawakens, clicks here wakes %Abodo
        #   then its %Codoors c.neednt badly,
        #   < JRom post-error/pre-history better
        me&reaw,R,'Codap,Loc,selfs';
        #Rs&init_breeze = 1
        s&over = 1
        
        $Abodo = me.cbu(R,'Abodo');
        # to sample attention from
        $Loc = me&rollbsc,R,'Loc';
        Locc&W = Abodo.t;
        
        # seekto resume Loc%center
        $c = me&remember,Loc,'center';
        # thaw the first time, prefab if invented (spacer C) (even if saved)
        cc&thaw && !cc&prefab and Rs&seekto ||= c
        # others may set this
        me&rollbs,R,'seekto'
        
        # if scroll or Codin sizes change:
        # notice where center of view is
        #  as fractions of %Codin(/%Code)
        dish('o','notice_center',&fT{
            $din = f.Codepointer();
            !din and return
            #~>3 center: ki(din,2), ki(ner,2)
            Locs&center = din;
        });
        
        # scroll to counteract repositioning
        dish('o','dontscroll',&fTO{
            # see where we're looking
            $at = f.at;
            # select one at center to keep scroll to
            $din = f.Codepointer(null,O);
            !din and return f.heighten();
            # one Codin|Code, before|after
            $da = f.Codeba(din);
            f.heighten();
            $ba = f.Codeba(din);
            !ba and return
            dac&R != bac&R and throw "din!ba R"

            $move = das&top - bas&top;
            $abso = ats&top - move;
            atc&s = ba.t+" "+move+": "+abso;

            $was = f.on.scrollTop;
            f.on.scrollTop = abso;
            $diff = dec(abso - was);
            diff and ~>6     scrool: diff;
        });
   //   #c %Code acts: curse, point, click
        # %Code that wants typing into (%initCode)
        dish('o','Codon_curse',&fTr{
            r = me&yfuture,r;
            $cm = rs&cm;
            !cm and ~>6 lost cm: r.t
            !cm and return
            
            ~>6 Into cm: r.t
            cm.focus();
            cm.execCommand('goLineEnd');
            # < seekto it, ideally...
            G&yl:6,&{ cm.scrollIntoView() };
        });
        
        # Codap%seekto=din to go there
        dish('o','Codon_point',&f,T,din{
            # < specify seekto is the intent,
            #   drop on fail/success
            # < seekto as %loca, any depth/describitude
            #    as SCA ring
            dinc&ttl ||= 5;
            dinc&timetl ||= Gtime();
            if (--dinc&ttl == 0 || Gtime(dinc&timetl) > 5) {
                # might be things on trail no longer in W
                # < loose bits of uncommitted W to reintro
                delete Rs&seekto;
                ~>2 seekto gives up:
                return
            }
            T.waits = 'seekto';
            ~>2 seekto:
            f.heighten();
            
            $c = {};
            $thing = f.Codeba(din,c);
            $fora = c.fora;
            if (!thing) {
                # elvises unopen path (without %Codinner=%Codin)!
                T.waits and return ~>7 unopenable path?: din.t
                # or it cancels the go
                return delete Rs&seekto
            }

            $at = f.at;
            $on = f.on;
            
            $scroll = on.scrollTop + things&top;
            if (foray&cv != 0.1) {
                # put center
                scroll -= ats&gapy / 2;
                # yay far down
                scroll += things&height * foray&cv
            }
            on.scrollTop = dec(scroll);
            ~>7 sunk: ki(fora,2)
            if (!fs&sunketh) {
                fs&sunketh = 1;
                ~>3 sunketh inint:
                me&elvis,R,'sunketh-init';
            }
            delete Rs&seekto;
        });
        
        # Loc/** to %seekto
        dish('o','Codon_click',&fTO{
            $D = Oy&up;
            D == Loc and D = null
            !D and D = O; O = null
            $seek = Cye([D.t,1]);
            
            if (O) {
                # specific %Code
                $onto = fio(seek,O.t);
                # visited to open for the first time (until r%cm)
                #   after that ope=1|0 toggles cm display:none from stylepile
                $r = Oc&R;
                Os&ope = 1;
                if (r && !rs&cm) {
                    ~>7 ope-Code hop:
                    # < ux: seek then this via Dc&onsunketh
                    me&elvis,R,'ope-Code',{wake:Oc&R}
                }
            }
            
            # every odd Codon_click should seek top of it
            #   not $seek/-$onto
            $was = fs&last_Codon_click_O;
            was == O and onto = null; delete fs&last_Codon_click_O
            else { fs&last_Codon_click_O = O }
            
            $t = Locs&trail;
            if (onto && t) {
                # go where we left
                $la;
                each in ts&z {
                    la and break
                    n.t != D.t and continue
                    each ij ns&z {
                        j.t != O.t and continue
                        la = j
                    }
                }
                la and ontoy&cv = lay&cv
            }
            # note exactly where we leave
            f.hatch(T,'trailing','doit');
            Rs&seekto = seek;
            ~>2 Seek: ki(seek,2)
            # as very fast 
            T.feng = 1;
        });
        
   //   #c pointers: gapy<->ba<->din
        # din from gapy
        # < redo "pointer", f.ind thing
        dish('Codepointer',&point,not{
            $f = this;
            $at = f.at;
            point ||= ats&gapy / 2;
            # for %Codoor
            $din = f.atpoint(point);
                $oor = dinc&R;
                !oors&Codinner and return
            $N = f.balls(oors&Codinner);
            !N and ~>6 noseeingcenter:
            !N and return
            # for %Code
            $ner = f.atpoint(point,N,!not&&'exactly',not);
            ner and fio(din,ner);
            return din;
        });
        
        # din to ba, space item amongst f.balls
        dish('Codeba',&din,c{
            $f = this;
            c ||= {};
            # din/ner is sheer openness, two layers
            #  < good shape of thing to stream space solvitude around
            #  < should be ind magic, use cases are here
            
            # for %Codoor
            $v = f.M.filter(n=>din.t==n.t)[0];
            
            !v and ~>2 seek!found: din.t
            !v and return
                # which links into itself like s&Js&top
                $Codoor = vc&R;
                $Codin = Codoors&Codinner;
                if (!Codin) {
                    me&elvis,R,'seekto',{wake:Codoor};
                    T.waits = 'seektowake:'+Codoor.t
                    return
                }
            
            # for %Code, maybe
            $cn = (dins&z||[])[0];
            if (cn) {
                $n = f.balls(Codin,cn.t)[0];
                !n and return
                    # which must look ready < know Zave/waits
                    $nr = n && nc&R;
                    $s = nr && nrc&s;
                    !s || ss&string == null and n = null
                    !n and ~>6 waitseek: din.t, cn.t
                    !n and return
            }

            $at = f.at;
            $on = f.on;
            $thing = n || v;
            c.fora = cn || din;
            return thing
        });
        
   //   #c trail
        me&remember,Loc,'trail';
        $muchdif = &ab{
            a *= 1;
            b *= 1;
            return b > a + 0.05
                || b < a - 0.05
        };
        $muchpoint = &din,don{
            $nir = (dins&z||[])[0];
            $nor = (dons&z||[])[0];
            return din.t != don.t || nir.t != nor.t
                || muchdif(diny&cv,dony&cv)
                || muchdif(niry&cv,nory&cv)
        };
        # location accumulator
        dish('o','trailing',&f,T,doit{
            # trail wanders along
            $t = Locs&trail;
            !t and throw "noitime"
            ts&z ||= [];
            $don = ts&z[0];
            # we are on it
            $din = Locs&center;
            $ner = (dins&z||[])[0];
            $nor = (don&&dons&z||[])[0];
            # don't trail 1-pointers
            !ner and return
            
            doit = doit || !don || muchpoint(din,don);
            !doit and return
            doit== 'doit' and ~>7 doing leave: ner.t
            # add a place we were
            $tr = Cye(din);
            trs&z = dins&z.slice();
            ts&z.unshift(tr);
            f.hatch(T,'mapstyle');
            # slow down
            ts&changey ||= 0;
            ts&changey++;
            ts&changey < 5 and return
            delete ts&changey;
            
            blurtrail(t);
            
            me&remember,Loc,'trail';
            
            $ner = (dins&z||[])[0];
            ~>3 strail: ki(din,2), ki(ner,2)
        });
        # trail/$Codin+/$Code+ pointers smush down
        # < scaling up, grouping into each other
        $blurtrail = &t{
            $tend = 30;
            $ima = 100;
            while (ts&z.length > 5 && ima-- > 0) {
                $tw = {};
                $not = [];
                each in ts&z {
                    $m = delete tw[n.t];
                    # for two %Codin
                    !m and tw[n.t] = n; continue
                    not.push(n);
                    each il ns&z {
                        # leave more recent Code fraction
                        ms&z.filter(L => L.t == l.t).length and continue
                        fio(m,l)
                    }
                }
                each in not {
                    $ni = ts&z.indexOf(n);
                    ni < 0 and throw "notnot"
                    ts&z.splice(ni,1);
                }
            }
            while (ts&z.length > 30) {
                # we gradually blur into time,
                #  easiest to exclude (eg a curve) first
                ~>2 blurtrail truncates:
                ts&z.pop();
            }
        };
        
        
   //   #c stylepile!!!
        # < center changes faster
        # < to unify all waits-ing, sparkles of activity
        # < pointers through !O%ope should ...
        
        # rebuilds r:Abodo/** to O:Loc/**
        $sch = {
            # < wake R when these emerge
            schinf:['Codin','Code'],
            # really Abodo/Codoor/.../Codin/Code
            # < handle being for the %Codoor until let in
            schifat:{Codoor:{scto:'Codinner'}},
            # links each Oc&R=r, Rs&Org=O
            S:'cR',
            O:'sOrg',
        };
        $Org = me&indot,Abodo,Loc,sch;
        
        # map drawn
        # ! d.d > 3 (Code/Code) causes e loop
        # ! cant seekto a Code!string
        # < ind a floppy case
        $ma =
        n map   %bg:033,dis,ws:0
        delete mac&s;
        mas&align = 1;
        Rs&selfs = Org.self(&rOds{
            # Oc&n = map modulat
            $se = d.se;
            # n/{t,...,z/...}
            if (se) {
                $ze = fio(se,'z');
                zes&ml = 1;
                sey&ze = ze;
            }
            $n = fio((ze||ma),s.t);
            d.se = Oc&n = n;
            nc&forgk = ds&gk;
            
            ns&ml = 0.3;
            ns&hue = 60;
            
            $t = ny&label = me&mtsc,n,'t',s.t,'g';
            # wraps to keeps whole
            ts&dis = 2;
            ts&fs = 12;
            d.d == 2 and ts&fs = 18; ns&dis = 1;
            else {
                ns&dis = 1;
            }
            $N = me&ollbs,R,'selfs';
            if (N && !N.includes(O)) {
                $Gens = me.cbu(r,'Gens')
                ~>4 O el=1: O.t, Gens && Gens.Zaving ? "GZ" : Gens ? "G" : "!"
                
                # see if s is in s^^%Gens %Live...
                #  if not, e:1up tells it to Describing
            }
            
            $clicksat = &OTe{
                $was = Os&ope;
                $is = Os&ope = e.t.includes('C') ? 0 : 1;
                if (is == 0) {
                    if (rs&Codin) {
                        # close innards
                        me&ioty,O .map(O => Os&ope = 0);
                    }
                }
                if (is != was) {
                    Rs&fengi(T,'mapstyle',O)
                    # < too strange. it's an around method,
                    !is and Rs&fengi(T,'dontscroll',O);
                }
                return is||-1
            };
            
            # clicks in the map
            me.nto(R,n,&sTe{
                ~>4 selfs: n.t, e.t
                clicksat(O,T,e) > 0 and Rs&fengi(T,'Codon_click',O);
                T.wake = 'not';
            });
            # clicks on their label (dont boost)
            Oc&nto_label = &sTe{
                ~>4 others: n.t, e.t
                clicksat(O,T,e);
                T.wake = 'not';
            };
            
            return O
        });
        
        
   //   #c map styled!!
        # O-memorised c-styling n-modulat
        #  not bound to reapply since O !~ n,
        #   but we always call mapstyle
        $apply = &Onc{
            $modon = me&Dispon,n;
            me&eCsc,O,'mapstyle',c (modon);
        };
        dish('o','mapstyle',&fT{
            # apply styles to Loc/*/* map
            
            # start using that pointer
            # < to steer around (d.not=1)
            # < if we have the O we want styles updated on...
            #   supposing its meaning doesn't spread up ind
            #   ie ind's doming/grasp of itself from recently,
            #    is allowed to reinc small change
            $cent = me&doint,'center',Locs&center;
            $tra = me&doint,'trail',Locs&trail,{};
            # looking for the center, etc
            # < and any Rversioned since,
            #   and the last path we thought it was
            
            
            Org.other({y:&rOds{
                $sc = {};
                $n = Oc&n;
                $l = ny&label;
                
                cent(s,d) and sc.deco = 1
                # points over time (which is lost)
                # < ind reducing/knowing reduced,
                #   could keep nulls in between
                tra(s,d) and sc.bri = 1.2
                
                # init
                #Os&ope == null && haks(sc) and Os&ope = 1
                # explicit tinkering
                Os&ope and sc.fs = 16
                
                if (rs&Code) {
                    $cm = rs&cm;
                    if (cm) {
                        # < O and the %fix tighter bound,
                        #   so it doesn't load cm when starting closed,
                        $is = Os&ope ? '' : 'none';
                        #   yet open for new & unsaved
                        cm.lineCount() < 5 and is = ''
                        $div = cm.getWrapperElement();
                        if (div.style.display != is) {
                            div.style.display = is;
                            T.feng = 'cmope';
                        }
                        # < some Org styling should lead to f.heighten()
                        #  < %height that knows to apply to cm,
                        #    and join it into this geometry quest
                        #cm.heighten(55);
                        if (fs&regeo) {
                            cm.refresh();
                        }
                    }
                }
                elsif (rs&Codin) {
                    # explicitly shut hides $n/z
                    $is = Os&ope == 0 ? 'none' : '';
                    $zc = {};
                    is and zc.dis = 0;
                    $ze = ny&ze;
                    # <! throw here looping crazy
                    !ze and ~>6 stylemap Codin !ny&ze: O.t
                    else { apply(ze,ze,zc) }
                }
                
                apply(O,l,sc);
            },anycha:&chad,{
                each id chad {
                    $go = ds&cha;
                    ~Othicha: d.ind, d.s.t, ki(go,4.23)
                }
                # < hierarchy to tunnel
                me&elvis,R,'Orgup'
            }});
            
            delete fs&regeo
        });
        
        
        # random printouts/tools!!
        
        dish('shut_also',&fTe{
            Locs&trail = Cye(['trail',1]);
            # and delete the explicit tinkering
        });
    },'ift,D'],
  
  
  //#c indother!!!
    &{
    
    # surf into S, not S itself
    #  
    me.indot = &acgtSOd{
        $initc = &y{
            $c = ex({},d);
            isha(y) and ex(c,y); c.yy = delete c.y
            else { c.yy = y }
            return c
        };
        $topO = O;
        return {
            self: &y{
                $c = initc(y);
                # rc&s=s? preferred .t to sync up
                #  see out|in .t, r.t may dedupe|repurpose s.t
                c.y = &rds{
                    # i Loc/...
                    d.O ||= topO;
                    O = d.O = me&syncup,d.O,s||r;

                    # Oc&R=r, rs&Org=O
                    me&futlink,O,c,r
                    
                    # middle
                    $re = c.yy ? c.yy(r,O,d,s) : r;
                    return re;
                };
                c.finaly = &rds{
                    $gone = me&syncdown,d.O,(ds&z||[]).map(d=>d.O);
                    gone.length and ~>5 Orggone: ki(gone,4.23)
                };
                return me&indo,S (c)
            },
            other: &y{
                $c = initc(y);
                c.schexcuse = 1;
                c.y = &Od{
                    # Oc&R=r yfutures, rs&Org=O
                    $r = d.S = me&futlink,O,c
                    r && isC(r) and $s = rc&s
                    
                    # middle
                    $re = c.yy ? c.yy(r,O,d,s) : r;
                    return re;
                };
                $chad = [];
                c.finaly = &Od{
                    # can now trust d.S beyond
                    #  to be the latest r inside r
                    $r = d.S;
                    # r/* not in O/*
                    #  as sch would filter it
                    $Z = (rs&z||[])
                        .map(r => c.schableto(r,null,d.d+1))
                        .filter(r => r);
                    $neu = me&syncdown,Z,(ds&z||[]).map(d=>d.S),'noop';
                    
                    # O/* not in r/*
                    $N = (rs&z||[]).map(r => me&setngk,r,c.O )
                    $gone = me&syncdown,O,N,'noop';
                    
                    $cha = [...neu,...gone];
                    !cha.length and return
                    
                    # gone will be always be O, neu always S
                    # < hierarchy to tunnel
                    ds&gone = gone;
                    ds&neu = neu;
                    ds&cha = cha;
                    chad.push(d);
                };
                $re = me&indo,topO (c);
                chad.length && c.anycha and c.anycha(chad)
                return re
            },
        }
    };
    
   //#c indo-f
    
    # climb pointer C
    #  returns callback to test in middle
    me.doint = &acgtknc{
        !isC(n) and throw "pointer !C";
        c ||= {tw:1};
        c.tw && ns&z && !ny&tw and throw "pointer C!tw"
        k = "p_"+k;
        $topn = n;
        return &sd{
            $h = d[k];
            n = topn;
            # they match s.t unless:
            !n and return
            h == 'not' and return
            if (c.tw) {
                # default, begins matching n
                if (!h) {
                    n.t == s.t and h = n
                }
                else {
                    h = fio(h,s.t,0);
                }
            }
            else {
                $N = [];
                # begins matching n/*
                if (!h) {
                    N = ns&z || []
                }
                else {
                    each in h {
                        !isC(n) and throw "inpointz !C", n
                        N.push(...ns&z)
                    }
                }
                h = N.filter(n => n.t == s.t);
                h = h.length && h
            }
            !h and d[k] = 'not'
            else {
                d[k] = h
            }
            return h
        };
    };
    
    # make/keep eg Oc&R=r, rs&Org=sy&Org=O
    #  r may not be supplied if indother
    me.futlink = &acgtOcr{
        c.O ||= 'yOrg'
        c.S ||= 'yD'
        r and me&setngk,O,c.S,r
        r ||= me&setngk,O,c.S
        !r and return
        # always use the latest R
        #  yfuture moves yR-wards from a node s
        isR(r) and r = me&yfuture,r
        # other links yD to 
        me&setngk,O,c.S,r
        # self|source links to other
        me&setngk,r,c.O,O
        # r%ball also sy&Org
        $s = rc&s;
        s && rs&ball and s.y [c.O.substr(1)] = O
        return r
    };
    # O,'yD',v [sg]ets O.y.D = v
    me.setngk = &acgtOks{
        isst(k) and k = [k.substr(0,1),k.substr(1)]
        k[0] == 's' and k[0] = 'sc'
        $gv = O[k[0]]
        s and gv[k[1]] = s
        return gv[k[1]]
    }
    
    # replication
    # i going in
    me.syncup = &acgtDs,noop{
        $S = fio(D,s.t,0);
        noop and return !S
        S and return S
        S = fio(D,s.t);
        Sy&up = D;
        return S
    };
    # o coming out
    me.syncdown = &acgtDz,noop{
        !isar(z) and throw "z=[s+]"
        isar(D) && !noop and throw "D=[] !noop"
        $Z = isar(D) && D || Ds&z || [];
        $gone = Z.filter(&s{
            # refs not names
            return !z.includes(s)
        });
        noop and return gone
        each is gone {
            $S = fio(D,s.t,0);
            S != s and throw "inexactly"
            fio(D,s.t,9)
        }
        return gone
    };
    
   //#c indo
    # < BAB me&ind,v,...{\n should let us close the bracket
    # me&indo,r ({sch:['Types'],y:&rds{ ...
    #  supposing rc&s=s
    me.indo = &ACGTsd{
        d ||= {};
        # callback r before r/**, still depth first
        d.cbfirst == null and d.cbfirst = 1
        return &y{
            $N = [];
            $ay = &yrd{
                $s = isC(r) && rc&s;
                return y (r,d,s)
            };
            if (isha(y)) {
                $c = y;
                c.schinf and c.sch = c.schinf
                if (c.sch) {
                    c.beyond ||= 1;
                    c.schableto = &r,d,depth{
                        if (!d) {
                            # middle may call schableto(somer,null,depth
                        }
                        else {
                            # avoided for the other
                            c.schexcuse and return r
                        }
                        depth ||= d.d;
                        $schi = depth - 2;
                        # < climb to it: inheriting, opening
                        $gk = c.sch[schi];
                        !gk && c.schinf and gk = c.sch.slice(-1)[0];
                        !isC(r) and return
                        $fail = !r.sc[gk];
                        
                        if (fail && c.schifat) {
                            # for switching d.s into a link
                            each kv c.schifat {
                                # if we're a %Codoor
                                !r.sc[k] and continue
                                !v.scto and throw "!scto"
                                # with a %Codinner
                                $or = r.sc[v.scto];
                                !or and continue
                                # that is %Codin, as it were
                                !or.sc[gk] and continue
                                r = or;
                                fail = 0;
                                break
                            }
                        }
                        fail and return
                        # sometimes hypothetical, no d yet
                        if (d) {
                            ds&gk = gk
                        }
                        return r
                    };
                }
                y = &rd{
                    d.sc = {};
                    # for those inside s
                    c.beyond && d.d <= c.beyond and return
                    c.within && d.d > c.within and return
                    if (c.sch && d.d > 1) {
                        r = c.schableto(r,d);
                        !r and return d.not = 1
                        # < should be re-2'd (SCA)
                        r != d.s and d.s = r
                    }
                    $re = c.y ? ay(c.y,r,d) : r;
                    if (!d.not) {
                        # flat list, depth first
                        N.push(d);
                        # each ds&z = [d+]
                        d.up and ac(d.up,'z',d);
                    }
                    return re
                };
            }
            $re = me&ind,s,y,d;
            if (c) {
                c.finaly and N.map(d => ay(c.finaly,d.s,d))
            }
            return re || N
        };
    };
    
   //#c ind climb C
    # from 26:NutCertainty
    me.ind = &acgtsyd{
        # setup
        d ||= {};
        if (!d.refs) {
            d.refs = []; # all things
            d.refid = {}; # those indices to d
        }
        y ||= &s{ return s }
        if (typeof y == 'string') {
            if (y.slice(0,2) == 'ki') {
                $dl = y.slice(2);
                y = &s{ return ki(s,dl) }
            }
            else { 
                throw "ind y named", y
            }
        }
        
        $i = {};
        # dedupe (s always an Object)
        i.refin = &ds{
            $ri = d.refs.indexOf(s);
            if (ri < 0) {
                ri = d.refs.push(s) - 1;
                d.refid ||= {};
                d.refid[ri] = d;
                return 1
            }
            else {
                $od = d.refid[ri];
                # dupe seeing very interesting for -jod
                return;
            }
        };
        !i.refin(d,s) and return

        if (d.hup) {
            # clone each thing, not repointing tw/tv/z etc
            # < a separate object, a map to the result of the map this is
            #d.infolate == null and d.infolate = 1;
            $D = s;
            s = G&Cye,s;
            s.y.D = D;
        }

        $dd = &d{
            d = ex({},d);
            d.path = (d.path||[]).slice();
            return d
        };
        $up = d.out && d;
        d = dd(d);
        up and d.up = up
        d.s = s;
        $pi = d.path.push(s.t+' '+s.y.cv)-1;
        # accumulates on every depth's return of a string
        d.ind = d.ind == null ? '' : d.ind+'  ';
        d.d ||= 0;
        d.d++;
        # depth limit vs depth
        d.dl && d.dl < d.d and return;

        $out = d.out = [];
        $one;
        $my = [];

        d.cbfirst and one = y(s,d)
        d.not and return
        d.nofurther and return one
        d.for_string and $for_string = delete d.for_string
        
        if (d.s != s) {
            !i.refin(d,d.s) and throw "switched s dup ref"
            s = d.s;
            d.path[pi] = s.t+' '+s.y.cv;
        }

        # )
        #c the ways to go deep, should be all? will dedup
        # user throws something on any way
        if (ss&z) {
            $z = ss&z.filter(&s{ return 1 && s });
            d.zort and d.zort(z,s,d);
            each iD z {
                out.push( me&ind,D,y,d );
            }
        }

        if (s.y.in) {
            out.push( me&ind,s.y.in,y,d );
        }

        if (s.y.tw) {
            each tD s.y.tw {
                out.push( me&ind,D,y,d );
            }
        }

        if (s.y.tv) {
            each tvD s.y.tv {
                out.push( me&ind,D,y,d );
            }}
        }

        out = out.filter(&s{ return 1 && s });
        # flatten a bit, G&ind returns js arrays
        $oute = []; 
        out.map(&s{
            s.constructor == Array ? 
                s.map(&s{ oute.push(s) })
            : oute.push(s)
        });
        out = oute;

        out = out.filter(&s{ return 1 && s }).map(&s{
            if (typeof s == 'string')
                return s.split("\n").map(&s{ return '  '+s }).join("\n")

            if (typeof s.constructor == Object) {
                if (d.infolate) {
                    if (!sc&ind) {
                        # (once) write where things are
                        # on the things themselves
                        sc&ind = d.d;
                        sc&inds = '';
                        $i = 0; # to d.d==1 for the first level
                        while (i++ < d.d)
                            sc&inds += '  ';
                        sc&inside = d.path;
                    }
                }
                my.push(s);
            }
            return s
        });

        if (s.y.next && !d.nonext) {
            $od = dd(d);
            od.path.pop();
            od.d--;
            out.push( me&ind,s.y.next,y,od );
        }

        if (!d.cbfirst) {
            one = y(s,d)
            d.for_string and $for_string = delete d.for_string
        }
        d.not and return
        out.unshift(one);

        out = out.filter(&s{ return 1 && s });
        !out.length and return
        $retrefs = out.filter(&s{ return typeof s != 'string' }).length > 0;
        for_string && retrefs and throw "!string"
        for_string and for_string(s,d,out)

        if (d.d == 1 && !retrefs) {
            d.wantarray and return out
            return out.join("\n");
        }
        else {
            # an N with insidenesses, has been organised, located...
            # put insides (s&z,yin) in a z on the outside
            my.length && typeof one == Object and ones&z = my
            # return every C in N, each G&ind leaves [] to dissolve
            $flat = [];
            each is out {
                s.constructor != Array and flat.push(s); continue
                each IS s {
                    flat.push(S);
                }
            }
            return flat
        }
    };
  
   
    },
   
  
  //#c Abodis wires an Abodo
    # R%Abodo implied by R/r%Abodis
    #  ball+Abodo+Codon @297 creates r, but elsewhere...
    # hopefully in time for Abodo @6
    ['Abodis','2918',&acgtRs{
        $p = Ry&up;
        ps&Abodo ||= 1;
    },'ift,D'],
    &{
        me.moveDisplayto = &acgtR,to{
            ah(R,'NinetySixer','tobody',&{
                $on = me&Dispon,R
                !on || on.parentElement == to and return
                # trick &gev|w:EleMento into reading the whole path
                on.trickparentNode = on.parentElement
                # cull history
                $t = on.getAttribute('title')
                t && Array.prototype.slice.call(to.childNodes) .map(&n{
                    n.getAttribute && n.getAttribute('title') == t
                        && n.remove()
                })
                to.appendChild(on)
            })
        }
    },
    # the lab to sort out
    #   maximises/styles a bit
    #   listens for tunneling
    ['Abodo','6',&acgtRs{
        s&po = 3;
        s&left = '0';
        s&top = 0;
        s&width = '55%';
        s&height = '100%';
        # modern browsers nest fixed|absolute
        me&moveDisplayto,R,document.body
        s&bgi = '/i/IMG_3524.JPG';
        s&over = 'scroll';
        s&attr = {class:'fathandle'};
        Rs&rowish = 0;
        delete s&br;
        
        me&reaw,R,'Abodo,Alooseion';
        # hooks from Abodis while sleeping Abodo
        me&rollbs,R,'Alooseion';
        
        $N = me&ioty,R;
        each in N {
            $c = ns&C;
            # things inside
            ns&rowish == null and continue
            # redone when %Abodis.heighten()
            #   pl:14 =~ ab,left:14,height:...
            ns&ball and me&eCsc,n,'Abodo','ml:14',1
        }
    },'ift,D'],
    
    # asleepic callbacks, after Display
    # oncers, eg cm must start on the page
    ['NinetySixer','96',&acgtRs{
        me&reaw,R,'NinetySixer'
        $N = Rs&NinetySixer;
        each t,cb N {
            cb('NinetySixer');
        }
    },'ift,D,sleeping'],
    
    # rolling, any tunneling through %Abodo
    ['Alooseion','98',&acgtRs{
        $Al = Rs&Alooseion;
        each t,cb Al {
            cb('Alooseion');
        }
    },'ift,D,sleeping'],
   //#c Abodis maproom
    # has a layout, icon trays
    ['sleeping+Abodis','293',&acgtRs{
        $f = Rs&Abodis;
        ~>5 sleeping+Abodis:
        # < fengi, f<->R ?
        fs&init = 0;
    },'ift,D'],
    ['Abodis','293',&acgtRs{
        $f = Rs&Abodis
        !f and debugger
        # add a function to f.**
        f.u = &{ah(R,'Abodis',...arguments) }
        # use fengi for n:modulat events
        f.fenginto = &nt{
            me.nto(R,n,&sTe{
                Rs&fengi(T,t,e)
                # tends not to wake, may feng
            });
        };
        # se:modulat has icons (must sey&can) that 
        f.iconing = &se,{
            sey&icon = &ts{
                $n = sey&can('n',t);
                nc&s = s;
                f.fenginto(n,t);
                $args = [...arguments].slice(2);
                args.length and f.u(t,...args)
            };
        }
        
        $se = Rs&headcase = me&case,2;
        ses&fs = 16;
        f.iconing(se);
        
        $pc = &n{ return dec(n*100,0)+'%' };
        
        s&dis = 1;
        s&po = 3;
        s&top = '5%';
        s&height = '90%';
        s&width = 14;
        #s&left = '5em';
        #s&over = 'v';
        me&walla,'b:2.3'; # ,bg:3423
        Rs&rowish = 0;
        
        # shut all the O-selfs
        sey&icon('shut','ʚ',&fTe{
            each iO Rs&selfs {
                Os&ope = 0
            }
            # default T.wake=not
            T.feng = 1;
            f.hatch('shut_also');
        });
        # widen Abodo
        sey&icon('widen','Ш',&fTe{
            fs&widened == null and fs&widened = 1;
            !e and fs&widened = !fs&widened;
            $is = fs&widened = !fs&widened;
            $width = is ? 0.8 : 0.55;
            $wrest = 1-width;
            # left
            f.on.style.width = pc(width);
            # right
            $div = $('body div.v8')[0];
            div.style.left = pc(width);
            div.style.width = pc(wrest-0.007);
            div.style.height = '100%'
            div.style.overflow = 'scroll'
            # also right
            4s&msgs.style.left = pc(width);
            4s&msgs.style.width = pc(wrest-0.007);
            4s&msgs.style.background = '#000';
            fs&regeo = 1;
            T.feng = 1;
        });
        sey&icon('fontsize','+',&fTe{
            fs&fontsize ||= 1.4;
            if (e) {
                # < for a Code if e.t.includes('S')
                $adj = 0.1;
                e.t.includes('C') and adj *= -1;
                fs&fontsize += adj;
            }
            f.on.style['font-size'] = pc(fs&fontsize);
            fs&regeo = 1;
            T.feng = 1;
        });
        
        $se = Rs&tailcase = me&case;
        f.iconing(se);
        
    },'ift,D'],
    
    # Loc may contain some data
    ['Abodis','293',&acgtRs{
        $se = Rs&tailcase;
        $Loc = Rs&Loc;
        !Loc and return
        $i = 0;
        each tv Loc.sc {
            !isC(v) and continue
            i++;
            $ca = sey&can('m',t);
            !cas&ope and continue
            cas&dis = 1;
            
            $y = &sd{
                return d.d == 2 ? s.t : ki(s,2)
            };
            $s = me&ind,v,y;
            $d = me&mtsc,ca,t,s;
            ds&hue = i * 60;
            ds&dis = 1;
        }
    },'ift,D'],
   //#c Abodis main acts
    # are levels of awareness of the grounds
    # places to dispatch to specifics
    # along the boundary of Abodis and whatever's joined
    
    # < flying into the one thing, its environment piling in
    #   as we know it's /ghost/such first,
    #   winding up Gensetc in the background,
    #   merging preemptive R with the native
    ['Abodis','293',&acgtRs{
        $f = Rs&Abodis
        $(window).on('beforeunload', e => "Really")
        # < rename 'main'
        f.u('o','main acts',&f,T,mode{
            $at = f.at;
            !fs&init and f.hatch(1)
            f.hatch(22) and return
            
            # sleepytime same geo
            $geo = f.M.map(m=>ms&top+':'+ms&height).join(',');
            $stillgeo = geo == fs&wasgeo;
            fs&wasgeo = geo;
            $is = [ats&left,ats&top,geo].join(' ');
            $still = is == fs&was;
            fs&was = is;
            !still and delete fs&casual
            
            !stillgeo           and f.hatch(6)    and return
            !still              and f.hatch(71)   and return
            mode && !f.sc[mode] and f.hatch(mode) and return
            
            mode == 'casual' and return
            #~>2 shui: mode||'...', still?"still":""
        })
        $thisR = R;
        # < rename 'init'
        f.u('o',1,&fT{
            $at = f.at;
            $on = ats&on; # Abodo
            $con = ats&con; # Abodis

            $wasleft;
            window.lon = on;
            on.onscroll = &ev,{
                # == Gtime()
                fs&scrolltime = ev.timeStamp / 1000;
                # < interface for formula watching
                if (wasleft != on.scrollLeft) {
                    wasleft = on.scrollLeft;
                    $(con).css('left','-'+wasleft+'px');
                    $re = con.getBoundingClientRect();
                    re.right < 0 and 'sleep'
                }
                if (4s&scrolltiming) {
                    $time = Gtime();
                    $cb = &{
                        $del = Gtime(time);
                        ~>6 scrolltook: del
                    };
                    G&yl,1,cb;
                }
            };
            
            
            f.hatch('widen');
            f.hatch('fontsize');
            f.hatch('mapstyle');
            f.hatch('fengup');
            # < this is proto &settle
            # < GOING
            $bre = Rs&init_breeze && !Rc&b
            bre = bre && &{
                $theR = me&yfuture,thisR
                me&elvis,thisR,'breeze'
            }
            bre && G&delay,1.14,bre
            
            fs&init = 1;
        });
        
        # pretty inexplicably complicated
        #  doesn't seem to future anywhere,
        #   was somehow holding R%Domed, closure weirdness?
        # < do f acts as e, immediato from the top level, if finding f
        #   else (and for now) e Codap to re-fengup (re-ein)
        # e->f entry, eg nto callback, hatch with args
        $sharef;
        f.u('o','fengup',&fT{
            f.fengi =
            Rs&fengi = &TtO{
                f = fs&f;
                $args = [...arguments].slice(2);
                f.hatch(t,...args);
                T.wake ||= 'not';
            };
            f.fengisup = 1;
        });
        # delays calls until replaced on f.22
        Rs&fengi = me&tooearly,'fengi','stub' (&{
            ~>5 thisR: thisR.t
            !Rs&calledback and Rs&calledback = 1; me&elvis,R,'fengi-back'
            $f = sharef;
            # futurises f
            f = f && fs&f;
            # futureises R
            $r = me&yfuture,thisR;
            rs&fengi = f && f.fengi || rs&fengi;
            return rs&fengi
        },&TtO{ T.wake = 'not'; return T });
        
        #c more acts
        # early ish, before sleepcheck
        f.u('o',22,&fT{
            Abodo = f.Abodo;
            sharef = f;
            
            # f, per R, could be f.init,
            # as opposed to fs&init which is permanent
            !f.fengisup and f.hatch('fengup');
            
            # notice instructions left, from things just rendered
            each tO Abodos&fengtodo {
                O == 'not' and continue
                f.hatch(t,O) and return
                Abodos&fengtodo[t] = 'not' 
            }
            delete Abodos&fengtodo;
            
            Rs&seekto and f.hatch(T,'Codon_point',Rs&seekto)
        });
        
        # aft sleepcheck:
        
        # if sizes change:
        f.u('o',6,&fT{
            f.hatch('dontscroll')
        });
        # if scroll changes:
        f.u('o',71,&fT{
            delete Rs&seekto;
            f.hatch(T,'notice_center')
        });
        # to casually be somewhere
        #  part of the shui('casual') loop
        #   not 2s near action
        #  comes back after !still
        f.u('o','casual',&fT{
            f.hatch(T,'trailing') and return
            fs&casual = 1;
        });
        
    },'ift,D'],
   //#c Abodis clockworks
    ['Abodis','292',&acgtRs{
        me&walla,'b:2.4,h:7';
        #~BLapa
        ah(R,'reawakens','Abodis',{rollbs:'Abodis,comf'});
        
        $f = Rs&Abodis = {};
        f.sc = me&rollbs,R,'comf',{};
        fs&f = f;
        fs&init = 0;
        
        $Abodo = me.cbu(R,'Abodo');
        Abodos&Abodo = f;
        # for any tunneling through %Abodo
        ah(Abodo,'Alooseion','Abodis',&{ f.shui() });
        
        each tv f.sc {
            Rc&Verbose and me&nu,t,v
        }
        
        f.hatch = &t{
            $args = [...arguments];
            $T = isha(args[0]) ? args.shift() : {};
            $t = args.shift();
            $cb = f.o[t] || f[t];
            !cb and return
            
            cb(f,T,...args);
            
            if (T.feng && !T.fengdone) {
                # very fast
                G&delay,0.001,&{f.shui()};
                T.fengdone = 1
            }
            if (T.munt) {
                $k = 'munt:'+T.munt;
                R.sc[k] ||= 0;
                R.sc[k]++ <3 and G&delay,0.44,&{f.shui()};
                else
                R.sc[k]++ >= 3 and ~>7 shui gives up: k
                T.waits = k
            }
            T.waits and return 1
            return 0
        };
        
        f.o = {};
        f.sanity = &fT{
            $at = f.at;
            # eat
            !ats&on || !ats&con and window.fat = f; return T.munt = 'aton'
            ats&gapy < 500 and return T.munt = 'skinny gap'
            
            # check dom semi arrived
            $N = f.M && f.M.filter(m => (ms&height||0) < 9) || [];
            !f.M || N.length and return T.munt = 'heightholes'
        };
        f.shui = &mode,{
            # < Abodo knowing better its outoftime function waterfallery
            #  < if $mode it should persist for the new R/f
            fs&f != f and return
            # try to avoid doing while scrolling
            # > A.4 etc using these things,
            #   everyone pooling timestyles,
            #    esp on drag, everyone holds breath
            $ro = fs&scrolltime;
            ro && Gtime(ro) < 0.5 and return G&yl,40.4,&{f.shui(mode)}
            # looped waterfallery zombying
            f.on && !f.on.ownerDocument.contains(f.on) and return
            # to shui not in a hurry since the last shui
            # < may never happen if you shui faster than this delay
            $cb = me&sccb,R,'shui_casual',&{f.shui('casual')};
            G&delay,2.14,cb;
            
            $began = Gtime();
            Abodo = f.Abodo = me&yfuture,Abodo;
            # f.at - view, also f.on/f.con
            $at = f.at = f.where();
            # f.M - Codoors
            f.M = f.balls(f.Abodo);
            # and that should look right
            f.hatch('sanity') and return
            
            # wait for the Abodo to be done
            # elvis shunting awake cn
            # which we can rely on %Alooseion to reactivate us after
            $JR = me.cbu(Abodo,'JRom');
            if (JRs&elvoids) {
                fs&beenwaiting ||= 0;
                $i = fs&beenwaiting++;
                i > 5 and ~>8 fs&beenwaiting: fs&beenwaiting
                return
            }
            if (fs&beenwaiting) {
                ~>2 Ready: fs&beenwaiting||''
                delete fs&beenwaiting
                # < one more?
                #return G&yl,0.01,f.shui
            }
            f.hatch('main acts',mode) == null and debugger
        };
        
        
        #c Abodis...
        # measure each|one r/*%ball
        f.balls = &rt{
            $M = [];
            $N = me&ioty,r,'ball';
            each in N {
                t && t != n.t and continue
                $ba = f.whereart(n)
                !ba and ~>6 !Dispon ball: r.t+'/'+n.t
                !ba and return
                bac&R = n
                M.push(ba)
            }
            return M
        };
        
        f.whereart = &D{
            $ba = Cye([D.t,8])
            bas&on = me&Dispon,D
            !bas&on and return
            $re = bas&on.getBoundingClientRect()
            bas&height = re.height
            bas&top = re.top
            return ba
        }
        
        # the view
        f.where = &D{
            $at = Cye(['attend','']);
            $on = f.on = ats&on = me&Dispon,Abodo;
            $con = f.con = ats&con = me&Dispon,R;
            !on and return at
            # position of the view
            ats&top = on.scrollTop;
            ats&left = on.scrollLeft;
            # size of the view
            ats&gapx = on.offsetWidth;
            ats&gapy = on.offsetHeight;
            # scrollable ground (> view)
            ats&width = on.scrollWidth;
            ats&height = on.scrollHeight;
            return at
        };

        # apply absolute positioning
        f.heighten = &M{
            M ||= f.M;
            $sum = 0;
            each i,ba M {
                $r = bac&R;
                # < skip dis:0 - the recently open
                $css = 'po,left:14,width:100%,top:'+dec(sum)+'px';
                # overwrites the other eCsc Abodo
                $apply = me&eCsc,r,'Abodo',css;
                apply(bas&on);
                sum += bas&height;
            }
            f.M = f.balls(Abodo);
        };
        
        # make C = t, fraction, {R,at}
        #  for point in ats&gapy
        f.atpoint = &point,M,exactly,not{
            M ||= f.M;
            $la;
            $precisely = 0;
            each i,ba M {
                not && not.t == ba.t and continue
                la = ba;
                bas&top + bas&height < point and continue
                bas&top > point and continue
                precisely = 1;
                break;
            }
            # tries to return something if !exactly
            exactly && !precisely and return
            $ba = la;
            $prog = point - bas&top;
            $frac = dec(prog / bas&height);
            frac < 0.001 and frac = 0.001
            frac > 0.999 and frac = 0.999
            return Cye([ba.t,frac,{R:bac&R,ba:ba}])
        };
    },'ift,D'],
  
  //#c Codo inside
    ['ball+Codin','296',&acgtRs{
        $c = me&tsc,'%Codon','Codin','g';
        me&walla,'hu:2';
        # is left outside
        #  is JRom's s&Js&top
        $oor = me.cbu(R,'Codoor');
        oors&Codinner = R;
        #s&bgh = '111';

        #n saying   %e,fs:8,bgh:010,ma:1,pa:1,va
        $n = me&quainto,'add-ghost';
        ns&fs = 12;
        $say = me&Tie,R,'add-ghost',1;
        say and me&input,R,say .sc.initCode = 1;
    },'ift,D'],

    # fixturism
    ['ball+Code','293',&acgtRs{
        s&bgh = '311';
        if (!sy&Org && !sy&Org_enquired) {
            # notify Codap of new this, once
            $Codap = me&ioty,me.cbu(R,'Abodo'),'Codap';
            sy&Org_enquired = 1;
            Codap and me&elvis,R,'Code-init',{wake:Codap}
        }
        else { delete sy&Org_enquired }
        
        
        # T: W becomes worth saving
        $Ge = me.cbu(R,'Gens');
        (me&ollbs,Ge,'onceinhabited' || [])
            .map(y => y ());

        me&rollbs,R,'incount';
        Rs&incount ||= 0;
        Rs&incount++;

        $c = me&tsc,'%Codon','Code-'+Rs&incount,'g';

        4s&thecode = R;
        Rs&Zaving = "tmp,ghost";
        Rs&compLines = &D{
            # < %size of it, texture, headings
            # < %ghost=dig(%string)
            delete Ds&string
        };
        Rs&initCode and ss&string = "# "
    },'ift,D'],

    ['fix+Cofix','296',&acgtRs{
        #$c = me&tsc,'%Codon','Cofix','g';

        $p = Ry&up;
        !ps&Code and throw "Cofix^!Code"
        $z = pc&s;
        $O = zy&Org;
        # feed openness from Org
        O && Os&ope || s.length < 100 and Rs&beopen = 1
        if (R.t == 'string') {
            # T: the cm object placed on the Code, etc
            $h = Rs&cm_sc = ps&cm_sc = {hoistcm:p};
            me.cm_chunksfold and h.chunksfold = 1
        }
        
    },'ift,D'],
    
    ['ball+Code','88',&acgtRs{
        # put cursor on init
        # < io doing: {} easy, ^^ efforty
        # i {ah:fengtodo:Codon_curse} o ^^%Abodo/$R%initCode
        if (Rs&initCode) {
            sy&from_initCode = 1;
            $Abodo = me.cbu(R,'Abodo');
            ah(Abodo,'fengtodo','Codon_curse',R)
        }
        
        # save while typing
        if (Rs&cm_sc) {
            $l = [];
            each in Rs&Zaving {
                $f = ns&AutoSave;
                f && isfu(f) && l.push(f);
            }
            l.length &&
            ah(R,'cm_sc','hands','changes',&cm,{
                # per key, wait for a pause
                $cb = me&sccb,R,'AutoSave_casual' (&{
                    $r = cm.R;
                    $s = cm.getValue();
                    r && rs&value == s and return
                    rs&value = s;
                    l.map(y => y(s))
                });
                G&delay,1.14,cb;
            });
        }
    },'ift,D'],
    
    &{
    me.Codin_or_Code_title = &acgtRt{
        # O that map assigns to us
        #  similar to %tracting=f, tidier
        me&rollbs,R,'Org';
        # let the map hook label clicks
        # < defer to what would happen (^^R%elvis)
        #    if modeening unsatisfied
        #    inc pushing maxed value
        me.nto(R,t,&sTe{
            # < ind various kinds of d.matter, io.input etc
            #   which has some this should be C,
            #    C up should down it, etc observables
            $O = Rs&Org;
            !O and return ~>7 no O yet: R.t
            $y = Oc&nto_label;
            !y and return ~>7 nto_label missing: R.t
            y and y (...arguments)
        });
    };
    
   //#c Code cosmetics
    # erase labels etc
    me.mowthing = &acgtR{
        if (Rs&ball) {
            [['','%Codon'],['Be','clicktoplay']]
                .map(l => me&Mwty,R,...l ).filter(n=>n)
                .map(n => n.c.not = 1);
            $t = me&Mwty,R,'ball','t';
            delete ts&deco;
            
            me&Codin_or_Code_title,R,t;
        }
        else {
        
        }
        $N = me&Mwty,R,'','','';
        each in N {
            ns&va == null and ns&va = 1
        }
        return t
    };
    },
    ['ball+Codin','4',&acgtRs{
        $t = me&mowthing,R;
        ts&fs = 55;
        #s&bgh = 331;
        s&pl = 0;
        delete s&bo;
    },'ift,D'],
    
    ['ball+Code','88',&acgtRs{
        $t = me&mowthing,R;
        ty&cv = 0.1;
        ts&fs = 45;
        $p = Ry&up;
        !ps&Code and s&pl = 0
        ss&string && ss&string.length > 100 and s&mb = 3
        delete s&bo;
        delete s&br;
    },'ift,D'],
    
    ['fix+Cofix','4',&acgtRs{
        R.t == 'string' and me&Mwty,R,'fix','k' .c.not = 1
    },'ift,D'],
]};
#Fiveplan#######################################c 

=editor
    make way into /G/$cat/$way
    organised by /W/$cat of $way+
  will be
    network of %Gens%Codon
   
  sleep
   < interactive widgets want tiny Displays,
     eg for the map to redraw,
     knobby adjustables
   < complicate %busy, typing/scrolling/mouse waving
   < e delaying
   < modulats awaking as a faster layer of change
     those 82-4ish pile sorters give one M
   < wake elvi can get done in the mean time
   < know of outstanding %elvoids for ^^%JRom
     pointers seek as their path comes alive
      all the loose ends of the Codon would generate some e
 
 %Search
   they are in a network scenario
   sending batches of Q up/downstream:
   up:
    may be %Search, or just C to believe
     %ein to Talk $of
   down:
    things per J
     remembering the R its from, zombies
     %ein to pull changes
   %GhodigWay has up/down expression:
    the $Way%Idoubleyou fed to %Again
     should be defining seekend
   %tracting collects %tings
   
 %Codo search
   preventDefault a C+F event
     prioritised by where we are
      then knowing all %Codo/%Code/%Zave=mem
       then /ghostack/
     presenting them as %Codo around us
      disjointed, to be pulled in
       as dependencies/further reading

 %Codap
  < pointers
     should me&ind more,
      know cm and line,ch
    find ideal groupings of the matter by size
  
  < always on screen bits: the Rs&headcase?
   < jump to end of/next/where-trail-was-in Code
   < %Zave trouble (jump to)
   < %User trouble
      via websocket irc for the %section
      gateways ask people to auth it there
  
 %Abodis
  makes a toc and fullscreen-ness
   toc made of O, list of t at depths
   
    < openness map: Os&ope over time
    < time/change figured limbs
    < attention/change history
      < squishy log, grind time, sweet genes
        collapsing into the unified samepoint
        as finding the coherent several diffs
        along a trail of string evolution

  unfolding labby mess, way too many dimensions:
   and bring some automation over the top
   saving opennesses, stacking their difference:
     < such that it can be relied upon by others
       who includes it is security over time
       time = distance over the network


  ideologies:
    < Zaving 67-7 'e preempt and group other e'
    < learn a slep scan to reduce into Cit
      from the in-pile, applying schemas, noticing freaks
      presenting normalisable (into Cit) structure
       the receptive phenomenon
      oscillator application
    < convert to names, replay for testing
    < iframe http://webchat.freenode.net/?channels=location.hash
    < Abodo eg https://www.darkroastedblend.com/2018/11/drb-visual-caffeine-8.html

 # elvising
    #  < talks to JRom of A.4
    #     from inside A.4, brokering async
    #     moves e towards completion
    #  < callback() is able to lose e
    #    set down e, check they complete
    #    plane should throttle, delay e
 #c moreplan
  monday:
    fold markers
    discover new Loc/** per new R:Abodo
     ind revival unlimits pointers
  tuesday:
   style map
  wenesday:
   style %Codes, openable, ʚ
  thursday:
   < G&way,'g'
    chase Error lines
    chase digwaypoll
  frudai:
    born
  saturday:
   takeover width toggle
   Abodis+Codap
  wednesday:
   fixed multi-tunneling: non-first doesnt Display
     because me&ing iterated Rs&z while it unrecycles
      as seen by Lafr/a not e:init-pull,
       f.seek seeing !ms&height
   %Abodo starts (%elvoids?)
    resumes point, unless you give it extra wakes:
     seek waits while ^^%elvoids only
  thursday:
    separate %Codap/%Abodis
    resumes point in last many %Codes per %Codin
     trail/$t%Codin+/$t%Codes squishy log
  friday:
    trail the leaving
  sat:
    cm.focus should pause 4
    style %Code
 monday:
   AutoSave hands cm.on.changes
   moving in
 tuesday:
  load way as wjs
 wed
  right align Codap map
  picking towards Fiveplan:
   me&way looks at %Search, subs
    > several, using their ein() out of time
 th
  JRom_asyncQs allows stumbling at way-ting without throw
   for constant "pause on exceptions"
  Search%Qup() tunnels e:elQup
  Qc&gitmv
  Peace Abodo
 fr
  S+Peace clusters J.*
 sa
  Peace R:+MindInto
  save whenitblurs
  Rom %wantsleep wakes if !b
 mo
  4s&scrolltiming shows Abodo slow
  %reawakens.Peace.bg == not convincing to reawaken ?
  SCA
 tu
  SCA
 wed 
  ! %mindused not spreading to 3s:
   ! 2:Blang s%W not seeing 9%mindused reaw
     something about JRom?
    want %Slope over elvising tests
 thur-thur:
  SCA, de-rewind
 fri:
  everything but wai
 sat:
  adhere, twmt, nodes
 mon:
  brack <- wai
 tu:
  Ying muck
 we:
  CB_*: half of %Paving half shaken out
 th: 
  %Paving conclusioning strategy imagined
 fr:
  %Paving conclusioning strategy
  sprout icon looks better in git gui
  way errors find stack =~ location.host, link script.way
   < G&Ban too? only if not ^^JRom
 sa:
  brack: ancient cruft trimmed
  brackstep, e circuit

 mo:
  %Travel stimulating:
    brackology: group rows
 tu:
  nodeio design
 wed:
  nodeeio begun
 th:
  fix tunnel throw wob, &yfuture in &unpacke
  hoisting %eto
 fr:
  rearrange furniture, forcing self into:
 sa:
  v
 mo:
  $p%onlyish/*%sleeping
 tu:
  ^
  text lab up
 we:
  text lab Glimpes
 thu
  Glimpes -> Textl, for %Cofix
 fri
  Textl minisculity
  Codons again, quick polish:
   chunksfold after huge pastes, folds new stuff
   every odd Codon_click should seek top of it
   Code definitely starting closed, then open
   %seekto should ttl, clear on scroll (untested)
   fengi seems ok now (doesnt init per R%Codap)
    not all R%Codap ever shui to set up R%fengi() -> f.hatch
     they should redirect messages to the future,
      see 'pretty inexplicably complicated'
    mostly by e:sunketh-init@Codap
     at the end of %seekto
 sa:
  Codons still:
   more reliable save on alt-tab
    cm.blur is reliable, EleVisAn ec&type=says|blur
    < in less than 3 travels to %Zaving
   %Code init with e:Code-init@Codap
   %Code new saving ^^%Gens/mem%Zave instant
    < %Zave=W autoaccepting additions,
      distributing diff per thing!
  ghosts %of:w, get Ps&listened
  %JRom%Pring groups Ps to Qup to
   < el=9 are ok
 mo:
  massive hunt for shui sanity:
    f.M ($Abodo/*%ball) height min 9px
  /peek/ - file(s) traversal,
   /peek/j/j/281?line=<3 # indent<3 headings are /ghost/$t
   /peek/j/j/281?line=30-40 # line range
   /peek/j/j/28* # dir listing
 tu:
  of:peek
 wed:
  crashlanding Foogla
 th:
  stream Foogla etc to G/g-j/Foogla
   copy to new git for G,W,serve.pl
 fri:
  edit g-j/*
  get folds working
  stop editor GhodigWap
 mo:
  stylemap vertical space: Codins folding
  help with chicken house
 tu:
  ^
 wed:
  preen Soogle
  cm:
   no 's 0.1' tooltip
   middle click paste ! very strange, tends to not work
     paste leaks a blur,focus, delay to detect it
    

    %Code%Zaving:
      o - overall com dot, clicking in
      (~|-| |!) inside/next to o
      for (wild|got|still|err)
       relationships to their stores/consumers
        probably having one each (G/W)
      < which are G - space for belief
       G store:
         wild - tmp stored (recent keystrokes)
         got - fully stored (available to consumers)
         err - compiletime errors
          may not know args of way
           they could be made up from error messages
       G consumer:
         wild - ghost updating
         got - runtime ok
         err - runtime errors

     < chase 'Kn-burst' error, boosting a medo%fix 
       while Km:Display(Kn:Mw) is there, not zuctedto
       < forward escape &KnowSmush
=cut
#c %Zaving %Codons
me.Zavingness = &acgt{ return [
    # watch the game, sequence pushes
    # by timing/commit policy
    # to these locations
    ['Zaving','294',&acgtRs{
        if (Rs&Gens && !Rs&self) {
            # Gens @25:
            #  rollbs %self
            #Rs&self = G&Cye,[R.t,'',{},{}];
            # Gens+self @31:
            #  Rings %Here = R self)%ball
        }
        # < might get here if reaw
        Rs&Paving and delete Rs&Zaving; return
        isob(Rs&Zaving) and return
        $lo = Rs&Zaving.split(',');
        Rs&Zaving = {};
        each il lo {
            i *= 1;
            $t = R.t +' Zaves '+ l;
            $n =
            n $t  $Zave:l,R

            if (l.length == 3) {
                # tmp%ting%directory = AutoSave/ghost/$t
                $next = lo[i+1];
                next and ns&AutoSave = next
            }
        }
    },'ift,D'],
    # overseeing our data's particular ...
    ['Zaving','67',&acgtRs{
        $allready = 1;
        $allnine = 1;
        each tn Rs&Zaving {
            $h = me&Rsc,n,'Here';
            $t = me&Rsc,n,'Saveting';
            $Q = t && ts&Q;
            $P = Q && Qs&P;
            !P || !Pc&el and allready = 0
            else
            Pc&el != 9 and allnine = 0
        }
        if (Rs&Code) {
            if (!ss&string) {
                if (!allready || !allnine) {
                    # let it arrive
                }
                else {
                    $t = me&tsc,'init-string','+string?','B';
                    me.nto(R,t,&sT{
                        ah(R,'nextlifesc','initCode',1)
                    });
                    Rs&LetGrow = 1;
                }
            }
            ss&string == '# ' && allnine and Rs&LetGrow = 1
        }
        elsif (Rs&Gens) {
            # to reset a %Gens, put %self
            if (allready && !Rs&self) {
                if (allnine) {
                    # init from the out-ball
                    s ||= Rs&other;
                    !isC(s) and throw "Gens init C"
                    Rs&self = Cye([s.t,1]);
                    me&elvis,R,'init-self';
                }
                else {
                    # pull? see %Zave backflip
                }
            }
        }
        if (!allready) {
            # < e preempt and group other e
            #   with a ledger of e to Search
            #me&elvis,R,'tingback',{wake:R,delay:0.3,W:Search};
        }
        if (Rs&LetGrow) {
            # centralised pause 
            $old = me&tsc,'LetGrow-pause','..?','d';
            olds&fs = 16;
        }
    },'ift,D'],
    #c %Zaving 7 - unify autogits
    # see overall com dot
    # lum=
    #  0: disappear
    #  1: sym+%Zave, some modulat
    #  2: everything
    # < parameters?
    #   volume - how much to say about changes
    #   pause - no acting (%Unsure currently?)
    #   rewind - to a point (see %differ switching up)
    #   speed - push while typing, etc
    ['Zaving','7',&acgtRs{
        # displaycase room
        s&dis = 1;
        # for some css craziness, a case has two sides to it
        $g = me&case,5;
        $gp = gy&up;

        $de = gy&can('o','describe');

        $sym = dey&can('c','sym');
        $l = symy&can('i','output','s:o,fs:22');

        $gi = gy&can('c','gits');
        $allope = 0;
        each tn Rs&Zaving {
            $na = ns&Zavingna = giy&can('c','git-'+t);
            nas&dis = 1;
            me&zuct,na,n;
            ns&waits and allope = 1
        }
        # < amb wake waits until settled
        #    delay/drum machine
        # < e preempt and group other e
        #    the waits might log to e already
        #    invalidated by eg e:tingback
        #allope and me&elvis,R,'waitsing',{wake:R,delay:2};
        # lum=2 - leave cases open
        allope ||= ls&ope
        allope ||= Rs&allope
        allope and return gps&dis = 1
        # lum=0 - nothing
        $allzen = 1;
        each tn Rs&Zaving {
            ns&wants || ns&summary and allzen = 0
        }
        if (1 && allzen) {
            each tn Rs&Zaving {
                ns&noDisplay = 1
            }
            return
        }
        # lum=1 - somewhat: minidmo + wants
        each tn Rs&Zaving {
            $na = ns&Zavingna;
            # should look at patch
            ns&wants && ns&Unsure and continue
            # wants to look at patch (click summary)
            me&rollbs,R,'Lookat_'+t and continue
            #me.nto(R,na,&{ R.sc['Lookat_'+t] = 1 });

            ns&noDisplay = 1;
            # have a tiny id
            each im ns&minidmo {
                delete ms&dis;
                fio(na,m)
            }
            $su = ns&summary;
            su and fio(na,su); sus&fs = 7; sus&lh = 0.3;
            each im ns&wants {
                !su and throw "wants !summary"
                fio(na,m)
            }
        }

    },'ift,D'],
    #c %Zave - saving thing tricks!!!
    # aft %Gens 25:
    # %Zaves collect
    ['Zave','291',&acgtRs{
        $p = Ry&up;
        ah(p,'Zaving',Rs&Zave,R)

        $ting = Rs&Saveting ||=
            n $p.t  $ting:Rs&Zave,R
        
        $dand = &s{
            tings&directory ||= '';
            tings&directory = s+'/'+tings&directory;
        };
        $dir = ps&directory;
        if (dir) {
            if (isC(dir)) {
                # realises into directorie
                $est = dirs&directorie;
                ps&directorie = (est?est+'/':'') + dir.t
            }
            else {
                ps&directorie = dir;
            }
            dand(ps&directorie);
        }
        if (Rs&AutoSave) {
            dand("AutoSave");
        }

    },'ift,D'],
    # %Zave <-> %Save completes
    ['Zave','32',&acgtRs{
        $p = Ry&up;
        if (ps&Gens) {
            # %Here = s%string)%ball
            # Gens @25 rolls %self,
            # Gens+self @31 makes %Here
            $h = Rs&Here = me&Rsc,p,'Here';
            if (me&rollbs,R,'Describing' ) {
                !h and return me&waits,'!h@32'
                !hs&ball and throw "h!ball"
                hs&string = me&ballLines,h,hc&s
            }
        }
        elsif (ps&Code) {
            # %Here = %ball(s%string
            Rs&Here = pc&s;
            me&rollbs,R,'Describing' and 'conjoin'
        }
    },'ift,D'],

    # also these tiny details
    &{
    # filed under se%Codin: G/$se/$t
    me.ghost_section = &acgtR{
        $din = me.cbu(R,'Codin');
        din ||= me.cbu(R,'Section');
        return din && din.t
    }
    },
    ['Zave','292',&acgtRs{
        $p = Ry&up;
        $ting = me&Rsc,R,'Saveting';

        if (Rs&Zave == 'ghost') {
            $se = me&ghost_section,R;
            !se and delete Rs&Zave; return me&waits,'no^^%Codin'
            tings&section = se;
            # fixes !section on initCode commit
            $Q = tings&Q;
            Q and Qs&section = se;
            # also needed on commit!?
        }

        # they cache each other
        me&ollbs,R,'Settled' and return
        Rs&AutoSave and return
        each tn ps&Zaving {
            R == n and continue
            # < this climb should be a couple of sc
            $tting = me&Rsc,n,'Saveting';
            $tQ = tting && ttings&Q;
            # sync %ting can happen
            if (!tQ && tting) {
                ns&AutoSave and me&Ring,R,{und:tting,ov:314}
                else {
                    # past would do
                    tQ = me&ollbs,tting,'Q';
                }
            }
            $tQ = tting && ttings&Q;
            tting && !tQ and me&tsc,"tmp!Q"
            $tP = tQ && tQs&P;
            if (tP && tPs&dige) {
                !tPs&string and throw "dige but not string"
                ah(R,'havediges',tPs&dige,tPs&string)
            }
        }
        Rs&havediges and tings&havediges = Rs&havediges
    },'ift,D'],
    #c Zave autogit
    # and git harness for %Code or %Gens
    # late so %Saveting for %Gens happens
    #  tmp should be ready, ghost will have sent
    #   unless its storage/place is local
    #    within this javascript runtime/elvisability
    #     /insideness
    #    which may have time to process the request
    &{
        # hard pull There -> mem & reset
        #  must be in a handler or so to:
        #   try to wake after this, but reset
        # on C+click of the < (to-local) symbol
        me.Zaving_haul = &acgtn{
            !ns&Zave and debugger
            $Z = ny&up
            Z = me&yfuture,Z
            # Z must be real|awake, see SupelaRealier etc
            Z = Zs&laReal || Z
            $ing = Zs&Zaving
            !ing and debugger
            $mem = ing.mem
            ns&Zave != 'W' and debugger
            !mem || mems&Zave != 'mem' and debugger
            $There = ns&Saveting
            $Q = Theres&Q
            $P = Qs&P
            !Ps&string and debugger
            mems&AutoSave(Ps&string)
            # and reset
            $JRom = me&yfuture,me.cbu(n,'JRom')
            JRoms&reset = 1
            ~>7 hauled: Z.t, "mem<-W"
        }
    },
    ['Zave','68',&acgtRs{
        # chop up a displaycase
        s&dis = 1;
        me&rollbs,R,'Described,Committing,Whichto,Unsure';
        $g = me&case,2;
        $gu = gy&up;
        gus&dis = 2;
        # can do:!
        #gy&can('ope',&{ while_open() });

        $gi = gy&can('c','git','fs:17');

        $de = gy&can('c','describe');

        $sym = dey&can('c','sym');
        # hoisted by Zaving lum=1
        ac(R,'minidmo',sym);
        ac(R,'minidmo',me&tsc,Cye(['Zave','',{s:Rs&Zave}]),0,'G' );

        # big < and/or > symbols
        $l = symy&can('n','local');
        $r = symy&can('n','remote');
        ly&label = me&mtsc,l,'local','◀','B';
        ry&label = me&mtsc,r,'remote','▶','B';
        [l,r].map(&s{ s = sy&label; ss&lh = 0.5 });



        # settings after logic may change them
        $and_finally = &{
            # we have eg to,from = l,r
            #  where 'pull' == (Rs&Wantsto || Rs&Whichto)
            # <> control/show flow
            #  extra clicking makes Unsure
            #   and could open the git log etc
            if (!Rs&Whichto || (Rs&Wantsto && Rs&Amountto < 2)) {
                # <> flop direction of the patch
                $Wantingto = &se{
                    if (s == 'pull' && e.t == 'C+click') {
                        # hard pull There -> mem & reset
                        return me&Zaving_haul,R
                    }
                    Rs&Wantsto == s and return Rs&Unsure = 1
                    Rs&Wantsto = s
                };
                me.nto(R,l,&sTe{ Wantingto('pull',e) });
                me.nto(R,r,&sTe{ Wantingto('push',e) });
            }
            else {
                # single < once pulled
                froms&dis = 0;
                # tampering with < makes Unsure
                me.nto(R,to,&s{ Rs&Unsure = 1 });
            }

            if (Rs&Whichto) {
                # direction it was going
                $was = Rs&Whichto == 'pull' ? l : r;
                wass&bri = 1.7
            }

            if (Rs&Unsure) {
                # resume autopush, various causes
                $un = me&mtsc,sym,'Unsure-re-autogit','i'
                me.nto(R,un,&s{ Rs&Unsure = 0; });
            }
        };

        $en = gy&can('c','enter');

        $re = eny&can('c','remote');
        Rs&waits_modopt = re;
        me&walls,re,'b:2.2h866';
        res&bgh = '010';
        
        # where the patch etc may live
        $co = guy&can('w','commit');
        #cos&dis = 1;
        
        # and then put this situation in it
        $p = Ry&up;
        $h = me&Rsc,R,'Here';
        h ||= me&Rsc,p,'Here';
        $t = me&Rsc,R,'Saveting';
        !t and return me&waits,"Z!ting"
        me&zuct,re,t

        $Q = ts&Q;
        $P = Q && Qs&P;
        !P and return Rc&b && me&waits,"Z!P"
        !Pc&el and return me&waits,"Z!Pel"

        # now on to entering it
        Rs&waits_modopt = en;
        #c timing

        # neighbours - help save time/space
        $neighbours = [];
        each in ps&Zaving {
            R != n and neighbours.push(n)
        }

        # particular types, when & how to git them
        if (ps&Code) {
            # hs&string is always
            $pull = &{ hs&string = Ps&string };
            $ot = hy&renamed_from;
            ot and Qc&gitmv = ot
            Qc&gitmv && Rs&Settled and delete Qc&gitmv; delete hy&renamed_from;
        }
        elsif (ps&Gens) {
            $pull = &{
                # to reset a %Gens, put %self
                # see Gens+ting @31
                $s = ps&self = me&Copy,R,Pc&s .c.s;
                sy&Pfrom = P;
                Rs&Describing = 1;
            };
            $old = me&mtsc,sym,'Describe','🔁','d';
            olds&fs = 16;
            
            if (!h && !ps&self && Rs&waits) {
                # %Gens!%self backflip, when waits:!h@32
                # after throw, rolling %Describing?
                # < shouldn't lose %self but somehow does
                $igwaits = 1
                delete Rs&Described;
            }

            if (!Rs&Described) {
                # borrow
                neighbours.map(&r{
                    !rs&Described and return
                    Rs&Described = rs&Described;
                });
            }
            if (h) {
                if (!Rs&Described && !Rs&Describing) {
                    if (ps&Gens && !hc&b) {
                        # init picture from %Gens's ting string
                        # so heads can be compared
                        $s = ps&self;
                        $P = sy&Pfrom;
                        ps&stringguess = P && Ps&string;
                    }
                    if (!ps&stringguess) {
                        oldc&s = '...';
                        old.t += '-awaits';
                        olds&hs = 555;
                        me.nto(R,old,&{ Rs&Describing = 1 });
                        # Code want their Codin saved
                        ac(p,'onceinhabited',&{ Rs&Describing = 1 });
                        gs&fs = 7;
                        # can't think until got
                        return;
                    }
                }
                if (Rs&Describing || ps&stringguess) {
                    !h and debugger
                    delete Rs&Describing;
                    # keep a false %Here
                    $De = Cye(h);
                    # < never happens?
                    ps&stringguess and ~stringguess: R.t
                    ps&stringguess and Des&string = ps&stringguess
                    Des&now = Gtime();
                    Rs&Described = De;
                    Dey&Zave = R;
                    !Des&string and debugger
                }
            }
            $De = Rs&Described;
            if (De) {
                # the DZ = Dey&Zave = R that made De
                Dey&Zave and Dey&Zave = me&yfuture,Dey&Zave
                $DZ = Dey&Zave || R;
                # not transaction safe:
                #  current R for a permanence should be set via X
                Rc&N.indexOf(DZ) < 0 and DZ = R
                # keep borrowing new De from DZ
                De != DZs&Described and De = Rs&Described = DZs&Described
                # we trust the (earlier) neighbour to calc time
                # then they will look equal
                DZ == R and DZs&age = Gtime(Des&now)
                if (DZs&age > 0) {
                    me&mtsc,old,'howold',DZs&age+'s' .sc.fs = 5
                }
                $refresh = &{
                    h && !hs&nonDescribable and me&elvis,p,'reDescribing';
                    DZs&Describing = 1;
                };
                # can be clicked
                me.nto(R,old,refresh);
                # lights up when done
                De != me&ollbs,R,'Described' and olds&bri = 1.7
                # do when old
                DZ == R && DZs&age > 20 and refresh()
                # < when slep/ball/etc wants to
            }
            Rs&Zave == 'W' and Rs&Unsure = 1
        }
        #c look
        $De = Rs&Described || h;
        if (!De) {
            if (!Rs&Here && ps&Gens && !ps&self) {
                Rs&Wantsto = 'pull';
                Rs&Amountto ||= 2;
            }
            else {
                return me&waits,"Z!h"
            }
        }
        if (De) {
            # into time/desire for
            me&rollbs,R,'Settled,Wantsto';
        }

        # wait for changing situation
        $action = neighbours.filter(n =>
            ns&Wantsto == 'pull' && ns&Amountto > 1
        ).length;
        action and return

        if (De) {

        if (!ps&Code) {
            # Code may be Here without string
            Des&string == null and return me&waits,"De!string",0,'B'
        }

        ly&tree = De;
        ry&tree = P;

        # faulter the autocommit
        Rs&Settled != Ps&dige and delete Rs&Settled

        # centralised pause
        ps&LetGrow and return gs&fs = 7

        # init kinda thing
        if (Des&string == null && Ps&string != null) {
            !ps&Code and throw "init pull !Code"
            hs&string = Ps&string;
            me&elvis,R,'auto-pull',{wake:p};
            Rs&Whichto = 'pull';
        }

        # notice situation
        $Settle = &{
            Rs&Settled = Ps&dige;
            delete Rs&Wantsto;
            delete Rs&Amountto;
            Rs&Whichto ||= 'pull';
            if (Rs&Committing) {
                delete Rs&Committing;
                me&mtsc,en,'made-commit',"pushed",'B';
                Rs&Whichto = 'push';
                me&elvis,R,"pushed",{wake:R,delay:0.4};
            }
        };
        # De may change since push
        Rs&Committing && Rs&Committing == Ps&string && Settle()
        # and separately:
        De && Des&string == Ps&string and Settle()
        else {
            if (Rs&Settled || Qc&el == 9) {
                # we sync, they follow
                Rs&Amountto ||= 2;
                Rs&Wantsto ||= 'push';
            }
            else {
                # start different or their updates
                Rs&Amountto = 1;
                $someSettled = neighbours.filter(n => ns&Settled).length;
                someSettled and Rs&Wantsto ||= 'push';
                Rs&Wantsto ||= 'pull';
            }
        }

        if (Rs&Wantsto) {
            Rs&Amountto ||= 1
            Rs&Unsure and Rs&Amountto = 1
        }
        $reallyWantsto = me&ollbs,R,"reallyWantsto"
        if (reallyWantsto) {
            # from @Gome etc
            Rs&Wantsto = reallyWantsto
            Rs&Amountto = 2
        }

        }

        $goingto = Rs&Wantsto || Rs&Whichto;
        $redirection = goingto != Rs&Whichto;
        $to = goingto == 'pull' ? l : r;
        $from = to == l ? r : l;
        #c patch
        Rs&Wantsto == 'pull' && Ps&string == null and delete Rs&Wantsto
        if (Rs&Wantsto) {
            Rs&Amountto ||= 1;

            tos&sha = '3 3 3 777';

            # < patch chunk pluck
            # < commit with message, put somewhere
            #   and other ways to convene to key states
            $pa = coy&can('w','patch','fs:14');
            cos&dis = 1;
            me&walls,pa,'b:2.2h666';
            pas&bgh = '010';
            pas&zi = 30;


            if (Ps&string == null) {
                # < Zif could say new
                Rs&summary = me&tsc,'summary','new!','B'
            }
            elsif (De) {
                # < attention upgrades to JRom
                $c = {t:'Zif',Zif:1,neighbours};
                c.got = fromy&tree;
                c.exp = toy&tree;
                $di = me&Ret,R,c;
                me&zN,di;
                me&Ring,di,{und:di,ov:314};
                me&zuct,pa,di;
                each in dis&waits {
                    ac(R,'waits',n)
                }
                Rs&summary = dis&summary;
            }
        }
        
        #c %Zave%commit
        $commit = &{
            # wakes this
            me&elvis,R,Rs&Wantsto,{wake:p};
            if (Rs&Wantsto == 'pull') {
                # depends on the thing
                pull();
                Rs&Whichto = 'pull';
            }
            else {
                # awaits ack
                Rs&Committing and mac&s += '..'; return
                Ps&string == null && Qc&el != '9' and return me&waits,'!ready'
                !Des&string and return me&waits,'!string'
                if (Dey&from_initCode) {
                    delete Dey&from_initCode;
                    # wake $Codin on new $Codin/$Code commit
                    # < subtrees, so Search @$Codin finds $Code
                    $r = me.cbu(R,'Gens');
                    !r and ~>7 from_initCode !Gens: p.t
                    else {
                        $cb = &{
                            r = me&yfuture,r
                            # ! for some reason it doesn't have %Zaving
                            rs&tunneling and r = rc&b;
                            # < the e should take parameters to apply with
                            each tn rs&Zaving {
                                ns&Describing = 1;
                            }
                            ~>7 ...initCode: r.t
                            me&elvis,R,'1up',{wake:r}
                        };
                        G&yl,600,cb
                    }
                }
                if (Rs&Zave == 'ghost') {
                    $se = me&ghost_section,R;
                    !se and throw "ghost!section"
                    Qs&section = se
                }
                
                commit_ting();
            }
        };
        $commit_ting = &{
            Rs&Committing = Qs&string = Des&string;
            ts&_ting(Q,R)
        };
        Rs&AutoSave and Rs&AutoSave = &s{ Des&string = s; commit_ting() }
        
        if (Rs&Wantsto) {
            $says = Rs&Wantsto;
            $ma = me&mtsc,en,'make-commit',says,'B';

            Rs&waits && !igwaits and '...'
            else
            if (Rs&Amountto == 1) {
                # clickable talk
                mac&s += "?";
                #!di and throw "no %Zif @ Amountto=1"
                # hoisted by Zaving 7 lum=1
                # shall be given nto that lum=2s it
                # keeps nto that commits
                ac(R,'wants',ma);
                me.nto(R,ma,&sT{
                    commit();
                    # wakes %ball%Code%Zaving
                    #  and innards (R%Zave)
                    ~>6 waking: p.t
                    T.wake = p;
                });
            }
            else {
                commit();
            }
        }
        else {
            #Rs&Zave == 'tmp' && !me&ollbs,R,'crushed' and Rs&crushed = me&mtsc,en,'!crush'
        }
        and_finally();
    },'ift,D'],
    #c Zif
    ['Zif','3',&acgtRs{
        s&ws = 'pre';
        s&fs = 7;
        s&wb = 'break-word';
        s&ma = 0.2;
        s&pa = 0.3;
        s&lh = 1;

        $g = Rs&got;
        $x = Rs&exp;
        gs&string == null and return me&waits,'g!string'
        xs&string == null and return me&waits,'x!string'

        $ob =
        n $R.t 13 s:~ %fs:29,lh:0.1
        gs&string == xs&string and return obc&s = '=='
        Rs&boost < 0 and return

        me&rollbs,R,'Digs,Diff,CompN,Comp';
        # < view entirety
        # < switch chunk: word/line
        $c = {chunk:'word',fold:1};
        Rs&stickline and c.stickline = 1
        $digs = dig(xs&string||'')+dig(gs&string||'')+dig(ki(c));
        Rs&Digs != digs and delete Rs&Diff; 
        Rs&Digs = digs;
        each in Rs&neighbours {
            $z = me&ioty,n,'Zif'
                .filter(z => zs&Digs == Rs&Digs)[0];
            if (z) {
                $su = zs&summary;
                n $su
                me&tsc,'as-bove',"♲"+ns&Zave,'G' .sc.fs = 20
                # < put dupe R with Mlimits,
                #   to simple api for others, eg:
                # %Zaving 7 expects this if %wants
                Rs&summary = su;
                # < behaviour melts away with lum
                #   or any customising the patch
                #   like cell division of the %Zifs
                #   becoming for particular targets
                return
            }
        }

        $N = Rs&Diff ||= diff(xs&string||'',gs&string||'',c);

        # CompN - sum noise!
        (Rs&boost||0) > 0 and delete Rs&Comp;
        Rs&CompN != N and delete Rs&Comp;
        if (!Rs&Comp) {
            Rs&Comp = me&textdiffN,N,c;
            Rs&CompN = N;
        }
        me&diffproximate,R;
        $su = Rs&summary =
        n summary  
        sus&z = delete Rs&Mw.diffproximate;


        $p =
        n patch   %mh:33,mw:55,over,dis,pa:0.3
        ps&z = [...Rs&Comp];
    },'ift,D'],
#c Zavmo - exercise in surfing modulata
    ['Zavmo','3',&acgtRs{
        Rs&rowish = 1;
        $p = Ry&up;
        if (!ps&Zavmo || Rs&Zavmo > 1) {
            Rs&Zavmo > 1 and me&walla,'bd:3.1h5,hu-7';
            Rs&Zatop = [];
            #s&fs = 12;
            Rs&zoom = 4;
            if (!Rc&b) {
                # start tiny unless problematic
                # action awakens to usual degree
            }
            ps&zuctzto and me&zuct,ps&zuctzto,R
            # controls
            $g = me&case,5;

            $de = gy&can('o','describe');

            $l = dey&can('i','local','s:o,fs:12');

            $l = gy&can('m','rolls');
            ls&ope and Rs&opecsc = 1;

        }
        ac(R,'inheritsc','zoom');
        ac(R,'inheritsc','opecsc');
        Rs&zoom ||= 0;
        Rs&boost and Rs&zoom += Rs&boost;
        Rs&zoom -= 0.5;
        $stop;
        Rs&zoom < 0 and stop = 1
        Rs&boost < 0 and stop = 1
        #Rs&zoom < 2 and Rs&opecsc = 0;
        Rs&opecsc ||= 0;
        Rs&opecsc -= 0.5;
        Rs&opecsc < 0 and Rs&opecsc = 0

        (Rs&boost||0) > 0 and Rs&Zatop = []
        $op = me.cbu(R,'Zatop');
        ac(op,'Zatop',R);
        ops&Zatop.length > 22 and stop = 'Zatop-many'

        $g = me&case,5;
        $co = gy&can('c','coordinate');

        # t/y
        Rs&via and me&mtsc,co,'via',Rs&via,'6';

        me&mtsc,co,'t',s.t,'T';
        sy&cv && sy&cv != 0.1 and me&mtsc,co,'cv',sy&cv,'y';
        $scan = Rs&scan = me&scan,s;
        scan.is == 'R' and Rs&isR = 1
        if (scan.is != 'C') {
            $sym = me&mtsc,co,'sym','fs:15,ls:-0.1,zi:-1,hs:4955';
            symc&s = scan.is;
            symy&cv = 0.12;
        }

        # c/sc

        $ca = g;
        # gy&can('c','knowables');
        # unblocks R)%fix
        $Za = cay&can('i','%');
        Zas&ope and Rs&opecsc += 1
        if (Rs&opecsc > 0 && (!Rs&isR || Zas&ope)) {
            me&fixatfour,R,s;
            Rs&Fixturing = ca;
        }

        $cb = ops&Zavmiddle;
        cb and cb(op,R,s,g)
        Rs&stop and stop = Rs&stop

        me&endome,R;
        # & more

        if (Rs&isR) {
            ss&Zavmo and return me&tsc,'loopback','❮','B' .sc.lh = 0.5;
            # look at modulat inners
            each tin ss&Mw {
                $z =
                n $n.t  $s:n %R:Zavmo
                zs&via = "Mw:"+t
            }}
            each tn ss&M {
                $z =
                n $n.t  $s:n %R:Zavmo
                zs&via = "M"
            }
            return
        }
        else {
            each in ss&z {
                n $n.t  $s:n %R:Zavmo
            }
        }
        if (stop && T.nN.length) {
            T.nN = [];
            me&tsc,'zoom-in','❩','B' .sc.lh = 0.5;
        }

    },'ift,D'],
    ['Fixturing','31',&acgtRs{
        me&bewind,R and return
        $ca = Rs&Fixturing;
        $Za = cay&can('i','m');

        me&Knowfix,R,{ca:ca};

        # debug
        Zas&ope &&
            n ZavKnow  $s:ca,R %Zavmo:2,Zavspin

    },'ift,D'],
    ['Zuctto','4',&acgtRs{
        me&zuct,Rs&Zuctto,R
    },'ift,D'],

] };


#c monday?
=beyondo
 //figures:
    %Codon%Code the contained way
    < concat fragments from %Code/*%Code
     < inside way are hash-c markers, etc
       see cm doc.markText
        so %Code might not have %string,
         once burst into many somethings
     < reordering folded I
     < send patches, of lines & their ranges
        new similar to gone = move
        sub-diff with move abstracted
        # waits for serve.js?
    
    %Gens starts from out%ball to have in%ball
     < %ino for in feeds out sans s&z
        is a qua muter situation, as is:
         %Lines encoding customs
         %slep deciding where to crawl
         %Te accepting as 'the story'
     < ghost/wormhole happens when in appears
     < %slep for changes, helps %Lines

    room for a tool for composing %slep schema
     < wants to use Zavmo for slep on modulata
     < a wand shedding glow
       pointing for KnowC
       which should be from /W/
       see time above

    slep wanting to be there for most piles
     generating a change awareness (wai)
      we can otherwise effect
       to drive change from/to A something

  thence
    T - phenomenate when going to an aboveness that may not be awake
    G - intelligensiata
    the whole vs. a part
    new git repo, just /G/ and /W/
      ignore, slowly import /wormhole/

  new server
  # generated by `./spot.pl StyleAgent`
  # run `./serve.pl`
    /way/ - compiled code
      sees /G/$se/$way
    /ghost/ - source code
      for /G/$se/$way
      API like /W/
      maintains dige in wormhole/digway/$way
      notifies /digwaypoll/
       < wait 3ms to scoop any batched changes?
        < they come through one %Sock frame
    /digwaypoll/ - code change socket
      watching wormhole/digway/$way

    /W/
      futuristics

    /js/ GONE temporarily?
      needs Beach, etc.
      just host /js/Hunt.js
      comes back when $W has .js file?
=cut

