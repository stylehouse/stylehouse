# discussion
$me = 4c&me;
!me and throw "no me";
$io = me.io;
me.iooia = &{
    # reuse this {}, lexical over 28*
    haks(io).map(k => delete io[k]);
    $newio = G&way,'iooia',{io,io}
    me&ioconfig;
};
me.ioconfig = &{
    io.properz = 1;
    io.iz = 1;
    io.doz = 1;
    io.usu_dup = &{};
}
me&ioconfig;
G&waylay,'NutGravy';

#c spec-ish
=pod
o general Passness
  %Citying etc does s&lv=1:
    converts Display to C and attaches/Lines it
      so %ball%Lines can stop/conjoin at y&lv
  %ball+%whatwewant:
    %www copies to children
      thing type believers should roll around
        wash truth-presentation deception in 4d
    darkening (to s&J/s&H, or s&testrun)
     should be presented as such,
      overcome by Tes&boost before it becomes Rs&boost
  %Cit:
   # high level:
   atomisation of symbols that could accept styles
    and be plucked into a scheme for automating etc.
     teaching it new classifications
      deriving code from pointers in other language
   # nowgrunge:
   %Citop starts a capsule of %Cits, R.t!='Cit' makes title
    for s, anyone looking at anything stuff
    Tes&boost+- open/close
     < more A/R/other understandings
    Tes&play to config in W:Das, turn into City%doing:
      c&s selected by c&points (usu previous %doings Wout)
      s&z is the elvising/config to %TeImplant
  %run:
   %pushes %steps (via TeCo) to $Co
   < making a refpool for (%Cit)
    < Mlimits path talk: '%step:2.3' should do for same thing/place
     < hoist ha somewhere clearer, City?
    < have one %differ doing a lot of the work:
  
  %differ:ance machine
       a %run branch merging %step branches,
       %step branches merging %doing branches,
       %doing branches continuing from their last self
        sounds like an lv receiver
        and $W/$H storage format hierarchy mode
       and describing the HEAD as $W, $T, $G
        the overmind/repool for %Cit as $suchR
         we want Wdiff, shouts politics
      cascading acceptance of the same diff
      
   %differ be a source to models
     such as Lis, AndContinue,
       anything pile sorting stuff that takes anything
       and presents it as anything, allowing anything
     to hold state against the constituent parts,
      and put them in an order/projection of hierarchy
       as A:s is going to seem once A=R
        < give you the iterator+function to do it yourself
          as in through the wormhole
       
   < branch a good/bad ghost when things dont work
     to increase lighting to differ
     < being able to diff all the way through to the B-stack
       when stuff at the edge keeps changing (391dcb93bb3)
       < it might also like to be ignored
    the tests are shaped like arrows then,
     that grow and shrink as trust permits
     
  $Co:
   gets %main/(%step/%doing+) from %run, n $doing
    < know how to get ahead of %run without breaking:
      while exp exactly got, clone next step, while in doN
      AND time-in < 5seconds, or half an A.4 frame...
        much > 90% cpu causes most of the heat
      < Co could happen in a Worker,
       < if %ball/%Cit can transport vision of its insides
         was doing similar in Karamea, 2017
         %slan-guts networked to the representation unit
    < want s&lv for the %doing
    < %main-centric elvisory implant,
      so tested W can be Te~d separately,
      but so we can engage them
    < properer $main=A.4
      that describes async story (AndContinues)
      (a&z was it?)
   
  %Cit across time &space:
   expect noise around the actual thing
    present change out of the essential scope of the check as such
     a %differ thing
    put notes in test data
     < compile ugly from that
  %testrun, attach to whatever we %play->%run
    implies ./%steps/%doings
      < ways to break from %doings,
        more result crunching in this/another A
        basically as W:City, does Cit + TeImplant
      
#c goalism
o test gonerism (XV)
  'fixed' error in %push:
      between R:I and R:*, R:C wasnt using arriveRbitX etc
      was:
       state falls apart too easily after error:
        %ball%pushed has to give them %their every time
        %push%moves also,
       are hanging on me&rollbs, which depends on b
        apparently bogus
       cant be pushed back together with the other side because:
        push%move after the fall ends up Co inside Co
          not knowing about the Co/$Redo thing
          is a setup for the %testrun:
            A.5erver (Co) gives you a fresh A.4 ($Redo),
              which you push steps to
            could be clearer than:
             %move,from:Co,to:T,into
             %move,from:Co,to:Co *
          TeCo could express such strategy,
            besides what is to be.
      Remember to avoid that next rebuild.
   
o test sleepology
  with extra %ools for Pass to:
    be on Rc&Tool all y&up
      and 4s&Tool
        < negotiate/nest if existant
        importo: get Rc&Tool in to every A.1/osc
          to check vitals (R0c&ha)
      < accum messages so,
       lookup up A for a handler,
        linking B
    rec/play elvising:
      < at the [click=>{path...}] level
        or nearabouts, we could get started...
         the Tool %aTool
      however:
      T:nab picks T/$bit to PuTe%doing before (picks) %doing
        < braiding it in as you elvis $main/A.4
    < rolling change accepting
       from one %doing to later %doings,
        or W reoccurring, versions of versions...
       half accepting chunks
         even if the patch must be rearranged a bit
       from/for here.diff or their.diff
       as they are capturing state as it builds up,
        then playing it back destructively
    dump/stash configurations of %Cit
      as %doings for W:PuTe + W:Lookat etc
    < Tool doings at times injected to... (Ting)
      see also 'R looks at R', and the crazy names
        given to top-down instruction
    < diff of C switching places could look better
        tracing it somewhere, new + gone = move stuff

o test tests (%play wanders %testrun)

o test Pass itself (recurse another? later)
 o then Ring could try for more ordered order (by t cv or Rs&ci)
  o also wants T.Z back, lurk-until, do others (T.wide)
    there is a lexical ov in Ring, yadda.
    things stuck or behind prioritise

=head1 #voidable bugs  #c laterthisweek

the editor
  keeps injecting the difference when you move a chunk marker
    remove, save, add back in to new place works
  freezes if you click+drag off the left

the %kvstore %furthering into ting W/ doesnt settle

io not doing a bunch more of the expression
 < do $s%ball/%ball
 < know to Rsync after messing with?
would take care of me&ioty and me&input

=head1 #I

(see Give)
for recompiling everything,
 G&t gets it from A*%believed
that may be part of or leading to elvising,
  the hyper-everything trans-anyway maculata
    (see head1 Elvising)
 which lives in the same form:
 <Source> /Transform|Select\ <Output>
any of that may need to live somewhere,
for independent intelliglance:
 CodeChange
   To
     Experie
       $Doleux # the -e below, put for destination
   For
     Vang # W from here to grabber
       Doleux -e
         %here: Doleux # version of grabbed thing
         %etc: whathaveyou
then Vang relives that %push
and Experie knows its got stuff incoming
  which it might already have pulled in,
    (it must also disconnect)
  or is able to pull in with/without Vang being awake

=head1 push

is near simplifying
  G/W rebuild would realise calmable push boundaries
 and how hard the codon was entered
 and an overmind to wander around %tests

=head1 Cnetobjet

all %H within should gather atop
  garbage collection
    the wandery overmind
rebuild this editor as a picture museum

 a juice - bioavailability of A prog C
 grab moment S, giving some kind of housing
 lexicals hang around,
 -the end- of computer science
 scene collapses into bubble
 try to get back to some kind of housing
 security is being stuck on the outside of some jeweled cavity
 
 once done a bunch of something, you can look at them.
 as gravity.

#c=head1 A=A and the Give

merge R into A.
A is R, throat is Ring, sooner of things
  throat - where Instructions iterate over Culture
# here we do the entire Ceeing instantly to the enclosing timeframe
(taking pictures of state that is about to change)
in general, knowing if the A is for a queue or for right now
 + the usual about how queues crud around
patching time... all Cnetobj
 it will look like itself, except for where it ruptures/grows

=head1 Srupto
we want to allow pin Steps to be Instructions
  a way to grab anything at any rhythm

the baseline C->osc mode may encode Instructions:
 Cont
   thinger 3 s:'s&er++' %of:Lat
becomes:
 Cont   %W
   Lat  W:of %W
     thinger 3 s:'C.c.er++'
then:
 Cont transports
 Lat is I stuff (%W with %z), posited as being Lat
 thinger is encoded (Latc&W:of)
such that it is mostly ready for action:
A.3+ believes in Cont%W
A.1 somewhere wants Lat
    (or thinger, knowing things like Lat might contain it)
 by elvising G/$pathtoA1/Lat,
  finding/choosing a Lat,
  which must 6 the whole of what it bit
    (W around might be only indexing of what can be got)
do-ing
then that elvising attaches to A.1/G/Lat/Cont
 which A.3 hoists/attaches/encodes/stores as some of:
   A.3/G/Cont # no idea wherefor but small edge
     # does updates for change at the large-object level
   A.3/G/Cont/$pathtoA1 # know where to send attention
     # andor where in the stream of Cont the change is!
   A.3/$pathtoA1/G/Lat/Cont # Q/A format per place
     # lends itself to network change sensitively
 easily all at once
 hyperspheres of definition named simply
and store perhaps on the first line of the W in Lines:
 AyeOne   %W,G:Cont@238hfd34;Normal@49d8c9ff
   Stuff   %produced
and something incorporating Cont and more looks like:
 AyeOne   %W,G:Cont@238hfd34;Normal@49d8c9ff
   Cont   %W
   Lat  W:of %W
     thinger 3 s:'C.c.er++'
     thingo 3 s:'C.c.o++'
   thingo 3 s:'s&er++' %of:Lat

 when thinger blows up, inspected:
    thinging from AyeOne%W/Lat%Wz/thinger
    and as asking around about random things:
    find AyeOne%W/Cont%W (aka Cont%W) also has Lat/thinger
    things may be asleep about here,
    but may be able to show source code, compile/mutate it

looking at the G would be lots of io-ing
  things packed into it
  checking those injection/projection points
  is RbitX extension for named/quantified indexes
    for hoisting things together cleverly,
      applying sleep to osc individuals
      supposing the transform has copious amounts of io
  relying on percolating those things
    along things that we can relive
   or shut down, rearrange, tamper with
  as osc-compatible:
   various $Gish of $Wish may be attached to $Wish
     so long as osc understands what/how to involve/mixage
   even outside itself on $Woth/$pathtoWish/$Gish
    just as $Teing is an index of landstructions to go here
    we have the chance to take with us or trust to recreation anything
    
   they are understood by the I, made meaningful where $Wish is
  and hoist/dehoist its structures into other places
    with others doing the same thing
  and also just the giant tabulation

#c ph (post R re-combobulation)
osc does new A:I over the old one
  probably rolling everything
 A:C make separations of a thing or things
  lets its content be distributed and depended on
  pattern matched and made into elvisings out to W:of,
  putting into a further self

so C may need separation to preserve various objectives:
 A:n C being the most-uphill thing
 A:C = C coming in
 A:s = C for doming/playing sc forward
 A:C = C going out
 A:W = C encoding/compressing
they all have ways to know about their previous lives

another life of the underlying shape:
A - receivability
C - received culture
G - culture + momentum, implantations
T - what could not fit in,
  its mysteries/problems/developments,
  its inclusion to/from the world
    to as in for Teing into some W-position,
    from as in its life was because of such insTruction
  the T is like the G
    dealing with a big tangle of comings & goings
the T decides/dealswith the edge of the picture,
by hoisting/making the content misfiture,
  such that a big C can have its anomalies adjusted

the layer above io, provides mode ala c&el
  io needs to readwrite A&X/A&V/A&Xo
    to provide the memory of the current play
    in parallel to the previous one,
      noticing when C views should complete (gonerism)
diversifying how to match $thing against $Thing,
  what we are looking for,
  what level of understanding to borrow what from
yet producing that sc-lang about how it was written:
  Some%sounds = {index of direction to points of resonance}
there could be:
  Cs making the structure of any kind of index
  direction Cs, coming from/with merge/over/with/etc
  resonating Cs, beings in a constellation unknown to themselves

A:s would be driving towards a goal
 juggling dives in, points and progress
   of expanding/shrinking pools in the pool
      and filling itself in for working through time
      once inflated...
 compiles fast checkers of 0-2 wobble once inflated
  so lowlevel changes (container re-ref) cause higher modes
needs a playspout
 told/finding how innards roll through time (A&ip++)
 pointing to things, as if regrouping into another
  laying schemes on what to do
   producing a unified linguistic core
    what they are becomes, in layers.
    and tangles, hyperlinked, wandering

drawing cellular boundary
  s&z = more C,
    so might its A&z = more A
  based a bit on A signage (A.so = $so)
    $so might be via Ay&up (would know if soA&ip aboves us)
    A.pileup of things involved/leading to A
      should cleanup per J or so,
      but provide being/groupology along A
  measures of depth/appropriateness
   A&d (A.c.d)
  thickness/gravitational of cultural boundary-ness

pointing to enlarge parts should shrink unpointed parts

    giving light pools an interface to one another
      os may be comissioned from n
        it finds its own previous thinking, checking it...
      presenting ways to understand from the moment G&n
        so os owns the things life from there
    from where it originally was scored
      eg. this showing the C subsisting sense of the C itself
       as edges
    
#c ph Srupto Elvising 
=head1 Srupto 
    
    for growing mind in a pin with sections
      the hook and the iterator switch places:
        iteration happens in a while
        that returns to the enclosing handler
    
    S Knowing 2 $r %unknown
      should Re 'Knowing' for each C s&unknown thing
      with this section generating/emitting the layer
    S Knowing 3 $r
      can take M
    S Knowing 4 $r
      similarities?
    and also I/s/unknown
      u should be generatable soon, with such a trick
    
    
    =head1 Elvising
    
    and other hanging around ness...
      throating is meeting several inputs at once:
       A:n->C+ dome-havers (leading to/with/during s for the J)
       Teing (Instruction overloading) from 'above'
       Regurgitants
    Js can be trusted to get their TGW meaning to a point,
     so they can be reset natively
      consuming all input, producing all output,
      for what is supposed to be here.
      inside J (s life) its expression is freer
       
    
    os makes Elvising of the Res
      a better way to hold history? in Jc&o now
      e want to have pointer stuff
        the things point/naming a bunch of atoms
        maps/traces of string
    
    the time-independent interface to osc action
    
    R are essentially
     for going into the C and its state through time, etc
      onward, redo, step, pause at trouble...
     matching between many pools
      for same objects had by each other
        eg. a bunch of C touring a cyclically linked structure
      and similarityin many pools, overlapping, notice objects had by each other
      a quiet link, to be modulated/packed into Cs
      produced and consumed by the process
      to represent, as thinking has things to it.
      for things qualities to get framed,
        process and its C-side project through it.
      for locating in the living mind (travel)
      bits dangling from it, leading to more bits
        as a Jup-place (on its Elvising)
        and the travel, anything coming out.
    repeatable stumbles.
    
    =head1 R looks at R
    
    getting into the minds of itselves,
    scribing c/sc as far as desired
     want to map out parallel bunches of C for display,
       or representing jobs going on (Elvising)
     strategies want to know if their reason changes...
     want to know the usual R properties, for shrinkage.
    
    schemas for drawing stuff with Cs
      presenting the spaces as two (ish) layers (c/sc)
     to grab their jobs from C & R:* happenings..
    
    < visually an osc
      
      expr-go shows lookfortheedge-globe's C/R/A with a bunch of -od
    < whose only changes are the ticking of the A's ip
      the classic want-to-grasp time thing...
        AND noticing/not trivial usual
      many employees passing through a role
      
    < osc animation layer... vast goings fade out
      is the one place anything can happen!
      motuvation. the < see stuff, the > assume CRAP
    
    < to have a native reset/rebase
      resolve which atoms are pointing to/from which others...
      last applied stratagem of suchness diffed with current one
      steps taken to satisfy certains, leave uncertain interactive
    < including generatedness...
    <  maps of various resolution and sprawl
    # interfaces available to those ^ (open/close, attach to..)
    # should be detailed on the 
    Geing stuff, departing pile of meaning
    # similar but for unpackedness in general,
    Teing suff, meaning of departing
    # phases of aiming the display and adjusting things
    a pi sewing machine:
    # latter -go wants to be pointed to not coded, initially
    
    =cut
    
    
#c push - %ball's establishment of an outgoing projection
# < working via elvising hung near
# < better pointering & grabbing styles
#    remember what things looked like,
#    be generating grammars/I off the screen
# in a %push on this %ball, rolling through time,
# < disconnecting once the cause (me&push call) stops
# 
# returns the %pull (which will Ring soonish) unless:
#  %pull%auto:
#    %their = me&input,%there,%herec&s
#    returns %their = %ball holding %herec&s under %there
# 
me.push = &acgtRpqtc{
    # the named %push + its mode (%auto if t,!c args)
    c ||= {auto:1};
    typeof c == 'string' and c = G&peel,c
    t and ex(c,typeof t == 'string' ? {t:t} : t)
    c.push ||= 1;
    !hak(c,'t') and c.t = ki(p,2)+' = '+ki(q,2)
    $l = me&Ret,R,c;
        me&zN,l;
    
    # and its items, from here
    # path to receiver %ball (inflated)
    #  < elvis pointing such that name changes/bits blow away when pushed
    $t = ls&there = me&pushpath,R,p;
    # the thing itself, where it is (also inflated)
    $h = ls&here = isC(q) ? q : me&pushpath,R,q;
    !t || !h and throw "falliball"
    
    # < pipelining of here as it goes there via ...
    #   so it can wander through a network started here
    
    # begin othering:
    if (ls&hard) {
        ac(t,'pushering',l)
    }
    elsif (ls&auto) {
        $thing = hc&s;
        ls&their = me&input,ls&there,thing;
        return ls&their
    }
    else {
        # no-push link (elviser knows who's nearly elvised them)
        ac(t,'pushish',l)
    }
    # %ball pushed to %there, practically
    # < %othering to %there,
    #   saving %balls of here/there for Cdar diff
    #   the %there%balls noticing our %push vanish
    return l
};
# %ball input limb, extra pathy
# < to hang push intentions on %ball
#   or on speculative balls for slow ...
me.pushpath = &acgtRp{
    $r = R;
    each is p {
        $nr = s == '/' ?
            me.cby(r,&r{ return rs&gee })[0]
            :
            me&input,r,s
        !nr and throw "No "+s+" after "+r.t+" along "+ki(p)
        r = nr;
    }
    return r;
};

#c push
me.Pushingness = &acgtR{ return [
    # %push = cv awake
    ['push','3',&acgtRs{
        me&rollbs,R,'moves,delivered';
        s&bo = '1px dotted green';
        s&hue = 70;
        s&br = 1;
        #s&fs = 8;
        #Rs&arrow =
        n $R.t 13 s:⇒ %fs:24
        # certain/lowlevel types of %push
        Rs&auto || Rs&hard and return Rs&push = 9
        # log
        Rs&moves ||= []
    },'ift,D'],
    
    # %their
    # not currently pointed to and found:
    #   %there + %here = %their
    #     might mean disregard for %their state
    #     or ignorance, as elvis might clue
    #      with all the logistical infolation
    # ways the item 7s from afars:
    
    # %push%their = %balls reporting back
    ['ball+pushed','56',&acgtRs{
        # since ball 53 yfuture'd %pulled...
        $p = Ry&up;
        $above = ps&pushed || [];
        each il Rs&pushed {
            # %pushed here and not above
            above.indexOf(l) >= 0 and continue
            # < many?
            ls&their = R;
        }
    },'ift,D'],
    # %push%their = what %deliverer did (via %pushish)
    ['push+deliverer','56',&acgtRs{
        $d = Rs&deliverer;
        $ed = d && ds&delivered
        ed and Rs&their = ed
    },'ift,D'],
    # the %moves could lead somewhere
    ['push+moves','56',&acgtRs{
        each in Rs&moves {
            n.t == 'push' and Rs&lastpush = n
        }
        # last %move that was a push
        $lm = Rs&lastpush;
        if (lm) {
            # this %push when %move was started (had the %made)
            Rs&Doing = lmc&pusher;
            # this %push when %move was done
            Rs&Done = lmc&pushed;
        }
    },'ift,D'],
    
    # an error getting fixed
    # detects disconnected %their
    #  searches for likely candidate
    #   or however there/their is pointed
    ['push+losttheir','77',&acgtRs{
        delete Rs&losttheir;
        !Rs&lastpush and return
        $m = Rs&main || Rs&made || Rs&here;
        $th = Rs&there;
        !m || !th and throw "m-th"
        $t = me&ioty,th,'%ball' .filter(t => t.t == m.t) [0];
        n sun  $s:m,R %sun
        !t and return me&tsc,'notfindable','gonetheir','d'
        Rs&losttheir = t;
    },'ift,D'],
    
    # and puts it forth
    ['push+moves','56',&acgtRs{
        # for push+losttheir 77
        $b = Rc&b;
        $l = b && bs&losttheir;
        l and Rs&their = me&yfuture,l
    },'ift'],
    
    # the 59%push%does becomes %act
    ['push','59',&acgtRs{
        Rs&push >= 9 and return
        # attaching checks to its parts
        me&suggesc,Rs&here,'Lines';
        me&suggesc,Rs&their,'Lines';
        # %act from what it %does to get %made
        #  engaged now so it can tamper with <6%their
        Rs&does and Rs&act = Rs&does
    },'ift,D'],
    
    #c push-7 have encoded %balls wormhole through %moves
    #   received by this %push early enough to action
    ['push','7',&acgtRs{
        Rs&push >= 9 and return
        $t = Rs&their;
        $h = Rs&here;
        hs&Lines && !hs&string and return T.wide = 1
        
        # both sides should Lines
        me&sch_didLines,R,h;
        !t || me&sch_didLines,R,t;
        
        if (me&Mw,R,'err' .length ) {
            Rs&push = 9;
            return me&tsc,'push7_errrors','⊗','L'
        }
    },'ift,D'],
    
    ['push','73',&acgtRs{
        Rs&push >= 9 and return
        $h = Rs&here;
        $t = Rs&their;
        $Done = Rs&Done;
        
        Done && !t and me&tsc,'va','vanishing!'
        !t and me&tsc,'notheir','⧁','L'
        
        # here <-> their if nothing organised (by 72%act)
        !Rs&diffya and me&diffya,R,'diff',h,t
        
        # their <-> their at the last push (negated by 72%act)
        $tdiff = t && Done && me&diffya,R,'theirs',t,Dones&their;
        if (tdiff) {
            # < handle changes we didn't push
            # < branch here <-> Dones&here, patch onto that
            # < a %differ tangle, wakes up to sort out a %push gone awry
            if (!tdiffs&exactly) {
                # < explore what'll happen, run in reverse
                #m pull $from:t,to:h %pull,pending,move
                n pending  s:pull? %hs:588
            }
        }
        
        $dy = Rs&diffya;
        $diff = dy && dy.diff;
        if (diff) {
            # the main diff
            if (diffs&exactly) {
                # %push%exactly if the diff named diff is exactly
                #   used to find %push leaving equilibrium
                Rs&exactly = 1;
            }
        }
    },'ift,D'],
    
    # %push makes %moves
    ['push','77',&acgtRs{
        Rs&push >= 9 and return
        $h = Rs&here;
        $t = Rs&their;
        # collects %moves
        $M = Rs&moves;
        
        # the checkout on init trick
        if (Rs&checkout && !M.length && me&sch_ballonlyt,h ) {
            m checkout $from:t,to:h %pull
        }
        
        # transmit here or what we made of it
        Rs&made and h = Rs&made
        
        if (Rs&shove || Rs&boost > 1) {
            !Rs&shove and Rs&Te.sc.boost = 1;
            Rs&shove &&
                n shovedby  $s:Rs&shove %hs:388,deco
            
            if (!t) {
                t = Rs&there;
                $into = '> '+t.t
            }
            ~PUSH: R.t, h.t, into||t.t
            # the usual
            $c =
            m push $from:h,to:t,pusher:R
            into and cc&into = 1
        }
    },'ift,D'],
    
    # random look
    ['push','8',&acgtRs{
        $b = Rc&b;
        Rs&act and s&dis = 1
        elsif (b) {
            # %push!%act with history
            # grow/shrink if leave/become exactly equal
            if (b && bs&exactly && !Rs&exactly && !Rs&boost) {
                me&introqua,R,{boost:1};
                Rs&boost = 1;
            }
            if (b && !bs&exactly && Rs&exactly && Rs&boost == '1') {
                ~Flattened settling push: R.t
                me&introqua,R,{boost:0};
                Rs&boost = 0;
            }
        }
        (Rs&boost||0) < 1 and return
        
        s&fs = 13;
        s&dis = 1;
        #n thing  $s:R.sc,R %sun
    },'ift,D'],
    #c push-moves
    # 7%push sends its future self %moves to do
    #   objects (esp %from and %pusher) from that time
    # now early enough to make %ball%othering
    # < tell it to be awake
    # a %move is just a C, has:
    #   c&from/c&to: most of all
    #   c&push: %push when it started to move
    # if you:
    #   c&pusher: whatever/%push the move was designed in
    #  you get:
    #   c&pushed: yfutured/%push when move completed
    ['push+moves','4',&acgtRs{
        $M = Rs&moves;
        each in M {
            ns&done and continue
            # with items from late last time
            $f = nc&from;
            $t = nc&to;
            t ||= nc&into;
            !t || !ts&ball and throw "move not sure of t%ball"
            !f || !fs&ball and throw "move not sure of f%ball"
            # us, last time
            $p = nc&pusher;
            nc&push = R;
            # f is likely to be the last %here, unless reversing
            # t (usu c&to=%their) may still be c&into=%there
            $tp = t && ty&up;
            if (tp && tps&pushering) {
                tp = me&yfuture,tp;
                # parent mediates %push for some reason
                #  eg to %kvstore %here%string
                # not %their directly
                ~pushering: t.t, R.t
                ac(tp,'pushering',R,'ball',f)
            }
            else {
                $to = t;
                t = me&yfuture,t,R;
                ~othering: t.t, R.t
                0 > Rc&N.indexOf(t) and ns&warn = 'to!cur'
                t == to             and ns&warn = 'to!futu'
                ts&ball == '6'      and ns&err = 'toolate'
                
                if (!ns&err) {
                    # bit more pto
                    ns&move = 1;
                    ns&from = f;
                    ns&to = t;
                    ac(t,'movingin',n);
                }
                # usu othering %push%here,
                # < the %moves making subcommits:
                #   their own reselections of %ball
            }
            
            ns&sym = n.t == 'checkout' ? '↽' :
                ns&pull ? (ns&pending ? '◅' : '◄') :
                ns&step ? '‣' :
                (ns&pending ? '▻' : '►');
            ns&err and ns&sym += '!'
            ns&done = 6;
            #n thereup  $s:ty&up,R %sun
            # t%ball%othering should get us
        }
        
    },'ift,D'],
    
    # moves talked about 
    ['push+moves','8',&acgtRs{
        $M = Rs&moves;
        M.length &&
            n moves $s:M,R %hadmoves
    },'ift,D'],
    # squishy shrinking ooze, preserving interesting events
    # more info at latest
    ['hadmoves','3',&acgtRs{
        $p = Ry&up;
        $forget = [];
        each in s {
            # done this round
            if (ns&done == 6) {
                ns&done = 9;
                $r = nc&pusher;
                # branch at %push%their with %move
                r and nc&pushed = me&yfuture,r,R
            }
            # id by name then symbol
            $sym = n.t;
            ns&sym and sym = ns&sym
            n $n.t  $s:sym %fs:12,hs:594
            
            ns&err and me&tsc,'error',ns&err,'d';
            ns&warn and me&tsc,'warn',ns&warn,'d';
            
            if ((Rs&boost||0) > 0) {
                # TEST doesn't get out?
                $t = "Cit:"+n.t;
                n $t  $self:n,R %Reis:Cit,set:Cit
            }
            
            # condenses
            if (s.length > 5) {
                $ne = s [i+1];
                ne && n.t == ne.t and forget.push(i)
            }
        }
        
        forget.map(i => s.splice(i,1));
    },'ift,D'],
    

] };

#c TeCo
# minimal pin-like thing returner (harness acts)
me.domething = &acgttc{
    !me[t] and throw "no me."+t
    !c.acgt and throw "somethingelse"
    $r = me[t](A,C,G,T, ...c.acgt);
    c.returns && !r and throw "me."+t+" !return"
    return r
};
# %act='TeCo' gets this %made
#  make instructions for Co
me.TeCo = &acgtRhtc{
    $s = hc&s;
    # s:
    # haps
    #   step_1
    #     WaTe %H:38247253
    #       someelvising
    #   step_2
    #     haps %H:38231253
    $Co = G&Cye,['Co','',{},{J:1}];
    i $Co/$s
    # r is %made, all new rc&s
    $r = me&Copy,R,Co,{ov:16,Ropia:[h]};
    
    # want to just:
    # o $Co/*:main/*:step/*:do
    # with %ball layer, style main + do
    
    $main = me&ioty,r,'%ball' [0];
    $m = mainc&s;
    
    # ensure step_1
    !mains&z and me&input,main,'step_1';
    $steps = me&ioty,main,'%ball';
    each in steps {
        # ensure doing=main.t
        !ns&z and me&input,n,main.t;
        $does = me&ioty,n,'%ball';
        each id does {
            $n = dc&s;
            # whittle to instruction part
            # hiding whatever is here that is not it:
            # - the H object it should be
            ns&H and ds&H = delete ns&H
        }
    }
    
    # < any s&H still anywhere should be loaded in
    # < why only now can this have effect?
    $main = me&ioty,r,'%ball' [0];
    $m = mainc&s;
    
    delete rs&ov;
    rs&Lines = 3;
    # onward 2%ball Rsyncs, anything under r may ~
    me&Ring,r;
    
    $mains = me&ioty,r,'%ball';
    each im mains {
        # blows everything away when othered
        ms&clobberypushingz = 1;
        # limit othering of steps (to %run%currentstep?)
        ms&pushingnoz = 1;
        # if new steps are wanted, what W?
        ms&invent_step = m.t;
    }
    ~TeCo: main.t
    return r
};
#c Actingness
# where it must do a computation
# the R that %push%made, relative to others
# ie an elvising that sleeps

# sanity/display helper for expanding joints
me.zoep = &acgtRptsk{
    # find/check scheme upwards
    if (p && p.up) {
        $path = p.up.split('%').slice(1);
        $r = R;
        each il path {
            r = ry&up;
            !r and throw t+" !up"
            !r.sc[l] and throw t+" up !"+l
        }
    }
    # introduce this
    me&tsc,t,s,'g';
    k == '' and k = R.sc[t]
    me&tsc,t,k,'G';
    return r
};

me.Actingness = &acgtR{ return [
    # the R that %made
    ['push+act','721',&acgtRs{
        Rs&push >= 9 and return
        $h = Rs&here;
        $hs = hc&s;
        hss&testrun ||= 1;
        # %Citop%play/nameup likes to find explicit things
        hs&testrun ||= 1;
        
        $t = Rs&their;
        # this R with %here + %made when %move was made
        $Doing = Rs&Doing;
        # negates theirs diffs
        Rs&diffya ||= {};
        Rs&diffya.theirs = 0;
        
        # diff the input with %made's input
        $mh = me&rollbs,R,'made_here';
        mh and $indiff = me&diffya,R,'input',h,mh
        if (indiff) {
            # input better understood as %made
            indiffs&sublated = 1;
            indiffs&exactly and Rs&made = Rc&b.sc.made
        }
        
        # %made ||= the act
        if (!Rs&made) {
            Rs&made = me&domething,Rs&act,{acgt:[R,h,t],returns:1};
            Rs&made_here = Rs&here
        }
        
        # diff %made to %made when move was made
        Doing and me&diffya,R,"diff",Rs&made,Doings&made
        
        if (t && t.t != h.t && t.t == 'Co') {
            Rs&mained = me&ioty,Rs&made,'%ball' .filter(n=>n.t == h.t)[0];
            !Rs&mained and throw "No Co/%mained thing";
        }
    },'ift,D'],
    
    # < as part of a %push%made%plan to make Co/%main/%steps
    
    # %made = Co [haps[step[do[elvis]]]]
    # is othered to %their instead of %here, so:
    # %mained = %made Co/haps
    # %main = %their Co/haps
    # two halves of living situation
    ['push+act','591',&acgtRs{
        Rs&push >= 9 and return
        $h = Rs&here;
        !h and return me&waits,'..h'
        $t = Rs&their;
        if (!t) {
            me&waits,'..t'
            Rs&losttheir = 1;
        }
        !t and return
        
        if (t.t != h.t && t.t == 'Co') {
            # locate their main thing (othered from %mained)
            $main = me&ioty,t,'%ball' .filter(n => n.t == h.t)[0];
            !main and return
            Rs&main = main;
            # Linesing per do
            $N = me&ioty,main,'%ball%ball';
            each id N {
                #me&tsc,'indo','('+d.t+')','b';
                me&suggesc,d,'Lines';
            }
        }
    },'ift,D'],
    #c push+act=made
    # Co/Hap/ Hap v1...
    # a bug chaser
    # make deals across the border so
    # a layer of task built onto a push
    # some complicated thing breaking out steps
    # < take %made/%step++ to %main/%step
    ['push+act','73',&acgtRs{
        s&bow = '3px';
        n act  $s:Rs&act %deco
        $h = Rs&here;
        $t = Rs&their;
        # persist %run per %main%ball c&s
        $mains = Rs&main && Rs&main.c.s;
        #  per clobberypushingz, restarts test run (drops J)
        $r = me&rollcounty,R,'run',{per:mains};
        # between two planes
        $N = me&ioty,Rs&main,'%ball'
        $Z = me&ioty,Rs&mained,'%ball';
        
        me&tsc,'thoughtclock',r.t+"@"+rs&count,'6' .sc.fs=7;
        me&tsc,'tot','('+N.length+'/'+Z.length+')','p'
        # 4%step and then 5%groksteps...
        n progress  R %groksteps
        
        # zip N-results to Z-expectations,
        #  allowing more N if all is %ok
        $i = 0;
        while (N[i] || Z[i] || i == 0) {
            $eye = i+1;
            $k = 'step_'+eye;
            n $k  $step:eye,got:N[i],exp:Z[i],R
            i++;
        }
    },'ift,D'],
    # groksteps
    #  playhead advances when more && ok
    #  boost to add steps
    # ⧐ from the top
    # ∿ big change
    # ~ small change
    # ☯
    # 
    ['groksteps','81',&acgtRs{
        $p = Ry&up;
        $steps = me&ioty,p,'%step';
        Rs&ok = 1;
        Rs&more = 0;
        each iS steps {
            $doings = me&ioty,S,'%doing';
            each in doings {
                ns&doing == 1 and return T.wide = 1
                !ns&got and Rs&more = 1; break
                # results got must be ok
                !ns&ok and Rs&ok = 0
            }
        }
        Rs&ok ? me&tsc,'ok'
            : me&tsc,'notok','!','B';
        # < pause/play/further from here
        # < redo = fork from last ok state?
        Rs&more ? me&waits,'more','≻','L'
            : me&waits,'moreanyway','⊁','L';
        
        if (Rs&ok && Rs&more) {
            if (ps&almost) {
                me&tsc,'almost','>-'
                return
            }
            ~okmore: R.t
            ps&boost >= 1 and Rs&wantstep = 1
        }
        Rs&boost > 0 and Rs&wantstep = 1; Rs&Te.sc.boost = 0
        
        Rs&wantstep and ps&stepforward = 1
    },'ift,D'],
    
    #c push+made=moves?
    # others a %main%step
    ['push+made','82',&acgtRs{
        $m = Rs&mained;
        $M = Rs&moves;
        if (Rs&main) {
            $main = Rs&main.c.s;
            main.y.run = R;
        }
        # < become %aTool in the nearest %Tool,
        #   gently raised exception, shoulding to disappear
        $problem = 0;
        $prob = &s{
            problem = 1;
            return me&tsc,'noforward',s,'B'
        };
        if (Rs&stepforward) {
            # mained is from TeCo, %Ropy to Wormhole
            !m and prob('!mained')
            # main has been %moved/ball-othered
            !Rs&main and prob('!main')
            # %moves
            !M and prob('!moves')
            problem and return
            
            # find step with no %got
            $N = me&ioty,R,'%step';
            $S = N.filter(S => !Ss&got)[0];
            if (!S) {
                # clone last step: keeps exp to show change
                $la = N.slice(-1)[0];
                $mez = me&ballio,R;
                $Wm = ms&Ropy;
                !Wm and throw "no test src"
                # put it in testdata
                $S = mez&step,Wm,la;
                # and leave it at that,
                #  since TeCo must format it (drops %H)
                #   could be elvisey understanding,
                #     a late iteration
                # < results in a new %main: tell %run to not restart
                return;
                # put it in mained (without TeCo doing so)
                #mez&link,m,S
                # gets to main via othering-ball, so get to %fix:
                Ss&ov = 8;
                me&Ring,S;
            }
            else {
                $pre = N[N.indexOf(S)-1];
                pre && pres&boost and return me&tsc,'resting'
                !Ss&exp and return me&tsc,'noforward',"nextstep!exp"
                S = Ss&exp;
            }
            
            # S is now a new %mained %step's %ball (or looks like it)
            # push the new %step to %main
            m step $from:S,into:Rs&main,pusher:R %step
            S && Ss&string and me&tsc,'shipping',Ss&string,'6'
            #n stepth  $s:Rs&main,R %sun
            
            #$c =
            #m push $from:h,to:t,pusher:R
            #~wouldstep: R.t
        }
    },'ift,D'],
    #c step acceptor
    # %push's %step/%doings build up %ok
    # < hang %step on the %here %ball it's for
    ['step','3',&acgtRs{
        Rs&rowish = 1;
        $p = me&zoep,R,{up:'%push'},'step','S','';
        $m = me&rollcounty,R,'mem',{per:ps&run};
        
        # if no elvising around here, complete steps fold
        !Rs&Te || !Rs&Te.c and me&rollbs,R,'whileago'
        Rs&whileago and return me&tsc,'whileago','-----------------',6
        
        # go main/mained %step -> %do
        $N = me&ioty,Rs&got,'%ball';
        $Z = me&ioty,Rs&exp,'%ball';
        
        $i = 0;
        while (N[i] || Z[i] || i == 0) {
            $eye = i+1;
            $k = 'doing_'+eye;
            n $k  $doing:eye,got:N[i],exp:Z[i],R
            i++;
        }
    },'ift,D'],
    ['step','8',&acgtRs{
        Rs&whileago and return
        # our %doings must be ok
        # < o %doing{all:%ok}
        #  < the all: being a grouping function
        $N = me&ioty,R,'%doing';
        $ok = 1;
        each ir N {
            !rs&ok and ok = 0
        }
        !ok and return
        # %step%ok
        Rs&ok = 1;
    },'ift,D'],
    ['step','82',&acgtRs{
        Rs&whileago and return
        # must be a %step%ok after us
        # < o ../$R,{%step%ok}
        #  < knowing that %ok is imperative to the next %step
        #     don't mind if there's random stuff between %steps
        #     they should be strewn through documentation
        $p = Ry&up;
        $N = me&ioty,p,'%step';
        while (N[0] != R) { N.shift() }
        N.shift();
        $aft = N.shift();
        !aft || !afts&ok and return
        Rs&whileago = 1;
    },'ift,D'],
    #c %doing
    ['doing','3',&acgtRs{
        $p = me&zoep,R,{up:'%step%push'},'doing','.','';
        $m = me&rollcounty,R,'mem',{per:ps&run};
        $M = ps&moves;
        $g = Rs&got;
        $x = Rs&exp;
        # helps %groksteps decide things are ready
        # (A below should be done by the time...)
        Rs&doing = 3;
        x && !g and return me&waits,'nogot','...'
        !x && !g and return me&waits,'noexpgot','..!'
        
        # prepare to %diff
        $dc = {};
        # was no %doing
        !x and dc.unexpected = 1
        else
        # was no %doing%H, the result
        # swaps x with nothing insides %diff
        !xs&H and dc.unexpected = 1; dc.expGhost = &{};
        else {
            # make it look Linesey
            xs&dige = xs&H;
            # decode contents if needed (for a diff_
            dc.expGhost = &{ return me&GhostOut,R,xs&H; }
            # < decompress vastnesses
            # < use trusted code to generate everything?
            #   a lobo A4 copying dispatches from a live instance
            #   clonesyncing as it transports between them
        }
        
        # got %ball = n
        $W = g && gc&s;
        # replaces instruction
        W && !Wy&C and return me&waits,'noWyC','n...'
        
        # diff
        if (g) {
            $d = me&diffya,R,R.t,g,x,dc;

            # < what happens to this?
            ds&new and me&tsc,'nothere','⧀','L'

            ds&exactly and Rs&ok = 1
        }
        
        Rs&ok and ms&ok = R
        elsif (ms&ok) {
            # results are allowed to wander off once ok
            # such info is interesting
            # < accept/test for history-warp
            d and ds&sublated = 1
            n accepted_before s:=)
            Rs&ok = 3
        }
        
        #c This
        # we have a diff, know if ok now/before
        # and all this:
        if (W) {
            if (Rs&boost < 0) {
                # quick redo thing
                # < when it <G
                $p = g.y.up;
                $ps = pc&s;
                $pi = pss&z.indexOf(W);
                pi < 0 and throw "nofind"
                !Wy&C and throw "nooriginal"
                W = Wy&C;
                pss&z[pi] = W;
                delete Wy&C;
                W = null;
                Rs&Te.sc.boost = 0;
                return
            }
            # the object
            n Cit  $self:W,R %Reis:Cit,set:Cit
            
            # and the Co-sync scan that might have failed on its own:
            $gs = gc&s;
            $tr = gsy&triedcopy;
            if (tr) {
                n Tried  $self:tr,R %Reis:Cit,set:Cit,hue:90
                me&diffya,R,"triedtospeed",tr,x,dc;
            }
        }
        Rs&ok and return me&tsc,'ok','ok','p'
        
        if (W) {
            if (Ws&err) {
                $skull = '☠';
                me&tsc,'error',skull,'D';
                me&tsc,'error',Ws&err,'d';
            }
        }
        
        # we have %here, find names for %step/%doing
        $S = Ry&up;
        $stepname = Ss&exp ? Ss&exp.t : S.t;
        $doingname = x ? x.t : 
            # to save an invented step/doing (!x) as got
            g ? g.t :
            R.t;
        
        # accept change
        if (g && Rs&boost > 0) {
            !Rs&shove and Rs&Te.sc.boost = 0;
            me&tsc,'accept',"<",'L';
            
            # find us from %here
            $step = me&input,ps&here,stepname;
            $doing = me&input,step,doingname;
            # store an object
            !gs&dige || !gs&string and throw "weird"
            me&GhostIn,R,gs&dige,gs&string;
            # put pointer
            $ds = doingc&s;
            dss&H = gs&dige;
            
            $dt = ds&Te;
            # reset diff about to become '='
            dt && dts&boost and dts&boost = 0
        }
    },'ift,D'],
    
] };
#c pushy
# operate on Ghost/kvstore remotely
# < s&H object pointers wander borders
me.GhostOut = &acgtRk{
    $Ghost = Rs&sGhost ||= me&sGhost,R;
    $s = localStorage[k];
    !s and throw "noH: "+k
    # a %ball with %Lines=0
    return Ghosts&arrange_decoder(k,s);
};
# write-once storage
me.GhostIn = &acgtRks{
    $Ghost = Rs&sGhost ||= me&sGhost,R;
    $bs = localStorage[k];
    bs && bs != s and throw "hash collision?"
    localStorage[k] = s;
};
# the source of your information
# o ^^%push %here %pushed'lookup' %there
me.sGhost = &acgtR{
    $Ha = me.cby(R,&b{ return
        bs&pushed && bs&pushed[0].t == 'lookup'
    })[0];
    if (Ha) {
        $pl = Hac&pushed[0];
        $Ghost = pls&there;
    }
    else {
        #  %pushed falls off if throw
        $Ghost = me&pushpath,R,['/','G'];
    }
    return Ghost
};
#c Ring mind
# while the R.t == mind of this pool
$osu = &Rt{
    $task = t || Rs&task || R.t;
    !me[task] and debugger;
    
    # %Ghostway do_permanence() drops this cache
    $w = me&wayta,'Coffle';
    $mI = ws&makesI ||= {};
    $z = mI[task];
    z and return z
    
    # m ... BQ breaks code visibility (until proper u)
    $z = [];
    $N = me[task](A,C,G,T,R);
    each in N {
        # sack of me.functions
        isfu(n) and n(); continue
        n = G&Cye,n;
        
        # compile instructions
        if (ns&ift == '1') {
            $op = n.t.split('+');
            if (op.length > 1) {
                # must have all these sc
                ns&ifs = op
            }
            else {
                ns&if = 's'+n.t
            }
        }
        elsif (ns&ift) {
            ns&if = 's'+ns&ift;
            ns&ifeq = n.t;
        }
        # < test switching sort semantics
        #   order of inclusion amongst equal cv
        me&sortin,z,n;
    }
    # < Cye should put c=code as c.s
    each in z {
        n.c = {s:n.c}
    }
    
    mI[task] = z;
    return z
};
# Rs&z post hook, R intro
$cz = &Ri{
    !Rs&z || Rs&z.length == i and return
    Rs&z.slice(i)
        .filter(z => z.y.cv == null)
        .map(z => me&zN,z );
};
# Rs&z -> hc&N, validates as atom
me.zN = &acgtR{
    R.y.cv != null and return
    Rc&middle = &sR{ R.c.not = 1 };
    me&ing,'',R;
    if (!R.c.not) {
        R.c.not = 1;
        return
    }
    delete R.c.not;
    delete Rc&middle;
    Rc&N.push(R);
    R.y.cv = 0;
};

#c Ring
# already invoked from an otheR,
#    which becomes its source, unless Rc&s?
# wake the pool of R,
#  1 is me&ing, its recursion we manage

# < processes instructions from a way with S-ections
#    which handle procedures on single/multiple items,
# creating and casting into subprocesses before/after:
#   S Pond 3 $R $r $s %vague
# gives R:Reason, r:Pond, rc&s=s=Rc&s where s.sc.vague,
#   S Pond 3 $R $r %vague $s
# gives R:Reason, r:Pond, rc&s=s=Rc&s where R.sc.vague,
#   S Pond 3 $R $r
# gives R:Reason, r:Pond, rc&s=R
# ie, there's always a R and a r. a dialect phrow.
# better than (post-harvest actuation of)
#  Y:Steps's stemful of acting
# is eventually replacing, once integrated;
me.Ring = &acgtRq{
    $h = Rc&N[0] || R;
    $oT = T;
    $p = h.y.up;
    $c = hs&clu ||= osu(h);
    $the = me&Timethe,'Ring:'+h.t;
    
    # while tasks
    if (h.y.cv == null) {
        # put the first R
        # on tape (Rc&N), as the emit queue
        me&zN,h;
        h.c.not and throw "h not"
    }
    # walk the 愛 tape, trying to do more
    $timing = 1s&Times;
    $direct = 0;
    $indirect = 0;
    $beginR = R;
    # a concentration
    # if things don't happen in the correct order,
    # since we go wide fairly often
    #  the parent Acv > the child sometimes matters:
    #   to get Cit3/slep2 to be Cit27(getslep)/slep2
    if (q) {
        # on those q.inside=$R (or und, includes R)
        #  growing q.onlyRupto
        q.und and q.onlyRupto = [q.und]; beginR = q.und
        q.inside and q.onlyRupto = [q.inside]
        q.ov and q.ov = G&sca,q.ov
        # < R indexed by cv
        # or otherwise grouped for meaningful disruptability
        #  TimeWaves
        # < have cursors not bunged by asyncs
        #    which is doming, a general segmentation
    }
    
    # < see how many Rings are in h
    # seek to somewhere
    #  Ringing is vague and rattley,
    #   yet usu ok direct/indirect
    # < more mapping out what to work on first/only (subnets)
    hs&iN = Rc&N.indexOf(beginR)-1;
    hs&iN < -1 and throw "!beginR"
    
    $busy = 1;
    $sheer = 445000;
    $onlyt;
    while (1) {
        indirect++;
        sheer-- < 0 and debugger;
        hs&iN == null and hs&iN = 0
        else { hs&iN++ }
        # select what up to
        $R = hc&N[hs&iN];
        
        if (q && R && q.onlyRupto && R != q.und) {
            R == q.inside and continue
            $not = q.onlyRupto.indexOf(R) < 0;
            if (not &&
            #Rs&ci == null &&
                q.onlyRupto.indexOf(Ry&up) >= 0) {
                q.onlyRupto.push(R);
                not = 0;
            }
            not and continue
        }
        
        if (!R) {
            #!hc&N[hs&iN - 1] and debugger
            # end of tape
            hs&iN = null;
            !busy and break
            onlyt = null;
            $lowci = '';
            $ati = 0;
            each in hc&N {
                if (lowci == '' || ns&ci == null || lowci > ns&ci) {
                    lowci = ns&ci;
                    ati = i;
                }
            }
            busy = 0;
            continue
        }
        
        # avoiding until a direct Ring
        q && q.und == R and delete Rs&nottilund
        Rs&nottilund and continue
        
        # Rs&z may be new R to emit
        $zi = Rs&z && Rs&z.length || 0;
        Ry&R ||= R;
        
        # step
        Rs&ci ||= 0;
        $t = c[Rs&ci];
        !t and continue
        R.c.not and continue
        #onlyt && t != onlyt and continue
        
        hs&ov && hs&ov < ty&cv and continue
        q && q.ov && q.ov < ty&cv and continue
        
    #c from here is going
        #  to accept the step as done
        #  except if T.wide, late abort/comebacklater
        #   for when your dependencies haven't filled out
        #    < keeping loopage direct with TimeWaves,
        #      which try to gather at fully awake
        
        # deciding
        $T = {};
        if (Rs&sleeping) {
            # misses everything but sleeping spells
            !(ts&sleeping || t.t.substr(0,8) == 'sleeping') and T.not = 'sleeping'
        }
        if (ts&ifs && !T.not) {
            each ik ts&ifs {
                R.sc[k] == null and T.not='ifs'
            }
        }
        if (ts&if && !T.not) {
            ts&if == 'RcX' and !Rc&X and T.not='if'
            else
            ts&if == 'h' and R != h and T.not='ifh'
            elsif (ts&if[0] == 's') {
                $v = R.sc[ts&if.substr(1)];
                !v and T.not='if'
                ts&ifeq && v != ts&ifeq and T.not='ifeq'
            }
            else {
                throw "if "+ts&if
            }
        }
        if (timing) {
            indirect--;
            direct++;
            $k = h.t+'/'+t.t+'@'+t.y.cv;
            timing[k] ||= 0;
            $from = G&time;
            $thestep = &{
                timing[k] += G&time,from
            };
        }
        
        $genR = null;
        if (!T.not) {
            $packdown = [];
            if (ts&D) {
                # doming for n
                T.nN = [];
                packdown.push(&{
                    # empties T.nN into M or more R
                    genR = me&endome,R,t;
                    delete T.nN;
                });
            }
            
            T.act = t;
            $cb = tc&s;
            q && q.callings and q.callings.push([R,t]);
            t
            cb(A,Rs&C||C,G,T,R,Rc&s);
            
            packdown.map(pd=>pd())
            
            $p = Ry&up;
            # see KnowC/Cit Ry&R, not in z but finds its way in
            !Rc&nofurther || p && ps&tightly and cz(R,zi)
        }
        delete T.Mw;
        delete T.not;
        T.cancel and return oT.cancel = T.cancel
        thestep and thestep()
        if (T.ziter && genR) {
            $ov = delete T.ziter;
            ov == 1 and ov = 0.3
            me&Ring,R,{inside:R,ov:ov};
        }
        if (T.Rq) {
            $TRq = delete T.Rq;
            me&Ring,R,TRq;
        }
        if (T.wide) {
            Rs&widenings ||= 0;
            Rs&widenings++ > 30 and throw "Lot of wideness", R, T.wide
            delete T.wide;
            busy = 1;
            continue;
        }
        Ry&cv = ty&cv;
        Rs&ci ++;
        Ry&up.c.N == Rc&N && Ry&up.sc.ci > Rs&ci and hs&iN--
        onlyt = t;
        busy = 1;
    }
    if (timing) {
        timing.direct ||= 0;
        timing.indirect ||= 0;
        timing.direct += direct;
        timing.indirect += indirect;
    }
    the();
};

#c Ringtastico
me.bewind = &acgtRN{
    $behind = &r{ return !rs&ci || rs&ci < Rs&ci };
    N ||= Rs&z
    each ir N {
        $waits = behind(r) || rs&z && rs&z
            .filter(r => behind(r)).length;
        waits and return T.wide = "KnowC"
    }
};
# S for an osc pin, bump through segments of the work
me.Srupto ||= &A,C,G,T,s,t,talk,params{
    ~Srupt: s, ':', t, '%', talk
    #t.includes('She 1') and debugger
    A&doings ||= {};
    $l = A&doings[t] ||= {};
    l.done and return
    l.done = 1;
    #~sttalk: ki([s,t,talk,params]);
    return 1;
};

#c Pass pitch time, run time, log saming
# < waver accepts advances in trave...
#   once off the path that sequences of trave indicate
#   begin a new branch of trave,
#     each named phase of things moresoer
# inside W:Wobulus, after W:Fourier
me.Ja.Pass = &acgts{
    me&Gomp;
    n Ha  $Travel:c&el %ravel:gee
};
# plugged into W:wobulus
me.do_main = &acgt{
    4c&fps = 0.2;
    
    $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
    
    #me&J,'digwaypoll';
    
    me&J,'Fourier','W';
    
    4s&Fourieronlynow and delete 4s&Fourieronlynow; throw "async Fourier only"
    
    me&J,['Pass','W',{el:el},{timing:0}]
    
    # start out of having Elvisory/*%J
    #   just like a e to them would...
    each in els&z {
        $J = ns&J;
        !J and continue
        J == '1' and J = n.t
        me&J,[n.t,1,{W:J}]
    }
};

# host attachable T with W + G around
me.Ja.Anetwork = &acgt{
    me&Gomp;
    n Afour  $s:A.4 %rovo:ning
    n Afive  $s:A.5 %rovo:ning
    n Asix  $s:A.5[4] %rovo:ning
};
# ^ check random stuff against brain-era osc etc,
#   free-ish list of bugs we fix

# manage Js&sleep, ongoing
#  compare to what really happened (async?) due to e etc
#  do_main posits what should be able to be attended
me.Ja.Drum = &acgt{
    me&Gomp;
    n Afour  $s:A.4 %rovo:ning
    n Afive  $s:A.5 %rovo:ning
    n Asix  $s:A.5[4] %rovo:ning
};
#c Co
# provide n to %main/%step/%doings
me.Ja.Co = &acgt{
    me&Gomp;
    $t = 1s&Te;
    $ocb = delete c&ocb;
    $cb = &{
        me&doN,ts&z;
        ocb && ocb()
    };
    # too late for this J to include it
    t && ts&z and G&yl:0,cb;
};
me.Ja.City = &acgt{
    me&Gomp;
    $z = delete s&z;
    $Te = C.y.zTe = z[0];
    $te =
    n Citey  $s:c&s,thisis:4 %ravel:Citying
    me&clearTe,1s&Te;
    tey&TeImplant = Te;
    # quiets T/City, about to get ^
    me&introqua,0,'quiet','@1';
};
# puts $W
me.Ja.PuTe = &acgt{
    me&Gomp;
    $z = delete s&z;
    $Te = C.y.zTe = z[0];
    $el = 4s&elvisory;
    i $el/-#$Te
    i $el/$Te
};
me.clearTe = &acgtt{
    !t || !t.c and return
    delete ts&z;
    delete ty&tv;
};
#c Co doN
# attends %main/%step/%doings
# < many attentions per C
#    usu wind-up C.y.A.cv, 4s&N also
#    most systemy C would have a way to hang out
#    (A:u@8)
me.doN = &acgtN{
    $Js = 1s&mainJs ||= {};
    each im N {
        # a main
        $mainJs = Js[m.t];
        if (!my&began) {
            # fresh run, clear memories
            each ti mainJs {
                #~Cleans: m.t, t
                delete 4s&Jtv[t];
                i 4s&elvisory/-#$t
            }
            mainJs = Js[m.t] = {};
        }
        my&began ||= G&time;
        my&began_stepping = G&time;
        $ii = 0;
        !ms&z and return;
        while (ms&z[ii]) {
            # a step
            $S = ms&z[ii];
            ms&pause || Ss&pause and continue
            $tw = {};
            $dideverything = 1;
            each iC Ss&z {
                # a doing
                if (C.y.C) {
                    # points to original when done
                    # becoming the latest of $t
                    tw[C.t] = C;
                    dideverything = 0;
                    continue
                }
                if (c&points) {
                    c&s = tw[c&points];
                    !c&s and s&err = "No points: "+c&points; continue
                }
                
                # 6
                $live = me&adoing;
                
                lives&W and mainJs[C.t] = 1
                # if another, keep it instead
                tw[C.t] = C.y.D = live || C;
                if (live && live != C) {
                    live.y.C = C;
                    Ss&z[i] = live;
                }
            }
            ii++;
            
            # Co speed
            dideverything && ms&testrun == '2'
                && !my&nospeeding
                && me&doN_speeding,m,S
        }
    }
};
# n $C # returns another
me.adoing = &acgt{
    $q = {q:'W'};
    try {
        q.part = 'Jin';
        me&J,C,q;
        q.part = 'Jreturned';
    }
    catch (er) {
        # < powow with Ban to surf Bstack
        C = q.C || C;
        s&err = ki(C,2)+"   !"+q.part+"! "+er;
        ~adoing_er: s&err
    }
    return q.C;
};
#c Co doN_speeding for %testrun=2
# check got exp and pull next step
#  steps&boost pauses
# < put next to the step puller
#   configurable step puller?
#    is the step with cognition on it, many appliables
me.doN_speeding = &acgtmS{
    # has the foreign Affair W...%run
    if (G&time,my&began_stepping > 5) {
        ~>6 Speeding longtime: m.t
        return 1
    }
    $r = my&run;
    $step = null;
    $stepn = null;
    me&ioty,r,'%step' .filter(&s{
        !step && s.t != S.t and return
        step && !stepn and stepn = s
        step ||= s
    });
    S.t != step.t and throw "Herestept"
    # don't check the last step, %run is about to
    !stepn and G&yl,0,4c&callback; return
    
    # steps&boost pauses
    steps&boost and return

    $doings = me&ioty,step,'%doing';
    Ss&z.length != doings.length and return

    $R = rc&N[0].y.I;
    R = me&Re,R,'nothings';
    Rc&N = [R];
    $ok = 1;
    each in doings {
        !ns&exp and throw "doing!exp"
        n = ns&exp;
        $C = Ss&z[i];
        $c = me&Copy,R,C,{ball:9,Lines:3,ov:8};
        cs&dige != ns&H and ~test2notok: S.t, C.t, cs&dige, ns&H
        cs&dige != ns&H and ok = 0
        #!ok and C.y.triedcopy = c;
        !ok and break
    }
    !ok and return
    # add another step
    $step = stepn;
    !step and return
    !steps&exp and throw "nextstep!exp"
    step = steps&exp;

    $c = me&Copy,R,step,{ov:12} .c.s;
    ms&z.push(c);
    ~>6 Speed: m.t, '->', c.t
};
#c Tests now we will try to make software:
me.Ja.lobbek =
me.Ja.happenings = &acgt{
    me&Gomp;
    $bit = 1s&bithold ||= G&Cye,['Bit',''];
    $b =
    n abit  s:lau %fopia
    i $b/$bit
    bits&bobs ||= 0
    bits&bobs --;
    #bits&bobs == -2 and throw "Unfielded quark"
    
    n Plethoria  $s:<<'' %oph:s
        # glampiture
        n now  s:noow %fs:54
    
    # < get rid of ^'s /^\t\t\t/
};
me.Ja.seeI = &acgt{
    me&Gomp;
    $Is = ['ravel','Cit','Beepingness'];
    each ik Is {
        $N = osu(C,k);
        $l =
        n $k 3
        ls&z = [];
        each iI N {
            G&m,ls&z,[I.t,Iy&cv];
        }
    }
};
me.Ja.XV = &acgt{
    me&Gomp;
    s&Ring = 'XVer';
    $eye = 1s&count-1;
    
    n A 2 $s:33
    n Saucerful 2 $s:55
    eye < 1 &&
        n of 32 $s:33
    eye > 1 &&
        n Secrets 35 $s:22
    n thy  $s:eye
    
};
# see history work
#   want to see Rc&X/V and Rs&X
#   across all instances of time
#   probably just from the top...

# a bit of history use
me.XVer = &acgtR{ return [
    ... me&DisplayTwoness ,
    ['Ring','2',&acgtRs{
        s&lv = 1;
        Rc&refs = [];
        Rc&refR = [];
        each in ss&z {
            n.t == 'thy' and Rs&count = nc&s;
            (ny&cv||0) < 0.2 and continue
            n $n.t  $stv:n,R %fr
        }
    },'if:h,D'],
    ['fr','2',&acgtRs{
        $p = Ry&up;
        if (s.t == 'Secrets' && ps&count == '2') {
            ps&Blewup = 1;
            pc&X.Blewup= 1;
            throw "chucka"
        }
        me&rollbs,R,'twang';
        
        Rs&twang ||= 0;
        Rs&twang < 8 and Rs&twang ++
        n twa  $s:sc&s %fs:16
        n for  $s:Rs&twang %hs:466
        ss&twan = Rs&twang
        
    },'ift,D'],
    ['Ring','4',&acgtRs{
        $b = Rc&b;
        each in Rs&gone {
            # yprev before
            $ni = bs&z.indexOf(n);
            $f = b.sc.z[ni-1];
            # now gets to know
            f = me&yfuture,f,R;
            ac(f,'remembers',nc&s.t)
        }
    },'if:h,D'],
    ['fr','6',&acgtRs{
        me&rollbs,R,'remembers';
        $r = Rs&remembers;
        r and ss&remembers = r.join(",");
    },'ift,D'],
] };
#c ravel about their state
# with localStorage stuck on 127.24.35.46:10202,
#  and in W/
# become straight, become curvy, cellvey
# have things wanting to be streamed uphill
# showing interfaces where things can come across

me.ravel = &acgtR{ return [
    #... me&Displayingness ,
    ... me&DisplayTwoness ,
    ... me&Rscinsideness,'ravel' ,
    
    # the living - a situation
    # slow rolling wakeup
    # openness is travelled in
    # up into cell
    ['gee','3',&acgtRs{
        Rs&rowish = 1;
        Rc&nl = 90000;
        # %ball %play-sers shot into T
        #  giving a pi? real/veyd layers of sc?
        #  e /T -run . %does:TeCo %boost:2
        Rs&playsheet = {
            ball: &acgtR{
                me&Bear,R,Rc&s,'play'
            },
            fix: &acgtR{  },
        };
        # A.4 to/run/from, shared
        # is the local stage, our gear projected on
        # land of ignoring your own mind
        me&introqua,0,'quiet','@1';
        
        n T  $s:sc&Travel,R %ball,bgh:383,slan_digify,beawake
        
        # < stuff above the line of W here
        
        n Tool  R %Tool
        
        # < the openness
        $opN = me&rollbs,R,'openness' || [];
        opN.unshift('Pass');
        each in opN {
            if (typeof n == 'string') {
                # open textfile
                n $n  $lookup:n,R %ballse
            }
            else {
                # some %ball s&W%fix%play becomes signpost leading in
                !ns&ball and throw "openness !%ball"
                $s = nc&s;
                $k = s.t;
                if (!localStorage[k]) {
                    !ns&toLines and throw "ball to store !toLines"
                    localStorage[k] = ns&toLines+"\n";
                    # < upgrading n%ball to separate storage,
                    #   taking its innards
                    # not working? could be much better expressed,
                    # in a desire with many pull/push parts
                    #!me&sch_gotstring,R,n and debugger;
                    #localStorage[k] = ns&string;
                }
                n $k  $lookup:k,R %ballse
            }
            #,dragelvis:projvey
        }
        # re-elect
        Rs&openness = [];
        
        n G  $kvstore:localStorage,R %ballse
    },'ift,D'],
    
    #c lookup %ball/*.t in G
    # assorted W you asked for, bay of incoming remotes
    #   elvising/G&t-ish interface to mysterious places
    ['lookup','2',&acgtRs{
        $g = Ry&up.sc.z.filter(g=>g.t == 'G')[0];
        !gs&ball and return T.wide = 1;
        # W holds many, to sync to G
        # with %lookup: highest/starting point
        $t = Rs&lookup;
        if (t != '1') {
            # < be othering ourselves, lending content
            #   to get instant %ball for things
            #   and so disconnections keep objects
            #     for packdown/gc
            #   specifying types of ephemerality:
            #     runspace kept tidier than piles
            $n = me&push,R,[],[t],'purpose';
            # ensure it's first in z
            $zi = ss&z.indexOf(nc&s);
            zi > 0 and ss&z.unshift(ss&z.splice(zi,1)[0])
        }
        
        # ready all s/* as R/*%balls
        me&Rsync,R;
        
        $N = me&ioty,R,'%ball';
        each in N {
            # posit they %push(ish) to G
            $l = me&push,n,['/','G'],[],'lookup','checkout';
        }
    },'ift,D'],
    
    ['continuity markers','28',&acgtRs{
        !(Rs&ball || Rs&push) and return
        $b = Rc&b;
        !b &&
        n newb o9 s:b %fs:7,hs:297
        if (b && bc&s != Rc&s) {
            n news o9 s:s %fs:7,hs:297
        }
    },'ift,D'],
    ... me&Ballingness ,
    ... me&Copyingness ,
    ... me&Pushingness ,
    ... me&Actingness ,
    ... me&Linesingness ,
    ... me&Diffingness ,
    
    ... me&Slepingness ,
    ... me&Toolingness ,
    #... me&Beepingness ,
    #c kvstore
    # accept %pushish as a name lookup first
    #  names %decode'd and pushed here
    #   they have a %delivered %ball stuck in the past
    ['kvstore','2',&acgtRs{
        # t source
        # weak %push
        # %pushin helps project lives from s
        #   as decode
        # looks at %balls pushing to it,
        #  look for them here
        #   pushing there 
        #  accept their content if full enough
        !Rs&pushish and return T.wide = 1;
        # tell %push to do
        # < search children for %othering
        # < upgrade %othering sense to
        #   any of the objects
        Rs&pushering ||= [];
        me&rollbs,R,'rememb';
        
        Rs&get_key_for = &t{
            return ts&H || t.t
        };
        Rs&arrange_decoder = &ksl{
            # arrange decoder
            $re = Rs&rememb ||= {};
            $kd = k+dig(s);
            $bc = {task:'ravel',Lines:1,intoa:'ball',noDisplay:1};
            bc.remova = &{ delete re[kd] };
            # keep the %balls with the decoding Lines stuff
            $S = re[kd] ||= me&Reis,R,k,s,bc;
            $Ss = Sc&s;
            Ssy&decoder = S;
            Ss&keepy = 'decoder';
            if (l) {
                # %pull%here=S, see below 
                $L = me&push,R,[],S,'decode','hard';
                # allow %their from ^ to look like l's %thing
                ls&deliverer = L;
            }
            return S
        };
        
        each il Rs&pushish {
            $t = ls&here;
            # a remote %push, for some id
            $k = Rs&get_key_for(t);
            $s = localStorage[k];
            !s and ls&new = 1; continue
            
            Rs&arrange_decoder(k,s,l);
        }
    },'ift,D'],
    ['kvstore','4',&acgtRs{
        !Rs&pushering and return
        $i = 0;
        while (Rs&pushering[i]) {
            l = Rs&pushering[i];
            $t = (Rs&pushering_ball||[])[i] || ls&here;
            if (ls&hard) {
                $S = tc&s;
                # %here%ball must be the same
                $still = ls&delivered && t == ls&delivered;
                if (!still) {
                    i Rc&s/-#S.t
                    n ush  s:ush
                    ts&keepy = 'decoder';
                    ac(R,'pushing_z',l,'ball',t);
                    # becomes %push%their
                    ls&delivered = t;
                }
            }
            else {
                # must have a Lines done
                !ts&ball || !ts&LinesN and throw "not %here=%ball%LinesN"
                $good = ts&string && ts&string.length > 7
                !good and throw "string dodgy"
                # redecode, sets/does another ls&deliverer since lookup
                #  checks it works,
                #  %move%pushed%their gets what was pushed
                $k = Rs&get_key_for(t);
                Rs&arrange_decoder(k,ts&string,l);
                localStorage[k] = ts&string;
                # < check it's what %push knew about when it pushed
                # < may contain several things to which you must link
            }
            i++;
        }
    },'ift,D'],
    #c further
    ['kvstore','6',&acgtRs{
        $N = me&ioty,R,'%ball';
        # hide innards
        each in N {
            ns&nofurtherDisplay = 1;
            # < in there ^
            $tee = n.t+"-further";
            n $tee  $self:n,R %tfurther
        }
        
    },'ift,D'],
    ['tfurther','3',&acgtRs{
        $g = Rs&self;
        s&ma = 0.2;
        me&tsc,'tfurther',g.t,'G','fs:12'
        (Rs&boost||0) < 1 and return
        Rs&rowish = 1;
        s&bo = '2px dotted green';
        s&hue = 30;
        s&br = 0.4;
        # create a bunch more lookups
        n $g.t  $self:g,R %Wirror
    },'ift,D'],
    # sync localStorage -> webserver
    # use 24/NutIns' new G&t (G&ting) and it's W mode
    # from the thing receiver outran the thing providor
    ['Wirror','3',&acgtRs{
        s&hue = 80;
        me&domesticate,R;
        $h = Rs&self;
        !hs&dige and h = hc&s.y.decoder
        !h and throw "nodecoder"
        $k = h.t;
        #k = 't/iooiatal';
        $C = me&rollcounty,R,'tinging',{per:k};
        
        # persist a Question
        $Q = s&Q ||= G&Cye,[k,'',{of:'W'}];
        # which may throw async
        $ting = &Q{
            $r;
            try { r =  G&ting,Q }
            catch (er) { }
            # gets stuck in pushing mode:
            delete Qc&s;
            return r
        };
        $r = ting(Q);
        # has a Pull, with the got content or not
        # almost looks ballish, a decoded C at c&s
        # < remotism, G tendrils of causality hung, shaft utils
        # < know if its state can be guaranteed by some news agent,
        #   prefer to hear of rather than go looking for news
        #   digwaypoll
        $P = Qs&P;
        
        !P and return me&tsc,'pleasewait','...','G'
        $del = G&time,Ps&now;
        del > 16 and me&tsc,'delta','>'+del+'s','b';
        me&tsc,'here','@'+hs&dige,'G'
        
        #n so  $self:C,R %sun
        !Pc&s and me&tsc,'notexist','⧁','G'
        else
        !Ps&dige and throw "eiwer"
        else
        Ps&dige == hs&dige and me&tsc,'equal','=','G';
        Pc&String == hs&string and me&tsc,'equals','==','G';
        else {
            # we have a P for the remote's branch
            # make it look like a ball so it can %diff
            Ps&ball = 1;
            Ps&Lines = 0;
            Ps&string = Pc&String;
            $d = me&diffya,R,'upstream',h,P,{hue:90};
        }
        
        (Rs&boost||0) < 1 and return delete s&qh
        Rs&rowish = 1;
        #c objects/names to copy
        $M = [];
        # write obj/$dige for versioning $h (if you know %H history)
        m h.t  $s:hs&string,dige:hs&dige
        
        # move depended objects first
        each in hs&LinesN {
            $s = nc&s;
            !ss&H and continue
            $string = localStorage[ss&H];
            !string and throw "Nolocal"
            
            $L = me.cby(n,&n{ return n == h });
            $path = L.map(n=>n.t).join('/');
            
            m $path  $s:string,aka:path,dige:ss&H
        }
        $qh = s&qh ||= {};
        $abug = 0;
        each in M {
            ns&ok = 1;
            $doq = &ts{
                $q = qh[t] ||= G&Cye,[t,'',{of:'W'}];
                $r = ting(q);
                $P = qs&P;
                $wai = &s{
                    ns&ok = 0;
                    ta(s);
                };
                $ta = &s{
                    $st = t[0] == 'o' ? '6' : '';
                    me&tsc,'waiting',t+s,st .sc.dis = 1;
                };
                # has a pull, has a result (decoded by G&ting)
                !P and return wai('..')
                Pc&String == s and return ta('==')
                # BUG stop it continually doing this later:
                #   losing P on update?
                #  just gets by if all updates succeed once
                abug = 0;
                Pc&String ? wai('!=') : wai('...');
                # write: add s to the question for next time
                qc&s = s;
                # next time
            };
            !nc&dige and throw "nodige"
            
            # a permanent object,
            #  excepting garbage collection (uninvented)
            #doq('obj/'+nc&dige,nc&s);
            
            # a place in the tree (Ha/Tothe/ThingthathasH)
            #   for some continuity in the git there
            nc&aka and doq(nc&aka,nc&s);
            
            if (!ns&ok) {
                Rs&in_progress = 1;
            }
        }
        if (abug) {
            # see BUG ^
            n so  $self:C,R %sun
            return
        }
        Rs&in_progress and return
        # change what links it all together
        Qc&s = hs&string;
        
        delete Rs&Te.sc.boost
    },'ift,D'],
    
    
    #c haveth
    # interesting comment rubble from drained %pull:
    
    # t individuals in any place
    #     < new/gone similar -> moved
    # %haveth=to %ball vaguely
    # %other=from %ball specifica
        # once turned up, may have an in-t and an out-t
    # concat modulat 1-2?
        # < overall, has it pushed? 
        # < state change here/there click show in %ball
        #     that %ball's %pushed_ball will be historic,
        #         have sc.z %fix and etc
            # should show up as an item to push
            #   push/display change fairly easily
            # conversely, n.t only implodes:
            #   (sch_ballonlyt) -> G&t-ish, pull almost auto
            # needs some opposite to search with
        # wants to Rc&refs s now?
        # and the usual two-step confusible C-C nametag
    # < if engaged, %ball 5 notifies us?
            # engage drawing up of planes
            # becoming matter for idea/diff/apply
    
    # give idea of where on screen such ref is from here
    # eg up/prev/in = up, up/next/in = down
    # < up = left, in = right
    ['haveth','3',&acgtRs{
        if (!Rs&haveth) {
            n nohaveth  s:!
        }
        delete Rs&elvis;
        # draw an arrow between two R
        $we = me.cby(R,&R{ return Rs&cell });
        $th = me.cby(Rs&haveth,&R{ return Rs&cell });
        $direction = "v";
        each in we {
            $t = th[i];
            t == n and continue
            # path separates
            i == 0 and throw "different cells"
            $f = th[i-1];
            each il fs&z {
                l == n and break
                l == t and direction = '^'
            }
            break;
        }
        $d =
        n direction  $s:direction %fs:17,lh:0.05,hs:346
        
        $p = Ry&up;
        R.t == 'other' and direction == '^' and ps&upward = 1;
        
        if (!Rs&self) {
            # no yon %ball
            #R.t == 'self' and throw "self no self"
            R.t == 'self' &&
                n ohno  s:!
            delete ds&hs; # green
        }
        # give other bigger arrow
        dc&s = dc&s == '^' ? '▲' : '▼';
        # < n should type styles into number etc
        R.t == 'other' and ds&fs = (ds&fs*1)+7
        # ◀ ▶
    },'ift,D'],
] };
#c rovo, mounts current problem
me.rovo = &acgtR{ return [
    # 284
    ... me&Beepingness ,
    
    ... me&DisplayTwoness ,
    ... me&Rscinsideness,'rovo' ,
    ... me&Ballingness ,
    ... me&Linesingness ,
    ... me&Diffingness ,
    ... me&Slepingness ,
    ... me&Actingness ,
    ... me&Toolingness ,
    # sleeperate the other thing
    # eg Elvisory%ball (or **)
    #  have a %slep injected by tangulate 27
    #  which checks %balls' input early with hindsight
    #    that means crawling around any %ball c&s
    #      < and the C%ball itself?
    #    and all other inputs
    #      which in the future
    #        all fall under Elvising
    #          and act like travelling X/V in tandem
    # %ball may %slan_digify:
    #   digs the landscape of each %ball down,
    #    into c&s.y.slandige
    #    and slan ignores it (or landscape would always change)
    # so then any Rs&Te.y.slandige is digs current elvising
    #   which can be saved with the work
    #     Ry&Te_slandige = Rs&Te.y.slandige
    #   which if conserving objects like Elvisory does,
    #     can be used to check if updates are within
    ['seeing','3',&acgtRs{
        Rs&rowish = 1;
        n Citula  $self:sc&s,R %Reis:Cit,set:Cit
    },'ift,D'],
    ['ning','3',&acgtRs{
        Rs&rowish = 1;
        s&lv = 1;
        $p = Ry&up;
        $D = pc&s;
        me&tsc,'arp','ning:'+D.t;
        
        if (D.t == 'seen') {
            # to deal sleep patterns/debug locally
            n Tool  R %Tool
            
            n visinghur  $s:1s&Te,R %ball,slan_digify
            
            if (4s&modeen) {
                #4s&modeen = me&yfuture,4s&modeen;
                n modeen  $s:4s&modeen,R %sun
            }
        }
        
        n Citula  $self:sc&s,R %Reis:Cit,set:Cit
        
        if (D.t == 'ajaying') {
            n vising  $self:A,R %Reis:Cit,set:Cit
            $vis = {sho:A.4};
            n visding  $gleep:vis,R %Citying
            
            $p = 4s&sleperp;
            p &&
            n pare  $self:p,R %Reis:Cit,set:Cit
            
            n visoring  $self:4s&elvisory,R %Reis:Cit,set:Cit
        }
    },'ift,D'],

] };

#c Toolingness
# medo for attachey/toggley %ball%fixes
# < applying styles
me.ballio = &acgtR{
    !R and throw "!youR"
    # < porting these to io knowing A%ball/C
    $mez = {
        # finds %ball.c.s
        forballs: &acgtR{
            if (!Rs&ball) {
                # to origin
                Rs&push and R = Rs&here
                else
                Rs&exp and R = Rs&exp

                Rs&Ropy and R = Rs&Ropy
            }
            !Rs&ball and throw "No a ball: "+R.t
            return Rc&s
        },
        link: &acgthr{
            h = mez&forballs,h;
            r = mez&forballs,r;
            i $h/$r
            return r
        },
        # < no way to io a move in one?
        # < i $h/$r<- # (should) remove r from ry&up
        move: &acgthr{
            # < might need forballs' to origin
            h = mez&forballs,h;
            $rp = ry&up;
            rp = mez&forballs,rp;
            r = mez&forballs,r;
            i $rp/-$r
            i $h/$r
        },
        # i $h/$r y o $r/**
        # < i $h/{clone}$r**
        # < numbers somehow referring to the level of data
        #   to which the awareness sinks before reemerging...
        #   ie 1 is everything reconstructed through text
        #   this'd be something including y.*,
        #    but not cloning properties/internals
        #    except tv/z, to repoint the structure
        clone: &acgthrc{
            c ||= {};
            h = mez&forballs,h;
            r = mez&forballs,r;
            $S = me&Copy,R,r,12;
            $s = Sc&s;
            c.aftCopy and c.aftCopy(S,s)
            i $h/-#$s:s
            i $h/$s
            return S
        },
        step: &acgthr{
            # has set Host = Remotey&up %step
            $c = {aftCopy:&Ss{
                # rename/number increment before io.i (tv)
                $title = s.t.split('_');
                $n = isnum(title.slice(-1)[0]) && title.pop() || 0;
                n++;
                title.push(n);
                s.t = title.join('_');
            }};
            return mez&clone,h,r,c;
        },
    };
    return mez
};
me.tangulate = &acgtR{
    $Te = Rs&Te;
    !Te and return
    if (Tes&Rz) {
        # just before R starts creating itself
        #  some forerbrain addons create themselves first
        $RN = Tes&z.filter(r => rc&R);
        each in RN {
            $z =
            n $n
            zs&Recipe = n;
            # anticipate becoming Real in Displayingness 27
            ny&Real = 1;
        }
        # insides get ahead
        T.Rq = {inside:R,ov:33};
        # and does Toolingness's 3%Recipe
    }
};

#c prop up M, ensures a lug.c like c
me.RMount = &acgtRc{
    $M = Rs&Mout;
    !M and throw "NoMout"
    $found = 0;
    each in M {
        # c checks n.c
        $ok = 1;
        each kv c {
            $s = n.c[k];
            s != v and ok = 0
            if (!ok) {
                # just yfuture?
                if (typeof v == 'object' &&
                    v.t == s.t) {
                    ok = 1;
                    if (v.y.R) {
                        ok = 0;
                        # should be able to be precise as yfuture,
                        me&yfuture,s == v and ok = 1
                        else
                        me&yfuture,v == s and ok = 1
                        # or maybe J/path/
                        if (!ok &&
                            me&namup,s,1 .join('/') ==
                            me&namup,v,1 .join('/')) {
                            ok = 1;
                            $was = me&namup,s,1 .join('/');
                            ~RMount resorts to path match: was
                        }
                    }
                    #!ok and debugger;
                    # a slep inside a slep has some history issue
                    # keeps spawning
                    #!ok and ~RMount nonmatch, same t: v.t
                    #ok = 1;
                }
                !ok and break
            }
        }
        !ok and continue
        found = 1;
        # then update them
        each kv c {
            n.c[k] = v;
        }
        break
    }
    #found and ~>4 Found:
    found and return
    #~>4 Lugging:
    lug = Rs&modlug();
    # put identifying things into lug.c
    ex(lug.c,c);
    # put lug in M (permanent)
    lug =
    m $lug
    # put lug in Rc&s for %aTool etc
    Rs&Middle(lug);
};
# get local Tool, may search
# < fatal
# see 2%Tool "t'ing it out"
me.RTool = &acgtR{
    !Rc&Tool and me.cby(R,&r{ return Rc&Tool = rc&Tool });
    $t = Rc&Tool;
    #!t and throw "NoTool"
    return Rc&Tool;
}

me.Toolingness = &acgtR{ return [
    # %Cit shows a thing
    ... me&Citingness ,
    # how %Cit etc can move around, become %doings
    ... me&Implantingness,
    # %displayon attaches Display units
    ... me&Renderingness,
    # newer diffing, for %slep_aTool
    ... me&Differingness,
    # < elvising to the local Tool to coordinate:
    #     wait for pattern
    
    # Real somewhere, made by %Recipe
    # insists on being in %Tool's M
    #   4%aTool gets %Recipe (later),
    #     also has %Remote, now Ry&up:
    ['Recipe','3',&acgtRs{
        $p = Ry&up;
        $r = Rs&Recipe;
        ry&Real != R and throw "NotRecipeReal"
        $t = me&RTool,R;
        !t and ~RecipeNoTool: p.t, '/', R.t
        !t and return
        #~>4 Recipeoutthere: p.t, '/', R.t
        # %Tool's M must have something like:
        $c = {Remote:p,Recipe:r,tool:R.t};
        me&RMount,t,c;
    },'ift,D'],
    
    
    #c Tool tray of icons to do tricks
    ['Tool','2',&acgtRs{
        Rs&rowish = 1;
        $J = A.1;
        Js&serial ||= 0;
        $M = Rs&Mout = Js&ToolMout ||= [];
        # controls for Tooling out there
        # < know dups with the scene but don't create any more
        # < generalised M-anagement
        
        # < take over Tool-ness for a locale
        # < t'ing it out, so it can become to R already departed
        me.cby(R).filter(r => rc&Tool = R);
        
        Rs&modlug = &{
            return G&Cye,['plug:'+(Js&serial++),'']
        };
        Rs&modeen = &acgtr{
            # r is not R
            $atool = r.t;
            $mode = rs&pickel || 'probe';
            # captures the next click
            T.pickel = &acgtr{
                $lug = Rs&modlug();
                lugc&tool = atool;
                lugc&Remote = r;
                lugc&Pointer = C;
                if (mode == 'probe') {
                    # elvise probes into R
                    lugc&Recipe = me&Tein,r,'Rz',[atool,6,{R:atool}];
                    # insides should transplant to rack,
                    #  especially if they s&down already
                    #  eg Reis:Cray pushes Displays up
                    # < figure out why this sticks on/off
                    #ns&nofurtherDisplay = 1;
                }
                elsif (mode == 'nab') {
                    # Remote is
                }
                else {
                    throw "what pickel mode: "+mode
                }
                # bug:
                T.wake = 1;
                # keep together in %Tool
                m $lug
            };
            ~picking: mode
        };
        n t  $s:R.t %hs:789
        n slep  s:● %fs:22,medo:modeen
        n sunn  s:● %fs:22,medo:modeen,inv
        n countlife  s:☪ %fs:22,medo:modeen,inv
        n nab  s:∝ %fs:22,medo:modeen,inv:0.7,pickel:nab
        n testruns  s:⊧ %fs:22,medo:modeen,inv:0.5
        
        Rs&Middle = &n{
            !n.t and debugger;
            $z = me&Ret,R,{t:n.t,s:n,aTool:1,refpool:1};
            # < Ring/ing clarify particle onramp
            me&zN,z;
            #n $n.t  $s:n,R %aTool,refpool
            # < sort out that CyC leads sourceward,
            #   CyO where it went? or D?
            #  we have z.y.R = R created by z
            # %aTool%boost<-1 removes it
            zs&remova = &{
                each im M {
                    m != n and continue
                    M.splice(i,1);
                    break
                }
                # and any elvising configuring it
                i Ry&up.sc.Te/-Rs&Te
                # through the doming?
                z = zy&R;
                # %aTool packdown/deprobe
                zs&alsoremova and zs&alsoremova();
            };
        };
        each in M {
            Rs&Middle(n);
        }
        #n stop  s:■
        #n redo  s:◀
        # wander?
        n play  s:▶ %fs:22
    },'ift,D'],
    #c aTool
    ['aTool','4',&acgtRs{
        Rs&rowish = 1;
        # looks elvisy
        # Rc&s is $lug in Tool%M
        # < pool names children can use as the things
        # < yfuture to currently awake R... a Tool is usu nearby
        # < yfuture breakdown + refind by sc&Pointer,
        #     a click elvis we can relookfor
        $r = Rs&Remote = sc&Remote = me&yfuture,sc&Remote;
        me&tsc,'tool',sc&tool,'q' .sc.bg = '#000';
        me&tsc,'Remote',r.t,'G';
        if (sc&Recipe) {
            $n = Rs&Recipe = sc&Recipe;
            # Recipe already y&Real,
            #  so is rs&Te - another way to find future?
            ny&Real ||= 1;
            ny&Real && isC(ny&Real) and Rs&Real = ny&Real
            # remove Recipe from Remote
            Rs&alsoremova = &{
                $Te = rs&Te;
                i $Te/-Rs&Recipe
            };
        }
        
        (Rs&boost||0) < -1 and Rs&remova()
        # closed but not disabled
        (Rs&boost||0) < 0 and return
        # open
        
        # BUG: just %Cit doesn't work:
        #   and this, if deleted, sticks on the screen
        n Remote  $self:r,R %Cit,tightly
        
        # %slep_aTool out there
        # when ready if Recipe
        if (!Rs&Recipe || Rs&Real) {
            $k = sc&tool+'_aTool';
            n Perspect  $R:k
        }
        
        if (Rs&Recipe) {
            $z =
            n Recipe  $s:Rs&Recipe,R %ball
            # < Ring that can return ^ yReal already,
            #   though the %yRealism bit is D<6
            
            # < M-anagement, its lifecycle of crud
            # < io.i futurism, putting/syncing to many places
            # hooked by %ball%boost<-1:
            zs&remova = &{
                # remove %aTool from Tool%M
                Rs&remova();
            };
        }
        
        Rs&Real &&
            n Real  $s:Rs&Real,R %Realism
    },'ift,D'],
    
    # the yReal diveinto
    ['Realism','3',&acgtRs{
        !isC(s) and return me&tsc,'yReal','..',6
        Rs&rowish = 1;
        me&tsc,'yReal','Real','q';
        n its  $self:s,R %Reis:Cit,set:Cit
        n show  $self:s,R %displayon
    },'ift,D'],
    
    # < G&c/T'ing messages to a debug channel
    # inject R-ing to the 
    ['Telife','35',&acgtRs{
        #$disr = me&Reis,R,'Cray',re;
        #me&Reis,R,'Cray',Rs&down;
    },'ift,D'],
    
    #c Tools
    
    # see data out there
    # can be Recipe'd into place,
    # < Ring-transcending timing options
    ['sunn','71',&acgtRs{
        $p = Ry&up;
        ps&ci+1 < Rs&ci and return T.wide = 1;
        me&tsc,'sunno','sunn','q' .sc.bg = '#000';
        Rs&nofurtherDisplay = 1;
        # < ensure this Display gets somewhere
        me&Reis,R,'Cray',p,{refpool:1}
    },'ift,D'],
    # show how many times this R has happened
    #   continuity by namup from A.1
    ['countlife','71',&acgtRs{
        $tee = me&namup,R,1 .join('/');
        $teec = 1s&tee_countlife ||= {};
        teec[tee] ||= 0;
        $i = ++teec[tee];
        me&tsc,'i',i,'q' .sc.bg = '#000';
    },'ift,D'],
    
    
    # < put somewhere else:
    # Reis: completes an R:$Reis
    #  in an R, funneling its Display
    # always gives a new refpool,
    #  and first rs&self from Rs&self
    # Reis=Cit% does R:Cit %Cit
    # Reis=Cit%la does R:Cit %la
    ['Reis','3',&acgtRs{
        $c = {refpool:1,self:Rs&self};
        $k = Rs&Reis.split('%');
        c.task = k[0];
        k[1] != null and Rs&set = k[1] || k[0];
        Rs&set and c[Rs&set] = 1;
        # Rs&TeImplant is observed from below:
        c.rec = ex({},c);
        Rs&ReisR = me&Reis,R,R.t,null,c;
    },'ift,D'],
    
    
    #c nab_aTool
    ['nab_aTool','3',&acgtRs{
        $p = Ry&up;
        Rs&Remote = ps&Remote;
        !Rs&Remote and debugger;
        $s = pc&s;
        Rs&modeen = &acgtr{
            # r could be in a %run/%step or in W
            $template = r.t;
            if (rs&Hostup) {
                $re = Rs&Remote;
                !re and debugger;
                sc&Host = rey&up;
                sc&As = template;
                return
            }
            # captures the next click
            T.pickel = &acgtr{
                !ry&R == r and throw "pick an R"
                sc&Host = r;
                sc&As = template;
                ~Pluycks
            };
        };
        # < re-find Host and Remote by path,
        #  < Remote = latest %step%ok
        #   < continuous push Te/edges->latest PuTe
        # < and copying the latest %step%ok,
        #   to keep %H so diff is of changes
        $mez = me&ballio,R;
        # < ensure this Display gets somewhere
        if (sc&Host) {
            $reselect = me&rollbs,R,'Host' != sc&Host && Rs&Host;
            Rs&Host = sc&Host = me&yfuture,sc&Host;
            n Host  $self:Rs&Host,R %Reis:Cit%
            
            if (sc&As) {
                Rs&As = sc&As;
                $t = Rs&As+':';
                $k = 'nab_'+Rs&As;
                $mo =
                n $Rs&As  $s:t %fs:11,medo:modeen
                if (mez[Rs&As]) {
                    # some kinda...
                    me&rollbs,R,'done' and return me&tsc,"Done"
                    mez[Rs&As](A,C,G,T,Rs&Host,Rs&Remote);
                    Rs&done = 1;
                }
                else {
                    # makes an R%nab_$As,
                    #  probably making an %$As:
                    moc&s = '%'+moc&s;
                    $tem =
                    n $Rs&As  R:1
                    tem.sc[k] = 1
                    reselect and tems&reselect = 1
                    reselect and me&tsc,'reselect',null,'g'
                }
            }
        }
        else {
            # add/update %testrun %step W:PuTe%doing
            n PuTe  s:%PuTe? %fs:11,medo:modeen
            # copy somewhere
            n link  s:link %fs:9,ma:1,medo:modeen
            n move  s:move %fs:9,ma:1,medo:modeen
            n clone  s:clone %fs:9,ma:1,medo:modeen
            # not picking, set Host = Remotey&up
            n step  s:step %fs:9,ma:1,medo:modeen,Hostup
        }
    },'ift,D'],
    #c nab_PuTe
    ['nab_PuTe','5',&acgtRs{
        $n = Ry&up; # %nab_aTool
        $p = ny&up; # %aTool
        $s = pc&s; # Tool%M lug
        s&fs = 12;
        
        # find a step to put this in
        #   up to %run/%step/%doing
        #     or %ball(%testrun/(%step))
        # < new steps if %run
        # happens continuously,
        #  will chaos if for one of many City run through
        $S;
        $N = me.cby(sc&Host,&r{
            $p = ry&up;
            !p and return
            $s = pc&s;
            if (rs&doing || rs&step || rs&run ||
                ps&ball && rs&ball && ss&testrun) {
                return S = r
            }
        });
        $puts = &ts{
            n $t  $self:s,R %Reis:Cit%
        };
        if (!S) {
            return puts('StepNotFound',N)
        }
        if (!Ss&ball) {
            if (Ss&run) {
                throw "new step %run?";
                # S = make-new-step, as %push does
                # then DoingFor = its doing (%ball)
            }
            if (Ss&doing) {
                # PuTe before a doing
                if (!Ss&exp) {
                    return puts('DoingNoExp',S)
                    #and throw "doingnoexp"
                }
                sc&DoingFor = S;
                S = Sy&up;
                !Ss&step and throw "!Step"
            }
            if (Ss&step) {
                # PuTe before step's doings
                !Ss&exp and throw "stepnoexp"
                S = Ss&exp;
            }
            else {
                throw "Nonball/step"
            }
        }
        # < ^ should be a few lines max
        !Ss&ball and throw "Not at ball"
        $D = sc&DoingFor;
        # locate the %doing in W/...
        $before;
        if (D) {
            $g = Ds&got;
            !g and me&tsc,"DoingFor!got",null,'6'
            $x = Ds&exp;
            !x and throw "DoingFor!exp"
            if (x.t == 'City') {
                # forget nabbed thing?
                #   update City/(*) got->exp
                $z = gc&s;
                $zTe = zy&zTe;
                !zTe and return me&tsc,'?'
                $Te = me&Copy,R,zTe,18 .c.s;
                # < stream, differ?
                !xs&ball and throw "x!ball"
                # that is the one after TeCo,
                #  goes directly to W/.../$exp s:
                x = xs&Copy;
                !x and throw "no prior"
                !xs&z and throw "unz"
                i $x/-#$Te
                i $x/$Te
                while (xs&z.length > 10) {
                    xs&z.shift();
                }
                n zTe_updating  $self:x,R %Reis:Cit%
                return
            }
            $xo = xs&Ropy;
            if (!xo) {
                n ExpNoRopy  $self:x,R %Reis:Cit%
                return
            }
            !xo and throw "DoingFor exp !Ropy"
            !xos&ball and throw "Doing exp Ropy !ball";
            before = xoc&s;
            
            # might be !ball?
            n DoingFor  $self:D,R %Reis:Cit%
        }
        #c and the %step in W/...
        $st = Ss&Ropy;
        !st and throw "Step !Ropy"
        $step = stc&s;
        !step and throw "Step Ropy !C"
        # < looking at stc&ss&z (C) in sts&z (R)
        #   io handling A/C
        n Step  $self:S,R %Reis:Cit%
        
        $P = me&rollbs,R,'PuTe';
        P &&
        n PuTe  $self:P,R %Reis:Cit%
        before &&
        n before  $self:before,R %Reis:Cit%
        
        if (Rs&reselect) {
            P = null;
            
        }
        P && (Rs&boost||0) < 1 and return me&tsc,'stop','stop','g' .y.cv=0.7
        
        # wants a PuTe%doing:
        $P = Rs&PuTe = G&Cye,['PuTe',1];
        $r = me&Copy,R,sc&Remote,18 .c.s;
        # by ^ we have X for a bunch of new stuff
        i $P/$r
        # then $P into the test data:
        
        # PuTe%doing maybe already there
        $already;
        # or to be spliced into where %doing is (in W/.../%stepc&ss&z)
        $xi;
        if (before) {
            # ^ the W/.../%doingc&s for a %doing we clicked
            # put PuTe before this %doing
            xi = steps&z.indexOf(before);
            if (xi < 0) {
                # try harder, resolve by name instead
                o $step/#$before
                before = ays&before[0];
                !before and debugger
                xi = steps&z.indexOf(before);
            }
            xi < 0 and debugger;
            # throw "No such doing in step"
            $xa = steps&z[xi-1];
            # update self:
            before.t == 'PuTe' and already = before
            else
            # update self, clicked %doing after it
            xa && xa.t == 'PuTe' and already = xa
        }
        else {
            # beginning of %step
            xi = 0;
            $xa = steps&z && steps&z[xi];
            xa && xa.t == 'PuTe' and already = xa; xo = null
        }
        if (already) {
            # see io z dupe bug in displayon
            i $step/-#$already
            i $step/$P
        }
        else {
            i $step/-#$P
            i $step/$P
        }
        
        if (xi != null) {
            $inow = steps&z.indexOf(P);
            inow < 0 and throw "fail"
            if (inow != xi) {
                steps&z.splice(inow,1);
                steps&z.splice(xi,0,P);
            }
        }
        # etc and just noticed:
        # BUG via testruns stops acceptance applying...
    },'ift,D'],
    
    
    #c testruns GOING?
    ['testruns','6',&acgtRs{
        $p = Ry&up;
        !ps&ball and throw "for %ball"
        $M = [];
        # find any %testrun in a few layers of %ball
        # similar to me.cbu but down, for %ball and then ss&testrun
        # < me.cbu(p,'ball','z','testrun') ?
        # < o **%ball$%testrun
        # < %balls may look in known/Berson gov/central index
        $lookfortestruns = &pd{
            d ||= 0;
            d++;
            d > 3 and return
            $N = me&ioty,p,'%ball';
            each in N {
                $s = nc&s;
                ss&testrun ? M.push(n)
                    : lookfortestruns(n,d)
            }
        };
        lookfortestruns(p);
        =pod
        o play %pushes
        o T%ball receives %moves
        o W:Co
        o T%ball again,
           for some %step/%doings
             which each have been waiting since play %pushes
           which causes more %moves, goto 20
        
        asyncily without any async,
        unless something !ok, then stops.
        
        BUT THEN,
         it looks like all the %plays simultaneously works ok
        and besides, its complicated and subject to change.
        averted by tes&almost, all this other complicated stuff.
          wants T itself and really good visual A debugger.
        how clearly that thing could unfold in a namepond...
        
        =cut
        Rs&rowish = 1;
        me&tsc,'testruns';
        me&tsc,'count',M.length,'g';
        each in M {
            n $n.t  $s:n.t %ma:0.5,fs:8
        }
        (Rs&boost||0) < 1 and return me&tsc,'dotestruns','?','G'
        delete Rs&Te.sc.boost;
        
        $current;
        $began = G&time;
        each in M {
            # %play them all
            $te = me&introqua,n,{play:1}
        }
        # collects nothing
    },'ift,D'],
    
]};

#c R ing , collecting rays, bouncing across matter
# diving gear, has a middle you can steer it from
# like ind but leaving Rs, looking at the points across it
# A becomes the looking
# runs once, then you compare your copies of it...
# can only travel one property at a time, d.k
# < path as a function climbing d.up
# 
me.ing = &acgtsR{
    $cb;
    typeof R == 'function' and cb = R; R = null
    R ||= {t:'ing',y:{},c:{s:s,N:[]},sc:{}};
    cb and Rc&middle = cb;
    $s = Rc&s;
    # a way to depth-first, see slep
    Rc&N && Rc&N.indexOf(R) > -1 and return
    
    # limits want workarounds
    $limit = &s{ me&Rec,R,s };
    
    !Rc&refs and Rc&refs = []; Rc&refR = [];
    if (s && typeof s == 'object') {
    # dedupe/limit objects already in this pool
    $ri = Rc&refs.indexOf(s);
    if (ri < 0) {
        ri = Rc&refs.push(s) - 1;
        Rc&refR ||= {};
        Rc&refR[ri] ||= [];
        Rc&refR[ri].push(R);
    }
    else {
        $h = Rc&N[0];
        # see the per-ref R table
        $RN = Rc&refR[ri];
        Rs&refR = RN;
        RN.push(R);
        # in this pool
        $RhN = RN.filter(r => h && rc&N == hc&N);
        $nvm;
        if (Rs&dupup) {
            # when -known also -unknown inside itself
            RhN.indexOf(Ry&up) >= 0 and nvm = 1
        }
        if (!nvm) {
            $dupl = Rc&dupl || 0;
            if (RhN.length > dupl) {
                limit('dup');
                Rc&nofurther = 1;
            }
            else {

            }
            !Rc&nofurther and limit('dub')
        }
        # < to know circular links, converge
    }
    }
    # sprawl limits
    Rc&dl && Rc&dl < Rc&d and return limit('dl')
    Rc&nl && Rc&N && Rc&nl < Rc&N.length and return limit('nl')
    Rc&N ||= [];
    
    # make a callback
    Rc&middle ||= A&middle;
    !Rc&middle and throw "nocb"
    # that emits more R
    
    # 6 framing
    Rc&middle(Rc&s,R);
    
    R.c.not and return
    
    # accepted into the list of atoms
    # < out of order mode
    # < place more carefully under Ryup and its z
    Rc&N.indexOf(R) == -1 and Rc&N.push(R)
    
    Rc&nofurther || !Rs&z and return
    
    # middle gives more options to try
    $z = Rs&z.slice();
    each ir z {
        rc&N != Rc&N and continue
        r.c.not and continue
        me&ing,rc&s,r;
    }
    return R
};
#c RbitX arrives
=pod

Receive the past (V) and make a now (X)

# X is the space index...
#  of X.x.$bit = X (inwards)
#     X.z = [ R nodes
simply inherited, moved into, children made with
cX/V is carelessly inherited
each R goes inside each
 toplevel R=I, r=C, makes IcX

  Re gives children:
    # X - names for history
    rc&X = Rs&X ||= {};
    $b = Rc&b;
    # V - names from history
    rc&V = b && bs&X ? me&RbitXtend,bs&X : {};

see me.RbitXingness in DisplayTwo,
  for putting arrive/gone/apply in time
=cut

# the named self resolves in 17:
me.arriveRbitX = &acgtR,bit{
    # X goes inside
    #  RcX = Rs&X = {} at Resurrect
    #   Re inherits us RcX and RcV,
    #    we simply move into the name we are
    $X = Rc&X ||= {};
    # %sleeping %notsleeping should unrecycle
    X.recycled and me&unrecycleRbitX,Ry&up,bit,R
    # < X.up more conducive to simple transplants
    X.top ||= {};
    X.x ||= {};
    X = Rc&X = X.x[bit] ||= {top:X.top};
    X.x ||= {};
    X.z ||= [];
    X.z.length and 'dups allowed'
    # it could also be a sleeping stub eg under an %onlyish
    X.recycled && me.unrecycleRbitx and me&unrecycleRbitx,R,X
    $i = X.z.push(R);
    # me&Re gives children X from this point
    Rs&X = X;
    # < the simple inheritance isn't simply implemented

    # someone gave you V that used to be X
    # but let's depend on X.z being as it was, not X.x
    #  to make history easier to forge
    $V = !Rs&igV && Rc&V && Rc&V.x && Rc&V.x[bit] || {};
    R.t == "Flar" && Rc&b && !haks(V) and debugger
    # X (new) must hold which V (old) z we're up to
    $b;
    if (V && V.z && V.z[i-1]) {
        b = V.z[i-1];
        # V is an X becoming the past
        bc&X != V and throw "bcX != V"
        # let yfuture find b->R if not commit
        # not for anything else
        V.newz ||= [];
        V.newz[i-1] = R;
    }
    # care to leave history (Re)
    # = V ? me&RbitXtend,V : {};
    Rc&V = V;
    Rc&V == Rc&X and debugger
    R == b and debugger
    b and Rc&b = b
};
# clone for destructive history
me.RbitXtend = &acgtV{
    V = ex({},V);
    V.z and V.z = V.z.slice()
    V.x and V.x = ex({},V.x)
    #delete V.newz;
    return V
};
# rollback a part of X
me.resetRbitX = &acgtRr{
    $b = rc&b;
    # reset X, failed R don't become b
    each tX Rc&X.x {
        X != rc&X and continue
        Rc&X.x[t] = bc&X
    }
};

#c   and is supposed to be completed by 4
# < by the time it is 4?
# < decide moves by new/gone pairs with similar appearance
#   the thing producing changes may be willing to help
me.goneRbitX = &acgtR{
    R != Rc&N[0] and throw "!head"
    # atoms in locations, another lives
    $N = Rc&N;
    each iR N {
        $b = Rc&b;
        $s = Rc&s;

        $V = Rc&V;
        $X = Rc&X;
        if (V) {
            each kv V.x {
                $x = X.x[k];
                # @93, R:Display, not around yet
                # < Doming stuff provides separation,
                #   not really here-ness,
                #   part of the oscillator of,
                #   like the different $W.dis files
                k == 'Display' and continue
                if (!x || x.z.length < v.z.length) {
                    # < filter to goners yup==Rc&b
                    Rs&gone ||= [];
                    Rs&gone.push(... v.z.slice(x ? x.z.length : 0));
                }
            }
        }
        Rs&gone and me&chR,R,'Goners:'+(Rs&gone.length)
        !b and me&chR,R,'new!'
    }
};
# commits the wiring of past to future at 91
#  almost at the same time osc/I will
# before Display
me.applyRbitX = &acgtR{
    R != Rc&N[0] and throw "!head"
    $N = Rc&N;
    each iR N {
        $b = Rc&b;
        
        each ir Rs&applyRbitX {
            me&applyRbitX,r
        }
        
        !b and continue
        if (Rc&X.recycled) {
            # recycled inners Ry&up olds
            #  unless something yfutures the slope,
            #  this could make es&tunnel[i] != Rc&b
            each ir Rs&z {
                ry&up = R
            }
        }
        # check this is still our history?
        # eg. the second slep/slan takes over X.newz
        #   after a deleteRbitX reduces X.z
        #Rc&V.newz.indexOf(R) >= 0 and continue
        b == R and debugger
        by&future = R;
        # no further back
        !bc&b and continue
        b = bc&b;
        !bc&b and continue
        b = bc&b;
        !bc&b and continue
        b = bc&b;
        delete bc&b;
    }
};
#c   RbitX ops

# o n%X/$x=$t, returning one /$n=$r
#  many $t=[t,t,t] climb eg tpath
#  ! the $x there is the name of the $bit=R.t index, X.x
#   weird and archaic
#  used by &unpacke
me.RbitXt = &acgtnt{
    # < sub this
    isar(t) and return t.map(&t{ n = n && me&RbitXt,n,t; return n })
    $X = nc&X
    $oX = X && X.x && X.x[t]
    oX && oX.z and return oX.z[0]
}
# keep history of unhad children
# sleeping @28 may do this for you
#  and adds them to Rs&z
# they may still arrive: unrecycle
me.recycleRbitXz = &acgtRc{
    $b = Rc&b;
    !b and throw "recycle !hist"
    Rc&X.recycled and return
    $ig = [];
    each bit,oV bc&X.x {
        # no support for dupes, which share an X
        # would take merging the new over the old or so,
        Rc&X.x && Rc&X.x[bit] and continue
        Rc&X.x ||= {};
        Rc&X.x[bit] and ~>7 recycle already: R.t, bit
        Rc&X.x[bit] = oV;
    }
    # %sleeping %notsleeping should unrecycle
    Rc&X.recycled = 1;
    # and links to their last selves
    # < io may notice the z !tv
    #   me&ioty just looks at z
    Rs&z ||= [];
    $avoid = [];
    each in Rs&z {
        nc&b and avoid.push(nc&b)
    }
    each in bs&z {
        $ni = avoid.indexOf(n);
        ni >= 0 and ~>5 Ret-before-recycle: R.t, n.t
        ni >= 0 and continue
        c && c.where && !c.where(n) and continue
        ac(R,'z',n);
    }
};
# remove thing from its present history
# causing dup identities to crosswire, an interesting area...
#  so the early slep/scan inherits the later
me.deleteRbitX = &acgtr{
    $R = ry&up;
    $X = Ry&up.c.X;
    each bit,oX Rc&X.x {
        oX == rc&X and delete Rc&X.x[bit]; break
        # also no support for dupes, which share an X
        #  would be a deep search for $R/**
        #   splicing out of X.z
    }
};
# as above but not so far inside
# from R knowing bit is about to happen
# eg removes recycled Display, anything awake for %sleeping
#  %sleeping .y.Display gets set
# < more proper... R%sleeping spawns r:%notsleeping?
me.unrecycleRbitX = &acgtRtr{
    $bit = t;
    $oV = Rc&X.x[bit];
    !oV and return
    delete Rc&X.x[bit];
    Rc&X.unrecycleX = 1
    !Rs&z and return
    each in oV.z {
        $ni = Rs&z.indexOf(n);
        ni < 0 and continue
        Rs&z.splice(ni,1);
        !r and continue
        # keep order of Rs&z dappled awake
        # < N-order, is overcome by placeness (Lines, etc)
        $ri = Rs&z.indexOf(r);
        ri < 0 and debugger
        # if removing before it, put -1
        ri < ni and ni--
        $out = Rs&z.splice(ri,1);
        Rs&z.splice(ni,0,r);
    }
}


#c growing R

# Ret-urn what's out there, growing R
# using Rc&emit,change to push new R into R-ing
# s = C
me.CaR = &acgtRs{
    # yon J, parts Aing,
    # < joins os? instead of 1s&on being the thing
    $n = s.y && s.y.A;
    if (n && n.1 != A.1) {
        Rc&nofurther = 1;
        $J = n.1;
        #!Js&on and throw "Yon J not ready: "+J.t
        Rs&J = J;
    }
    # way in
    if (ss&z) {
        each iD ss&z {
            !D and continue
            me&Ret,R,{s:D}
        }
    }
    # also y.tv, y.in, etc...
};
# data/anything
me.daR = &acgtRs{
    if (typeof s == 'object') {
        each kv s {
            me&Ret,R,{t:k,s:v}
        }
    }
};

# of Rc&ha being R with hoistables

# Rodulat pool coms
# send message upwards
me.Rec = &acgtRs{
    $h = Rc&N[0] || R;
    $a = hc&ha ||= {};
    if (s.length == 2) {
        # dl or nl count
        # too small and Reality has missing parts
        # too large and stupid takes forever
        $tee = me&namup,R .join('/');
        $was = '>'+R.c[s];
        !a[s] and ~>8 newha: s, was, tee
        #!a[s] and debugger
        a[s] ||= 0;
        a[s]++;
    }
    else {
        # others list nodes of trouble
        $m = a[s] ||= [];
        m.push(R);
    }
}
# s collects pile of reasons for Rs&cha
# < R-centricism, layered change, to phases
# < lossless.. for any R and any of its complains and their anyness.
# < with an index grouper, to merge the complainso
#   perhaps note which R have what symptoms,
#     then the R notes which symptoms are where.
# debuggy noise at this point...    
me.chR = &acgtRs{
    Rs&cha = 1;
    Rs&Rch ||= [];
    Rs&Rch.push(s);
    A&chR ||= {};
    $ch = A&chR[R.t] ||= [];
    ch.push(s)
};
#c Realise t
# the awkward toplevel
# optional previous R
me.Resurrect = &acgttR{
    $r = R;
    R = {t:t,y:{},c:{},sc:{}};
    # doesn't ing, tapes itself
    Rc&N = [R];
    # Rc&X, keeping the start in Rs&X
    Rc&X = Rs&X = {};
    # children (Re) will V = upc&bs&X || {}
    r and Rc&b = r
    # a spiral of names coming back to itselves
    r && rc&b and delete rc&b
    # children should not .y.up = I
    Ry&R = Ry&I = R;
    # each rc&N[0] should Ic&head[t] = [R{c&N*r}]
    return R
};

# get R, s and R's middles to stream work
# new Re, ing & middle work as progress stream ala A
# R is basically an exploration of A
#  lets get pictures of the R joining first
# $r = me&Reis,I,'C',C;
#  R.t='C', Rc&s=C
#   then me&Re will Rs&task||=R.t
#     then early I:C changes R.t to tv-bit
#  Rc&s = C
# or:
# $r = me&Reis,R,{task:'rovo',t:'bit'}
me.Reis = &acgtRtsc{
    c = typeof t == 'object' ? t
        : ex({t:t,s:s},c||{})
    $r = me&Re,R,c;
    me&Ring,r;
    return r
};

# new R pool
# sprout node in new pool...
# < these want to know each other,
#   the many bits of work
# < put waves of orders through with P
#   such that early R can sleep, latereRs can life
#   like the ghost is still, pure activity
# dime flange
me.Re = &acgtRc{
    $r = me&Ret,R,c;
    delete rc&nl;
    delete rc&dl;
    delete rc&N;
    # grasp task, eg Pond
    rs&task ||= r.t;
    if (Rs&z) {
        # is not a dive for the above R-ing
        Rs&z.slice(-1)[0] != r and throw "unlast"
        Rs&z.pop();
        # Reason section ...
        $I = Rc&N[0];
        I = I && I.y.I;
        if (I) {
            Ic&head ||= {};
            $hz = Ic&head[r.t] ||= [];
            # if many R:C sprout many R:Knowing in one pool
            #   if hs&joinR we ry&I but r != rc&N[0]
            $h = h && h.length == 1 && h[0];
            if (h && hs&joinR) {
                rc&N = hc&N;
                # < avoid Ringing on the way out of Reis
            }
            else { hz.push(r) }
            r.y.I = I;
        }
    }
    rc&d = 0;
    # nor its N (set)
    rc&N ||= [];
    # X - names for history
    rc&X = Rs&X ||= {};
    $b = Rc&b;
    # V - names from history
    rc&V = b && bs&X ? me&RbitXtend,bs&X : {};
    return r
};

# new R, same pool
# like G&A, but many R to an A, which (dispatch to) ... of thought
# R.c inherits, R.y.up up/out and Rs&z down/in
me.Ret = &acgtRc{
    $r = R;
    R = ex({},R);
    R.y = {R:R};
    R.c = ex({},R.c);
    delete Rc&s;
    delete Rc&b;
    delete Rc&ha;
    Rc&d = (Rc&d||0) + 1;
    R.sc = {};
    if (r) {
        R.y.up = r; 
        rs&z ||= [];
        rs&z.push(R);
    }
    if (c.refpool) {
        # we become a pool of refs
        #  something about A.1-9
        #   the magnitude of a distance
        $p = delete c.refpool;
        if (p != '1') {
            !isC(p) || !p.y.R and throw "refpool !R"
            Rc&refs = pc&refs;
            Rc&refR = pc&refR;
            
        }
        else {
            Rc&refs = [];
            Rc&refR = [];
        }
    }
    each kv c {
        $to = k == 't' ? R : k == 's' ? R.c : R.sc;
        to[k] = v;
    }
    return R;
};
