# yip[]
  // start from Sevo
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    4c&fps = 1;
    # loop comebacks between attentions
    $lastwas = 0;
    me.star = &acgt{
        !A.on.ownerDocument.contains(A.on) and return 4s&dead = "Unplugged"
        $me = A&me;
        $starts = G&time;
        lastwas and 4s&nonms = G&time,lastwas;
        $Y = A;
        A.on.A = A;
        #A.noelvis = 1;
        $frames = 1000/A&fps;
        frames += A&brake ||= 0;
        A&brake > 0 and ~braking: A&brake
        A&brake > 7000 and A&brake = 7000

        4c&callback ||= &{ me.star(Y,C,G,T) };
        $sing = 4c&callback.singly = {};
        G&yl:frames,&{ sing == 4c&callback.singly && 4c&callback() };

        try { me&starc }
        catch (e) {
            $async = e.message.match(/^async/);
            # assume requests complete between framerates
            if (!async) {
                # or staccato explosions
                A&brake += 2000;
                throw e, 'star'
            }
            ~Ytp: e.message
        }

        $ends = G&time,starts;
        4s&ms = ends;
        lastwas = G&time;
        # aim for a third of our time in the loop
        ends > (frames * 0.1) and A&brake += 200
        elsif (A&brake) { A&brake -= 100 }
        4s&busyratio = ends / frames;
        4s&busyratio < 0.001 and delete 4s&busyratio;
    };
    # medo from wobulus
    me.pause = &acgt{
        return 4s&paused = !4s&paused
    };
    # cast gazet
    # this is a bag of marbles, they are free and together
    me.starc = &acgt{
        $A = G&Aye,'star';
        $g = A.ground = G&Cye,[me.timestamp(),{},{root:1},{}];
        # clusp
        4s&paused and return
        # already part of some self-reflexive time
        4s&upghost and me&doupghost
        4s&downghost and me&dodownghost
        !me.inita.ed and me&inita

        # 1/10th attend
        A&sip.slice(-1)[0] == 0 and me&otherandcontinue

        4s&Jays = 0;

        me.Fourism and return me&Fourism
        me&J,'wobulus';
    };
    # elvis/S reroute
    me.inita = &acgt{
        me.uY = A;
        # for 25/Domes/S
        4c&Srupto = &A,C,G,T,s,t,talk,params{
            return me&Srupto,s,t,talk,params
        };
        # for w EleVisAn
        4c&elvrupto = &acgt{ me&elvrupto };
        me.inita.ed = 1;
    };
    #c sidetrack
    me.otherandcontinue = &acgt{
        # #msgs: log of random talky elements
        if (4s&msgs) {
            $m = $(4s&msgs).children();
            m.length > 2330 and m.slice(2290).remove();
        }
        # the ACGT-remembering equivalent of #msgs
        if (4s&log) {
            4s&log = 4s&log.filter(&l{
                return G&time,ls&now < 15
            });
        }
        if (4s&N) {
            4s&N = 4s&N.filter(&Y{
                if (Y.4 && G.DNS[Y.4.t] != Y.4) {
                   #~TheirAnd: ki(Y.4)
                }
                else { return 1 }
            });
        }
    };
    # returns A:ws to $t,
    #   or maintains given Y:ws, like me.Resurrect
    # eg W:digwaypoll is for mirroring ws:/digwaypol
    #  notifying ghost updates
    me.ws = &acgttY{
        A = Y || G&Aye,'ws';
        $ws = A&ws;
        ws && ws.readyState == 1 and return A
        if (ws) {
            # < non-new non-ready?
        }
        else {
            A&s = t;
            A&url = 'ws://'+location.host+'/'+A&s;
            ws = A&ws = new WebSocket(A&url);
        }
        ws.onclose = &ev,la{
        };
        ws.onerror = &ev,la{
            debugger;
        };
        ws.onopen = &ev,{
            ws !== A&ws and return ~sockalivedupe: A&ws
            ~connected: ws.url
            A&open and return A&open(ws)
        };
        ws.onmessage = &ev,la{
            4s&dead and return ws.close()
            $s = ev.data;
            if (A&receive) {
                A&receive(s)
            }
            elsif (A&receives) {
                $l = s.split("\n");
                l.slice(-1)[0] == '' and l.pop()
                A&receives(l)
            }
            else {
                throw "unhandled ws", ws.url, s
            }
        }
        return A
    };

//#c Cav-on 7dress html
    # and whatever after the state of atoms is got (osc/3)
    # really it does 4 here - catching state of properties changing
    #   some sleep/wake
    # < inc versions of styles applied
    # 5 + 6 in Css, translating properties to another language
    # but could end up in multifaceted games, showing working, etc...
    me.Cavon = &acgtR{
        $N = Rc&N;
        each iR N {
            $b = Rc&b;
            $C = Rs&C || Rc&s;
            Rs&on ||= b && bs&on;
            # originsleeping and ..?
            if (Rs&originsleeping) {
                !b and throw "Disleep !b"
                Rs&J and throw "Disleep J"
                Rs&on !== bs&on and throw "Disleep ons not exactly"
                # keep css state
                me&rollCscon,R;
                # and Rs&down later in Cupon
                continue
            }
            Rs&on ||= $("<stylehouse>")[0];
            
            # each A.1 does os, plants sequencer of 
            if (Rs&J) {
                $(Rs&on).css('display','block');
                $J = Rs&J;
                # 1s&on noticed
                Rs&in = Jc&on || Js&on;
                b && Rs&in != bs&in and me&chR,R,'Jin'
                continue
                # more to think mode?
                # expand/see into Js&v, write on this atom
            }
            # C.sc decorate
            me&Cscon,R;
        }
    };
//#c Cscon
    # apply styles to html.. expand unto copies of this thing,
    #   allowing a compressed notation to turn into styles,
    #     giving space to dream of altering the situation
    #     as the matter forks along a path of progress
    #   (we may use d to collect & export workings)
    #     and the whole osc atomism
    #   into css styles
    $verbose = 0; # causes window.styletos to list styles
    $robust = 0; # applies all css properties every time
    # state things, see also Rs&down
    me.rollCscon = &acgtR{
        me&rollbs,R,'attr,tag,css,html,text,value,hands'
    };
    me.Cscon = &acgtR{
        $isnew = !Rc&b;
        # past self
        $b = Rc&b || {c:{},sc:{}};
        if (s&e && s&e != 2) {
            #s&tag = 'input';
            #s&inv = 1;
            ah(C,'attr','contenteditable',true);
            c&s == null and c&s = '';
            if (c&s == '') {
                # stackoverflow:cant-get-to-empty-paragraphs-in-contenteditable
                s&dis ||= 2;
                s&height = 1;
            }
        }
        s&nobody and throw "used to reselect d.on"
        if (s&tag || bs&tag) { # or historically
            if (bs&tag != s&tag) {
                # recreating the d.on clears applieds
                Rs&on = $("<"+(s&tag || 'stylehouse')+">")[0];
                delete bs&attr;
                delete bs&css;
            }
            s&tag and Rs&tag = s&tag
        }
        # < hammerhead stylings wanting some cache api
        #   alike, C fork down paths repeatable
        # < title should be replaced by hover -> question elvis
        $attr = ex({title:C.t+' '+(C.y.cv||'')}, s&attr||{});
        s&title and attr.title = s&title
        if (attr || bs&attr) {
            $notin = ex({},bs&attr||{});
            Rs&attr = {};
            each kv attr {
                # '!"->'' makes a bareword attribute, ease coding in a peel
                v == '!' and v = ''
                Rs&attr[k] = v;
                delete notin[k];
                !robust && bs&attr && bs&attr[k] == v and continue
                $(Rs&on).attr(k,v);
            }
            each kv notin {
                $(Rs&on).removeAttr(k);
            }
            !hak(Rs&attr) and delete Rs&attr
        }
        $css = {};
        $st = 4s&styler ||= me&styler;
        # ^ merge into me&styler:
        # also s&cod/NutText
        # and Stylaplicants's dropdown
        st(C,css);

        # css stamped on on
        if (hak(css) || bs&css) {
            $notin = ex({},bs&css||{});
            each kv css {
                delete notin[k];
                bs&css && bs&css[k] == v and continue
                $(Rs&on).css(k,v);
            }
            each kv notin {
                $(Rs&on).css(k,'')
            }
            hak(css) and Rs&css = css
        }

        #c Cs say their c&s
        if (s&draggable) {
            # < needs a spacer or absolute space
            $(Rs&on).udraggable({stop:&ev{
                debugger;
                G&gev
            }});
        }
        # < should be attr.e=G&$t
        delete Rs&on.eintro;
        s&e && c&s == null and c&s = ''
        if (typeof c&s == 'string' || typeof c&s == 'number') {
            if (s&e) {
                s&e == '1' and me&textinput,R,b
                else
                s&e == '2' and me&codemirror,R,b
                else {
                    throw "other e type"
                }
            }
            elsif (c&ht) {
                Rs&html = c&s;
                b && Rs&html != bs&html and me&chR,R,'html'
            }
            else {
                Rs&text = c&s;
                b && Rs&text != bs&text and me&chR,R,'text'
            }
        }
    };
    # store %value submit (e:say) or set (c&s)
    #  avoids settting what was submit,
    #   or we'd lose bits of fast typing while saving
    me.valuecha = &acgtRhv{
        $b = Rc&b;
        # untyped into
        Rs&value = v;
        !b || bs&value != v and return 1
        #h != v and ~Valuewander: ki(h),'<-',ki(v)
    };
    me.valuesays = &acgtRe{
        e.t = 'says';
        ec&noisyinput = &{
            # called once accepted as un-noisy
            # avoids setting what was submit,
            #   keeping your typing
            $r = me&yfuture,R;
            rs&value = ec&s;
        };
        # we default to ec&s = $(on).val()
        # unless wanting to watch typing as it happens,
        # throws out events like click, keypress other than esc/enter
    };
    me.textinput = &acgtRb{
        Rs&textonly = 1;
        # sets value
        if (c&s != null) {
            if (me&valuecha,R,Rs&on.textContent,c&s ) {
                $(Rs&on).text(c&s)
            }
        }
        # gives value
        Rs&on.eintro = &e{
            ec&s = Rs&on.textContent;
            me&valuesays,R,e
        };

        # leave valuec

        $hands = {
            blur: &{ G&gev },
            focus: &{  me&wantpause,R,1 }
        };
        me&hands,R,Rs&on,hands;
    };
    me.hands = &acgtRlh{
        #Rs&hands and throw "many layers of handlers"
        # notice leaving
        $b = Rc&b;
        if (b && bs&hands) {
            each ty bs&hands {
                h[t] ||= 0;
            }
        }
        Rs&hands = h;

        $cm = l instanceof CodeMirror && l;
        each ty h {
            if (cm) {
                # cm.off() requires the exact t/y again
                cm._handlers and delete cm._handlers[t];
                # cm.off(t);
                y && cm.on(t,y);
            }
            else {
                $(l).off(t);
                y && $(l).on(t,y);
            }
        }
    };
    #c codemirror
    # https://codemirror.net/doc/manual.html
    # < should mostly in osc, high level fork important
    me.Ryuph = &acgtR{
        $r = Ry&up;
        r = r && rc&N && rc&N[0];
        return r
    };
me.codemirror = &acgtRbh{
    # rely on %Alooseion, higher tension
    #   as soon as Rs&on is somewhere
    
    if (!h || !Rs&on.ownerDocument.contains(Rs&on)) {
        # cm must start on the page,
        #  rely on parents to callback
        # < reliability, as e solved while A3
        h = me&Ryuph,h||R;
        !h and throw "no idea how to plug in cm", R
        #~>3 cmdefer: R.t, h.t
        ac(h,'NinetySixer',&{
            #~>3 cmback NinetySixer: h.t
            me&codemirror,R,b,h
        });
        return
    }
    # make A:e here to save
    $h = s&cm_sc || {};
    s&cm_sc and ex(C.sc,s&cm_sc);
    Rs&cm ||= bs&cm;
    Rs&cm ||= CodeMirror(Rs&on,{
        mode:'perl',theme:'midnight',
        lineWrapping:true,indentUnit:4,smartIndent:0,
        # indent after {
        electricChars:1,autoCloseBrackets:1,
        foldOptions: {
          widget: &from,to{
              $count = to.line - from.line;
              return `\u21A4${count}\u21A6`
          },
        }
    });
    $cm = Rs&cm;
    cm.R = R;
    if (s&chunksfold) {
        # when it sets value and for big pastes
        h.valuecha = h.onbigpaste = &acgt,cm,ch{ me&cm_chunksfold,cm,0,ch }
    }

    # sets value
    if (c&s != null) {
        # a string starts or updates
        $is = cm.getValue();
        if (me&valuecha,R,is,c&s ) {
            if (is) {
                ~CMerge
                # usually for a pull
                # merge/merge.js
            }
            cm.setValue(''+c&s);
            h.valuecha and h&valuecha,cm
            cm.refresh();
            #G&yl:400,&{ cm.refresh() };
        }
        # ? = s&dige;
    }

    # gives value
    # < S/C/A-esc doing different things
    # < softly on bunch of changes: cm.signal('changes',...)
    #   cursor moves
    # < select if for syntax restructuring options
    # < 
    # < as different intensities, cm.getchanges, do branching in time...
    #   differ everything we code up, suggest types...
    #   
    Rs&on.eintro = &e{
        ec&s = cm.getValue();
        s&digs and ec&parent = s&digs
        me&valuesays,R,e;
    };
    #c codemirror 8
    $save = &ev,{
        ~>3 cm-save:
        G&gev,ev
    };
    cm.setOption('extraKeys', {
        'Esc': &{ save() },
        'Tab': &c{
            c.getSelection().length ? 
                c.execCommand('indentMore')
                : c.replaceSelection("    ")
        },
        'Shift-Tab': &c{
            c.execCommand('indentLess');
        },
        "Ctrl-Enter": &{ save() },

        # TODO push the fix for mode/perl:
        #   add fold: "indent", next to electricChars:"{}"
        #  isnt indent mode independent?
        "Ctrl-Q": &cm,{ cm.foldCode(cm.getCursor()); },
    });
    # < use/upload/download markers, fold with them
    #  < use approximations of the line it is,
    # have them able to be open or closed
    #   to the next marker of same ind..
    # cm.foldCode(CodeMirror.Pos(21, 0));
    each in s&foldCode {
        cm.foldCode(n)
    }
    
    # < cm closer to the %Code
    #   the %Code could claim %string from %fix,
    #    its renditions utilised by others, %Know
    $hoi = s&hoistcm;
    hoi and hois&cm = cm
    
    $blurry = 0;
    $hands = {
        focus: &{
            blurry = 0;
            # no click/key events
            G.clof();G.keof();
            me&wantpause,R,1;
        },
        # click: &{ G.clof();G.keof(); },
        blur:  &{
            blurry = 1;
            # https://github.com/codemirror/CodeMirror/issues/1394
            # paste leaks a blur,focus, delay to detect it
            $ev = event;
            $cb = &{
                !blurry and return
                G.clon();G.keon(); save(ev);
            }
            G&yl,22,cb;
        },
        inputRead: &cm,ch{
            !ch.text || ch.text.length < 20 and return
            h.onbigpaste and h&onbigpaste,cm,ch
        },
    };
    s&hands and ex(hands,s&hands)
    # and here
    me&hands,R,cm,hands;
    
    $wr = cm.getWrapperElement();
    wr.style.background = 'initial';
    cm.heighten = &s{
        if (s == 1) {
            # wide open
            cm.setOption('scrollbarStyle',null);
            cm.setOption('viewportMargin', Infinity);
            wr.style.height = 'auto';
        }
        else {
            # something else
            s and wr.style.height = s+'em'
            else { delete wr.style.height }
            cm.setOption('viewportMargin', 10);
            cm.setOption('scrollbarStyle','native');
        }
    };
    cm.heighten(1);
    
    window.keem = cm;
    Rs&on.setAttribute('title','');
};
me.wantpause ||= &acgtRs{};

#c css
me.styler = &acgt{
    # generate noise
    # s&mh -> the proper css name: max height
    #  and a formatting function
    $data = [
    'numb z index',
    #'numb+plus:-20 z ig^^index',
    #'numb+plus:-10 z ie^^index',
    'empc letter spacing',
    'empc wo^rd spacing',
    'empc line height',
    'empc margin left,right,top,bottom',
    'empc ma^rgin',
    'empc padding left,right,top,bottom',
    'empc pa^dding',
    'empc mi^n width,height',
    'empc max width,height',
    # %ab:1 also position:absolutes
    'ori:static~absolute~relative~fixed po^sition',
    #'empc lef^t,ri^ght,top^,bot^tom',
    'empc left^,right^,top^,bottom^',
    'empc width^,height^',
    'empc wi^dth,he^ght',
    'empc border radius',
    
    'ori:hidden~scroll~visible over^flow',
    ' float^',
    ' bo^rder',
    'hsle bo^rder color',
    ' bo^rder left,right,top,bottom,width,style',
    # ^ also color, bolw = left width?
    ' opa^city',

    ' tr^ansform origin',
    'saydeg ^transform rad^^rotate',
    ' ^transform scale^',
    'saypx ^filter blr^^blur',
    ' ^filter sat^urate',
    ' ^filter con^trast',
    ' ^filter bri^ghtness',
    'saydeg ^filter hue^-rotate',
    ' ^filter sep^ia',
    ' ^filter inv^ert',
    ' ^filter gray^scale',
    'sayurl background gi^^image', // bgi
    ' bg^^background',
    'hsle bgh^^background-color',
    'hunine font size',
    'hundr font si^ze',
    'hundr font weight',
    
    'shadole ^text sha^dow',
    'cole co^lor',
    'hsle hs^^color',
    'defsa:underline ^text deco^ration',
    'ori:left~right~center ^text align^',
    'ori:none~all poi^nter ^events',
    'ori:all~none unsel^^user ^select',
    'whipre white space',
    'ori:normal~break-word~break-all word break',
    'ori:none~block~inline-block'
    #    0    1     2 
    #  3         4          5
    +'~table-row~table-cell~inline-table dis^play',
    'ori:none~middle~top-bottom v^ertical a^lign',
    ];
    # was|will be mind
    $N = [];
    each il data {
        l = l.split(' ');
        $format = l.shift();
        $g = {}; # a bunch of css properties
        $set = [g];
        each is l {
            $get = [];
            each ig set {
                $poss = s.split(',');
                $gb = g;
                each iz poss {
                    $g = ex({},gb);
                    $m = [];
                    # different name
                    if (m = z.match(/^(.*)\^\^/)) {
                        g.gk ||= '';
                        g.gk += m[1];
                        z = z.replace(/^(.*)\^\^/,'');
                    }
                    # part of name
                    elsif (m = z.match(/^(.*)\^/)) {
                        g.gk ||= '';
                        g.gk += m[1];
                        z = z.replace(/^(.*)\^/,m[1]);
                    }
                    # tiniest part of name
                    else {
                        g.gk ||= '';
                        g.gk += z[0];
                    }
                    g.cssks = (g.cssks||[]).slice();
                    g.cssks.push(z);
                    get.push(g);
                }
            }
            set = get;
        }
        each ig set {
            !g.cssks and throw "nocsskeys"
            g.cssk = g.cssks.join('-');
            delete g.cssks;
            
            if (format) {
                $m = format.split(':');
                m[1] and g.options = m[1].split('~')
                g.format = m[0]
            }
        
            N.push({t:g.gk,y:{},c:{},sc:g});
        }
    }
    
    $auto = 'geo ab'.split(' ');
    each in auto {
        N.push({t:n,y:{},c:{},sc:{gk:n,format:'do_'+n}});
    }
    #c formatty things
    $co = {};
    # GOING (otherhow) scale into such a space (changes C)
    co.scaly = &acgtsl{
        l ||= 15;
        s&fs ||= 9;
        $d = l - s.length;
        d /= l/3.14159;
        s&fs += d;
        d < -0.6 and s&width = co.ron((6+l/2.13169),1);
        s&fs < 3 and s&fs = 3
        s&fs > 17 and s&fs = 17
    };
    co.ron = &s,precision{
        return +(+s).toFixed(precision || 4)
    };
    co.do_geo = &s,opt,css{
        $s = s.split(' ');
        $aung = s[0].match(/^a(\d+)/); #]
        if (aung) {
            s.shift();
            # s&ab = aung[1] # can't set sc from here
            co.do_ab(aung[1],{},css);
        }
        s = {x:s[0],y:s[1],rad:s[2],scale:s[3],tro:s[4]};
        css.top = (s.y * 100)+'%';
        css.left = (s.x * 100)+'%';
        css['transform-origin'] = '0% 0%';
        s.tro and css['transform-origin'] = s.tro;
        s.rad and css['transform-rotate'] = s.rad+'rad';
        s.scale and css['transform-scale'] = s.scale;
    };
    co.do_ab = &s,opt,css{
        if (s == '100') {
            css.width = '100%';
            css.height = '100%';
        }
        css.position = 'absolute';
    };
    # hex value colouring, converted to 0-255
    co.cole = &s{
        if (s.length == 1) {
            # as ~messages?
        }
        else {
            # rgb(a)
            if (s.length == 3 || s.length == 4) {
                s = s.split('').map(&s{ return s+''+s });
            }
            else {
                $l = [];
                while (s.length) {
                    l.push(s.slice(0,2))
                    s = s.slice(2);
                }
                s = l;
            }
            each in s {
                s[i] = +eval('0x'+n)
            }
            $called = 'rgb';
            s[3] and s[3] = s[3] / 255; called += 'a'
            return called+'('
                +s.map(&s{ return co.ron(s) }).join(',')
            +')'
        }
    };
    co.hsle = &s{
        $z = s.split(' ').map(&s{ return (+s) / 100 });
        s = z.length > 1 && z
            || s.split('').map(&s{ return (+s) / 10 });
        s[0] = co.ron(s[0] * 360,0);
        s[1] = (s[1]*100)+'%';
        s[2] = (s[2]*100)+'%';
        $called = 'hsl';
        s[3] != null and s[3] = co.ron(s[3],3); called += 'a'
        return called+'('+s.join(',')+')'
    };
    co.empc = &s{
        s += '';
        !s.match(/%|em|px/) and s += 'em'
        return s
    };
    co.defsa = &s,opt{
        return s == '1' ? opt[0] : s
    };
    co.ori = &s,opt{
        opt.length == 1 and return opt[0]
        if (isnum(s)) {
            opt[s] == null and throw "Not a choice: "+s, opt
            return opt[s]
        }
        return s
    };
    co.whipre = &s{
        s += '';
        return s.match(/^[0i]/) ? 'initial'
            : s.match(/^[2n]/) ? 'nowrap'
            : s.match(/^[3l]/) ? 'pre-line'
        : 'pre';
    }
    co.shadole = &s{
        s = s.split(' ');
        $colour = s.length == 4 && s.pop();
        colour and colour = co.cole(colour)
        return s.map(&s{ return s+'px' }).join(' ')
            + (colour ? ' '+colour : '')
    }
    # number of radians in a 90 degrees?
    co.radian = 1.57079633;
    # wind radial info only once around
    co.radun = &s{
        $o = co.radian*4;
        $swish = o;
        s < 0 and swish *= -1;
        $i = 0;
        while (s > o || s < o*-1) {
            s -= swish;
            i > 5 and throw "muchwinding"
        }
        return co.ron(s,8)
    };
    
    # 1 -> 100%
    co.hundr = &s{
        return co.ron((+s)*100,0)+'%';
    };
    # 9 -> 81%
    co.hunine = &s{
        return co.ron((+s)*9,0)+'%';
    };
    co.numb = &s{
        return co.ron(+s)
    };
    # adds jargon
    co.say = &s,unit{
        return s.includes(unit) ? s : s+unit
    };
    co.saypx = &s{ return co.say(s,'px') };
    co.saydeg = &s{ return co.say(s,'deg') };
    co.sayurl = &s{ return "url('"+s+"')" };

    
    #
    
    
    #c applied

    
    # index by gk
    $ext = {};
    $tos = [];
    each iD N {
        !Ds&gk and continue
        ext[Ds&gk] and throw "two gk:"+Ds&gk+": "+Ds&cssk+" or "+ext[Ds&gk].sc.cssk;
        ext[Ds&gk] = D
        verbose and tos.push(Ds&cssk+'   '+Ds&gk)
    }
    verbose and window.styletos = tos.join("\n");
    
    # styles: that(are) group(ed)
    $po = {};
    po.transform = ['rotate','scale'];
    po.filter = ('blur saturate brightness sepia'
        +' hue-rotate invert grayscale').split(' ');
    
    return &C,css{
        # apply C -> css
        each gk,D ext {
            $v = C.sc[gk];
            v == null and continue
            if (Ds&format) {
                $f = co[Ds&format];
                !f and throw "No format: "+Ds&format
                typeof v == 'number' and v = ""+v
                v = f(v,Ds&options,css);
                #gk == 'fs' and ~Formats: gk, Ds&format, v
            }
            !Ds&cssk and continue;
            css[Ds&cssk] = v
        }
        
        # grouped
        each tik po {
            $lie = t+'-'+k;
            css[lie] == null and continue
            css[t] ||= {};
            css[t][k] = css[lie];
            delete css[lie];
        }}
        # string grouped
        each kv css {
            typeof v != 'object' and continue
            $val = [];
            each KV v {
                val.push(K+'('+V+')')
            }
            css[k] = val.join(' ')
        }
        # ancient chrome on a 32bit island
        # %unsel, composited bunch of %sat, %con, %bri etc
        $fall = {'user-select': '-webkit-user-select',
            'filter': '-webkit-filter'};
        each kc fall {
            css[k] == null and continue
            css[c] = css[k];
            delete css[k];
        }
    };
};
//#c Cup-on 8html output: put each in another
    # the html elements are closer to the C this time,
    #  used to always output a C-patch
    # s gets s&on
    me.Cupon = &acgtR{
        $N = Rc&N;
        $aftmoddy = [];
        each iR N {
            $b = Rc&b;
            $s = Rc&s;
            $p = R.y.up;
            # child needs parent to attach it
            # < TES less often, if b.on still == d.on?
            Rs&cha && p and me&chR,p,'Inner:'+R.t

            if (!Rs&on) {
                throw "!on:"+(me&namup,R .join(','))
            }
            # how else shall we entangle R/on/C/A?
            if (s.y.A) {
                $j = s.y.A;
                jc&s != s and throw "notC"
                s.y.A.on = Rs&on;
                Rs&on.A = s.y.A;
            }
            if (s == C && s&J && s&J == A.1) {
                C != A&s and throw "notC"
                i > 0 and throw "sC>0"
                # 1s&on set to thing, big deal
                1s&on = Rs&on;
            }
            Rs&down ||= [];
            if (Rs&originsleeping) {
                $already = Rs&down;
                Rs&down = [];
                # fill with history
                Rs&down.push(... bs&down);
                # already/awakers replace
                already.map(n => bac(R,'down',n));
                # that still are
                $rm = Rs&down.filter
                    (n => !ns&modulat && nc&s.c.not);
                rm.length and ~>6 rmconsc: R.t, ki(rm,4.23)
                Rs&down = Rs&down.filter
                    (n => !(!ns&modulat && nc&s.c.not))
            }

            !p and continue

            # we put R:I%down
            pc&N == Rc&N && !ps&down and throw "not in order"
            ps&down ||= [];
            # R%Cy&cv sets order relative to R+, like modulat
            $align = Rs&C
            align = align && align != Rc&s
                          && num(aligny&cv) && align
            if (align || Rs&modulat) {
                align ||= s
                if ((aligny&cv||0) <= 0.6) {
                    # before
                    $mi = ps&modulati ||= 0;
                    ps&down.splice(mi,0,R);
                    ps&modulati ++;
                }
                elsif ((aligny&cv||0) >= 0.7) {
                    # after
                    aftmoddy.push(p);
                    $m = ps&modulato ||= [];
                    m.push(R);
                }
                else {
                    # between/amongst R
                    # < R could have Mcv to escape channeling into 6-7
                    throw "M@6 sort into things between upscdown",align
                }
                aftmoddy.push(p);
            }
            else {
                bac(p,'down',R);
            }
        }
        # R/* modulat put after R
        #   eg closing brackets
        # < sort it
        aftmoddy.map(&p{
           if (ps&modulato) {
               ps&down.push(... ps&modulato)
               delete ps&modulato
           }
           delete ps&modulati;
        });

        #c C have!!
        $rev = N.slice().reverse();
        each iR rev {
            $b = Rc&b;
            !b && !Rs&cha and throw "Nota"

            # memory leaker:
            # < use famous[sip] and title = ty for event target
            Rs&on.C = Rc&s;
            Rc&s.y.A and Rs&on.A = Rc&s.y.A;
            Rc&s.y.Display = R;

            # what will be
            #  want to D that r, let it swim rs&on
            $have = (Rs&down||[]).map(r => rs&on);
            have.length and Rs&havedown = have.slice();

            if (!Rs&cha && b && (Rs&havedown || bs&havedown)) {
                # BUG: there is some place where a %downer is not %cha'd
                #  atop a Cray...
                # < fixed by 2ac202656a2?
                Rs&cha = ! me&sameset,Rs&havedown,bs&havedown;
            }

            $orig = R.y.origin;
            $talky = orig && origs&Cupon_talky;
            if (talky) {
                #debugger;
                talky =
                ~>5 chaof: orig.t, (Rs&cha?"Y":"0"), '>:sum ', '>:dop '
            }

            !Rs&cha and continue
            Rs&textonly and continue

            # what is
            $has = Rs&on.childNodes;
            # text/html (first)
            Rs&text != null and have.unshift($('<cs>').text(Rs&text)[0]);
            Rs&html != null and have.unshift('<cs>'+Rs&html+'</cs>');

            if (Rs&J) {
                $J = Rs&J;
                # yon 1s&on put into Rs&on
                $on = Jc&on || Js&on;
                !on and throw "noJon";
                have.push(on);
            }
            # < scan what is there, leave siblings of changes
            #   rebuilding dom annoys stately insides (cm, video)
            #     whose continuity (history + cursor + focus)
            #       could be made up somehow
            # hasnt - what we didn't know was there
            # havent - what goes
            # leaving it open to elements being rearranged by the user?
            # rearrange, carefully. or just:
            $dif = 0;
            each i,on have {
                $ha = has[i];
                on == ha and continue
                # this is probably expensive:
                # < redundant?
                typeof on == 'string' && ha && on == ha.outerHTML and continue
                # different...
                dif++;
            }

            talky && talky.set('sum',(dif?"dif":"=="));
            # only !Rs&cha can sleep,
            #  html always disturbed if so
            !4s&Cupondif and dif = 1

            if (dif) {
                # true if it works/is done
                dif = ! me&Cuponhashave,R,has,have
                talky && talky.set('dop',dif?"fault":"done")
            }
            if (dif) {
                $(Rs&on).empty();
                each i,on have {
                    $(Rs&on).append(on);
                }
            }
        }

        # 8

        # < is h always R?
        $h = N[0];
        $c = hc&s;
        # < is c ever !C?
        if (c && c.sc) {
            if (cs&directDisplay) {
                # Implantingness sneaking awake
                $b = hc&b;
                !b and ~only works once:
                b and $(bs&on).replaceWith(hs&on);
            }
            if (cs&J == A.1) {
                # for this J
                1s&OscDoneHook and 1s&OscDoneHook(h);
            }
        }

        me.Fourismness and return
        # < when A.1 == A.3?
        A.2 == A.4 and me&Cup24,h
    };
    # A.3 attaches to A.4
    me.Cup24 = &acgtR{
        $on = Rs&on;
        $onto = A.4.on;
        !onto and throw "No A4on"
        onto.contains(on) and return
        ~>2 Cup24: A.1.t, R.t, R.y.up.t
        me.cbu(R,'JRom') and return
        onto.appendChild(on)
        # if it was already, take it as an unplug?
        # or find new parent, get adopted
    };
    # play with Cupon's awareness of change
    me.stuffsomewhere = &acgtR{
        ~>6 Bleepso:
        me&tsc,'forcest',null,'1G';
        me&tsc,'bleep',null,'1G';
        me&tsc,'forcest',null,'1G';
        me&tsc,'sources',null,'1B';
        Rs&Cupon_talky = 1;
    };

    #c Cuponhashave 
    # Cupon changes a sentence with minimal typesetting
    #  returns true if we figured & made the change
    #  or fallback to empty()+append(everything)
    # a writable Element.childNodes
    # 'moving elements only as needed'
    # Append Before: element.parentNode.insertBefore(newElement, element);
    # Append After: element.parentNode.insertBefore(newElement, element.nextSibling);
    # engage with 4s&Cuponhashave on for the JRom catch
    # < try eventual 4s&Cupondif, maybe with fallbackery?
    me.Cuponhashave = &acgtRMN{
        $orig = R.y.origin;
        $t = orig ? orig.t+'/D' : R.t;
        $D = G&Cye,[t+"/*",''];
        Ds&began = G&time;
        # return false to fallback
        Dc&may_totally_change = 1;

        # M NodeList -> Array
        if (typeof M == 'object') {
            if (M.constructor == NodeList) {
                $m = [];
                $i = 0;
                while (1) {
                    $s = M.item(i);
                    s == null and break
                    m.push(s);
                    i++;
                }
                M = m;
            }
            else {
                throw "mobject"
            }
        }
        $talky = orig && origs&forceses;

        # check situation is complicated enough
        $keptnothing = 1;
        # M is a nodelist but is iteratible
        each in M {
            N.indexOf(n) >= 0 and keptnothing = 0
        }
        keptnothing && talky and ~lv: D.t, 'keptnothing'
        keptnothing and return

        # don't deal directly with the objects
        $refs = [];
        $refin = &s{
            $si = refs.indexOf(s);
            si < 0 and refs.push(s)
            si = refs.indexOf(s);
            si < 0 and throw "Can't find indexOf(s) "+ki(s)
            return si
        };
        # has
        Ds&got = [];
        each is M {
            Ds&got.push(''+refin(s))
        }
        Ds&exp = [];
        each is N {
            Ds&exp.push(''+refin(s))
        }
        # 6
        me&lvhashave,D;
        # 7
        Ds&fail and 4s&hashavefail = D; Ds&total_change = 1

        Ds&total_change && talky and ~lv: D.t, 'total_change'
        Ds&total_change and return
        else {
            # 4s&Cuponhashave and debugger;
            $t = null;
            each in Ds&actN {
                $l = refs[n[0]];
                $k = n[1];
                $t = n[2] && refs[n[2]];
                k == 'still' and continue
                !l and throw "lost"
                !t ? $(l)[k]() : $(l)[k](t)
            }
            # randomly check one of them is still inside parent
            t && $(t).parent()[0] != Rs&on and debugger

            if (talky && Ds&talklv) {
                $acty = [];
                $la = [];
                $absorbing = 0;
                $deabsorb = &m{
                    m and absorbing =- 1
                    absorbing > 0 && acty.push(
                        [88,'..'+absorbing+(m ? ".." : '')]
                    );
                    absorbing = 0;
                };
                each in Ds&talklv {
                    n[0] == 8 && la[0] == 8 and absorbing++
                    else {
                        # say the 8 before !8
                        absorbing and deabsorb(1); acty.push(la);
                        acty.push(n);
                    }
                    la = n;
                }
                deabsorb();
                $talk = [];
                each in acty {
                    $el = n[0];
                    $t = n[1];
                    el > 9 and talk.push(">9 "+n[1])
                    else {
                        talk.push(">3 "+el);
                        $v = refs[n[1]];
                        $vt = v.title || "?:"+(n[1]);
                        talk.push(">7 "+vt);
                    }
                }
                ~lvha: D.t, ... talk
            }
        }
        Ds&delta = G&time,Ds&began;
        Ds&delta > 0.01 and ~Longhashave: D.t
        # < regenerate M and check it is N
        return 1
    };

    #c &lvhashave - doming to rearrange

    # soul olympics
    # s'al' o limb pics
    # read-write culture

    # deal acts to change set
    #  < primary function of the A/D.t=lvhashave,
    # prefers keeping things moving left/up
    # < generalise
    # < lovely fuzzy matches, el7 (moves, duplinks)
    me.lvhashave = &acgtD{
        # < got/exp=[s+] -> has/have=[D+]
        #   D being A being D
        $got = Ds&got;
        $exp = Ds&exp;
        # Ds&V verbosity=0, test data 1, debug 2
        # < size of (tee)veeing available
        $V = Ds&V;

        $have = Ds&have = got.slice();
        # see also

        # what for each have
        $re = [];
        $ret = &tcn{
            t = G&Cye,[t,'',{},c||{}];
            re.push(t);
            return t
        }

        # will make true:
        me&sameset,exp,have and return Ds&same = 1

        # simple add/remove
        $dif = have.length != exp.length;
        # el=9 what isn't anymore
        $drop = [];
        each ih have {
            exp[i] == h and continue
            dif = 1;
            $ei = exp.indexOf(h);
            ei >= 0 and continue
            drop.push(i);
            ret(h,{el:9});
        }
        if (drop.length == have.length) {
            # < 100% change should skip lvhashave
            Ds&total_change = 1;
            # the option to empty() and reinput taken
            Dc&may_totally_change and return
        }
        drop.reverse().map(&hi,{
            have.splice(hi,1)
        });
        drop = [];
        # $dif is now sleepable - Cupon might

        # el=9/1 what moves, el=1/2 come, 8 stay
        # insert before next locatable thing
        $prepend = [];
        # know earlier same thing
        # < selecto must be told when the hi changes due to prepend,
        #   setting it to manual ig
        $have_once = {};
        $ihave = me&selecto,have,have_once;
        $lastsame = 0;
        each ix exp {
            $hi = ihave(x);
            if (hi < 0) {
                prepend.push(x)
            }
            elsif (hi != i) {
                #~move: x, hi, i
                if (hi < lastsame) {
                    # an 8 walls drift down move
                    i < lastsame and throw "allow?"
                    have.splice(hi,1);
                    ret(x,{el:9});
                    prepend.push(x);
                    continue
                }
                # shall has its place once data leaves
                #x == 'shall' and ~>4 mohave: ki(have)
                have.splice(hi,1);
                prepend.push(x);
                ret(x,{el:6});
            }
            else {
                #~same: x, hi, i, ki(prepend)
                hi > lastsame and lastsame = hi
                have_once[hi] = 1+prepend.length;
                each in prepend {
                    ret(n,{el:2});
                }
                ret(x,{el:8});
                have.splice(hi,0,... prepend);
                prepend = [];
            }
        }
        have.push(... prepend);
        each in prepend {
            ret(n,{el:1});
        }

        !me&sameset,exp,have and Ds&fail = Ds&fail_brute = 1
        #c tidylv the el6-1 where possible
        # move el9s to beginning
        $ninegr = re.filter(n => ns&el == 9);
        each in ninegr {
            re.splice(re.indexOf(n),1);
        }
        re.unshift(...ninegr);

        if (V) {
            me&tsc,'input',got.join('-'),'1d'
            me&tsc,'wanted',exp.join('-'),'1b'
        }

        $res = re.slice().map(n => n.t);
        # < to selecto, to always work in sets of previum?
        $latere = me&selecto;
        # rei(movestart)=rei(moveto) voidable el=6
        $nvm = [];
        # rei=sc talk n
        $shrinki = [];
        each in re {
            $t = '  '+n.t;
            V && me&tsc,'changeto',t,'6';

            # last same thing's i in re
            $was = latere(n.t,i);
            $r = was >= 0 ? re[was] : null;

            # at the recreation end of a move
            if (r && ns&el <3 && rs&el == 6) {
                $between = re.slice(was, i);
                # things we may not end up in front of
                $outof = [];
                V>1 && me&tsc,'tveen',was+'-'+i,'y';
                between.map(&b{
                    if (bs&el <3 || bs&el == 6
                        || bs&el == 9) {
                        # fine where we are
                    }
                    elsif (bs&el == 5) {
                        # bow to elements moving left
                        # ensure b's 6 started left of n
                        # < not dupeable
                        $bi = got.indexOf(b.t);
                        $ni = got.indexOf(n.t);
                        bi<0 || ni<0 and throw "nofind"
                        bi==ni and throw "bini"
                        bi > ni and outof.push(b.t)
                    }
                    else {
                        outof.push(b.t)
                    }

                    if (V>1) {
                    $s = '  '+ki(b);
                    me&tsc,'between',s,'1q';
                    }
                });
                if (!outof.length) {
                    nvm[was] = i;
                    $dn = shrinki[was];
                    dn and dns&fs = 6;
                    ns&el = 5;
                }
            }
            if (V) {
            shrinki[i] =
            me&tsc,'changes',ki(n.sc)+"\n",'d';
            }
        }
        # 6/5 pairs become 9/1 or 8/nothing
        $lv = [];
        each in re {
            ns&el == 5 and ns&el = 8
            ns&el == 6 and ns&el = 9
            !nvm[i] and lv.push(n)
        }
        #c Element.* acts -> n-domefor
        $actN = Ds&actN = [];
        $cha = Ds&cha = [];
        # and test apply to:
        $lvd = Ds&lvd = got.slice();
        # last thing
        $la = null;
        $prepend = [];
        # follows lvd[lvi] = what lv[i] is about
        $lvi = 0;
        Ds&talklv = [];
        each in lv {
            Ds&talklv.push([ns&el,n.t]);
            if (V) {
                me&tsc,'lv',ns&el,'d';
                me&tsc,'lvto',n.t+"\n",'6';
            }

            # < selecto splicing+reading lvd
            $was = lvd.indexOf(n.t);
            $el = ns&el;
            if ((ns&el <3 || ns&el>=8)
                && !la && prepend.length) {
                lvd.splice(lvi,0,... prepend);
                prepend.map(&t{
                    actN.push([t,'insertBefore',n.t]);
                    cha.push(t+'<-'+n.t)
                    lvi++;
                    was++;
                });
                prepend = [];
            }
            if (ns&el == '9') {
                lvd.splice(was,1);
                actN.push([n.t,'remove']);
                cha.push('-'+n.t);
                continue
            }
            elsif (ns&el <3) {
                if (la) {
                    lvd.splice(lvi+1,0,n.t);
                    actN.push([n.t,'insertAfter',la]);
                    cha.push(la+'->'+n.t)
                }
                else {
                    prepend.push(n.t);
                    continue
                }
            }
            else {
                # < allow gaps? 8 with delete until
                lvi = was-1;
                actN.push([n.t,'still']);
                cha.push('('+ns&el+':'+n.t+')')
            }
            lvi += 1;
            la = n.t
        }
        if (!la && prepend.length) {
            # < 100% change should skip lvhashave
            $lastnine = actN.pop();
            !lastnine || lastnine[1] != 'remove' and throw "Noel9?"
            $lastninecha = cha.pop();
            $n = lastnine[0];
            prepend.map(&t{
                actN.push([t,'insertBefore',n]);
                cha.push(t+'<--'+n.t)
            });
            actN.push(lastnine);
            cha.push(lastninecha);
        }
        else {
            prepend.map(&t{
                actN.push([t,'insertAfter',la]);
                cha.push(la+'<---'+t)
            });
        }

        !me&sameset,exp,lvd and Ds&fail = Ds&fail_elementing = 1
    };

//#c Ja.od, schemas, netty GOING
    # each of these to present furthers,
    # and watch/let go intermediaries as they squish from focus
    # visualising the shifting yet sameness
    me.Modu = &acgtNM{
        each in N {
            if (ns&swal) {
                $C =
                m $n
                !me[n.t] and throw "no swal cb: "+n.t
                me[n.t](A,C,G,T,nc&s);
            }
            else {
                throw "nonswal";
            }
        }
    };
    me.Ja.od = &acgts{
        $M = c&M = [];
        n t  $s:C.t %fs:20,hs:594
        s&dis = 1;
        s&bgi = 'i/greencush.jpg';
        s&bgh = '1115';
        s&bo ||= '3px dotted #235';
        s&br = '3';
        s&zi = -2;


        $d = me&scan,s;
        delete d.s;
        $is = d.is || d.sym;
        $ym =
        n sym  $s:is %fs:15,ab,mt:-0.1,ml:-0.1,zi:-1,hs:4955

        $check = &{
            $el = 1c&on;
            $le = ym.y.A.on;
            $(le).css('font-size', $(el).height()+'px');
        };
        #G&yl:300,check;
        # the minor modulate gang hang at mid-swallow (y)
        $swal = d.modu ? &{ me&Modu,d.modu,M; swal = &{} } : &{};
            # the swept up (behind/as y) pile of junk
            #   in the hallway of infinity, outside a room
            #   but essentially not in a door we believe in that much
            #   everything will be C soon

        each ik d.ks {
            A.ground = C;
            if (d.C) {
                if (k == 't') {
                    # no label, underlined
                    n t 2 $s:s.t %fs:15,deco
                }
                elsif (k == 'y' && 0) {
                    # no label, balled...
                }
                else {
                    swal();
                    # C.*

                    #$g = A.ground =
                    #n $k  lef %ml:1
                    #gs&bo ||= '3px dotted #235';
                    #gs&dis ||= 1;
                    m k  $s:k %fs:21,lh:42%
                    #m k  $s:k %hs:0000
                    each qv s[k] {
                        #]
                        m k  $s:q %hs:748
                        $pow = 3;
                        k == 'y' and pow = 2
                        c&smallish and pow--;
                        k == 'c' && q == 'N' and pow = 2
                        m v  $s:ki(v,pow) %fs:8
                    }
                }
            }
            elsif (c&forit) {
                $v = s[k];
                me&J,[C.t+c&forit+k,'-od',{s:v,smallish:1}];
            }
            else {
                $v = s[k]; #]
                m k  $s:k %lh:4
                m v  $s:ki(v,3) %fs:8
                if (c&fora) {
                    $vv = v[c&fora];
                    m vt  $s:c&fora
                    #vv = vv.c.s ? vv.c.s : vv;
                    me&J,['foracs'+c&fora+k,'-od',{s:vv}];
                }
            }
        }
        swal();

        if (d.C) {
                $psc = {bo:'3px dotted #784'};
                psc.bolw = '19px';
                sc&slope &&
                    me&J,['slope','-od',{s:sc&slope.map(n=>n.t)},psc];
                ss&solvey &&
                    me&J,['solvey','-od',{s:ss&solvey,forit:'C'},psc];
        }
        each in M {
            n.t == 'k' and ns&hs ||= 748
        }
        A.ground = C;
        #n scan 8 $s:ki(d) %hs:857
    };
    #c schemas
    # a non-ind d, osc data tool
    $obs = {
        C:{ks:'t y c sc'.split(' ')},
        R:{as:'C',but:'s.y.R==s'},
        A:{as:'C',but:'d.ks>4'},
        J:{as:'A',but:'s.1==s'},
        netty:{as:'JA',ks:'1 2 3 4 5'.split(' '),swal:'netty'}
    };

    # empty here implies checkout
    me.sch_ballonlyt = &acgtr{
        !rs&ball and throw "!ball"
        return !rs&z || !rs&z
            .filter(n => ns&ball || ns&fix).length
    };
    me.sch_gotstring = &acgtRrk{
        k = k ? k+': ' : '';
        $M = me&Mw,R,'err';
        !r and throw "fednull"
        $ok = 1;
        rc&el == 9 && !hak(r.sc,'string') and return 1
        if (!rs&string || rs&string.length < 2) {
            ok = 0;
            $z =
            m noscstring  s:⊗
            zc&s += k
        }
        return ok
    };
    # 
    # < checking states of R on a tiny %sun
    #   binding schema - place it is applied
    me.sch_didLines = &acgtRrk{
        k = k ? k+': ' : '';
        $M = me&Mw,R,'err';
        !r and throw "fednor"
        !rs&ball and throw k+"!ball"
        $ok = 1;
        if (rs&Lines == null) {
            ok = 0;
            m notLinesey  s:⊗
        }
        if (rs&Lines && !rs&LinesN) {
            ok = 0;
            m notLinesNtoppy  s:⊗
        }
        if (!rs&string || rs&string.length < 5) {
            ok = 0;
            m noLinesstring  s:⊗
        }
        return ok
    };

    $arin = &sz{
        return 0 <= z.indexOf(s)
    };
    #c scan
    me.scan = &acgts{
        $d = {s:s};
        if (s instanceof Array) {
            d.sym = '[';
            d.ks = [];
            each kv s {
                d.ks.push(k);
            }
        }
        elsif (typeof s == 'object') {
            d.sym = '{';
            d.ks = [];
            each kv s {
                d.ks.push(k);
            }
        }
        elsif (typeof s == 'string' || typeof s == 'number') {
            d.sym = "'";
            d.isp = ki(s);
        }
        elsif (typeof s == 'function') {
            d.sym = "&";
            d.isp = ki(s);
        }
        else {
            d.sym = '?';
            d.isp = ki(s);
        }
        if (d.sym == '{') {
            $M = d.modu ||= [];
            # apply some observations
            each tD obs {
                if (D.ks) { # keys to have
                    $match = 0;
                    each ik d.ks {
                        # see 
                        0 <= D.ks.indexOf(k) and match++
                        elsif (!D.swal) {
                            $wk = d.weirdkeys ||= [];
                            wk.push(k);
                        }
                    }
                    if (match == D.ks.length) {
                        if (D.swal) {
                            # group some details:
                            # envelopes some d.ks with a d.modu[C]
                            # eg netty, keys 1-5
                            # swallows 1-5 from d.weirdkeys (misfits for C)
                            # and d.ks, keys shown
                            # < diving in, bursting the representation,
                            #   the illusion becoming items in the medium
                            $r =
                            m $D.swal  $s:s %swal
                            rs&ks = D.ks;
                            d.weirdkeys = d.weirdkeys.filter(k=>!arin(k,D.ks));
                            d.ks = d.ks.filter(k=>!arin(k,D.ks));
                            #A.1.t == 'delicio' and debugger
                        }
                        else {
                            d.is = t;
                            d.ks = d.ks.filter(&k{
                                return 0 > D.ks.indexOf(k);
                            });
                            $ks = D.ks.slice().reverse();
                            each ik ks {
                                d.ks.unshift(k);
                            }
                        }
                    }
                }
                D.as && !D.as.includes(d.is) and continue
                D.but == 'd.ks>4' && d.ks.length > 4 and d.is = t
                D.but == 's.1==s' && s.1 == s and d.is = t
                D.but == 's.y.R==s' && sy&R == s and d.is = t
                d.is == 'A' && s.y == s and d.ks = d.ks.filter(&k{ return k != 'y' });
                d.is == 'C' and d.C = 1
            }
            if (d.weirdkeys) {
                $r =
                m weirdkeys  $s:s %swal
                rs&ks = d.weirdkeys;
                d.ks = d.ks.filter(k=>!arin(k,d.weirdkeys));
            }
            !d.modu.length and delete d.modu
        }
        return d
    };
    #c alabroise netty
    me.weirdkeys = &acgts{
        $M = s&z = [];
        $ks = s&ks;
        s&ml = 1;
        #m weirdkeys  $s:ki(ks) %dis,hs:490
        each ik ks {
            m wk_k  $s:k %hs:748
            m wk_v  $s:ki(s[k],3) %fs:8
        }
    };
    me.netty = &acgts{
        # osc app? prints netname relative to surrounding netnames
        # borrowed from 251 ki
        # split out A.\d, points on wormhole slope
        $ks = [];
        each kv s {
            k.match(/^\d+$/) and ks.push(k);
        }
        !ks.length and return
        # crunch them together implicitively
        ks = ks.sort();
        $Js = [];
        $la;
        $is = [];
        $isness = &{
            !is.length and return
            E.push(is.length == 1 ? is[0] : is.shift()+'-'+is.pop())
            is = [];
        };
        # n->s match, call it again (eg 1+3) by its lowest number
        $has = [];
        $hast = [];
        $E = [];
        #debugger;
        each in ks {
            n *= 1;
            $v = s[n]; #]
            v.1 != v and throw "JnetnotJ"

            if (v == s) {
                is.push(n);
                la = v;
                continue
            }
            isness();
            if (la == v) {
                continue
            }
            $st = v;
            # call it again (eg 1+3) by its lowest number
            $was = has.indexOf(v);
            if (was >= 0) {
                st = was;
            }
            has[n] = v;
            hast[n] = st;
            E.push(st);
            la = v;
        }
        isness();

        if (has.4 == A.4 && has.5 == A.5) {
            # omit .Four.Five if simple
            hast.4 == A.4 && hast.5 == A.5 and E.pop(); E.pop();
        }

        $netname = [];
        each id E {
            typeof d == 'object' and d = d.t
            netname.push(d);
        }
        netname = netname.join('.');

        s&fs = 6;
        s&hs = 848;
        $M = s&z = [];
        #netname += "\n";
        m netname  $s:netname
    };

//#c way notifies, GOING
    # to receive way notifies
    me.Ja.digwaypoll = &acgt{
        A&o = 'IndofC';

        $w = A.5.I.w;

        $ws = 1c&ws = me&ws,A.1.t,1c&ws;

        wsc&open = &w{
            # assert what we care about
            each ti me.importo {
                me&waytime,t,null;
                w.send(t);
            }
        };
        wsc&receives = &l{
            4c&nodigway and return
            each is l {
                $s = s.split('%');
                $t = s[0];
                $c = G&peel,s[1];
                me&upghost,t,c.dige
            }
        };
    }
    me.wayta = &acgtts{
        $wa = A.5.I.w; # alien stash
        !wa and throw "no wa", t
        # G&way uses
        return wa.y.tw[t];
    }
    me.waytime = &acgtts{
        $w = me&wayta,t;
        !w and return
        !w and throw "no w", t
        s == null and s = G&time + 3600
        ws&now = s; # unixtime, forces update
    };
    me.upghost = &acgttd{
        $dige = d;
        $w = me&wayta,t;
        # these don't match yet...
        w && ws&dige == dige and return
        t ||= 'Soogle';
        me&waytime,t,1;
        4s&upghost ||= [];
        4s&upghost.indexOf(t) < 0 and 4s&upghost.push(t)
    };
    # < merely starts fetching new copy
    #   next frame will carry out the update
    $w = me.importo = {};
    # the way to trigger, or simply the way to trigger

    'Soogle Packle Coffle Foogla'
    .split(' ').map(t => w[t] = 1);


    me.doupghost = &acgt{
        each it 4s&upghost {
            # make sure it's out of date
            me&waytime,t,1;
            # noop, ttl = 1 hour
            $cb = &t,ar,w{ ws&now = G&time + 3600 };
            G&way,t,{},cb;
            !w[t] and continue
            4s&downghost ||= [];
            4s&downghost.indexOf(t) < 0 and 4s&downghost.push(t)
        }
        delete 4s&upghost
    };
    me.dodownghost = &acgt{
        each it 4s&downghost {
            ~>3 downung: t
            G&way,t
            ~>3 downund//1: t
        }
        delete 4s&downghost
    };

//#c J timing/random
    #   enable in Jpin:
    #     me&DeltaDelOsc
    #     or me&Gomp while s&timing=1
    #   then anywhere in A.1:
    #     $the = me&Timethe,'Display';
    #     ..work..
    #     the();
    # < hierarchy: outside time - inside time
    me.findRef = &acgtRs{
        !(R && R.y && R.y.R == R) and throw "!R"
        $i = Rc&refs.indexOf(s);
        # as many as Rc&dupl || 1
        $refR = Rc&refR[i] || [];
        return refR[0]
    }
    me.Timethe = &acgts{
        $ti = 1s&Times;
        !ti and return &{}
        $starts = G&time;
        return &{
            $delta = G&time,starts;
            ti[s] ||= 0;
            ti[s] += delta;
        };
    };
    me.DeltaDelOsc = &acgt{
        $starts = G&time;
        1s&Times = {};
        $d =
        n delta  s:... %dis:1,float:right
        1s&OscDoneHook = &h{
            $R = me&findRef,h,d;
            $on = Rs&on;
            $delta = G&time,starts;
            delta += 's';
            each kn 1s&Times {
                # 10ms threshold
                !k.includes('slep@0.03') && 0.01 > n and continue
                delta += "\n"+k+": "+G&desca,n +"s";
            }
            $done = G&time;
            $whendone = &{
                done = G&time,done;
                delta += "\ndone: "+done+"s";
                $(on).text(delta);
            };
            G&yl,0,whendone;
        };
    };
    #c random
    # wants to leap onto new osc gear
    me.Gomp = &acgt{
        s&timing and me&DeltaDelOsc
        $n = me&heading;
        A&o = 'Graze';
        s&med = 'cra';
        return n
    };
    me.heading = &acgts{
        $n = G&n,['t',0.01,{s:C.t},{ab:1,zi:-20}];
        ns&fs = A.1 == A.3 ? 19 : 13;
        ns&mt = '-0.7';
        #ns&dow = 'do/Shrinkage';
        $r = C;
        rs&mt = '1em';
        rs&mih = '2em';

        rs&dis = 'block';
        #A.1 == A.3 and rs&width = '50%';

        s == null and s = 'pac';
        if (s) {
            if (s == '55') {
                rs&left = '50%';
                rs&width = '100%';
                rs&ab = '1';
            }
            elsif (s == 'pac') {
                1s&count ||= 0;
                $count = ''+1s&count++;
                n i  $s:count %medo:Jause
                if (1s&pausing) {
                    n paused  s:paused %medo:Jause
                    1s&paused = 1;
                }
            }
            else {
                throw "unknown heading style", s
            }
        }
        return n
    };
    me.Jause = &acgtD{
        $Y = D.y.A;
        Y = Y.1;
        me&JPause,Y;
    };
    me.JPause = &acgtYi{
        i == null and i = Ys&pausing = !Ys&pausing;
        Ys&pausing = i;
        # goes around %pausing to draw "paused" inside the J,
        #   which then stops it happening in J/5,
        #   where the desire computation decides awake
        !i and delete Ys&paused
    };

//#c M limits, cvdeal, Rc&ha
    # deprunablism - note Ry&ups&M about lost
    # would sit as a general ableness,
    #  working on h's dim awareness of what is not included 
    me.Mlimits = &acgtr{
        !rc&ha and return
        $upritN = {};
        each tz rc&ha {
            typeof z != 'object' and continue
            t == 'err' and continue
            # write trouble next to each node
            each in z {
            if (rc&N.indexOf(n) >= 0) {
                nc&dubquiet || ns&dubquiet and continue
                # R included are from Rc&refs/refR
                # < may not be in our h/R pool, showing...
                #   same Rc&s=objects near but not in this process
                $M = me&Mw,n,'Mlimits';
                $re =
                m $t 1189 s:♲ %deco,fs:13,lh:0.3
                $o = ns&refR[0];
                # say where it originated
                $nam = me&nampup,o,n;
                if (ns&tiny) {
                    res&hs = '499';
                    re.t += '@'+nam
                }
                else {
                    m $t 11892 $s:nam %deco,fs:7,hs:999
                }
            }
            else {
                # or the upward
                $p = ny&up;
                $upri = rc&N.indexOf(p)
                upri < 0 and debugger
                upritN[upri] ||= {};
                upritN[upri][t] ||= [];
                upritN[upri][t].push(n);
            }
            }
        }
        each itN upritN {
            $R = rc&N[i];
            $M = Rs&M || me&Mw,R,'Mlimits';
            $lim = '';
            N.length > 12 and lim = '..'+N.length; N = N.slice(0,10)
            $zs = t+' < '+N.map(t=>t.t).join(',')+lim
            $te = '*'+t;
            m $te 117 $s:zs %deco,fs:13
        }}
    };
    # warns of Rc&ha
    me.safer = &acgtR{
        R != Rc&N[0] and throw "!head"
        $ha = Rc&ha;
        !ha and return
        each ks ha {
            typeof s == 'object' and continue
            me&tsc,'Rlimits',k+'*'+s,'B'
        }
    };

    # M*

    # < move nearer Display, which handles the modulats

    # suggest y.cv of 30i+
    me.cvdeal = &acgtMv{
        # should never get to 4
        v ||= 3;
        v >= 1 and v /= 10
        $amount = 0.001;
        $amounted = 0;
        each in M {
            n.y.cv and continue
            n.y.cv = G&desca,v,8;
            v += amount;
            # final cent goes far
            # < doesn't make dupes?
            #  < change condensing this
            ++amounted == 99 and amount /= 1000
            ++amounted == 99000 and amount /= 1000
        }
    };

    # < tvsortz
    # insert C to z after cv ==, before cv >
    me.sortin = &acgtzC{
        $i = 0;
        while (1) {
            $s = z[i];
            !s and return z.push(C)
            C.y.cv < s.y.cv and return z.splice(i,0,C)
            i > 2600 and debugger;
            i++;
        }
    };
//#c ev->Elvising
    # for acting out matters
    # several types of delivery...
    # c&slope are on.Cs from paths into html
    # < being a FE
    # < collectively, esp. with Js
    # < the out-C and in-C are the same
    #   but their elements are not? what is set when?
    $drag;
    # from EleVisAn, an event
    Gs&elvrupto =
    me.elvrupto = &acgt{
        $T = {};
        $Y = me.uY;
        !Y and return
        if (c&path) {
            c&Jat[0] != Y.4 and c&Jat.shift();
            c&Jat[0] == Y.4 and c&Jat.shift();
            # <body>
            c&path.shift();
            A = Y;
            # < push for immediacy
            c&JC = c&Jat.map(&J{ return Jc&s });
            # on.C = C
            $full = c&path.slice();
            c&path_yon and full.push(...c&path_yon);
            c&slope = [];
            each in full {
                $c = n.C;
                !c || c == c&slope.slice(-1)[0] and continue
                c&slope.push(c);
            }
        }
        me&handelvis,'';
    };
    me.handelvis = &acgt{
        $msg = &s{
            a&msg && a&msg.set('state',s);
        };
        # unless dragging
        C.t.includes('mousedown') and drag = C; return 
        if (C.t.includes('mouseup')) {
            C.t = C.t.replace(/mouseup/,'click');
            if (drag) {
                $d = drag;
                $dif = [];
                # one common C, the rest different?
                each in dc&slope {
                    if (n != Cc&slope[i]) {
                        !dif.length && i > 0 and dif.push(Cc&slope[i-1])
                        dif.push(n)
                    }
                }
                dif.length and c&dragslope = dif;
            }
        }
        if (C.t == 'esc') {
            # gone too far
            # < and you know...
            $el = delete 4s&eloncer;
            el and msg("--4s&eloncer");
            return
        }
        if (C.t == 'space') {
            # press space for time
            # < say it's vaguely related to...
            G&yl,0,4c&callback;
            !c&ev and debugger;
            c&ev.preventDefault();
            event && event != c&ev and event.preventDefault();
            return
        }

        #c e finds purpose
        # may include a wander inside:
        $srv = &{
            !T.wake || T.wake == 'not' and return
            # e-nvelope the finished e with one to wake its target
            #  similar can be used to send things,
            #   unpacking e = ec&e for an act on arrival
            $e = Cye(['wake','',{e:C}]);
            ec&wake = delete T.wake;
            $cb = &{
                4c&callback(e);
            };
            G&yl,0.001,cb;
        };

        # go up C path until bingoed
        $lop = c&slope && c&slope.slice().reverse();
        # unless attention already grabbed
        $elo = delete 4s&eloncer;
        if (elo) {
            elo(A,C,G,T,lop[0]);
            s&edone = 'eloncer';
            s&n = lop[0];
            srv();
            return
        }

        # - s&medo - instant, outside (A=4) (eg Jause)
        #   T.non to keep going inside, doing no other %medo
        #     eg. the e:says for a title that also %modeens
        each in lop {
            # dont fire usual click event when dragging stuff to it
            c&dragslope and break
            $medo = ns&medo;
            !medo and continue
            !me[medo] and return ~Nomedo: medo
            $msg =
            ~Elvised: medo, '>3:what ...'
            $ret = me[medo](A,C,G,T,n);
            T.non and ret = 'non'; delete T.non; break
            else {
                s&edone = 'medo';
                s&medo = medo;
                s&n = n;
            }
            G&yl:123,&{ msg.set('what',ki(ret)) };
            srv();
            return
        }
        # - s&med: 
        #   e -> 4c&elvrupto -> me.handelvis (here)
        # puts 4c&elvising as the event of the 4c&callback
        #   then inside callback J:Fourier oscs me.Elvising
        #    finding Rs&elvis = Gazer, etc
        $cb = &{
            4c&callback(C);
        };
        #~Insideon: ki(c&slope,2)
        # GONER:
        4s&elvising = C;
        G&yl,0,cb;
    };
//#c Fourier < in-time elvising, as revampable relics
    me.Ja.Fourier = &acgt{
        me&heading;
        A&o = 'Elvising';

        4s&elvised = [];
        G.oclon ||= G.clon;
        G.oclof ||= G.clof;
        if (0 && 'draggable') {
            G.clof();
            G.clof = &{ window.onmousedown = null; window.onmouseup = null; };
            G.clon = &{ window.onmousedown = &{ G&gev }; window.onmouseup = &{ G&gev }; };
            G.clon();
        }
        else {
            G.clof();
            G.clon = G.oclon; G.clof = G.oclof;
            G.clon();
        }
        $l = 4s&elvising;
        !l and return
        $z =
        n elvising  $s:l %elvising
        #me&J,['elviseeing','-fe',{s:l}];
    };
    # Elvising looks at innermost s&med on ec&slope
    # s&med=cra:
    #  then looks at c&slope's yRs
    #    may find origin of the stimuli grasped (hy&interpreted)
    #  for Rs&elvis,
    # something to keep books on the piles of C
    # and be an instantaneous adjustment of something
    #  would the boost type Travel in parallel

    # the introgen starts, picking other
    #  an overlay chasing particular adjustments in the field from 4
    # something needs to hook named points as it goes, ensure fullness
    me.Elvising = &acgts{
        # find the one bit...
        me&CdaR,s;

        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;

            !s&elvising and continue

            if (Rs&cha) {
                ~IS
                $e = c&e || c&s;
                if ((e.t.includes('click')||1) && ec&slope) {
                    $sl = ec&slope.slice().reverse();
                    each in sl {
                        # ns&medo is handled without 4c&callback
                        $m = ns&med;
                        !m and continue;
                        # not in C or A
                        $C = c&s;
                        $s = c&s;
                        me&$m,s;
                        return
                    }
                    ~NODICE
                }
            }
        }
    };
//#c e y slope/pointer
    # c&pointer snips to subnets, finds your stuff
    # for pointing into R pools, finding Rs&elvis=hook
    #  taking the c&slope from small to big
    #  looking for Rs&elvis
    #  towards hy&interpreted
    $latestR = &R{
        $il = 275;
        $futu = 0;
        while (R.y.future) {
            R = R.y.future;
            futu++;
            il-- < 0 and throw "ancient R"
            #debugger;
        }
        futu > 5 and ~futu: R.t, futu
        return R
    };
    me.pivot = &ft{
        !f and throw "no from"
        !t and throw "no to"
        $futurup = &r{
            r = ry&up;
            r && ry&future and r = latestR(r)
            return r;
        };
        $from = me.cby(f,0,futurup);
        $to = me.cby(t,0,futurup);
        from[0] != to[0] and debugger
        $la;
        $i = 50;
        while (from[0] == to[0]) {
            i-- < 0 and debugger;
            la = from.shift(); to.shift();
        }
        $a = from.slice();
        la and a.push(la);
        a.push(...to);
        return {f:from,v:la,to:to,a:a};
    };
    # looks like a chunk of solveR, for one
    # < go up while modulat...? may change R0...
    #   this is interesting to know where our path leads,
    #   in the invisible world we act with in waves
    me.anRfromelC = &acgts{
        !isC(s) and throw "notC";
        $r = sy&R == s ? s :
            # Display's C
            s.y.Display;
        !r and throw "no idea";
        # out of some M (which get R's each under Display)
        $i = 0;
        while (rs&modulat) {
            r = ry&up;
            i++ > 15 and throw "Many modulats deep";
        }
        # out of Display
        ry&origin and r = ry&origin;
        return me&yfuture,r
    };
    me.solveR = &acgtN{
        N = N.slice().reverse();
        $M = [];
        $c = {};
        # find the deepest each of ...
        $perc = 'elvis dragelvis elvisrefresh'.split(' ');
        each in N {
            $v =
            m $n.t  $s:n
            ny&cv != null and vy&cv = ny&cv
            if (ny&A) {
                $Y = ny&A;
                # find J
                ns&J and vs&J = Y.1
                c.1 = Y.1;
                # find W, the level Travel is got to
                ns&J && ns&J == ns&J.3 and vs&W = Y.1
            }
            if (ny&R) {
                $R = vs&R = latestR(ny&R);
                vs&nam = ki(me&namup,R );
                $h = Rc&N && Rc&N[0];
                if (h) {
                    # follow to what head is looking at
                    #  for Rc&s = another pool's R
                    $t = !Rs&modulat && hy&interpreted;
                    if (t) {
                        $ri = tc&N.indexOf(Rc&s);
                        ri < 0 and ~Notininterpreter: R.t
                        R = vs&R = Rc&s;
                        h = Rc&N && Rc&N[0];
                        vs&namu = ki(me&namup,R );
                    }
                    vs&h = h;
                    vs&task = hs&task;
                }
                each it perc {
                    !R.sc[t] and continue
                    # only notice the first of each
                    c[t] and continue
                    c[t] = v;
                    v.sc[t] = R.sc[t];
                }
            }
        }
        $p = [];
        each iv M {
            # down to inner %elvis
            vs&elvis and p.push(v); continue
            !p.length and continue
            p.unshift(v);
            vs&W and break
        }
        return p
    };
//#c e-cra, e-do boost/say/drag
    # does %elvis=hook with Te
    # < make Plans to swim in there and deliver it
    me.cra = &acgtD{
        s&solvey = me&solveR,c&slope;
        !s&solvey.length and return
        if (c&dragslope) {
            s&dragsolvey = me&solveR,c&dragslope;
            each in s&solvey {
                !ns&dragelvis and continue
                # once someone up the line wants to do motion
                each id s&dragsolvey {
                    # the dragged from R%elvis
                    !ds&elvis and continue
                    c&dragfrom ||= ds&R;
                }
                each id s&solvey {
                    # and what would have handled a non-drag
                    !ds&elvis and continue
                    c&dragto ||= ds&R;
                    delete ds&elvis;
                }
                # use the travel agent
                ns&elvis = ns&dragelvis;
                break
            }
        }
        # solvey to the first %elvis
        $deep = [];
        $redeep = [];
        $refresh;
        each in s&solvey {
            # modulats don't form path
            ns&R and deep.push(n)
            if (ns&elvisrefresh) {
                refresh = n;
                redeep = deep.slice();
            }
            !ns&elvis and continue
            # here's state
            $el = me&stackTe,deep;

            T.qua = {};
            $R = ns&R;

            # make the adjustment
            $s = c&slope.slice(-1)[0];
            me[ns&elvis](A,C,G,T,R,s);

            if (T.non) {
                T.non = 'drag' and delete T.non
                # invlaid approach: drag becomes click
                if (Rs&elvis && Rs&elvis != ns&elvis) {
                    ns&elvis = Rs&elvis;
                    continue
                }
            }
            # save the state
            each kv T.qua {
                el.sc[k] = v;
            }
            T.qua and T.wake ||= R;
            R == T.wake && Rs&wakesparent and T.wake = Ry&up

            # strategise forth
            $r = refresh;
            if (r) {
                $b = rs&R;
                $reel = me&stackTe,redeep;
                bs&elvisrefresh(A,C,G,T,{Te:reel});
                s&elvisrefresh = "on n.t";
                4s&Fourieronlynow = 1;
            }
            s&elvis = ns&elvis;
            s&Teing = el;
        }
    };
    #c e-do boost/say/drag
    # click up/down anywhere
    # C = e, R above s, may be modulat or so
    me.Gazel = &acgtRs{
        if (C.t == 'says') {
            if (Rs&ball && ss&qua == 'ballrename') {
                T.notime = 1;
                me&ballrename,R,c&s;
                ~>7 rename: R.t, c&s
                # < avoidable if history/Te/etc are renamed as well
                #   or if T.wakealso = R, waking Ry&up but sleeping the non R
                #   otherwise R.t remains as it was
                T.wake = Ry&up;
                return;
            }
            else {
                # renaming requires context
                s && s.t == 't' and T.wake = Ry&up; T.wakealso = R;
                # Te.sc.$qua = input
                $qua = ss&qua || 'sayeth';
                qua == 1 and qua = s.t
                return T.qua[qua] = c&s
            }
        }
        C.t.includes('S+') and return T.qua.play = Rs&play ? 0 : 1

        Rs&boost ||= 0;
        C.t.includes('C+') ? Rs&boost-- : Rs&boost ++;
        T.qua.boost = Rs&boost;
        # < boost returning to 0 should rollback the
        #   whole bunch of elvisory it autovivified,
        #   after a few seconds
    };
    # ESC from textinput
    me.sayeth = &acgts{
        throw "GONER"
        ~Sayeth: ki(A), c&s
        T.qua.sayeth = c&s;
    };
    # ein medo:modeen, click tool then thing to drop it on
    me.modeen = &acgts{
        $R = me&anRfromelC,s;
        if (Rs&modeen) {
            Rs&modeen(A,C,G,T,s);
            $pick = delete T.pickel;
            if (pick) {
                4s&eloncer = &acgts{
                    # the above is already thus
                    $r = me&anRfromelC,s;
                    pick(A,C,G,T,r);
                };
            }
            return
        }
        ~NOTHING: R.t
        4s&modeen = R;
    };
    # via a drag-n-drop of gear to send massages
    # < e become active que-sheets
    #   may arrange/drop themselves into Wormhole...
    #   workings for the Step: wait for such release
    # all a AndContinuance, but let's see it think in R
    me.projvey = &acgtR{
    $A = G&Aye;
    $f = c&dragfrom;
    $t = c&dragto;
    $d = A.ground = G&Cye,['dr','',{elvis:C}];
    4s&eland = d;
    ds&from = f;
    ds&to = t;
    f == t and return ds&same = 1;
    $p = me.pivot(f,t);
    $v = p.v;
    # between places simple?
    $nonballic = p.a.filter(n => !ns&ball);
    if (!nonballic.length) {
        $S = tc&s;
        $s = fc&s;
        i $S/$s
        ds&moved = 1;
        ~move: S.t, '<-', s.t
    }
    elsif (vs&Cell) {
        fs&Tool and ts&play = ts&play ? 0 : 1
        else {
            ~cellsomething
        }
    }
    else {
        # move item
        debugger;
        ds&dunno = 1;
        ~dunno
        T.non = 'drag'
    }
    dc&s = p;
    }
//#c getTe receive Te
    # drive wiring from above
    # < check every point was found
    me.JT = &acgts{
        delete 1s&Te;
        $p = A.1 == A.3 ? 4s&elvisory : 2s&Te;
        !p and return
        $t = C.t;
        $Te = p&tv $t;
        !Te and return
        1s&Te = Te;
        me&TeyReal,Te,A.1;
    };

    # know if it's Te's first lifecycle or not
    # < it's our holding of this Te that has the c&el-ness
    #   and could it be on Te.c? shows sleep map
    me.TeyReal = &acgtts{
        # may be called multiple times
        ty&Real == s and return
        # < hang off R:I, but s is sometimes J
        $Y = A.n;
        $z = Ys&Teelone ||= [];
        $zi = z.indexOf(t);
        if (!ty&Real) {
            # Te's first lifecycling
            zi < 0 and z.push(t)
        }
        else {
            z.splice(zi,1)
        }
        ty&Real = s;
    };
    # < getting any c&el of any part
    me.TeyReal_celone = &acgtt{
        $Y = A.n;
        $z = Y && Ys&Teelone;
        return !t.y.Real || z && z.indexOf(t) >= 0
    }
    # R gets %Te and/or rolls:
    #  $k - Tes&$k given to Rs&$k
    #  $d - '1' to oncer/consume that sc
    # can resume pointering across Rs that don't Tie
    # < intro much more: throat's ability to pause/step etc.
    #     see tangulate for hotwiring R creation
    # < checks all pointers were found,
    # < find hidden lands

    # returns the name for the R
    # < using it, test everywhere it might change things
    me.RXbit = &acgtR{
        $t = R.t;
        # has a better .t
        Rs&RXbit and t = Rs&RXbit
        else
        0 && Rs&Te && Rs&Te.c and t = Rs&Te.t
        else
        Ry&R == R && Rc&N[0] && Rc&N[0].sc.task == 'C' and t = Rc&s.t
        return t
    };
    # makes yReal if found
    # like rollbs if k, s/b/Rs&Te/
    me.Tie = &acgtRkd{
        Ry&R != R and throw "notR"
        if (!Rs&Te) {
            # default unattached error-avoidance thing
            Rs&Te = {sc:{}};
            $r = R.y.up;
            !r || r == R and return
            !rs&Te and me&Tie,r
            $v = rs&Te;
            !v and return
            # most R.t aren't C.t
            $t = Rc&N[0] && Rc&N[0].sc.task == 'C' ? Rc&s.t : R.t;
            # Babz to tv[t] && tv[t][0.1]
            $Tet = v&tv $t;
            if (0 && !Tet && v.t == t) {
                # pointer is thinning itself, stretch while t constant
                $vv = r.y.up;
                vv = vv && vvs&Te;
                if (vv) {
                    v = vv;
                    Tet = v&tv $t;
                    Tet and ~tstretch: r.y.up.t, t
                }
            }
            Tet and Rs&Te = Tet
        }
        $Te = Rs&Te;
        !Te || !Te.c and return

        me&TeyReal,Te,R;
        # return the Rs&Te if it is real (see error-avoidance ^)
        if (k) {
            # roll sc from Te to R
            if (hak(Te.sc,k)) {
                $V = Te.sc[k];
                k == 'boost' and V *= 1
                R.sc[k] = V;
            }
            # oncer
            d == '1' and delete Te.sc[k]
            return R.sc[k]
        }
        return Te
    };
    # make Te for N pointer/solvey path
    # < a pile of travel, io T points to look at
    me.stackTe = &acgtN{
        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        each in N {
            $t = n;
            if (typeof n == 'object') {
                t = n.t;
                # has a better .t
                ns&Te && ns&Te.c and t = ns&Te.t
                else
                ny&R == n && nc&N[0] && nc&N[0].sc.task == 'C' and t = nc&s.t
            }
            # < io spacerising
            i $el/#$t
            el = ays&t[0];
            if (i == 0 && t == A.3.t) {
                3s&Te = el
            }
        }
        return el
    };
//#c setTe
    #  for setting boost that can then wander off as per
    # or just materialise the Teing to $R and return it
    me.TeNforR = &acgtR{
        # for Rs&Te, resolved if not:
        me&Tie,R;
        # randomly check I...R uplinkage
        $N = me.cby(R);
        N.shift().t != 'I' and throw "I!=0"
        return N
    };
    me.introqua = &acgtRcq{
        # for A.1
        R ||= [A.1.t];
        c && typeof c == 'string' and c = G&peel,c
        # c&el, the part of C lifecycle
        $cel = q;
        $N;
        if (R.constructor == Array) {
            N = [];
            each in R {
                typeof n == 'string' and N.push(n)
                else { N.push( ...  me&TeNforR,n ) }
            }
        }
        else {
            N = me&TeNforR,R
        }
        $el = me&stackTe,N;

        # yReal means it was already
        #  to push some init state to begin a Te
        cel == '@1' and !me&TeyReal_celone,el and c = {}
        else
        cel and throw "cel:"+cel

        each kv c {
            el.sc[k] = v
        }
        return el
    };
    # input R%Te with %Rz and %z=[C:$l]
    #  compels an R to the ground
    me.Tein = &acgtRcn{
        typeof c == 'string' and c = G&peel,c
        n = G&Cye,n;
        # get Rs&Te + qua to open R-in-z awareness
        $poi = me&introqua,R,c;
        if (!poi) {
            ~failtoel: R.t
            4s&modeen = R;
            return;
        }
        i $poi/$n
        return n
    };
//#c nameslope
    me.namup = &acgtsJ{
        !s and return
        $l = me.cby(s);
        $I = l[0];
        Iy&I != I and debugger;
        #throw 'InoI'
        !Iy&J and throw 'InoJ'
        J and l.unshift(Iy&J)
        return l.map(n => n.t)
    };
    # show path between two R
    me.nampup = &acgton{
        $namo = me&namup,o;
        $name = me&namup,n;
        $pup = [];
        each is namo {
            if (!pup.length) {
                s == name[i] and continue
                if (name[i] != null) {
                    # up the n
                    pup.push(name.slice(i).map(la=>'^').join(''))
                }
            }
            pup.push(s)
        }
        if (!pup.length) {
            $ups = name.length - namo.length;
            while (ups--) { pup.push('^') }
            pup = [pup.join('')];
        }
        $nam = pup.join('/');
        return nam
    };
    # R should know how protrusive each is
    #  spot statistical anomalies in gk,
    #  and which is definitive amongst I
    $keywords = 'testrun run step doing'.split(' ');
    # find bunch of upwards R by sc
    me.nameup = &Rlc{
        c = ex(c||{fatal:1},{wander:1});
        c.tight and delete c.wander
        # < *-match
        # < off the side of io, match + select,
        #   parallel dimensions
        $h = {};
        l = l ? l.split(' ') : keywords;
        $kw = l.slice();
        # from R going up
        $N = me.cby(R);
        N.reverse(); kw.reverse();
        h.N ||= [];
        h.twas = [];
        each in N {
            !kw[0] and break
            if (c.any) {
                # < any order
            }
            elsif(!n.sc[kw[0]]) {
                !c.wander and break
                continue
            }
            $k = kw.shift();
            h[k] = n;
            h.N.push(n);
            h.twas.push(k);
        }
        $found = h.twas.length;
        if (found != l.length) {
            if (c.fatal) {
                throw "nameup got: "+ki(h.twas)+'   exp:'+ki(l)
            }
            elsif (found == 0) {
                # not as schemed,
                # get that many upwards of whatever
                h.N = N.slice(0,l.length);
                h.twas = h.N.map(n => haks(n.sc)[0]);
            }
            else {
                # partial match
            }
        }
        # h.N becomes top-down
        h.t = h.N.reverse().map(n => n.t).join("/");
        h.twas.reverse();
        return h
    };

//#c cby
    # path/slope finder
    me.cby = &sfzdo{
        !s and return !f && d
        isC(f) and $want = f; f = &R{ return R == want }

        if (typeof f == 'string') {
            if (f.substr(0,2) == '^^') {
                $k = f.substr(2);
                k[0] == '^' and $matchesonly = k = k.substr(1)
                # ^^^ returns only the continuous blob of %$k up there
                # ^^ includes the non-matching also
                $started = 0;
                f = &R{
                    $has = R.sc[k] != null;
                    !has && !started and return matchesonly ? -1 : 0
                    has and started = 1; return 0
                    !has and return -2
                };
            }
            else {
                throw "other than ^^^?: "+f
            }
        }

        z == 'up' and z = null
        z ||= &s{ return s && (s.y && s.y.up || s.up) };
        d ||= [];
        d.unshift(s) > 512 and throw "manycby"
        $r = f && f(s,o);
        r < 0 and d.shift(); r++
        r and return d
        return me.cby(z(s),f,z,d,s)
    };
    me.cbuac = &sfzKV{
        $dom = me.cbu(s,f);
        return dom && ac(dom,f,z,K,V);
    };
    me.cbu = &sfz{
        $cb = f;
        if (typeof f == 'string') {
            if (f.substr(0,1) == '^') {
                # cby knows ^+
                cb = f;
            }
            else {
                # find ^^%$f
                cb = &R{ return R.sc[f] }
            }
        }
        typeof f == 'object' and cb = &R{ return R == f }
        $l = me.cby(s,cb,z||'up');
        return l && l[0]
    };

    # me.cbu having a boundary
    #  eg find %ting between %ting and %tingspot
    me.cbub = &Rkbc{
        c ||= {};
        isha(b) and c = b; b = null

        # k - climb for
        isob(k) and c.refk = 1
        isfu(k) and c.fuk = 1

        # b - climb while %string
        if (isst(b)) {
            b.startsWith('!') and c.neggk = b.substr(1);
            else { c.gk = b }
        }
        else
        isfu(b) and c.boundy = b
        else
        b and c.bound = b

        $alongthe = &s{
            return c.boundy && c.boundy(s)
            || c.bound && s == c.bound
            || c.neggk && s.sc[c.neggk]
            || c.gk && !s.sc[c.gk]
        };
        $N = me.cby(R,&s{ return alongthe(s)
            # k may be an inclusive boundary, returns path
            || (c.fuk ? k(s)
             : c.refk ? s == k
             : s.sc[k])
        });
        # hit boundary, no path
        alongthe(N[0]) and return
        return c.refk || c.many ? N : N[0]
    }
    me.cbyb = &Rkbc{
        c ||= {};
        c.many = 1;
        return me.cbub(R,k,b,c)
    }
  #c R timewards
    # get sc + futurise
    # < for y, etc
    me.Rsc = &acgtRtc{
        if (t.substr(0,2) == '^^') {
            t = t.substr(2);
            R = me.cbu(R,t);
            !R and return
        }
        $r = R.sc[t];
        r && isC(r) && Ry&R and r = me&yfuture,r
        # < Ring throws, with the Rc&N[0]s&clu[Rs&ci].t
        r and R.sc[t] = r
        return r
    };
    # timewards
    #  c.merged=1 for only up to finished R
    me.yfuture = &acgtrRc{
        c ||= {};
        if (r.constructor == Array) {
            # keep an array up to date,
            # not changing into ny&R
            each in r {
                ny&R != n and continue
                $o = me&yfuture,n,R;
                n != o and r.splice(i,1,o)
            }
            return
        }
        $i = 300;
        # Rs&C etc y&R to R
        ry&R && ry&R != r and r = ry&R
        while (ry&future) {
            r = ry&future;
            i-- < 0 and throw "manyfuture"
        }
        if (rc&X && rc&X.newz && !c.merged) {
            # is being a b
            $X = rc&X;
            $ri = X.z.indexOf(r);
            $l = null;
            while (!l && ri >= 0) {
                # TEST whenwhy exactly
                l = X.newz[ri];
                # can only trust things in this Rc&N,
                #   we leave aborted things in newz
                R && Rc&N.indexOf(l) == -1 and l = null
                ri--;
            }
            l and r = l
        }
        #R && Rc&N.indexOf(r) == -1 and debugger;
        R && Rc&N.indexOf(r) == -1 and throw "yfutured "+R.t+" not in RcN"
        #R && Rc&N.indexOf(r) == -1 and ~yfutured not in RcN: R.t
        return r
    }
//#c Rdata ioty, Mwty
    # io should be able to: $t/Thing%ball/%ball or so
    #  t = C or R%ball
    #  y = path of ns&$gk
    #  M = path of n.t
    # insphere/outsphere awkward:
    #  M=c{st=M} to match nc&s.t,
    #   y keeps matching ns&$gk
    #   Z->N keeps climbing ns&z
    # < make y=['','ball',{if:...}]
    # < layer above this combines [y,M]
    me.ioty = &acgttyM{
        $c = {}; # might be M

        # %sc%to%match
        $leg = y;
        if (typeof leg == 'number') {
            leg == 0 and return [t]

            $scgk = 'ball';
            $i = 1;
            $p = scgk;
            while(leg>i) {i++; p += '%'+scgk}
            leg = p
        }
        if (typeof leg == 'string') {
            leg = leg.split('%');
            leg[0] == '' and leg.shift();
        }
        leg ||= [];

        # names/to//match
        M ||= [];
        if (typeof M == 'object'
            && M.constructor != Array) {
            c = M;
            $k = haks(c)[0]; # trick?
            M = c.st || c.t || [];
        }
        typeof M == 'string' and M = M.split('/')

        # default *
        !leg.length and leg.push('');
        !t and return []

        $tz = &n{
            if (c.zvia == 's') {
                # if trusting nc&s more than s,
                # Rsync where it looks out
                $cs = nc&s;
                !cs || !css&z and return []
                $ok = 1;
                each is css&z {
                    # < hasRef?
                    $rfor = ns&z && ns&z
                        .filter(r => rc&s == s).length;
                    !rfor and ok = 0
                }
                ok || me&Rsync,n
            }
            return ns&z || []
        };
        $N = t.constructor == Array ? t : tz(t);
        !N and return []

        $Z
        each i,bit leg {
            $t = M[i];
            bit == '*' and bit = ''
            t == '*' and t = ''
            if (Z) {
                N = [];
                each in Z {
                    N.push(...tz(n))
                }
            }
            Z = [];
            each in N {
                $l = c.st ? nc&s : n;
                !l and continue
                bit && n.sc && n.sc[bit] == null and continue
                t && l.t != t and continue
                Z.push(n);
            }
        }
        return Z
    };
    # get modulat by t,mindtfrom,sc
    # all optional
    # k which Rs&Mw[k]
    # M matches t path
    # y matches scgk path
    # returns one/many
    me.Mwty = &acgtRkMy{
        $Mw = Rs&Mw;
        $N = [];
        k and N = Mw[k] || [];
        else {
            each in Mw {
                N.push(...n)
            }
        }
        $N = me&ioty,N,y,M;
        return M && y == null ? N[0] : N
    };
//#c Rsync
    # input s to Rc&s, updating %balls
    # an io that makes changes to both A & C at once
    me.input = &acgtRs{
        if (!Rs&ball) {
            # we are pathing to another group of %balls
            # find R.t instead of Rc&s.t:
            typeof s != 'string' and throw "input path out of %ball !string"
            # there might be multiple of these, of %hypball
            #   for each %push to hang up its state/ambition on
            return Rs&z.filter(n => ns&ball && n.t == s)[0]
        }
        $S = Rc&s;
        # look for it
        o $S/#$s
        ya && typeof s != 'object' and s = ya
        if (ya && ya != s) {
            ~Bepicky: Ry&up.t, R.t, s.t
            $si = Ss&z.indexOf(s);
            i $S/-$ya
            ya = null
        }
        if (!ya) {
            if (typeof s != 'object') {
                i $S/#$s
                s = ya
            }
            else {
                i $S/$s
            }
            if (si != null) {
                # keep order
                $is = Ss&z.indexOf(s);
                is < 0 and throw "noin"
                if (is != si) {
                    Ss&z.splice(is,1);
                    Ss&z.splice(si,0,s);
                }
            }
        }
        me&Rsync,R;
        each in Rs&z {
            nc&s == s and return n
        }
        debugger;
        # should have found that input
    };
    # redo tv/tw
    # < rename its Te also
    # < keep it still in z
    # < move to ballio
    me.ballrename = &acgtRt{
        $S = Rc&s;
        S.t == t and delete Sy&renamed_from; return
        $p = Ry&up;
        $P = pc&s;
        $zi = Ps&z ? Ps&z.indexOf(S) : -1;
        if (ps&ball)
            i $P/-$S
        $ot = S.t;
        S.t = t;
        !ps&ball || !ays&S.length and debugger
        me&Rsync,p;
        i $P/$S
        if (zi > -1) {
            $zn = Ps&z.indexOf(S);
            zn < 0 and debugger
            # if removing before it, put -1
            zn < zi and zi--
            $out = Ps&z.splice(zn,1);
            Ps&z.splice(zi,0,S);
        }
        Sy&renamed_from = ot;
        me&Rsync,p;
    };
    # keep a %ball for each Rc&ss&z!
    me.Rsync = &acgtRV{
        $S = Rc&s;
        $p = Ry&up;
        Rs&noRsync and return
        ps&childy and Rs&childy = ps&childy
        if (Rs&childy == 'tw') {
            # rebuild from tw
            delete Ss&z;
            each ts S.y.tw {
                ac(S,'z',s);
            }
        }
        # o $S/*
        $ba = (Ss&z||[]).slice();
        $rm = [];
        each in Rs&z {
            !ns&ball and continue
            $bi = ba.indexOf(nc&s);
            bi >= 0 and ba.splice(bi,1)
            else { rm.push(n) }
        }
        each in rm {
            ns&eph and continue
            Rs&z.splice(Rs&z.indexOf(n),1);
            n.c.not = 1;
            T.V &&
            ~Removed: R.t, n.t
        }
        T.notime and return
        each in ba {
            if (Rc&nofurther) {
                ~Rsyncnofurther: R.t, n.t
                delete Rc&nofurther;
            }
            T.V &&
            ~Included: R.t, n.t
            $t = me&Ret,R,{t:n.t,s:n,ball:1};
            # do not yet know if tc&nofurther (ing of Ring)
            # pass movers good luck
            # < refR clearer, things it may recycle/is forking
            # < remove Removed (above) from refR
            # also %ball compulsively dupl=0
            tc&dupl = 2;
            me&zN,t;
        }
    };

//#c Roll
    # < put all Rs&$k stuff somewhere
    # attaches Rs&One callback
    # calls only if still the Rs&One
    # for grouping various delayed reactions
    me.sccb = &acgtRky{
        !y and return &y{ return me&sccb,R,k,y };
        $cb;
        cb = R.sc[k] = &{
            R.sc[k] == cb && y ();
        };
        return cb
    };
    # s.sc[k] ||= (v||1) unless 0 or ''
    me.suggesc = &acgtskv{
        v == null and v = 1
        s && s.sc[k] == null and s.sc[k] = 1
    };
    # return unresumed sc
    me.ollbs = &acgtRt{
        return Rc&b && Rc&b.sc[t]
    };
    # keeps Rs&tracting current
    # ! may move ryR away from modulat
    me.rollbsy = &acgtRk{
        $r = me&rollbs,R,k;
        r and R.sc[k] = r = me&yfuture,r
        return r
    };
    # resume sc
    me.rollbs = &acgtRsv{
        typeof R == 'string' and v=s;s=R;R=C.y.R
        $b = Rc&b;
        !isar(s) and s = s.split(',')
        each ik s {
            # we will keep setting from b
            # < change that, test elvising
            Rs&rolled && Rs&rolled[k] and continue
            b && hak(b.sc,k) and R.sc[k] = b.sc[k]
        }
        v != null && R.sc[k] == null and R.sc[k] = v
        return R.sc[k]
    };
    # Rs&* doesn't roll from Rc&b
    #  will overwrite change
    me.rolled = &acgtkdc{
        $R = Cy&R;
        Rs&rolled ||= {};
        Rs&rolled[k] = c || 1;
        d and R.sc[k] = d
        else { delete R.sc[k] }
    };

// #c rollbsc
    # R.sc.$process restarts/continues
    # < sleeping clues, A:Kn
    me.rolls = &acgtkc{
        $R = Cy&R;
        c ||= {};
        me&rollbs,k;
        $dig = ["Foogla@"+G&t,'w','Foogla' .sc.dige];
        c.s and dig.push(c.s);
        $d = c.alsolineate;
        d and dig.push(isC(d) ? "C:"+d.t : d+"")

        $lin = dig.join(' & ');
        $was = me&rollbs,R,'lin_'+k;
        $dwas = me&rollbs,R,'lin_'+k+'_also';
        if (was != lin || d && d != dwas) {
            R.sc['lin_'+k] = lin;
            R.sc['lin_'+k+'_also'] = d;
            # can decide to return old or new state
            $s = c.cb ? c.cb() : {};
            me&rolled,k,s,c;
        }
        else {
            # still or init
            return 1
        }
    }

    # roll %run per result[0] (c.lineate)
    #   and c&increment++ added to .t
    me.rollcounty = &acgtRtc{
        c = ex(c||{},{incrementt:1,count:1});
        c.per and c.lineate = delete c.per
        return me&rollbsc,R,t,c
    }

    # roll %process that persists, is C
    me.rollbsc = &acgtRtc{
        c ||= {};
        typeof c == 'string' and c = G&peel,c

        $layers = t.split('/');
        $t = layers.shift();
        # rolls the top
        me&rollbs,R,t;
        $S = R.sc;
        $r = S[t];
        # inflate index
        while (layers.length) {
            !r and S[t] = r = {}
            S = r;
            t = layers.pop();
            r = S[t];
        }
        # eg %Compiling=1 becomes a rolling C
        #  then rollbs will replace 1 with that C
        r == 1 and r = null; delete S[t]
        c.b and delete S[t]
        if (c.lineate) {
            if (r && ry&lineate != c.lineate) {
                # y.hist?
                delete S[t]
            }
        }
        if (!S[t]) {
            $n = G&Cye,[t,''];
            # may have r history
            c.increment ||= c.incrementt;
            if (c.increment) {
                nc&increment = r ? rc&increment + 1 : 0;
                if (c.incrementt) {
                    n.t += '_'+nc&increment;
                    delete c.incrementt;
                }
            }
            delete c.increment
            c.b && r and nc&b = r; delete rc&b
            if (c.lineate) {
                ny&lineate = c.lineate;
                delete c.lineate
            }

            ex(n.sc,c);
            r = S[t] = n
        }
        if (c.count) {
            rs&count ||= 0;
            rs&count++;
        }
        return r
    }

//#c tsc walla 
    me.tsc = &acgttscb{
        # like n, may c={s:string}
        isob(s) and $s_c = s; s = s.s
        else
        s == null || s == 0 and s = t
        isC(t) and $n = t;
        else {
            $M = T.Mw && me&Mw,Cy&R,T.Mw;
            if (M) {
                $n =
                m $t  $s:s
            }
            else {
                $n =
                n $t  $s:s
            }
        }
        s_c and ex(n.c,s_c)
        $y = &b{ ex(n.sc,G&peel,b ); return 1 };
        typeof c == 'object' and ex(n.sc,c); c = ''
        c += '';
        $silent = 0
        $eat = &n{
            c.substr(0,1) == n and c = c.substr(1); return 1
        }
        eat('s') and silent = 1
        eat('1') and y('dis')
        eat('2') and y('dis:2')
        eat('3') and y('dis:3')
        eat('4') and y('dis:4')
        eat('5') and y('dis:5')
        eat('6') and y('fs:6')
        eat('7') and y('fs:7')
        eat('8') and ny&cv = 0.8
        c == 'B' and y('hs:856,fs:17')
        c == 'T' and y('hs:966,fs:14')
        c == 'b' and y('hs:856')
        c == 'D' and y('hs:675,fs:25')
        c == 'd' and y('hs:676')
        c == 'G' and y('hs:999,mar')
        c == 'g' and y('hs:634')
        c == 'p' and y('hs:395')
        c == 'C' and y('fs:13,lh:0.8,hs:757')
        # yellow:
        c == 'y' and y('hs:296')
        # verticalised label
        if (c == 'l') {
            # turn original into spacer
            $s = delete nc&s
            nc&s = '&nbsp;'
            nc&ht = 1
            y('ma:0.4,dis:2');
            $M = ns&z = [];
            $l =
            m $n.t  $s:s
            ny&label = me&tsc,l,0,'label';
        }
        silent and delete nc&s
        # ,ml:-0.5,mt:-0.4,
        c == 'label' and y('wb:0,ml:-0.5,tro:20% 0%,hs:296,rad:90,scale:0.8,ab,poi:0')
        c == 'L' and y('fs:15')
        b and y (b)
        return n
    };

    # cell wall style
    # < dome for geometry adjustement on its own
    me.walla = &acgthc{
        R = Cy&R;
        isC(h) and throw "its &walls,C..."
        me&walls,R,h,c;
    }
    me.walls = &acgtthc{
        !isC(t) and throw "walls C"
        !ty&R || ty&R != t and $C = t
        else {
            $R = t;
            $C = Rs&C;
            !C and throw "walls R!C"
        }
        $x;
        typeof h == 'number' and x = {m:h}; h = null
        c ||= h || {};
        typeof c == 'string' and c = G&peel,c
        x and ex(c,x)

        # can be used to style any C
        if (R) {
            Rs&C != C and throw "Cy&R not Rs&C"
            c.m == null || c.r and Rs&rowish = 1
        }

        # mass/space from others
        c.m and s&ma = c.m

        c.hu and s&hue = c.hu * 10
        if (c.wi) {
            # wider than parent
            $f = (100*c.wi);
            s&wi = f+'%';
            f > 120 and s&ml = (-(f-120))+'%'
        }
        c.bd and c.b ||= c.bd
        c.ba and c.b ||= c.ba
        if (c.bg) {
            s&bgh = c.bg == 1 ? '000' : c.bg;
            s&bgh += ''
            s&bgh += '142'.substr(s&bgh.length);
        }
        if (c.b) {
            # (border px).(rounded em)
            $s = (''+c.b).split('h');
            $geo = s [0].split('.');

            $px = geo[0] || 0;
            $round = geo[1];

            $style = c.bd && "dotted"
                || c.ba && "dashed"
                || "solid";

            s&bo = px+'px '+style;

            # is a hue away from
            $boc = s [1];
            boc == null and boc = 6
            boc += '';
            boc += '175'.substr(boc.length);
            s&boc = boc

            round and s&br = round
        }
    };


//#c rolltog/modeen - click on/off Rs&$k
    # the %modeen callback, see togla, nto
    me.modeenery = &Rc{
        c ||= {};
        Rs&modeen = &acgtr{
            R = me&yfuture,R;
            !C.t.includes('click') and return T.non = 'notaclick'
            ry&modeening and ry&modeening(r,T,C)
            else
            if (rs&togla) {
                $k = rs&togla;
                $v = R.sc[k] = R.sc[k] ? 0 : 1;
                c.setter && c.setter(v)
            }
            else {
                throw "What? "+r.t
            }
            T.wake ||= R;
        };
    };
    # sets up R to respond with y(r:elC) to clicks on n
    me.nto = &Rny{
        n.y == n and throw "A"
        ns&medo = 'modeen';
        ny&modeening = &sTe{
            y (s,T,e);
            # prefer waking this R to 4c&callback
            T.wake ||= R;
        };
        me.modeenery(R);
    };

    # toggle fs&$k = m[0,1]
    # < dropdown/typein
    me.gamesc = &acgtRfkm{
        $c = {may:'change_'+k,tsc:'d',once:1};
        c.s = f.sc[k] || '+';
        $get = me&rolltog,R,c;

        $n = c.n;
        me&walls,n,'b:2.2h8'
        ns&bri = 1.3;
        $bet = "toggles %"+k+" between "+m.join(',');
        #ns&z = [G&Cye,[bet,1,{s:'?'},'fs:8'] ];

        # leaves unset (will init to m[1])
        # returns it if not changed
        !get and return f.sc[k]
        $ki = m.indexOf(f.sc[k]) + 1;
        !m[ki] and ki = 0
        nc&s = f.sc[k] = m[ki];
    };

    # on/off button displayed/returned
    me.rolltog = &acgtRkdy{
        $c = typeof k == 'object' ? k : {k:k};
        $setter = c.y || y;
        $initval = c.d || d;
        if (c.k && c.k.substr(-1) == '?') {
            # 'W?' %maydo_W, textual
            # < regex like perl
            c.maydo = c.k.substr(0,c.k.length-1);
        }
        c.may and c.maydo = c.may;
        if (c.maydo) {
            c.hue = 30;
            c.k = 'maydo_'+c.maydo;
            c.s ||= c.maydo;
            !c.may and c.s += '?'; c.ma = 0.6
        }
        c.k.length < 6 and c.s = c.k; c.fs = 11
        c.s ||= '●';
        $k = delete c.k;
        $s = delete c.s;
        $M = delete c.M;

        M = M || me&Mw,R,(T.Mw||c.Mw||'rolltog');
        $n =
        m $k  $s:s %medo:modeen
        c.togla = k;
        ex(n.sc,c);

        c.tsc and me&tsc,n,0,c.tsc
        c.n = n;
        ns&hue ||= -30;

        $v = me&rollbs,R,[k],initval;
        if (v) {
            # is on
            ns&fs = 13;
            c.once and delete R.sc[k];
        }
        else {
            ns&bri = 0.5
        }

        # < merge to Tool's
        me.modeenery(R,{setter});
        if (setter) {
            # set value every time
            !c.relax and setter(R.sc[k]);
            me.cbuac(R,'unDoming',&{
                setter(0);
            });
        }
        return v
    }

//#c Data
    # have consumed array
    # indexOf with mask
    # $sel = selecto(N)
    #  sel(thing) gives thing's i in N, once
    #  sel(thing,-1) doesn't count as a once
    #  sel(thing,i) puts another at i
    #  sel(thing,*,from) i must > from
    me.selecto = &acgtdl{
        d ||= [];
        $ignoreonceread = !l;
        $ig = l || {};
        $sel = &sif{
            $hi = null;
            # doesn't count as a read
            i != null && i < 0 and $noig = 1
            $have_from = 0;
            while (hi == null) {
                hi = d.slice(have_from).indexOf(s);
                hi < 0 and break
                hi += have_from
                $no = ig[hi];
                noig and no = 0
                f && f >= hi and no = 1
                no and have_from = hi+1; hi = null
            }
            if (hi >= 0) {
                # read that only once
                ignoreonceread && hi >= 0 && !noig and ig[hi] = 1
            }
            # stash again/at i/make readable again
            i != null && i >= 0 and d[i] = s; delete ig[i]
            return hi
        };
        return sel
    };
    me.sameset = &acgtMN{
        return heq(M,N)
    };

#c differ - newer than diff, older than Zif
me.Differingness = &acgt{ return [
    # branching difference
    # one or more things observed at a time, branching:
    #  building a chain of state change through time:
    #   show the usual either-whole and/or difference
    #   fade/compress far history
    #   reverse/abandon limbs
    #   %push's general motive of %here->%their with option to <-
    #   chunking the entire diff to commits
    #     handy for cleaning up messy current state
    #   auto commit:
    #     hanging on something (test acceptance)
    #     commit message, what other activity/commits it was with
    #      when a commit message is available
    #      the goaley development-awareness of a %testrun?
    #   grouping commits if:
    #     time passes, lum importance
    #     total change is much < each of the changes (churn)
    #   inheriting branching:
    #     uses/gives a continuity of %what is
    #     the format to hold commits in
    #       eg. $mad_situation can be traced to %what is feeding it
    #       %testrun using this to bisect source of errors
    #   inheriting treeing:
    #     parts of the string relate to Cs
    #      clickthrough to the relative realities
    #     not even string but Reality itself
    #   permanent difference:
    #     when %their will never fully be %here
    #      know some difference isn't new, ignore it etc
    #       similar to reworking a patch: has an already layer
    #     learn how to create that difference
    #      pattern match trainer
    #       reducer of vastness by some compression
    #   incorporators:
    #     transmitting diffs may be a few elvisings complicated in the worst case
    #     probably just $t $dig $parent_dig $diff = OK
    
    # all fairly important features to have...
    # a good novelty gatherer
    # do without until development is easier?
    # then suddenly when making lots of rum
    
    # %differ
    #   Min = [
    #     %differing
    #       c&s = slan
    #       backups [ more slans
    ['differ','7',&acgtRs{
        Rs&rowish = 1;
        # < figure out why such dub tho we %refpool 
        Rc&dubquiet = 1;
        !s and return me&tsc,'nos',"s?",'B'
        $ingwaz = 'ᛜ';
        me&tsc,'differ',"☞",'G' .sc.fs=20;
        
        $M = Rs&Min = me&rollbs,R,'seriala,Min' || [];
        Rs&seriala ||= 0;
        # < any large string, choose ways to make string
        $k = ss&landscape ? 'landscape' : 'string';
        Rs&diffthescgk = k;
        $current;
        $include = &s{
            !s and throw "Not something"
            $ok = 0;
            each in M {
                $z = nc&s;
                !z.sc[k] || !s.sc[k] and ok--; break
                z.sc[k] != s.sc[k] and continue
                current = n;
                ac(n,'backups',z);
                while (ns&backups.length > 5) {
                    ns&backups.shift();
                }
                nc&s = s;
                ok++; break
            }
            ok<0 and return me&tsc,'notcompable',"s\&string?",'B'
            if (ok<1) {
                $serial = Rs&seriala++;
                current =
                m $serial  $s:s,R %differing
            }
            #c current is
            # < circuitey trees of whatever is observed,
            # < exactly how they connect
            # < knowing more instances of %slan
            #   sharing dimensions of self, tree may import
            $b = Rc&b;
            if (b) {
                # tries to get order making sense,
                #  single branch only, may loop
                $parent = bs&current;
                parent != current and currents&parent = parent
                $ci = M.indexOf(current);
                $pi = M.indexOf(parent);
                ci == 0 && pi+1 == M.length and 'end to end'
                else
                pi == 0 && ci+1 == M.length and 'end to end'
                else
                ci == pi+1 and 'follows'
                else {
                    M.splice(ci,1);
                    M.splice(pi,0,current);
                }
            }
        };
        if (!M.length) {
            # start knowing as much history as possible
            $N = me.cby(s,0,&s{ return sc&b }).reverse();
            N.map(b => b && include(b));
        }
        # this look
        include(s);
        Rs&current = current;
        # < shrink things that havent been current
        #   since current was last current
        
        $la;
        each in M {
            # put diff between
            $rd = ns&parent && 
                n ringdiff  $exp:ns&parent %R:differings
            $d =
            n $n
            # to the thing now
            rd and rdc&got = d
            n == current and ds&current = 1
            # to permanent
            dy&C = n;
            # for got=parent to turn into R
            ny&D = d;
            M.length == 1 &&
                n ringdiff  $got:d %R:differings
            la = d;
        }
    },'ift,D'],
    #c compute between [%differing+]
    # %differing impersonates %slan,
    # looking more like what %diff expects
    ['differing','11',&acgtRs{
        $p = Ry&up;
        $k = ps&diffthescgk;
        !k and throw "this"
        Rs&dige = ss&dige;
        Rs&string = s.sc[k];
        !Rs&dige || !Rs&string and return me&tsc,'digestring',"?s?",'B';
        
        # serial number or commit message
        $t = me&tsc,'t',R.t,'G';
        Rs&current and ts&bg = '#000'
        # could be renamed to dige
        #  but test wriggle breaks too many pointers
        #   < auto rename
        #R.t = "the "+ss&dige;
    },'ift,D'],
    # they form our name
    ['differings','12',&acgtRs{
        $ot = [];
        # de-dome input differences.
        # < in the future it will all be the same,
        #   osc will choose along the y-vailable onness...
        $intoR = &s{ 
            s.y.D and s = s.y.D;
            return s.y.R || s;
        };
        Rs&got and Rs&got = intoR(Rs&got)
        Rs&exp and Rs&exp = intoR(Rs&exp)
        $s = [Rs&got];
        Rs&exp and s.push(Rs&exp);
        # then, many diffs
        each in s {
            # modulated %differing's c&s = %slan
            $z = nc&s;
            $di = zs&dige;
            !di and return me&tsc,'notcompable',"s\&dige?",'B'
            ot.push(n.t);
        }
        # goes backwards?
        R.t = ot.join("->");
    },'ift,D'],
    # 
    ['differings','3',&acgtRs{
        # < many diffs, weave together?
        #   bit of a funtime
        $h = Rs&got;
        $t = Rs&exp;
        $c = {};
        !t and c.unexpected = 1;
        me&diffya,R,'diff',h,t,c;
    },'ift,D'],
]};

//#c diff balls with strings
    # setty http://xahlee.info/comp/unicode_math_operators.html

    # keep diffs around 7%push
    # tolerate string=''
    me.diffya = &acgtRkhtc{
        c ||= {};
        ex(c,{t:k,got:h,exp:t,diff:1});
        $dt = Rs&diffya ||= {};
        # may be switched off:
        dt[k] != null && !dt[k] and return
        $d = dt[k] = me&Ret,R,c;
        # can be seen to be ... already
        t && h && ts&dige == hs&dige and ds&exactly = 1
        h && !t and ds&new = 1
        return d
    };

    # a %diff
    me.Diffingness = &acgt{ return [
        # < map diff back out to %balls, if clicked
        # < might turn the diff into another artifact of time
        #   that needs rebasing when what you're working on changes
        # < making several commits of a bunch of change
        #   by the initial diff selecting %self%balls
        #   to go %othering into a %staging%balls
        #   %Lines that and diff etc against %other again

        ['diff','3',&acgtRs{
            s&ws = 'pre';
            s&fs = 7;
            s&wb = 'break-word';
            s&ma = 0.2;
            s&pa = 0.3;
            s&lh = 1;
            !me.Fourismness and s&bob = '1px dotted yellow';
            Rs&hue and s&hue = Rs&hue
            # ^ applies to diffproximate but not the patch?

            $g = Rs&got;
            me&sch_gotstring,R,g,'got';
            $x = Rs&exp;
            x && !Rs&expGhost and me&sch_gotstring,R,x,'exp';
            $ob =
            n $R.t 13 s:~ %fs:29,lh:0.1

            if (x) {
                if (gs&dige == xs&dige) {
                    # apparently the same, avoid load/decode
                    Rs&exactly = 1;
                    obc&s = '=';
                    ob.t += ' equal';
                }
                elsif (Rs&expGhost) {
                    # decode contents of expectation
                    x = Rs&exp = Rs&expGhost();
                }
            }
            if (!x) {
                !Rs&unexpected and throw "Not expected to be unexpected"
                # < most after the difference from previous step
                obc&s = 'new!'
            }
            if (me&Mw,R,'err' .length) {
                n diff3_errors  s:⊗ %fs:18
                obc&s = '!'
            }
            if (Rs&boost > 0 && Rs&exactly) {
                # boost wears off as it stills
                # somewhere else does the reverse..?
                $b = Rc&b;
                b && !bs&exactly and Rs&boost = --Rs&Te.sc.boost
            }
            if (obc&s.match(/[!=]$/)) {
                if (Rs&boost > 0) {
                    n entirety  $s:gs&string %max-height:7,over,dis
                }
                return
            }

            # switch chunk: word/line

            me&rollbs,R,'Digs,Diff,CompN,Comp';
            $digs = dig(xs&string||'')+dig(gs&string||'')+dig(ki(c));
            Rs&Digs != digs and delete Rs&Diff; 
            Rs&Digs = digs;

            # the job
            $c = {chunk:'word',fold:1};
            $N = Rs&Diff ||= diff(xs&string||'',gs&string||'',c);

            # CompN - sum noise
            Rs&CompN != N and delete Rs&Comp;
            if (!Rs&Comp) {
                Rs&Comp = me&textdiffN,N,c;
                Rs&CompN = N;
            }

            me&diffproximate,R;

            if (Rs&boost > 0) {
                $l = Ry&up;
                ls&rowish = 1;
                $p =
                n patch   %max-height:7,over,dis
                ps&z = [...Rs&Comp];

                if (!ps&z.length) {
                    obc&s != '=' and throw "empty patch !="
                }
            }
        },'ift,D'],
        ['diff','87',&acgtRs{
            Rs&sublated and s&fs = 4
        },'ift,D'],
    ] };


    #c diffy
    me.diffproximate = &acgtR{
        # how many lines +- approx
        $M = me&Mw,R,'diffproximate';
        $h = {};
        $diff = 0;
        each in Rs&Comp {
            if (nc&s.indexOf("\n") < 0) {
                # in-line boundary means something is changing, a little
                # note that once per line
                if (!diff) {
                    h.diff ||= 0;
                    h.diff++;
                    diff = 1;
                }
            }
            else {
                diff = 0;

                $Lines = nc&s.split("\n");
                $lines = Lines.length;
                Lines.slice(-1)[0] == '' and lines--
                h[n.t] ||= 0;
                h[n.t] += lines;
            }
        }
        $k = G&peel,'new:+,diff:~,gone:-,same:=';
        each is k {
            $n = h[i];
            !n and continue
            $s = s+n;
            $C =
            m $i  $s:s %fs:25
            C.t == 'new' and s&hue = '265deg';
            C.t == 'gone' and s&hue = '111deg';
            C.t == 'diff' and s&hue = '55deg';
        }
        # < putting yay many things approximately where they are,
        # < putting in names shaded to their thisthatty
    };
    # textdiffN - clean up/fold
    # < reconduity el wai
    me.textdiffN = &acgtNc{
        $M = [];
        each in N {
            $m =
            m bit  $s:nc&s %
            m.t = n.t;
            n.t == 'new' and ms&hue = '265deg'
            n.t == 'gone' and ms&hue = '111deg'
            n.t != 'same' && !nc&s.includes("\n") and ms&deco = 1
            if (ms&hue) {
                # visible trailing \n
                mc&s.match(/^\s+|\s+$/) and mc&s = mc&s.replace(/\n/,"↯\n")
                continue
            }

            !c.fold and continue

            $s = mc&s;
            s.length < 40 and continue
            if (0 && !s.match(/\n/)) {
                ms&shortfor = [s];
                mc&s = s.slice(0,20)+" ... "+s.slice(-20);
            }
            else {
                $L = s.split("\n");
                $las = L.pop();
                L = L.map(&s{ return s+"\n" });
                las != '' and L.push(las);
                $w = []; # to be
                # fold ind level
                # deep is shallow+1, when shallow bit grouper found
                $deep = null;
                $la = null;
                $finalN = i*1+1 == N.length;
                $firstN = i == 0;
                each il L {
                    # not 3 lines near a change
                    if ((firstN || i > 1) &&
                        (finalN || i < L.length - 3)) {
                        if (la && deep && l.match(deep)) {
                            !la and throw "no la";
                            $sh =
                            las&shortfor ||= [];
                            sh.push(l);
                            continue;
                        }
                    }
                    la = null;
                    w.push(l);
                    $shall = l.match(/^(  +)/);
                    if (shall) {
                        deep = new RegExp('^'+shall[1]+'  ');
                        la =
                        m $m.t  $s:w.join("") %
                        w = [];
                    }
                }
                mc&s = w.join("");
            }
        } 
        each in M {
            ns&hue || ns&bri and continue
            # shortened inside lines
            $text = ns&shortfor;
            !text and continue
            # falsify a heading, 't y ... +n':
            $m = nc&s.match(/^(  \S[^\t]*\t[^\t]*\t)/);
            if (m) {
                text.unshift(nc&s);
                nc&s = m[1] + " ... +"+(text.length-1);
                nc&s += "\n";
            }
            else { # never misses? 
                #
            }
            !text.join and debugger;
            ns&shortfor = text.join("");
            ns&fs = '80%';
            ns&bri = 0.6;
            ns&dow = 'do/Swaps';
        }
        return M;
    };

#c Lines
me.Linesingness = &acgtR{ return [
    # c&s decodes, gets %dige, %string
    ['Lines','22',&acgtRs{
        # %Lines=3 skips decode
        Rs&Lines == '3' and return Rs&Lines = 1
        # < we should have a %dige to check s against
        #   or ref $s implies %Lines=3 if not there
        !s and ns&notfound = 1; return
        
        $b = Rc&b;
        Rs&string = s;
        if (b && bs&string == Rs&string) {
            me&rollbs,R,'toLines,dige,decoded';
        }
        else {
            Rs&toLines = Rs&string.split("\n");
            Rs&toLines.slice(-1)[0] == '' and Rs&toLines.pop();
            Rs&dige = dig(s);
            Rs&decoded = G&readLines,s [0];
        }
        Rc&s = Rs&decoded;
        Rs&intoa and Rs&Lines = 0; R.sc[Rs&intoa] = 1
        # R now %ball not %Lines
    },'ift,D'],
    # %Lines=1 set on %ball later
    # %Lines=[tops] is/inherits
    # tops accumulate LinesN of Linesers
    # < rename Linesers
    # < make that clearer with iobab
    ['Lines','6',&acgtRs{
        !Rs&ball && !Rs&Copy and throw "Lines!ball"
        # a top
        Rs&Lines == '3' and Rs&Lines = 1
        Rs&Lines == '1' and Rs&Lines = [R]
        # < dup would be fatal?
        Rs&Lines.map(r => ac(r,'LinesN',R));
        # < if this %ball dups, head to best dup?
        # which only happens now
        # should have more singular drawings from
        each in Rs&z {
            !ns&ball && !ns&Copy and continue
            ns&noDescribe and continue
            $toppy = ns&Lines == '1';
            ns&Lines = Rs&Lines.slice();
            # tops accumulate
            toppy and ns&Lines.push(n);
        }
        $the = me&Timethe,'toLines';
        $part;
        try {
            part = 'scan';
            !isC(s) and throw "Not C"
            typeof C.y != 'object' and throw "NotC"
            sc&N and throw "mightbe R"
            # ^ Care-ing for an unconscious R in z?
            #     if Rs&C wasn't made, Rc&s = Rousce
            #   as if Rc&nofurther + s&z emit, they may show up...
            part = 'clone';
            $D = G&Cye,s;
            part = 'comp';
            # comp && comp(R,D);
            #R.c.not and return
            part = 'Compress';
            G&Compress,D;
            Rs&compLines and Rs&compLines(D,R)
            Ds&M and Ds&M = []
            part = 'toLines';
            Rs&toLines = G&toLines,D;
            Ds&H && !Rs&toLines.match(/(H):(\w+)\b/) and throw "%H not so gc will see it"
        }
        catch (er) {
            ~enLinesR: ki(C,2)+"   !"+part+"! "+er
            me&Rec,R,'err';
            Rs&toLines = "[error} "+ki(C);
            Rs&err = "enLinesR: "+part+": "+er;
            n err  $s:Rs&err
        }
        the();
    },'ift,D'],
    #c gathering Linesers
    # build a LinesN for decoded Lines too,
    # to look more like Lines, so LinesN/%H can be found
    # < a more A'd to/readLines with each chunk a %ball
    #   good for twining compression patterns in to both sides
    ['intoa+ball','67',&acgtRs{
        Rs&Lines != 0 and return
        $N = Rs&LinesN = [];
        $z = &n{
            !ns&ball and return
            N.push(n);
            ns&z and ns&z.map(z);
        };
        z(R);
    },'ift,D'],
    ['Lines','67',&acgtRs{
        !Rs&LinesN and return
        # LinesN nonbeyond R%sleeping
        $rN = Rs&LinesN.slice();
        # Ring may distort the order of Rs&z
        $i = 0;
        while (rN[i]) {
            $r = rN[i];
            $ind = '';
            $ini = 0;
            $dent = rc&d - Rc&d;
            while (ini < dent) { ind += '  '; ini++ }
            $s = rc&s;
            $say = rs&toLines;
            $lv = s.y.lv;
            if (lv) {
                !lvs&Lines and throw "!Linesy"
                say = lvs&string;
                # s&strings have a trailing \n,
                #  toLines/LinesForSomeone don't
                say = say.replace(/\n\s*$/,'');
                #~>4 LV: r.t, say.length
            }
            say == null and say = '[error} null %toLines: '+r.t
            $l = say.split("\n")
                .map(l => ind+l).join("\n");
            #l += "\n";
            rs&LinesForSomeone = l;
            i++;
        }
        # o {%Lines} $R/**:
        #  leave(rN)
        #  have(%LinesForSomeone):%LinesBunch +[ %z's
        # < should do all this:
        $l = [];
        Rs&Bunchology = [];
        # without duping strings in memory,
        # Bunchology[LinesN i] = [3,6] # are LinesBunch i
        # slice(start,end) doesn't include the end
        $stitch = &r{
            $ri = Rs&LinesN.indexOf(r);
            if (0 > ri) {
                $ok = 0;
                if (rs&sleeping) {
                    $b = Rc&b;
                    $d = rc&b;
                    !b && !d and throw "sleeping nob"
                    #ds&sleeping and throw "sleepingbsleeping"
                    $di = bs&LinesN.indexOf(d);
                    di < 0 and throw "oldLinesN !old r"
                    $li = bs&Bunchology[di];
                    !li and throw "oldBunchology!"+di
                    $bunch = bs&LinesBunch.slice(li[0],li[1]);
                    # recycle into...
                    ri = Rs&LinesN.push(r)-1;
                    $sl = Rs&Bunchology[ri] = [];
                    sl[0] = l.length;
                    l.push(...bunch);
                    sl[1] = l.length;
                    return;
                    ok = 1;
                }
                !ok and throw "wandering stitch"
            }
            # rN should empty, Ringwarped order
            rN[ri] = null;
            # LinesBunch grows
            l.push(rs&LinesForSomeone);
            # track indices of LinesBunch each LinesN encompasses,
            #   helps fill in chunk when %sleeping
            # < histogram density vs depth
            $sl = Rs&Bunchology[ri] = [];
            
            sl[0] = l.length-1;
            delete rs&LinesForSomeone;
            
            # < ss&z ordered... gets parent correct for now
            # depth first
            each in rs&z {
                !ns&Lines || 0 > ns&Lines.indexOf(R) and continue
                stitch(n);
            }
            sl[1] = l.length;
            return l
        };
        stitch(R);
        Rs&LinesBunch = l.slice();
        rN.filter(n=>n).length and throw "unfound Linesers"
        Rs&string = Rs&LinesBunch.join("\n")+"\n";
        Rs&dige = dig(Rs&string);
    },'ift,D'],
    

] };
#c ball, continuing thing around thing
me.Ballingness = &acgt{ return [
   // ball-ish
    &{
    me.fixatfour = &acgtRs{
        Rs&nofix and return
        $not = Rs&nofixfor || {}
        each kv s.c {
            not[k] and continue
            n $k  $s:v,R %fix:c
        }
        each kv s.sc {
            k == 'z' and continue
            not[k] and continue
            n $k  $s:v,R %fix:sc
        }
    }
    },
    # that makes its C up
    #  now happens
    ['ballse','171',&acgtRs{
        $ba = 1s&ballse ||= {};
        Rc&s ||= Rc&b && Rc&b.c.s;
        Rc&s ||= ba[R.t];
        Rc&s ||= G&Cye,[R.t,''];
        ba[R.t] = Rc&s;
        Rs&ball = 1;
        delete Rs&ballse;
    },'ift,D'],
    
    ['ball','38',&acgtRs{
        me&fixatfour,R,s
    },'ift,D'],
    
    
    ['ball','9',&acgtRs{
        $N = Rs&z;
        !N and return
        $h = aroh(N,'fix,ball');
        Rs&z = [... h.fix, ... h.ball, ... h.N]
    },'ift,D'],
    
    
    
    # knows its %pushed to
    ['ball','2',&acgtRs{
        # see ball-othering
        me&rollbs,R,'pushed,pushed_ball';
    },'ift,D'],
    
    # awaked, sculpt a little
   // ball
    ['ball','6',&acgtRs{
        ss&z && !Rc&nofurther and me&Rsync,R;
        
        (Rs&boost||0) > 0 and return
        # hide %ball/%ball but not %ball/%fix
        # see Be
        $hbb = Rs&hideballsballs;
        hbb and me&ioty,R,'%ball' .map(n => ns&noDisplay = 1);
        # squish long skinny trees, etc
        $p = Ry&up;
        !ps&ball and return;
        me&ioty,p,'ball' .length != 1 and return
        Rs&tightly and return
        Rs&rowish > 1 and return
        delete Rs&rowish;
    },'ift'],
    ['ball','3',&acgtRs{
        Rs&rowish == null and Rs&rowish = 1
        Rc&dupl = 0;
        s&br = '4';
        s&bo = '0.1em dotted #543';
        
        # may have three different titles
        # R.t is for RbitX, hidden (usu ugliest)
        # title might be the purpose of this ball,
        #  before the s.t, real name
        #  &bal...%eph can make tv-impossible situ
        $title = Rs&title || R.t
        !s || title != s.t &&
            n ot 1 $s:title %fs:13,hs:288
        
        if (s == null || !isC(s)) {
            me&tsc,'nos',(s?'notC':'<null>'),'b';
            Rs&failedball = delete Rs&ball;
            return
        }
        
        $t =
        n t 11 $s:s.t %deco,fs:8,fix:t,mr:0.3
        
        Rs&is == 'live' and s&bo = '4px dotted #782';
        
        if (Rs&boost < 0) {
            if (Rs&boost < -1) {
                if (Rs&remova) {
                    Rs&remova();
                }
                else {
                    $pr = Ry&up;
                    !prs&ball and "up!ball"
                    $ups = prc&s;
                    i $ups/-$s
                    #upss&z = upss&z.filter(n => n != s);
                }
                n deleted  s:deleted %fs:6,hs:594
                delete Rs&Te.sc.boost;
            }
            Rs&nofurtherDisplay = 1;
            return
        }
        if (Rc&nofurther) {
            n nofurther 17 s:♲ %fs:8,mr:0.3
            return
        }
        
   //#c ballope (cont ball @3)
        # scan properties,
        #  a robust protoplasm of many %play
        me&Bear,R,s;
        
        #!Rs&fixatfour and me&fixatfour,R,s
        
        if (Rs&boost > 0) {
            # editable C.t
            ts&e = 1;
            ts&qua = 'ballrename';
            # implant C -> C.t
            me&quainto,'ballinto';
            me&Tie,R,'ballinto',1;
            $say = Rs&ballinto;
            if (say) {
                $m =
                n made  s:+ %fs:6,hs:594
                if (say.startsWith('%')) {
                    # %hi -> sc.hi=1
                    say = say.substr(1);
                    s.sc[say] = 1;
                }
                elsif (say.startsWith('&')) {
                    # &hi:2 = c.hi=2
                    $d = G&peel,say.substr(1);
                    ex(s.c,d);
                }
                elsif (say.includes(':')) {
                    # hi:2 = sc.hi=2
                    $d = G&peel,say;
                    ex(s.sc,d);
                }
                else {
                    me&input,R,say;
                    mc&s += 'C';
                }
            }
        }
        me&endome,R,T.act;
        ss&z && !Rc&nofurther and me&Rsync,R;
    },'ift,D'],
    &{
    # the standard green-rounded black hole of typing
    me.quainto = &acgtt{
        $n =
        n $t   %e,qua,fs:8,bgh:010,pa:0.3,va
        me&walls,n,'b:3.1.4';
        return n
    };
    },
   
    #c R%fix per c/sc style
    # < t/cv natively
    ['fix','3',&acgtRs{
        $p = Ry&up;
        $ps = pc&s;
        n k 1 $s:R.t %fs:11,hs:288
        
        me&Bear,R,s;
        $fx = ps&fixablestyle
        fx && fx[R.t] and ex(C.sc,fx[R.t])
        
        $beopen = Rs&beopen || Rs&boost;
        !beopen and return me&gkness,R
        
        if (Rs&boost < 0) {
            if (Rs&boost < -1) {
                delete ps[Rs&fix][R.t];
                n deleted  s:deleted %fs:6,hs:594
                me&elvis,R,'deleted',{wake:p};
            }
            return
        }
        
        me&Tie,R,'sayeth',1;
        if (Rs&sayeth != null) {
            Rc&s = s = ps[Rs&fix][R.t] = Rs&sayeth;
        }
        if (typeof s == 'object') {
            # < just have to open it more
            # < editable
            n obj  $self:s,R %Reis:Cit%
            return
        }
        s += '';
        $cm =
        n s 1 $s:s %e:1
        # < Besk options, to merge with locals
        # 1: <input> for \n-impossible text input
        # 2: <CodeMirror>
        # 3: slider(s)
        # < be e:say, knows how to form editable
        # < parent dige checking
        Rs&inputmode and cms&e = Rs&inputmode
        Rs&cm_sc and cms&cm_sc = Rs&cm_sc
        
    },'ift,D'],
   
   //#c ball-othering
    # as %ball, consume %push+%ball from afar
    # < disconnect/packdown? (git around it)
    # < take the %move instead
    #   < make a cursor for the job of applying it
    #   < may be a search and replace or anything
    #   < %balls as soft+fast version control
    # some %push has put:
    #   %othering(_ball) # incoming %push
    #    (and the %ball it %move%from)
    # becomes:
    #   %pushing(_ball) # fixes fixtures
    #     and sets up:
    #       %pushed(_ball) # log of pushes
    #  and(/or):
    #   %pushing_z(_ball) to enter its children
    #    (or itself as a child)
    ['ball','52',&acgtRs{
        Rs&ball = 6; # look before you other
        
        # take a %move
        each in Rs&movingin {
            $r = nc&push;
            $putting = 'pushing';
            if (R == rs&there && !nc&into) {
                # GOING
                # %push%there = %move%to, %their will inside
                me&tsc,'pushz','pushzthere';
                putting += '_z';
            }
            nc&into and putting += '_z';
            !ns&move and throw "!move"
            !ns&from and throw "move!to"
            # < sprawl %move as it others
            ac(R,putting,r,'ball',ns&from);
        }
        
        if (Rs&othertricks) {
            n oth  s:othertricks
        }
        
        each ir Rs&othering {
            # want the %move to be around?
            if (rs&push) {
                # a %push putting:
                $t = (Rs&othering_ball||[])[i] || rs&here;
                $putting = 'pushing';
                # if %there is here, their will inside
                R == rs&there and putting += '_z';
                ac(R,putting,r,'ball',t);
            }
            else {
                # a %pull putting %self at %other
                $o = rs&other;
                if (o) {
                    $cb = me.cby(o,&o{ return o == R });
                    !cb || cb[0] != R and throw "%other not here"
                    ac(o,'pushing',r,'ball',rs&self);
                }
                else {
                    rs&putting and throw "%pull !%other %putting somewhere"
                    # or just here-ish, with a put-in-z emotion
                    ac(R,'pushing_z',r,'ball',rs&self);
                    # < build there down a branch, pass tests
                }
            }
            
            $pr = ry&up;
            $D =
            n pushed   %fs:7
            D.sc.bo = '2px solid yellow';
            Dc&s = pr.t+'/'+r.t;
        }
        # %pushed keep their %push up to date
        each ir Rs&pushed {
            Rs&pushed[i] = me&yfuture,r;
            # < de-other zombies by rc&ip...
            # < things rupturing as they delete
            #   themselves at the edge of the light cone
        }
        each ir Rs&pushing {
            # whose treeing %ball is already here
            $S = ac(R,'pushing',r,'ball');
            !Sc&s and throw "pushing !cs"
            !Ss&ball and throw "pushing !ball"
            # and replacing the last %self
            $l = ac(R,'pushed',r,'ball',S);
            $Ss = Sc&s;
            
            # the t detail (%from can rename %to)
            Ss.t != s.t and s.t = S.t
            
            # the c/sc details, per %ball%fix'd
            each in Ss&z {
                !ns&fix and continue
                $gk = ns&fix;
                # GOING
                if (Ss&othertricks && gk == 'sc') {
                    ~baresc: R.t, S.t
                    continue
                }
                # < clone-out function would live on n%ball%fix
                s[gk][n.t] = nc&s;
            }
            # for streaming contents with other %pushes, eg %main/%steps
            Ss&pushingnoz and continue
            ac(R,'pushing_z',r,'ball',S);
        }
        each ir Rs&pushing_z {
            $S = ac(R,'pushing_z',r,'ball');
            $self_was_here = Rs&pushing && Rs&pushing.indexOf(r) >= 0;
            $z = self_was_here ? Ss&z : [S];
            each in z {
                !ns&ball and continue
                $x = nc&s;
                if (ns&othertricks || ns&clobberypushingz) {
                    i Rc&s/-#$x
                }
                # n thing that should be here
                #   Rs&z +[ t%ball -> clone(nc&s)
                # starts with spacer, keeps t%pushing=S to it
                $t = me&input,R,x.t;
                ts&ball && ts&ball == '6' and debugger
                # keep %pushing=n
                ac(t,'pushing',r,'ball',n);
                if (ns&keepy) {
                    # %kvstore's G/%balls othered from the decoder
                    $S = tc&s;
                    !x.y[ns&keepy] and throw "link no exi"
                    S.y[ns&keepy] = x.y[ns&keepy];
                }
            }
        }
    },'ift,D'],
] };
//#c Rcopy
    # clones s or %ball, as far as s goes
    me.Copy = &acgtRhc{
        c ||= {};
        # Rings up to a point
        typeof c == 'number' and c = {ov:c};
        while (c.ov > 1) { c.ov *= 0.1 }

        c = ex({task:'ravel',ball:1,noDisplay:1,refpool:1},c);
        c.Copy = 1;
        # h may be %ball or s
        $s = hy&R == h ? hc&s : h;
        # %Ropy is like C.y.C = origin, but for R
        h != s and c.Ropy = h
        # %Ropia=[R+] that might have any s, see TeCo

        c.t ||= h.t;
        return me&Reis,R,c.t,s,c
    };
    me.Copyingness = &acgtR{ return [
        # clones %balls for me&Copy
        ['ball+Copy','11',&acgtRs{
            $h = Rc&N[0];
            # %Copy = original s
            Rs&Copy = s;
            s = Rc&s = G&Cye,s;

            # replace s in up z, new tv + tw
            ss&z and sy&tv = {}; sy&tw = {}
            $p = Ry&up;
            if (p && ps&Copy) {
                $P = pc&s;
                # replace cloned ss&z in parent
                if (Ps&z) {
                    $pi = Ps&z.indexOf(Rs&Copy);
                    pi < 0 and throw "pi<0"
                    Ps&z[pi] = s;
                    P.y.tv and Py&tv[s.t] ||= {};
                    P.y.tv and Py&tv[s.t][s.y.cv] = s
                    P.y.tw and Py&tw[s.t] = s
                }
                # %Ropy = %ball cloned from
                $sisCopy = &nr{
                    ns&ball && nc&s == Rs&Copy and Rs&Ropy = n
                };
                $pR = ps&Ropy;
                # may come from above
                pR && pRs&z and pRs&z.map(sisCopy);
                if (ps&Ropia) {
                    # or any %Ropia, R whose c&s have
                    #  been rearranged into what we Copy
                    Rs&Ropia = ps&Ropia;
                    !Rs&Ropy and Rs&Ropia.map(sisCopy)
                }
            }
            # Copy not dive into lv
            $lv = s.y.lv;
            if (lv) {
                !lvs&Lines and throw "!Linesy lv"
                delete ss&z;
                # closes C, or its Lines will dupe
                # < Lines should know not to z+lv?
                # Copy bounds, makes W-part pointers
            }
            if (ss&z) {
                ss&z = ss&z.slice()
                me&Rsync,R;
                each ir Rs&z {
                    rs&ball and rs&Copy = 1;
                }
            }
        },'ift,D'],
        # Copy...{ball:9} to not %ball beyond its use as an Rsync
        ['ball+Copy','12',&acgtRs{
            Rs&ball == 9 and Rc&N.map(r => delete rs&ball)
        },'ift,D'],

    ] };
