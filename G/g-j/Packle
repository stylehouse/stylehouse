#
$me = 4c&me;
!me and throw "no me";
$io = me.io;

# bal
# my old aria: https://youtu.be/7tf1wzg4rdE?t=62

$ffmpeg = &{
    # the general overview
    # ! lost its code snippets
    # https://medium.com/@dernis/ffmpeg-tips-tricks-and-and-lessons-learned-a6f3c1187085
    # pics -> video
    # http://hamelot.io/visualization/using-ffmpeg-to-convert-a-set-of-images-into-a-video/
    #  https://youtu.be/Xx3_XKFZb7o Len Lye + Rock
    # video at their end -> pics
    # https://stackoverflow.com/questions/32699721/javascript-extract-video-frames-reliably
    # hard disk image as block device
    # cp -a /dev/sdc windos
    # and mounted:
    # sudo losetup --partscan --find --show windos
    # sudo mount /dev/loop0p3 ups
};

=pod 

dyn
@media only screen and (max-width: 600px) {
  .col { 
    display: block;
    width: 100%;
  }
}

=cut
#c Jay
me.J = &acgtsq{
    # do a J
    $C = typeof s == 'string' && G&Cye,[s,1,{J:s}];
    if (!C) {
        C = G&Cye,s;
        c&pi and c&J = C.c.pi; delete c&pi
    }
    q = q && typeof q == 'object' ? q : {q:q,C:C};
    if (q.q == 'W') {
        c&W = c&J ||= C.t;
        C.y.cv ||= 0.1;
    }
    
    $j = G&n,C,5;
    # C changes
    C = q.C = jc&s;
    $J = s&J;
    J.3 == J and j.3 = J
    
    4s&elvisory and me.JT(j,C,G,T)
    
    $Jlim = 40;
    4s&Jays++ == Jlim and ~OutofJ: ki(J);
    4s&Jays > Jlim and return C
    
    Js&paused and return C
    
    !me.Ja[c&J] and throw "unknown me.Ja."+c&J
    Js&runs ||= 0;
    Js&runs++;
    
    j.ground = C;
    
    me.Ja[c&J](j,C,G,T,c&s);
    
    jc&Jupstash();
    j.1 == j.3 and J.3 = J;
    
    # puts c&M
    c&M and me&Mwix,C; s&z ||= []; s&z.push(...c&M)
    delete c&M;
    
    me.os(j,C,G,T);
    
    return C;
};

# sweep towards 4 activities
me.Ja.wobulus = &acgt{
    # 1 expression close to Lines
    A&o = 'IndofC';
    # 3, random health dials
    # the conditions for creativity
    $br = upupc&brake;
    br &&
    n braking  $s:br
    n teeth 4  %medo:pause
    # 4 the pile
    if (!4s&famous) {
        $f = 4s&famous ||= {};
        f[4c&sip] = A.4;
    }
    # 5
    # < pause factory/drum machine,mode sleep
    # 6
    me&do_main;
    # 7
    me&Jelbowroom;
};

# adjusts J's parents height for its contents
# a factor of the grind
me.Jelbowroom = &acgt{
    $on = 1s&on;
    !on and return;
    $N = $(on).children().get();
    $height = 0;
    each in N {
        height += $(n).height();
    }
    height = height * 1.4 + 500;
    $cb = &{ $(on).parent().css('min-height',height+'px'); };
    1s&elbowroom > height ?
        # shrink slowly
        G&yl,300,cb
    : cb();
    1s&elbowroom = height;
};
me.Ja.upstream = &acgt{
    # have perl watch
    # acpi -a
};
#c edges
# pitch time, run time, log saming
# < waver accepts advances in trave...
#   once off the path that sequences of trave indicate
#   begin a new branch of trave,
#     each named phase of things moresoer
me.Ja.edges = &acgt{
    me&Gomp;
    s&dis = 1;
    s&bgi = 'i/greencush.jpg';
    s&hue = 90;
    
    $d = 0;
    $f = A.5;
    if (1s&Te && 1s&Te.sc.chaos) {
        1s&spin ||= 0;
        1s&spin++;
        1s&spin > 2 and 1s&spin = -2
        d = 1s&spin;
    }
    $s = me&trampel,d;
    
    
    $be =
    n seen  $s:s %rovo:ning
    
    n ajaying  $s:be %rovo:ning
};

# facilitate_daydream
# where the Js break up the gobes becomes a size thing
# could end up walking z by usuality
me.Ja.feel = &acgts{
    me&heading,'';
    A&o = 'Graze';
    s&med = 'cra';
    $z =
    s &&
    n seen  $s:s %rovo:ning
    if (s&boost) {
        # introqua to them? should home in Te
        # give an descendey iterator ala V/X
    }
};
# a data dumper
me.Ja.fe = &acgts{
    me&heading,'';
    A&o = 'Graze';
    s&med = 'cra';
    n feseeing  $s:s %sun
};

#c noise sources
me.noisesovertimeto = &acgt{
    1c&timeto ||= 0;
    if (1 && 1c&timeto > 1) {
    
        1c&timeto > 4 &&
        n toot 8 s:ffeli
        
        n tot 6 s:aly
        1c&timeto > 5 and 1c&timeto = 0
    }
    1c&timeto++
};
    
me.trampel = &acgtd{
    if (1 || !1s&es) {
        $st = <<''.split("\n");
        Long way going to
        Get my medicone
        Skys the autumn grey of a lonely wrench

        =pod
        Piano from a window played
        Gone tomorrow, gone yesterday
        I found it in the street
        At first I did not see
        Lying at my feet
        A trampled rose
        =cut

        st.pop();
        $s = {};
        each il st {
            l = l.split(" ");
            $z = s;
            each iw l {
                w == 'of' && d > 0 and z.lof = 'yea'; z.to={eo:{}};
                w == 'to' && d < 0 and z.edea = C
                z = z[w] ||= {};
                w == 'to' && d < 2 and z.edgga = A.5;
            }
        }
        1s&es = s;
    }
    return 1s&es;
};

#c Slepingness roadies
#   once tests...
me.Slepingness = &acgtR{ return [
    # hilight changing %balls if they yslandige
    # change style stays on once sleeping,
    #   time-limited styles?
    #   < style til new time for a frame but no frame
    ['ball','35',&acgtRs{
        !sy&slandige and return
        Ry&slandige = sy&slandige;
        $b = Rc&b;
        b && Ry&slandige == by&slandige and return
        # < on the title
        each tin Rs&Mw {
            n.t == 't' and ns&bri = 4
        }}
    },'ift,D'],
    
    # Slep, a Tool for checking sameness of a Dome/anything
    # scan happens early and late:
    #   late first, Long/** is awake, scan boosted around Rthings
    #   early thence, scan boosted (%Rthing'd) from before
    # Display 27 gets tangulate:
    #   they Ring ov=33 (ahead of slepy&up)
    # TheirSleepStrategy 28 gets this intel
    ['slep','3',&acgtRs{
        s&fs = 14;
        s&bo = '1px dotted green';
        me&tsc,'slep-ing','slep','6';
        # the top of the constellation of R with c&s
        $p = Ry&up;
        ps&slan_digify and Rs&digify = 1
        ps&beawake and Rs&beawake = 'p'
        # early should always receive history from late
        $b = Rc&b;
        !b and return me&tsc,'isnew','*','g'
        
        $re = me&slan,R,p,{early:1};
        # < it reusing this scan for whatever its doing
        Rs&slan = ps&slan = re;
        
        !rec&b and throw "slep Nohist early"
        
        # can be asked to display more, if you displayon for it
        # < clearer apis, 1s&ein-like
        # < express as 'dark cramped machine room,
        #   remote view scheme interestoids'
        Rs&nofurtherDisplay = 1;
        Rs&enlum ||= 0;
        me&Tie,R,'enlum' &&
            me&Reis,R,'Cray',re;
        
        if (res&sleepable && !Rs&beawake) {
            ps&sleeping = re;
            Rs&theysleep = 1;
            # keeps history/z of unhad children
            # < TEST why do this on this R
            me&recycleRbitXz,R;
            # R:Display knows Rs&sleeping
            # implement a %sleeping%whatever to etc
        }
        
        (Rs&boost||0) < 1 and return
        me&tsc,'landscape',res&landscape,'6' .sc.dis = 1;
    },'ift,D'],
    
    # implement a %sleeping%whatever
    # ! must t.t =~ /^sleeping/ || ts&sleeping
    #     Ring avoids everything if Rs&sleeping
    # thing-specific reasoning/management
    # but mostly the %slep and things involved know/do all else:
    #   keeps history/z of unhad children
    # R:Display also knows Rs&sleeping
    ['sleeping+Cee','28',&acgtRs{
        $l = Rs&sleeping;
        $b = Rc&b;
        # Display - avoids Rs&sleeping
        #   must put its bs&on y&up
    },'ift,D'],
    ['sleeping','28',&acgtRs{
        me&recycleRbitXz,R;
    },'ift,D'],
    
    # the R%sleeping itself doesn't rollbs
    # < sleeping more fully, so every Rc&b = last awake
    #   recycleRbitXz on this R does so for children
    ['sleeping+ball','28',&acgtRs{
        me&rollbs,R,'string,dige';
    },'ift,D'],
    
    ['slep','89',&acgtRs{
        Rs&theysleep and return
        $p = Ry&up;
        #~>3 Lately: p.t
        # leave one slep/slan, early trusts late's map
        Rs&slan and me&deleteRbitX,Rs&slan;
        
        $r = me&slan,R,p;
        Rs&slan = ps&slan = r
        #rc&b and ~hist late:
        rs&late = 1;
        
        (Rs&boost||0) < 1 and return
        me&tsc,'landscape',rs&landscape,'6' .sc.dis = 1;
        (Rs&boost||0) < 2 and return
        n slepe  $self:r,R %Reis:Cit,set:Cit
        n pare  $self:p,R %Reis:Cit,set:Cit
    },'ift,D'],
    
    #c slep_aTool configures a %slep in %aTool
    # < to show the slep in progress,
    #   must sit outside the %sleeping, or have its Display adopted
    # ᛍ c - sleeping
    # ᛟ othalan ethel o - awake
    # ᛤ cealc - dige
    # ᛄ ger - diff
    # ᛜ ingwaz - differ
    ['slep_aTool','8',&acgtRs{
        s&ma = 0.2;
        s&fs = 17;
        $p = Ry&up;
        $P = ps&Recipe;
        $r = ps&Real;
        $D = rs&slan;
        !D && Rs&paniq < 100 and Rs&paniq = (Rs&paniq||0)+1; return T.wide = 1;
        !D and me&tsc,'noD(slan)?',"!D",'B'
        D && !Ds&dige and me&tsc,'noslandige?',"!slan%dige",'B'
        $s = pc&s;
        # < be a number
        $they = rs&theysleep ? "ᛍ" : "ᛟ";
        $callit = rs&theysleep ? "sleep" : "wake";
        me&tsc,'they'+callit,they;
        me&tsc,'configure',"☞",'G';
        
        (Rs&boost||0) < 1 and return
        
        # various adjustables
        # wiring Time-things onto the Real or the On,
        #  for it has already begun,
        #   elvising must get any tampering to it prior
        # Recipe can be edited simply, it is a %ball
        #   mention modes we can attach,
        #   then once having %ball/%fix, embed knobs
        #     enriching the soil
        
        n beawake  s:ᛟ %medo:modeen
        n digify  s:ᛤ %medo:modeen
        n differ  s:ᛄ %medo:modeen,to:Te
        Rs&modeen = &acgtr{
            $mode = r.t;
            $to = rs&to == 'Te' ? Rs&Te : P;
            $v = to.sc[mode] = to.sc[mode] ? 0 : 1;
            ~modeen: mode+" = "+v
        };
        if (Rs&Te.sc.differ) {
            # BUG first time (test edges 2.2)
            !D and return
            n HEAD  $s:Ds&dige %fs:6
            n differ  $s:D %R:differ,refpool
        }
        
    },'ift,D'],
] };

#c slan
# R-ing that maps/checks the data underlying Ring
# straighter and sprawlier than a %scan,
#  which it should eventually replace?
$slanRon = &Rtsonc{
    $r = me&Re,R,{t:t,s:s};
    delete rc&refs;
    delete rc&inC;
    rc&middle = &sR{
        # 1 scan/title
        1 && o and o(R,s);
        # 2 resume history Rc&b
        me&arriveRbitX,R,R.t;
        # 3 generate furthers
        1 && n and n(R,s);
    };
    me&ing,'',r;
    # 4 X notices leavings
    me&goneRbitX,r;
    # 5- up to thou
    1 && c and rc&N.map(R => c(R,Rc&s))
    me&applyRbitX,r;
    return r
};
# there are two slep/scans
# sharing history (deleteRbitX the early)
me.slan = &acgtRpc{
    $the = me&Timethe,'slan';
    c ||= {};
    $oR = R;
    $firstRthing = p;
    $ot = p.t;
    $uptil = &Rkd{
        # < me.cbu having a boundary & return array
        $N = me.cby(R,&s{ return s == firstRthing 
            || typeof k == 'object' ? s == k : s.sc[k]
        });
        d and return N
        return N.length
    };
    
    # you can ignore a y.*
    ps&slan_igy and c.igy = ps&slan_igy
    # or put + ignore dige of the thing in the thing
    # < param this on the slep tool
    $digify = Rs&digify;
    digify == '1' and digify = 'slandige'
    digify and c.igy = c.digeity = digify
    
    
    $h;
    $r = slanRon(R,'slan',pc&s,0,&Rs{
        if (Rc&d == 0) {
            h = R;
            $b = Rc&b;
            if (c.early) {
                hs&early = 1;
                !b and throw "early no hist"
                # early one inherits %late
                if (bs&late) {
                    #!bs&early and ~late->early: ot
                    Rs&late = bs&late;
                    Rs&earlied = 1;
                    #~early & late: ot
                }
                else {
                    ~Early not substracting late history: ot
                }
            }
            else {
                # TEST as if deleteRbitX didn't work?
                #   when sleep interrupted
                b && bs&early and ~late b%early:
            }
            Rs&Rthing = firstRthing;
            
            Rc&dl = 144;
            Rc&nl = 2211;
            delete Rc&dupl;
        }
        Rc&N.push(R);
        # < within the slan'ing, as uptil()
        $p = Ry&up;
        $pp = py&up;
        #c 2 know 1
        if (typeof s == 'object' && s != null) {
            if (s.constructor == Array) {
                Rs&sym = '[';
            }
            elsif (isC(s)) {
                Rs&Cthing = s.t || 1;
                Rs&sym = 'C';
                if (s.y == s) {
                    Rs&Athing = 1;
                    Rs&sym = 'A';
                    s.1 == s and Rs&sym = 'J';
                }
                else
                s.y.R && s.y.R == s and Rs&sym = 'R';
            }
            else {
                Rs&sym = '{';
                if (R.t == 'y' && ps&Cthing) {
                    Rc&shrinky = 1;
                }
            }
        }
        else {
            # 3 at a value
            Rs&text = typeof s == 'number' ? ''+s
                : typeof s == 'string' ? '"'+s
                : ki(s);
            $into = Rs&text.split("\n");
            if (into.length > 1) {
                Rs&text = '"'+into[0]+'..dige:'+dig(Rs&text)
            }
            return
        }
        if (c.early) {
            # once early, %Rthing-ness comes from history
            #   vis. the same position of names
            # there are no origin Rs beyond first
            # download them from history
            !Rs&Rthing and me&rollbs,R,'Rthing'
        }
        # 4 or a thing we can feel out way to
        $N = uptil(R,'Rthing',1);
        $Rthingu = N[0];
        !Rthingu and throw "start on Rthing"
        if ('always detect Rthing') {
            # detect c&s in the last Rthing's pool
            # %Rthings are the origin R, have c&s we bump into
            # may happen even if c.early or theysleep
            $or = Rthingus&Rthing;
            !or and debugger;
            # < R=A, A.pool.c.N is the bunch,
            # < venn diagram to A.**.pool
            $ri = orc&refs.indexOf(s);
            if (ri >= 0) {
                # the R;origins with this c&s
                $refR = orc&refR[ri];
                # < R=A, will have c&ip some day
                each ir refR {
                    # look up til the last Rthing
                    #   or until firstRthing
                    # all R;origin
                    $got = uptil(R,Rthingu,1);
                    got[0] == Rthingu and break
                    # may not encounter either
                    r = null
                }
                if (r) {
                    Rs&Rthing = r;
                }
            }
            # see hs&Rthings ^
            # < make pile of R:slan before the next %Rthing
        }
        # connect to upwardia
        if (Rs&Rthing) {
            $Rdist = 1;
            
            hs&Rthingi ||= 0;
            hs&Rthingi++;
            # < dup would be interesting
            ac(h,'Rthings',R);
            # these all R:slan
            ac(Rthingu,'Rjoins',R);
            # < then Rc&Rthing = R and calc depth?
        }
        else {
            $Rdist = N.length+1;
        }
        
        
        #c 5 size
        # near a data fog valve
        Rs&plain ||= '';
        #Rs&plain += "RD:"+Rdist
        # apply a schema,
        # to decide whether to 6
        
        # shouldn't be looking at R
        # < complain eloquently
        !Rs&ltd && Rs&sym == 'R' and Rs&ltd = '>R'
        !Rs&ltd && pps&sym == 'R' and Rs&ltd = '>R**'
        
        
        # share refs
        $rl = Rs&refR;
        if (!Rs&ltd && rl) {
            $l = rl[0];
            Rs&plain = 'dup:'+me&nampup,l,R;
            # other side was limited, try express it here
            if (!Rs&ltd) {
                if (ls&ltd) {
                    # do here instead
                    delete Rc&nofurther;
                    # be the main instance
                    Rs&refR.reverse();
                }
                else {
                    Rs&ltd = '<'
                }
            }
        }
        
        # unless very near R
        if (!Rs&ltd && Rdist > 2) {
            # don't A.I
            ps&Athing && Rs&sym == '{' && R.t == 'I' and Rs&ltd = '>I'
        }
        if (!Rs&ltd && Rs&sym == '{') {
            # dom elements
            # < any .constructor.name != 'Object'
            if (s instanceof Element) {
                Rs&ltd = '>'+(s.constructor.name||'Element')
                Rs&sym = '<>';
            }
        }
        if (!Rs&ltd && Rdist > 3) {
            # one layer after A or y/%Cthing
            ps&Athing and Rs&ltd = '>A'
            else
            ps&Cthing && Rc&shrinky && pc&shrinky and Rs&ltd = 'y>'
        }
        
        # or farouts
        if (!Rs&ltd && (Rdist > 4 ||
            Rdist > 3 && uptil(R,'Cthing') > 3)) {
            Rs&ltd = '>';
        }
        # if limited, describe the edge of the pile
        if (Rs&ltd) {
            if (Rs&Cthing) {
                Rs&text = ':'+s.t;
            }
            elsif (Rs&sym == '{') {
                $ks = haks(s);
                $limit = 50;
                Rs&text = ks.length > limit+5 ?
                    ks.slice(0,limit-1).join(',')+'..'+ks.length
                : ks.join(',');
            }
            elsif (Rs&sym == '[') {
                Rs&text = 'x'+s.length
            }
            return
        }
        
        # 6 more values
        $l = haks(s);
        each ik l {
            $v = s [k];
            $Rc = {t:k,s:v};
            if (c.igy && ps&Cthing && R.t == 'y') {
                # wants to ignore s.y.dige in/for Elvis %balls
                c.igy.indexOf(k) >= 0 and continue
            }
            if (ps&Athing && R.t == 'c') {
                # < Ac&ip has a netmask, since Gc&ip?
                k == 'sip' and continue
                k == 'ip' and Rc.s = v = v.slice(); v[0] = '<snip>'
            }
            me&Ret,R,Rc;
        }
    });
    
    #c select moving parts
    $M = [];
    $seen = [];
    # in z order
    $gump = &R{
        Rc&N.indexOf(R) < 0 and return Rs&landscape = "NOTIN: "+R.t
        seen.indexOf(R) >= 0 and throw "gumpR seen"
        seen.push(R);
        
        $se = R.t+" "+(Rs&sym||'');
        # text == firstline + dig if \n
        Rs&text != null and se += ''+Rs&text
        Rs&plain != null and se += ' '+Rs&plain
        Rs&ltd and se += ' '+Rs&ltd
        
        $rt = Rs&Rthing;
        if (rt) {
            # anything else from the Rthing
            se += ' %R ';
            if (rty&Te_slandige) {
                # R receives Tey&slandige
                se += "Te_slandige:"+rty&Te_slandige
            }
        }
        
        Rs&landscape = 
        Rs&portrait = se;
        
        # < allpathy: what was/wasnt different and how
        each in Rs&z {
            gump(n);
            
            $is = (ns&landscape||"NOTHING:"+n.t);
            $at = is.split("\n")
                .map(&s{ return "  "+s })
                .join("\n");
            Rs&landscape += "\n"+at;
            
        }
        if (c.digeity && Rs&Rthing && Rs&Cthing) {
            # put + ignore dige of the landscape in s
            # < as a post-hook to io.i
            $s = Rc&s;
            Rs&dige = s.y [c.digeity] = dig(Rs&landscape)
        }
        
        $b = Rc&b;
        if (b && Rs&Rthing) {
            if (bs&landscape != Rs&landscape) {
                M.unshift(R);
            }
            else {
                Rs&sleepable = 1
            }
        }
    };
    gump(r);
    
    # for the origin (%slander?)
    rs&moving = M;
    rs&talk = rs&landscape.split("\n");
    rs&dige ||= dig(rs&landscape);
    # check dl/nl
    me&safer,r;
    the();
    return r;
};



#c doming - R matter/modulat channels
# empties grounda&z into M or more R
me.endome = &acgtRt{
    !T.nN || !T.nN.length and return
    $spawnDt = t && t.t || '?';
    $N = T.nN;
    T.nN = [];
    $M = null;
    $genR = 0;
    $dib = null
    each in N {
        !nc&R && ns&R and nc&R = delete ns&R
        Rs&endomemod and Rs&endomemod(n);
        if (nc&stv) {
            # namespace del C
            $s = nc&s = delete nc&stv;
            n.t = s.t+' '+(s.y.cv||'')
        }
        if (nc&R) {
            $parent = R;
            if (nc&R != '1' && typeof nc&R == 'string') {
                # c&R='mode' becomes sc.$mode = 1
                # < ongoing type-of-name smurgery
                n.sc[nc&R] = 1;
                nc&R = 1;
            }
            else {
                $s = nc&R;
                if (s && Rc&N.indexOf(s) >= 0) {
                    parent = s;
                    s = null;
                }
            }
            delete nc&R;
            # > R=$s sometimes
            nc&s and s = nc&s; delete nc&s
            $zuct = delete nc&Rzucto;
            ex(n.sc,n.c);
            $r = me&Ret,parent,ex({t:n.t,s:s},n.sc);
            parent != R and me&zN,r
            # to $r = n ... %R, me&yfuture or follow:
            n.y.R = r;
            dib and zuct ||= dib
            zuct and me&zuct,zuct,r
            genR++
        }
        else {
            # there is a %c=$c to pass through &tsc
            ns&c and me&tsc,n,0,ns&c
            # %dib, dis=1 and swallow til next
            ns&dib and dib = n; ns&dis = 1
            else
            dib and ac(dib,'z',n); continue
            
            M ||= me&Mw,R,spawnDt;
            M.push(n)
        }
    }
    return genR
};
# for T.nN, from n ...
me.ydome = &acgty{
    !T.nN || !T.nN.length and return []
    $N = T.nN.map(n => y ? y(n) : n);
    T.nN = [];
    return N
};

# Mw - named M, generated Catchment
# R spawn grits into these trays
#   may datagram them to sleep
# and use them to intro more R, when asyncable
    # how much to draw/fall in...
    #  these M might be named in future,
    #  compositive to 3s&Me, a tv of M bits
    #    good shape for magazine ladel
me.Mw = &acgtRt{
    !t and Rs&M ||= []; return Rs&M
    Rs&Mw ||= {};
    $M = Rs&Mw[t] ||= [];
    return M
};
# the idea of collapsing named M, assigning to 3-ish
#   sorting expensively
me.Mwix = &acgtR{
    $M = [];
    (Rs&M || Rc&M || []).map(n => M.push(n));
    if (Rs&Mw) {
        each win Rs&Mw {
            #M.indexOf(n) >= 0 and continue
            M.push(n)
        }}
    }
    inM: while (1) {
        each in M {
            !n.c.not and continue
            M = M.filter(&t{
                return !(t == n || n.t == t.t
                && n.y.cv == t.y.cv)
            });
            continue inM
        }
        break
    }
    me&cvdeal,M;
    vsortz(M)
    Rs&M and Rs&M = M
    else { Rc&M = M }
};
#c DisplayTwo 17 - R lifecycle, energies!
# makes each R clickable
# and R0@93 me&Displays:
#   foam of the atoms (R+C) + modulat (C)
#   gets put in html
#   < without jquery
#   < without the element.A leading back,
#       without the A.element (Rs&on)
#     just path by attr on the elements

# first two blobs are about resolving R identity on the way in,
#  adaptor has tension around title, headlines are controlled

# for a given $k, h's ss&$k=$gk -> Rs&$gk = 1
me.Rscinsideness = &acgtk{
    return [
    ['Rscinside','1',&acgtRs{
        $uh = Ry&up && Ry&up.c.N[0];
        uhs&task == Rs&task and return;
        isC(s) && s.sc[k] and R.sc[s.sc[k]] = 1
        Rc&dupl = 3;
    },'if:h']
    ]
};

me.RbitXingness = &acgt{ return [
    ['RbitX','17',&acgtRs{ me&arriveRbitX,R,R.t },'if:RcX'],
    ['RbitX','4',&acgtRs{  me&goneRbitX,R },'if:h'],
    ['RbitX','91',&acgtRs{ me&applyRbitX,R },'if:h,sleeping'],
] };
me.DisplayTwoness = &acgt{ return [
    ... me&RbitXingness ,
    ['Displayingness','1',&acgtRs{
        $C = Rs&C = G&Cye,[R.t,'',{}];
        # R = me&yfuture,C
        Cy&R = R;
        if (Rc&d == 0) {
            $p = R.y.up;
            $s = p && pc&s;
            isC(s) and Rs&fornt = s.t;
        }
        # GOING
        Rc&inC = R;
        #Rc&d == 0 and R.t = C.t;
        # index by R.t set by daR
        Rc&nl ||= 2888;
        Rc&dl ||= 35;
    }],

# then acting standards, interfaces!
# where our mind clicks on, important place for tricks

    ['Displayingness','27',&acgtRs{
        Rs&elvis = 'Gazel';
        
        # the tangulate this R injects from
        $Re = Rs&Recipe;
        Re and Rey&Real = R
        
        # inherit certain sc
        $p = Ry&up;
        # not if they reneg from the mainstream
        #  of matter unfolding with typology
        # < a "legitimate child created" hook
        #  < tunneling things's siblings,
        #     sleeping them on arrival if slep etc.
        if (p && !Rs&reneg) {
            # may end up on random things
            #  see %Codon && (!%ball||%Gens) and delete %Codon
            # parent must have it
            each ik ps&inheritsc {
                R.sc[k] = p.sc[k]
            }
            # only onto eg %ball
            each kc ps&inheritscif {
                !R.sc[k] and continue
                ex(R.sc,c)
            }
        }
        # remember certain sc
        $b = Rc&b;
        b && bs&nextlifesc and ex(R.sc,bs&nextlifesc)
        
        
        !1s&Te and return
        
        # (1|R)s&Te carry decentralising namewires from Elvising
        $Te = me&Tie,R;
        !Te and return
        Tey&Real == R;
        
        # elvising's version stamped on R
        Tey&slandige and Ry&Te_slandige = Tey&slandige
        
        
        
        # meanings
        me&playstulate,R;
        me&boostulate,R;
        # of Tool:
        me&tangulate,R;
    },'D'],
    
    # data dump R%sun
    ['sun','3',&acgtRs{
        $c = {task:'Cray'};
        Rs&sun == 2 and c.refpool = 1
        Rs&dupup and c.dupup = 1
        me&Reis,R,R.t,null,c;
    },'ift'],
    
    ['Displayingness','93',&acgtRs{
        Rs&noDisplay and return
        $the = me&Timethe,'Display';
        $d = me&Display,R;
        the();
    },'if:h,sleeping'],
] };

#c boost/play
# all R able to receive a %boost,
#  +/- reality
me.boostulate = &acgtR{
    Rs&elvis = 'Gazel';
    1s&Te and me&Tie,R,'boost';
    !Rs&boost and return
    
    # drawn
    $M = me&Mw,R,'boost';
    Rc&nl and Rc&nl += Rs&boost * 3;
    Rc&dl and Rc&dl += Rs&boost;
    $bo = Rs&boost;
    $sym = bo < 0 ? 's' : '↯';
    bo = bo < 0 ? bo*-1 : bo;
    $i = 0;
    while (i < bo) {
        $hu = 20*i+100;
        $z =
        m booste 11 $s:sym %fs:20,hs:594,lh:0.5,hue:$hu
        z.t += hu;
        i++;
    }
};
# %play mode engages scheme resolver of a mode
# usually looks at %ball's ss&testrun or so
me.playstulate = &acgtR{
    1s&Te and me&Tie,R,'play'
    if (!Rs&play) {
        $b = Rc&b;
        $packdown = b && bs&play && bs&unplaycb;
        packdown and packdown.map(y => y());
        return
    }
    n playing  s:▶
    
    # look up what to do
    # < G&ting for an A^%playsheet/%anyRscgk
    $N = me.cby(R).reverse();
    each ir N {
        $p = rs&playsheet;
        !p and continue
        each kc p {
            !R.sc[k] and continue
            c(A,C,G,T,R);
            return
        }
    }
    # hi
    n noplaysheetupwards  s:(buthow?) %fs:6
};
#c Renderingness
# patch the channels thiswaythatway
me.Renderingness = &acgtR{ return [
    # allow for %Cit & %Tool... to use Displays
    # link elvising to origin
    ['displayon','7',&acgtRs{
        $D = me&tsc,'displayon','D','G';
        Dy&cv = 0.11
        Ds&pa = 0.4;
        (Rs&boost||0) < 1 and return
        # < turn into a header with a cell in it
        # < controls for width/height, spillover
        Dc&s = 'displayon';
        
        s&over = 'scroll';
        Ds&dis = 2; # inline
        #Ds&ab = 1; # pos:absolute
        #Ds&over = 'hidden';
        Ds&bg = 'green';
        Ds&width = '50%';
        Rs&rowish = 1;
        s&bo = '4px dotted green';
        s&hue = 30;
        s&br = 0.4;
        
        $s = s||Rs&self;
        
        $ons = [];
        ss&on and ons.push(s)
        else {
            # for a !Display(ed yet?) R receiving others
            each in ss&down {
                ns&on && ons.push(n)
            }
        }
        if (!ons.length) {
            # interface to ask things to Display more
            if (ss&enlum != null) {
                if ((Rs&boost||0) < 2)
                    return me&tsc,'canbegot','?','b'
                me&introqua,s,{enlum:1};
                me&tsc,'canbegot','...','b'
            }
            else {
                me&tsc,'nobits','!D','6'
            }
        }
        
        $Te = Rs&Te;
        each in ons {
            ac(R,'down',n);
            # link elvising to origin
            $r = ny&origin;
            # R:C does R:Display in itself
            !r && ss&task == 'C' and r = R
            !r and throw "R:Display !yorigin"
            $ot = me&introqua,r;
            i $Te/$ot
            # BUG io z dupe
            # if multiple $ot to the same tv:
            # TEST
            # < io.i for two different $ot repeatedly
            #   singalises by tv, makes z dupey
            #   expecting o to filter z by tv?
            #    or can it dup_z what inserts by tv?
            #   ot1.y.later = ot2(.y.earlier = ot1)
            #    supposes the ot1/2 are singly theirs to muck with,
            #    not just linked to from there
            #   sometimes the z-ing (accumulation) is
            #    more desired than the tv-ing (namespace)
            $was = Tes&z.length;
            Tes&z = uniq(Tes&z);
            was > Tes&z.length and ~WasotinTe
        }
    },'ift,D'],
]};
#c Implantingness R:Cit mobility
# host disjointed innards
# autostarted when elvising available
me.Ja.Das = &acgt{
    me&Gomp;
    me&introqua,0,'quiet','@1';
    $Te = 1s&Te;
    $N = Tes&M ||= [];
    n DasN  $s:N %ravel:spond
};
me.Implantingness = &acgtR{ return [
    # %Cit%play mobilises as an origin
    #  then %spondo (W:Das playing with it)
    #   does spondoReis %Reis:Cit%,%TeImplant
    #   and configures it, making W:City
    # W:City %Citying
    #   does CityingReis %Reis:Cit%,%TeImplant
    # biggining, middle, end
    
    # realise we're becoming elsewhere:
    ['Cit+play','29',&acgtRs{
        $p = Ry&up;
        $pp = p && py&up;
        if (ps&Citop) {
            if (Rs&play && !ps&Implant) {
                # e to W:Das every time
                
                # map what's around here for them
                $hn = me.nameup(R,'testrun run step doing',{});
                # < less fatal, %spondo may only look for...
                
                # e
                $name = hn.t +":"+R.t;
                $D = G&Cye,[name,'',{R:R,Te:Rs&Te,nameup:hn,J:A.1}];
                me&Ravelvis,R,'Das','M',D;
                
                # causes a %spondo to %Reis again elsewhere
                delete Rs&Cit;
                Rs&Outplanted = 'Cit';
                
                # pausing the J it is examining
                $b = Rc&b;
                b && !bs&play and 1s&pausing = 1
            }
        }
    },'ift,D'],
    
    # in a %Reis:Cit%,%TeImplant
    ['Citop','52',&acgtRs{
        $p = Ry&up;
        $pp = py&up;
        # %Reis with %TeImplant
        if (ps&Reis && ps&TeImplant) {
            # makes %Citop%Implant
            Rs&Implant = 1;
            # and implants/links elvising:
            $Te = ps&TeImplant;
            if (!Rs&Te || !Rs&Te.sc.Implanted) {
                $el = me&introqua,R,{Implanted:1};
                i $el/$Te
                Rs&Te = el;
            }
        }
    },'ift,D'],
    
    # then inside W:City:
    ['Citying','3',&acgtRs{
        if (Rs&gleep) {
            Rs&rowish = 1;
            me&tsc,'nopddp';
            s&bo = '3px solid blue';
            n spondto  $self:Rs&gleep,R %Reis:Cit%,refpool
            return
        }
        # the R:C for...
        $p = Ry&up;
        # Citey s=thing %ravel:Citying
        $c = pc&s;
        !cc&s and me&tsc,'nos','nos','B';
        # %ravel gives s=thing here
        cc&s != s and me&tsc,'sdiff','sdiff(R/C)','B';
        $z =
        n CityingReis  $self:cc&s,R %Reis:Cit%,refpool
        # (dont) give Rs&Te directly,
        #  TeImplant would cause it to hang around,
        #  < could be alright if Co/$main ran its own W Te
        #  < then main-main could extract updates naturally?
        #  < click in test's displayon should re%doing it
        $Te = c.y.TeImplant;
        Te and zs&TeImplant = Te;
        
        s&lv = 1;
        # clone this Rs&C/** into R:C's Cs&z
        Rs&printDisplay = 1;
        #$s:c&s,TeImplant:Te %ravel:Citying
        #n spondo  $self:s,R,TeImplant:rs&Te %Reis:Cit,set:Cit
    },'ift,D'],
    #c spond (W:Das playing with it)
    ['spond','3',&acgtRs{
        Rs&rowish = 1;
        n t  $s:s.t %hs:789
        $N = sc&s;
        !N || !N.push and throw "!array"
        # squish repeatative entry by futurised R
        # later may have changes in Te/s we want
        $gotR = [];
        $outi = [];
        each in N {
            $r = me&yfuture,nc&R;
            # disconnect when yfuture but no extra push from it
            r != nc&R and nc&discon = 1
            nc&R = r;
            $ri = gotR.indexOf(r);
            if (ri < 0) {
                gotR[i] = r;
            }
            else {
                # has a more up to date s/%Te
                N[ri] = n;
                outi.push(i)
            }
        }
        outi.reverse().map(i => N.splice(i,1));
        
        #n rec  s:●
        #n stop  s:■
        #n redo  s:◀
        each in N {
            $del = &{ N.splice(i,1) };
            n $n.t  $s:n,R,remova:del %spondo
        }
    },'ift,D'],
    # as a dislocated being
    ['spondo','3',&acgtRs{
        Rs&rowish = 1;
        s&bo = '3px solid blue';
        s&br = 1;
        # the %Cit gone %Citless
        $r = sc&R;
        $h = sc&nameup;
        !h and me&domesticate,R
        else {
            n nameup  $s:h,R,aTe:rs&Te,Spondo:s %nameup
            
        }
        Rs&boost < 0 and sc&discon = 1
        sc&discon and me&tsc,'disconnected','unplug?','g'
        sc&discon and Rs&remova()
        #me&Reis,R,'Cray',s,{refpool:1};
        $s = rc&s;
        n Te  $s:rs&Te,R %ball,rowish
        
        # < inherit test's refpool
        n spondoReis  $self:s,R,TeImplant:rs&Te %Reis:Cit%
    },'ift,D'],
    # display the thing from me.nameup
    ['nameup','3',&acgtRs{
        Rs&rowish = 1;
        s&ml = 2;
        #me&tsc,'nameup',null,'G';
        $h = s;
        each in h.N {
            $k = h.twas[i];
            i > 0 and me&tsc,'upwardsof','/','y';
            me&tsc,'%'+k,n.t;
            #n $k  $self:n,R %Cit
        }
        if (h.doing && h.step) {
            # the %doing
            (Rs&boost||0) < 1 and return me&tsc,'Upplantscheme','(+%City?)','g'
            delete Rs&Te.sc.boost;
            
            $expco = &k{
                $d = h[k];
                $dex = ds&exp;
                return dexs&Copy;
            };
            $s = Rs&Spondo;
            !s and throw "DasN thing !self"
            # unpause the source J
            $J = sc&J;
            !J and throw "DasN thing !J"
            me&JPause,J,0;
            # unDasinate the source R
            $Te = Rs&aTe;
            delete Tes&play;
            # boost also, later
            
            $S = expco('step');
            # insert doing to step
            i $S/City:s
            $D = ya;
            # that looks at previous doing (W.t)
            $d = expco('doing');
            Dc&points = d.t;
            # awkwardly pass in %Te as s&z to City
            # un-push to Das,
            #   and save Te without the extra %play
            #   which will cancel out with %TeImplanted on arrival
            if ('how' && Te) {
                # gives you a little time to muck with it
                $r = me&Copy,R,Te,16;
                delete rs&ov;
                # every %ball to a %push should %Lines
                # < does doing it now matter?
                rs&Lines = 3;
                me&Ring,r;
                i $D/rc&s
            }
            # now the City takes the boost/gutsprawl
            #   inner boosts are still there
            delete Tes&boost;
        }
        else {
            me&tsc,'noUpplantscheme','(?)','g';
        }
    },'ift,D'],
    
] };

#c KnowCitingness
# only in rovo, tests in ravel depend on Cit

# < near a lot of extensibles for io
# data dumpers, using %Cit%tightly/KnowC
me.zu = &acgttsc{
    $R = Cy&R;
    typeof t != 'string' and c=s; s=t; t=''
    c == '' and c = {refpool:1}
    typeof c == 'string' and c = G&peel,c 
    c ||= {};
    !t && !s and s = R; t = 'R'
    c.t = t || s && s.t;
    !c.t || s && c.t == s.t and c.t='zun'
    $t = ' '+c.t;
    c.t = t;
    c.self = s;
    c.Cit = c.tightly = c.reneg = 1;
    $n = me&Ret,R,c;
    me&zN,n;
    
    return n
};
# new refpool, stable expression
me.nu = &acgttsc{
    $R = Cy&R;
    c ||= {};
    isst(c) and c = G&peel,c
    # too many me&nu calls limit
    if (isst(t)) {
        $limit = 5;
        $k = "nuff_"+t.substr(0,3);
        $n = R.sc[k] ||= 0;
        isC(n) and nc&s++; return
        elsif (n && n > limit) {
            R.sc[k] ||= me&nu,'limore',limit;
            return G&Cye,['blank',1]
        }
        else {
            R.sc[k]++;
        }
    }
    c.refpool = 1;
    $r = me&zu,t,s,c;
    me&zN,r;
    rc&stable = 1;
    rs&rowish = 1;
    return r
}

# wants to add more tricks:
# < C as openy as R
# < lum: across over in

# < ch %Tool any Rc&ha
# a side note:
# to allow being in more places
# < separate dupl for each maingk
#Rc&dupl += 3;
# to link to the main place of it
# < make dubquiet only for dubs (tests)
# < algebra instead of many dups
#    and similars, schemas,
#    the solve what that change is
#   wandering = cables?
#   in/out of the Citop?

me.KnowCitingness = &acgtR{ return [
    # %tightly inherits into everything
    ['tightly','3',&acgtRs{
        ac(R,'inheritsc','tightly')
    },'ift,D'],
    ['Cee+runny+tightly','29',&acgtRs{
        $Cit = me.cbub(R,'Citop');
        Cits&runny ||= 0;
        Cits&runny ++ > 20 and return Rc&nofurther = 1
        
    },'ift,D'],
    # effect that datadump
    ['Cit+tightly','5',&acgtRs{
        # talk of dupes
        delete Rc&dubquiet;
        $p = Ry&up;
        $pis = ps&scan || {};
        $is = Rs&scan;
        is.C and Rs&isC = 1
        
        # also is=R, specifics
        $laC = me.cbu(Ry&up,'isC');
        
        $ot = me&Mwty,R,'','ot';
        ot && Rs&isC and delete ots&deco;
        
        R.t == 's' and s&fs = 15; s&hue += 80
        
        if (Rs&isC && laC) {
            $P = laCc&s;
            ac(laC,'Citin',R);
            P == s and return me&tsc,'isCabove','*','y'
            $sym = P.t == R.t ? '⸧' : '⸦';
            Rs&samet = 1;
            Rs&newt = 1;
            me&tsc,'Citin-sym',sym,'q'
        }
        if (is.is == 'R') {
            if (Rc&N.indexOf(s) >= 0) {
                me&tsc,'isRinthisRcN','RN','b'
            }
            if (sc&sip != null) {
                $ip =
                me&tsc,'csip',sc&sip,'b';
                ips&float = 'right';
            }
        }
         
    },'ift,D'],
    
    ['Cit+tightly+isC','53',&acgtRs{
        (Rs&boost||0) < 2 and me&KnowC,R
    },'ift,D'],
    
    ['Cit+tightly','29',&acgtRs{
        $Te = Rs&Te;
        $te = Tes&refpoolin;
        !te and return
        ~refpoolin: ki(te);
        # are R/r.t to give its own refpool
        # process modulated R from Cit@3
        # < as mindfilter
        Rs&endomemod = &n{
            te[n.t] and ns&refpool = 1
        };
    },'ift,D'],
] };
    
#c Knowaken
# Near Be.*, an index of qualia
$Be = me.Be ||= {};
# accumulates h.a.$K.nkgk.$nk.$gk = {Ka}
me.Knowa = &acgths{
    each K,Kc Be.C {
        each i,nk Be.nks {
            $l = Kc[nk+'gk'];
            !l and continue
            $g = s [nk];
            each gk,v g {
                l.indexOf(gk) < 0 and continue
                $has = h.a[K] ||= {nkgk:{}};
                $nks = has.nkgk[nk] ||= {};
                $Ks = nks[gk] ||= {};
                $Ka = {K:K,Kc:Kc,nk:nk,gk:gk};
                Ks[K] = Ka;
            }
        }
    }
};
me.KnowKn = &acgthsc{
    each K,has h.a {
        $Kc = Be.C[K];
        
        $Km = null;
        
        # K found C.*.*
        each nk,gks has.nkgk {
            # those across hemispheres
            c.onlynk && nk != c.onlynk and continue

            # hash order: s for gks,
            #  per K spec for Kgks
            $l = Kc[nk+'gk'];
            each i,gk l {    
                # suggest it?
                $Ks = gks[gk];
                !Ks and continue
                $Ka = Ks[K];
                !Ka and throw "notoutK"
                
                c.igsc && nk == 'sc' && c.igsc[gk] and continue
                
                $v = s[nk][gk];
                
                Km ||= c.enKm && c.enKm(K,Kc);
                
                Km && c.enKn && c.enKn(Km,nk,gk,v,Ka);
            }
        }
    }
};
#c Knowfix
# just slightly! different that KnowC
me.Knowfix = &acgtRc{
    $s = Rc&s;
    c ||= {};
    c.for ||= 'fix';
    $ca = c.ca;
    !ca and throw "send c.ca=modulat"
    
    $h = {};
    #Rc&noKnowC and return
    #Rc&noKnowC = 1;
    me&bewind,R and return
    # have an R:$gk%fix=$nk
    h.r = {};
    me&ioty,R,'fix' .map(&r{
        $side = h.r[rs&fix] ||= {};
        side[r.t] = r;
    });
    h.a = {};
    me&Knowa,h,s;
    
    $top = h.top = cay&top = G&Cye,["Knowfix-"+R.t,1];
    
    c.giveq = &q{
        $qu = cay&can('c','caseof-'+q.t,'va');
        q.t == 'sc' and qus&fs = 16
        $de = quy&can('o','describe');
        $l = dey&can('i',q.t,'fs:18,lh:0.6');
        $fi = quy&fi = quy&can('c','fixens','va');
        fis&z = [...qs&z];
        # and enlarge c&s
        if (q.t == 'c') {
            qs&hue = 44;
            me&ioty,q,['','','groupthing'] .map(&n{
                if (n.t == 's') {
                    ns&fs = 27;
                    ns&lh = 0.3
                    ns&bgh = '010';
                }
            });
        }
    }
    
    
    each nk,sides h.r {
        # q for r for y,c,sc (if present)
        $q = fio(top,nk,[nk,1,{},'groupr']);
        $cK = {};
        cK.onlynk = nk;
        cK.igsc = {z:1};
        cK.enKm = &K,Kc{
            # r/* known
            $k = fio(q,'known'); ks&groupology = 1;
            # r/* known by K
            # C for the grouping (Be.C.*)
            $Km = fio(k,K,[K,1,{Kc:Kc},'grouping']);
            return Km
        };
        cK.enKn = &Km,nk,gk,v,Ka{
            $Kn = fio(Km,gk,[gk,1,
                {s:gk,Ka:Ka},
                'groupthing,fs:7,mar:0.3'
            ]);
            
            # find r(nk)/n($v
            $whr = &k{
                return me&ioty,R,k
                    .filter(r => rs&fix == nk)
            };
            $n = whr(gk) [0]
            # < should always Rbit by path out of over
            #   otherwise its Rname, sometimes preferred
            || v && typeof v == 'object'
                && whr()
                    .filter(r => rc&s == v)[0];

            if (n) {
                # ground relating to this gk
                # < %Cit%isC%ot should be the gk path?
                Knc&n = n;
                # attempt to claim the n
                # < while recently boosty?
                ac(q,'zuction',n,'K',0)
                    .push(Kn);
            }
            else {
                me&tsc,"gathermodulatsof:"+gk
            }
        }
        me&KnowKn,h,s,cK;
    }
    me&KnowSmush,R,h,s,c;
    
    return ca;
};

#c KnowC
me.KnowC = &acgtRc{
    !Rs&isC || !Rs&Cit and throw "uwhat"
    $s = Rc&s;
    c ||= {};
    $h = {};
    Rc&noKnowC and return
    me&bewind,R and return
    # have an R:$gk
    h.r = {};
    me&ioty,R,'Cit' .map(r => h.r[r.t] = r);
    !haks(h.r).length and return; # me&tsc,"Noz"
    
    me&tsc,'thoughtisC','isC!','B';
    
    #Rc&noKnowC = 1;
    
    # raw knowing have K/nk/gk
    h.a = {};
    me&Knowa,h,s;
    # getting baked into:
    # top/groupr(r(gk))/groupology()/grouping(Km)/groupthing(Kn)
    # Knc&n is an r%Cit out there
    $top = h.top = G&Cye,["KnowC",1];
    # which unifies C.* so we can style it up
    # across hemispheres especially,
    #   crescent moon shaped, so the c can have its sc near it
    # should gather at the edge
    
    each nk,r h.r {
        # q for r for y,c,sc
        $q = fio(top,r.t,[r.t,1,{r:r},'groupr']);
        # which may be as R or modulat,
        # wanting to apply as much effect to either
        # always have groupr
        $cK = {};
        cK.onlynk = nk;
        cK.enKm = &K,Kc{
            # r/* known
            $k = fio(q,'known'); ks&groupology = 1;
            # r/* known by K
            # C for the grouping (Be.C.*)
            $Km = fio(k,K,[K,1,{Kc:Kc},'grouping']);
            return Km
        };
        cK.enKn = &Km,nk,gk,v,Ka{
            $Kn = fio(Km,gk,[gk,1,{s:gk,Ka:Ka},'groupthing,fs:7,mar:0.3']);
            
            # find r(nk)/n($v
            $n = me&ioty,r,'Cit',gk [0]
            # < should always Rbit by path out of over
            #   otherwise its Rname, sometimes preferred
            || v && typeof v == 'object'
                && me&ioty,r,'Cit'
                    .filter(r => rc&s == v)[0];

            if (n) {
                # ground relating to this gk
                # < %Cit%isC%ot should be the gk path?
                Knc&n = n;
                # attempt to claim the n
                # < while recently boosty?
                ac(q,'zuction',n,'K',0)
                    .push(Kn);
            }
            else {
                me&tsc,"gathermodulatsof:"+gk
            }
        }
        me&KnowKn,h,s,cK;
    }
    return me&KnowSmush,R,h,s,c
};
#c KnowSmush
me.KnowSmush = &acgtRhsc{
    c ||= {};
    c.for ||= 'Cit';
    $top = h.top;
    
    # zuct having noticed $r/* they want
    $zuct = &Kn,r,n{
        $M = Kns&z ||= [];
        # grouping modulat hosts
        $zi = !rs&z ? -1 : rs&z.indexOf(n);
        if (zi <= 0) {
            # weird. must have just been there,
            # but now ain't? will be in Display...
            # < Test it out. sync GET will DIY debug.
            #   and/or Ring-bisecting watch data
            $M = ns&M ||= [];
            $wasnt = 'notinupz';
            Knc&Ka and wasnt += '_'+Knc&Ka.K;
            #m $wasnt  s:? %fs:22
            $M = Kns&z;
            if (nc&nofurther) {
                #m can_move  s:nofurther
            }
            else {
                $M = Kns&z;
                #m can_move  s:notinz
            }
        }
        else {
            #rs&z.splice(zi,1);
        }
        ns&zuctedto = Kn;
        delete Knc&s;
        $M = Kns&z ||= [];
        M.push(n);
    };
    
    $N = h.the = me&ioty,top,'groupr';
    each iq N {
        $r = qc&r;
        !r and continue
        each in qs&zuction {
            $refK = ac(q,'zuction',n,'K',0);
            each i,Kn refK {
                $M = Kns&z;
                if (i == 0) {
                    zuct(Kn,r,n)
                }
                else {
                    Kns&Alsohadby = refK.filter(n => Kn != n);
                    $known = "Alsohadby:"+Kns&Alsohadby
                        .map(n => nc&Ka.K).join('|');
                    m $known  s:* %hs:296,fs:6
                    Kns&fs = 6;
                }
            }
        }
    }
    
    #c zuct remaining r/* into unknown
    each iq N {
        $r = qc&r;
        # from R/$nk:r/$gk or R/$gk
        r ||= R;
        $out = c.for == 'fix' ?
            # looks for %fix=$nk
            me&ioty,r .filter(r => r.sc[c.for] == q.t)
            # or all these things
        :   me&ioty,r,c.for;
        # not zuctedto to (Km/Kn)
        out = out.filter(r => !rs&zuctedto);
        
        if (out && out.length) {
            fio(q,['KnowC-bound',5,{s:')'},
                'fs:25,ma:-0.4,separator']);
            
            # unknowns instead of groupology
            $k = fio(q,['unknown',51,{},'unknowns']);
            # < doming to clue its relation to r
            $Km = fio(k,['unknown',1,{},'grouping,wideas']);
            # Kn(r)/r
            $same = {sc:{}};
            # if Rc&s[r.t][gk] == nc&s,
            #  where gk starts a lie, is probably ot
            # < fix the R.t/Rs&ot thing, bad design
            #   Elvis gets better paths through arrays with it,
            #    and the thing gets its own name more often
            each in out {
                $gk = n.t;
                $g = Rc&s[q.t];
                if (g && nc&s && g[n.t] != nc&s) {
                    $topt = haks(g).filter(&gk,{
                        return g[gk] == nc&s
                        # sometimes Rc&s has 0 ||= null
                        || !g[gk] && !nc&s
                    });
                    if (topt.length < 1) {
                        # assumes nc&s == a gk v 
                        isC(nc&s) and ~Toptnot: q.t, n.t, ki(haks(g))
                    }
                    elsif (topt.length > 1) {
                        # probably knows gk anyway
                        $ni = !ns&ot ? -1 :
                            topt.indexOf(ns&ot);
                        ni >= 0 and gk = ns&ot
                        else {
                            ~Toptmany: n.t, gk, ki(topt)
                        }
                    }
                    else {
                        gk = topt[0];
                    }
                }
                gk != n.t && !ns&ot and throw "doesn'tot", gk, n.t
                if (ns&ot && ns&ot != gk) {
                    # let go
                    #~>3 dupnotot?: ns&ot, gk
                    gk = ns&ot;
                    #, r, Rc&s
                    #and throw "notot", ns&ot, gk, n.t
                }
                fio(Km,gk,0) and throw "multiple gk: "+gk
                $Kn = fio(Km,gk,[gk,1,{s:n.t,n:n},
                    'groupthing,fs:9,mar:0.3']);
                zuct(Kn,r,n);
                # see also if multiple ==
                $co = ac(same,'refs',nc&s,'head');
                !co and ac(same,'refs',nc&s,'head',Kn)
                else {
                    # the other Kn
                    ac(co,'equals',Kn)
                }
            }
        }
    }
    #c < same form between c/sc?
    
    # title/style the Kms
    $N = me&ioty,top,'groupr%groupology%grouping';
    each i,Km N {
        $M = Kms&z;
        
        # title
        m KnowC_K  $s:Km.t,K:1 %hs:684,fs:7,mt:-1,label
        # < sort modulat/**
        #  < Cye oo1 -> 0.001
        M.unshift(M.pop());
        
        me&walls,Km,'bd:1.4,hu:3'
    }
    
    # label, 'c{', path in
    $N = me&ioty,top,'groupr';
    each iq N {
        # non-%groupology
        # < put higher than groupologies,
        #   to spew open !%va
        # < ongoing eat everything in Rs&M/Mw
        $l = fio(q,'label');
        ls&label = 1;
        qs&z.unshift(qs&z.pop());
        
        $r = qc&r;
        !r and continue
        
        # < zuct modulats?
        #   supposing compressors go looking for traw
        me&Mw,r,'traw' .map(n => ls&z.push(n) );
        delete rs&Mw.traw;
    }
    
    #c make cells
    
    $cells = &nc{
        ny&R == n and n = ns&C;

        ns&dis = 4;
        ns&va = 1;
        c && ex(n.sc,c);
        ns&ma ||= 0.2;
        return;

        # debug obvium
        #return;
        me&walls,n,'bd:3.8,hu:2'
        ns&bgh = 341;
        #ns&hue = 30;
        c && ex(n.sc,c);
    };
    
    
    # top/groupr(r(gk))/groupology/grouping(Km)/groupthing(gk)
    #  groupology may also be unknowns|label
    $N = me&ioty,top,'groupr';
    each iq N {
        $r = qc&r;
        
        cells(q)
        
        # < places where the layout can use/learn
        #   more x: one/two lines of groups and ungr.
        #     could smushwrapout nicely
        #   more y: column of groups
        # main problem is expansion getting stuck in a cell
        # label, groupology, separator or unknowns
        me&ioty,q,''
            .map(k => cells(k));
        
        # hide separator
        $sn = me&ioty,q,'separator'
        sn.map(k => ks&dis = 0);
        
        $possibleK = me&ioty,q,'groupology%grouping';
        # groupology always, gets shaped
        $kM = me&ioty,q,'groupology';
        each i,k kM {
            cells(k);
            $KM = me&ioty,k,'grouping';
            $breakin = 0;
            each i,Km KM {
                $len = Kms&z && Kms&z.length;
                # tries to put long groups on their own line,
                # or every now and again
                # < 'the partitioning problem'
                if (len > 4 || breakin > 7) {
                    breakin = 0
                }
                else {
                    breakin += len;
                    # cells(Kn,{float:'left'});
                    cells(Km);
                    each i,n Kms&z {
                        !nc&K and continue
                        cells(n);
                    }
                }
            }
        }
        
        # non-groupology, the other tray
        $uKM = me&ioty,q,'unknowns%grouping';
        possibleK.push(... uKM);
        
        # < o $q/*/%grouping/%groupthing
        #   having rs&z order for Knc&n
        
        #c those leaping out of here, infinitree
        # < apply cruder mechanisms
        #  < object/nonobject
        #  < hash key order split around z
        $trailing = [];
        each i,Km possibleK {
            $burst = [];
            each i,Kn Kms&z {
                # are R
                $n = Knc&n;
                !n and continue
                
                # if recently boosty
                $b = nc&b;
                !ns&boost && (!b || !bs&boost) and continue
                
                # the unknown may hold until rs&z appear
                Kms&wideas && !ns&z and continue
                
                #~Bursting: Kn.t, ns&z?ns&z.length:"modulative"
                burst.push(Kn);
            }
            if (burst.length) {
                # get out of unknowns/
                trailing.push(...burst);
                burst.reverse();
                each i,Kn burst {
                    # are R
                    $n = Knc&n;
                    ns&zuctedto != Kn and me&tsc,'Kn-burst:'+Kn.t,'','y'
                    ns&zuctedto != Kn and continue
                    ns&zuctedto != Kn and throw "Kn r burst !zuctedto Kn"
                    
                    i = Kms&z.indexOf(Kn);
                    # leave a link/headline/booste
                    $sp = G&Cye,['burst-'+Kn.t,1,{s:Kn.t},{burst:Kn}];
                    Knc&spacer = sp;
                    Kms&z.splice(i,1,sp);
                }
            }
        }
        if (trailing.length) {
            if (0) {
                # fold knowC, stretch label
                #   relayout the groupr
                $l = fio(q,'label',0);
                !l and throw "nolabel"
                $qz = qs&z.filter(k => k != l);
                delete qy&tw;
                qs&z = [l];
                $rs = fio(q,'oneandinfinityrows');
                # ceiling row
                $und = fio(rs,'undercontrol');
                unds&z.push(...qz);
                # to put inside infinity
                $f = fio(rs,'infinity');
                cells(rs);
                cells(und);
                h.label = l;
                ls&va = 2;
            }
            $f = q;
            each i,Kn trailing {
                ac(q,'trailing',Kn);
                # some sorting
                Kny&cv = 0.53;
                fs&z.push(Kn);
                # indent like Rs&rowish
                Kns&pl = 1;
                Kns&dis = 1;
                # sustain size
                delete Kns&fs;
                # was Km
                Kns&zuctedto = f;
            }
        }
        each i,Kn qs&trailing {
            $n = Knc&n;
            !n and throw "Kn trailing !n"
            # allow tools in the spacer,
            #  where we're pointing while it opens beside
            $sp = Knc&spacer;
            if (nc&nofurther && sp) {
                # rolltog to Te their parent to %refpool them
                #  vanishes once enabled
                $M = sps&z ||= [];
                $ot = ns&ot || n.t;
                $y = &v{
                    $Te = me&introqua,ny&up;
                    $te = Tes&refpoolin ||= {};
                    te[ot] = v;
                };
                me&rolltog,r,{k:'refpool-'+ot,M:M},0,y
            }
        }
        #c you
        each i,Km uKM {
            each i,Kn Kms&z {
                cells(Kn,{float:'left'});
            }
        }
    }
    
    # getting baked into:
    # top/groupr(r(gk))/groupology()/grouping(Km)/groupthing(Kn)
    # Knc&n is an r%Cit out there
    
    # all Kn
    $N = me&ioty,top,['','','grouping',''];
    $short = N.length < 20;
    $unhuge = N.length < 40;
    # all Kn per groupr
    me&ioty,top,'groupr' .map(&q{
        me&ioty,q,['','',''] .length > 5 and short = 0
    });
    
    
    
    # symbols or small values
    each i,Kn N {
        $n = Knc&n;
        !n and continue
        $can = ns&scan;
        !can and continue
        $M = me&Mw,n,'traw';
        $sym = can.is || can.sym;
        if (sym) {
            # make the title white, gear coloured
            $ot = me&Mwty,n,'','ot';
            ot and ots&hs = 999; delete ots&deco
            
            $d = me&Mwty,n,'','sym'
            !d &&
                m sym 12 $s:sym %fs:11,lh:0.8,hs:4955
            
            if (unhuge) {
                # replaces sym with a small vision
                me&gkness,n
            }
        }
    }
    
    # ot=otherot=anotherot value
    # < do also for pointers toth
    each i,Kn N {
        $n = Knc&n;
        !n and continue
        $M = me&Mw,n,'traw';
        each il Kns&equals {
            m equals 11 s:=
            #m t 11 $s:l.t
            # lift the label from the tiny r
            $tr = lc&n;
            !tr and throw "equals other not tiny r"
            $ot = me&Mwty,tr,'','ot'
                || me&Mwty,tr,'','k';
            ot = G&Cye,['eqot',11,ot.c,ot.sc];
            m $ot
            ls&dis = 0;
        }
    }
    
    # pronounce
    $N = me&ioty,top,['','','grouping'];
    each i,Km N {
        if (Km.t == 'in') {
            # < get to the opening-in end
            #   etc for things above us (yup, cN, etc)
            #   have a here-business corner between?
            #     peace symbol
            # < things between gradually decreasing fs,
            #   then restoring to:
            Kms&fs = 15;
            me&ioty,Km,'burst' .map(&s{
                $Kn = ss&burst;
                Kns&fs = 15;
            })
        }
    }
    
    # give groupr to its r
    $N = me&ioty,top,'groupr';
    each iq N {
        $r = qc&r;
        $ce = r && rs&C;
        if (short) {
            # inline
            ce and ces&dis = 2
            # drop KnowC_K
            me&ioty,q,['','grouping','label'] .map(&n{
                n.t == 'KnowC_K' and ns&dis = 0
            });
            
        }
        # < our Mw/*/* is boost,t,sym,ot,thoughtisC
        
        # q/* wants to end up in:
        if (r) {
            $KM = me&Mw,r,'KnowC';
            KM.push(...qs&z);
        }
        else {
            c.giveq and c.giveq(q)
            else {
                throw "nowhere to put Knowing"
            }
        }
    }
    $c = Rs&C;
    # block makes solid background
    # < flex looks good if it only wrapped
    cs&dis = 1;
    
    h.R = R;
    # c.t == ' Thingstract' and me&zu,"has",h
};
#c Cit
=head2
dive into the result after it was made,
  showing output and crawling into the details:
    wants to be pointed to not coded
< fast pointing to the data you want,
    elvising into this Reis without its enclosing A
      resetting the 4s frame wait
< to create new %doings to W=Cit that check those points
see XVer for during
=cut
# as its own R
me.Cit = &acgtR{ return [
    ... me&DisplayTwoness ,
    # includes Citingness:
    ... me&Toolingness ,
    ... me&Slepingness ,
] };
# with you & your Tooling/Display/etc
me.Citingness = &acgtR{ return [
    ... me&Ceeingness ,
    ['Cit','13',&acgtRs{
        # subverted refs dedup
        s = Rc&s ||= Rs&self;
        # preferred is: see KnowC/trailing
        
        
        $p = Ry&up;
        # < Doming would be able to detransmit this
        #   in retrospect of %reneg appearing before:
        # Displayingness 27 hasn't downloaded tightly yet
        ps&tightly and Rs&tightly = ps&tightly
        ps&Cit || ps&Citop and 'inside %Cit gel'
        else {
            Rs&Citop = delete Rs&Cit
        }
        
        # when in.t should > out.t
        $rename;
        if (!Rs&Citop && isC(s)) {
            $pis = ps&scan || {};
            if (Rs&tightly) {
                # NEW, only in.t array members
                pis.sym == '[' and rename = 1
                Rs&Rt = s.t;
            }
            else {
                rename = 1
            }
        }
        $foret = R.t;
        if (rename) {
            if (Rs&tiny) {
                # path in != title once there
                # < doesn't work for Teing...
                #   many places decide what that bit is,
                #   mainly stackTe?
                Rs&RXbit = R.t;
            }
            # use inner title
            # < leave R.t, invent another %ot for t inside R.t
            #   may target by s.t sometimes, eg an array of C
            R.t = s.t
        }
        if (Rs&ot == '1' || !Rs&ot && foret != R.t) {
            delete Rs&ot
            foret != 'Cit' and Rs&ot = foret
        }
        
        # allow %Cit to have %play 
        # and yon %Cee to sprawl to C
        Rs&playsheet = {Cit: &acgtR{}};
    },'ift'],
    #c Citop the top Cit looks it over more
    ['Citop','6',&acgtRs{
        $b = Rc&b;
        $p = Ry&up;
        ps&ok and Rs&ok = 1
        # ok-ing overthing should calm...
        Rs&ok && b && !bs&ok and Rs&boost--
        
        # clicking in here should localise refresh
        ['Cit','Citop'].map(&k{ ah(R,'reawakens',k,{
            rollbs:'Cit,Citop,tightly,ot,RXbit'
                +',tiny,kvey,ma,dis,Rit,rowish,scan,self,reneg',
            sc:{refpool:1},
            wakeasparent:1,
        }) });
        
        s&bo = '2px dotted blue';
        s&hue = 30;
        s&br = 1;
        s&ma = 0.3;
        s&pa = 0.3;
        #s&float = 'right';
        !Rs&Te || !Rs&Te.c and s&fs = 6;
        
        if (typeof s != 'object') {
            me&domesticate,R;
            me&tsc,'notobject','!object','d'
            n notC  $s:s,R %Cee,dupup
            return
        }
        n $R.t  $s:s,R %Cit
        
        !isC(s) and return
        $WR = sy&R;
        if (WR) {
            $on = WRs&on;
            if (on) {
                n yRson  $self:WR,R %displayon,maybe
            }
        }
    },'ift,D'],
    ['TeImplantation','3',&acgtRs{
        # %ball?
    },'ift,D'],
    # continuity markers
    # < Tool continuity awareness over all
    # < slan diff also, probably already somewhere
    ['continuity markers','6',&acgtRs{
        return;
        $b = Rc&b;
        !b && !Ry&up.c.b and return
        !b &&
        n newb o9 s:b %fs:7,hs:297
        if (b && bc&s != Rc&s) {
            n news o9 s:s %fs:7,hs:297
        }
    },'ift,D'],
    #c Cit
    ['Cit','3',&acgtRs{
        Rs&Cit = 3;
        $p = Ry&up;
        $Cit = &tsc{
            $n =
            n $t  $s:s,R
            ex(n.sc,ex(c||{},{Cit:1}));
            return n
        };
        # title 0!
        $doot = &d{
            $tee = Rs&ot != null ? Rs&ot : R.t;
            $Rtee = Rs&Rt != null ? Rs&Rt : R.t;
            d && tee == Rtee and return
            
            $v = me&tsc,'ot','ot','q';
            vc&s = tee;
            vy&cv = 0.01;
            vs&deco = 1;
            doot = &{};
        };
        Rs&ot || Rs&tiny and doot()
        $scan = Rs&scan = me&scan,s;
        scan.is == 'C' && s.y == s and scan.is = 'A'
        scan.is == 'C' && sy&R == s and scan.is = 'R'
        scan.is == 'C' && ss&W and scan.is = 'W'
        Rs&isness = scan.is
        Rs&ma and s&ma = Rs&ma
        
        $Ay = ps&Cit && Rs&isness == 'A' && pc&s == Rc&s
        Ay and return
        
        
        Rs&wastiny = Rs&tiny;
        Rs&boost > 0 and delete Rs&tiny
        if (Rs&kvey) {
            each kv s {
                $c = {ma:0.1};
                c.tiny = 1;
                Cit(k,v,c)
            }
            me&domesticate,R
            Rs&tiny = 1;
        }
        if (Rs&tiny) {
            Rs&dis and s&dis = 1
            return
        }
        elsif (Rs&wastiny) {
            Rs&dis = 1
        }
        if (scan.sym == '[' && Rs&boost < 2) {
            n open 4 s:[ %hs:489
            
            each in s {
                # BUG this titling situ of z [ z,z,z,z
                Rs&tightly ? 
                Cit(''+i, n, {tiny:1})
                :
                Cit('['+i, n, {tiny:1,ot:R.t});
            }
            n close 7 s:] %hs:489
            return
        }
        
        if (!scan.C && ps&Citop && !Rs&boost && !Rs&tightly) {
            me&domesticate,R;
            n $R.t  $s:s,R %Cee,dupup
            return
        }
        
        #c title 1
        me&domesticate,R
        !Rs&dis and delete s&dis;
        Rs&tightly && ps&Citop and doot(1);
        #n swhu  $self:scan,R %sun
        ps&ope and Rs&boost ||= 1;
        
        if (scan.C && (Rs&boost||0) < 1) {
            n yes  s:」
        }
        elsif (Rs&tightly && !scan.C && isob(s) && (Rs&boost||0) < 2) {
            # C or not
            each nk,gv s {
                !isob(gv) and $n = Cit(nk,gv)
                else {
                    $n = Cit(nk,gv);
                    !isC(gv) and ns&kvey = 1
                    else {
                        ns&ot = 1
                    }
                }
                ns&rowish = 1;
                ns&ma = 0.3;
            }
        }
        elsif (scan.C && (Rs&boost||0) < 2) {
            # several C's with some interesting stuff in
            # < look for anomalies
            #   generate maps to call things
            if (scan.is == 'R' || Rs&tightly) {
                !Rs&tightly &&
                    n asR  s:¢
                $hem = {kvey:1,ma:0.3,dis:1};
                Cit('y',s.y,hem);
                Cit('c',s.c,hem);
                Cit('sc',s.sc,hem);
            }
            else {
                sy&R and Cit('yR',sy&R,{Rit:1,dis:1});
            }
        }
        else {
            doot(1);
            # some strangeness or the thing we're interested in
            s&dis ||= 1;
            $le =
            n $R.t  $s:s,R %Cee,dupup
            # if Cit is only a Cee, put title inside:
            # < computed overall, paint out vagueness
            ps&Citop and les&wanttitle = 1
        }
    },'ift,D'],
    #c as well as Cit-ing, shade and understand A
    ['Rit','3',&acgtRs{
        !sc&N and throw "Rit !R"
        $I = sy&I;
        if (I && !Rs&isI) {
            n yI  $s:I,R %Rit,Cit,isI
        }
        if (Rs&isI) {
            # see the big picture
            $head = sc&head;
            if (head) {
                n chead  $s:head,R %Cit
            }
        }
    },'ift,D'],
    
] };

#c Cee the truth (with folded edge)
# reliable expression of data as it is
# < json-compatible copy/paste
me.Ceeingness = &acgtRs{ return [
    ['Cee','3',&acgtRs{
        $Cee = &tsc{
            c = ex(c||{},{t:t,s:s,Cee:1});
            return me&Ret,R,c
        };
        $scan = Rs&scan = me&scan,s,R;
        
        $h = Rc&N[0];
        $P = me.cby(R,&r{ return !rs&Cee });
        $p = R.y.up;
        $it = P.shift();
        # above %plays to open all non-C
        ps&play || ps&sprawling and Rs&sprawling = 1
        scan.C and delete Rs&sprawling;
        if (Rs&sprawling) {
            delete Rs&isgk;
            Rs&rowish = 1;
            #Rs&sprawling and delete Rs&sprawling; Rs&isgk = 1;
        }
        $depth = P.length;
        $p = R.y.up;
        
        Rs&wanttitle || !Rs&dupup and me&domesticate,R;

        # decision of presentation
        p && ps&isnk || Rs&isgk and Rs&isgk = 1
        p && ps&scan && ps&scan.sym == '[' && depth > 1 and Rs&isgk = 1;
        # boost overrides tendency to isgk weirdkeys
        Rs&isgk && Rs&boost and delete Rs&isgk; Rs&rowish = 1;
        R.t == 'y' and delete Rs&rowish;
        Rs&boost < 0 and delete Rs&rowish; Rs&isgk = 1;
        #Rs&boost < 0 and delete ps&rowish;
        scan.sym == "'" and Rs&isgk = 1;

        if (Rs&isgk) {
            me&gkness,R;
            return
        }
        
        #    $M = me&Mw,R,'traw';
        #m things  s:Crays %fs:20

        # bunch of keys claimed by Modus&ks=[]
        # < pluck them, bending the last representation outwards
        # < or popping it in the short term... Rs wakier
        #   wanting child boost read by the time we're here,
        #   to choose whether to Modu or RetR
        me&bagatagage,R;
        
        Rc&nofurther and return

        $ks = scan.ks || [];
        $wk = scan.weirdkeys || [];
        
        wk = me&wktion,R,wk;
        
        each ik wk {
            $n = Cee(k, s [k], {isgk:1});
            i == 0 and ns&ml = 1
        }

        each ik ks {
            Cee(k, s [k], {rowish:1});
        }
        
        Rs&boost > 0 && depth == 1 and Rs&runny = 2

        
        if (scan.C && (Rs&runny > 1
            ||
            (Rs&runny || depth == 1) && sy&tv && ss&z && !ss&J
            )) {
            each in ss&z {
                # can zoom around Cs if ^
                Cee(i, n, {rowish:1,runny:1});
            }
        }
    },'ift'],
] };
#c domesticated, gkness
# exit the entrance
#  put label/C.t (not always the same)
#  C's cell wall
me.domesticate = &acgtR{
    # 1-sized domes should be, if t folds
    $M = me&Mw,R,'traw';
    $tee = Rs&Rt != null ? Rs&Rt : R.t;
    $t =
    m t 1 $s:tee %fs:13,hs:288
    
    # types at s
    $scan = Rs&scan;
    if (scan) {
        $is = scan.is || scan.sym;
        m sym 12 $s:is %fs:15,ls:-0.1,zi:-1,hs:4955

        # thing gets perforated edge
        if (scan.C) {
            !Rs&isgk and s&dis = 1;
            s&bgi = 'i/greencush.jpg';
            s&bgh = '1115';
            s&bo ||= '0.4em dotted #235';
            s&br = '3';
            s&zi = -2;
            s&hue = 60;
        }
    }
    return t
};
me.bagatagage = &acgtR{
    $scan = Rs&scan;
    $ks = scan.ks || [];
    if (scan.C) {
        ks[0] != 't' and debugger;
        ks.shift();
        $s = Rc&s;

        $M = me&Mw,R,'.t';
        scan.is == 'A' &&
            m tofA 19 s:: %ls:-0.2

        m t 2 $s:s.t %deco,fs:15

        if (scan.is == 'A') {
            $cv = s.cv+'';
            cv[0] == '0' and cv = cv.slice(2);
            cv = '@'+cv;
            m cv 21 $s:cv %ls:-0.1,hs:339
        }
    }

    if (scan.modu) {
        each in scan.modu {
            n.t == 'weirdkeys' and continue
            $M = me&Mw,R,'modu:'+n.t;
            me&Modu,[n],M;
        }
    }
};
# squished lump of thing
me.gkness = &acgtR{
    $M = me&Mw,R,'traw';
    $s = Rc&s;
    
    # make block,inline have same indento
    $p = Ry&up;
    $iN = (ps&z||[]).indexOf(R) - 1;
    $f = iN >= 0 && ps&z[iN];
    f && fs&rowish and s&ml = 1
    
    s&fs = 7;
    m sym 12 not
    if (Rs&viewvia == 'size') {
        $str =
        n s 3
        strs&bo = '1px solid #bbb';
        s == null and return strc&s = 'null'
        s = ''+s;
        $M = strs&z = [];
        $string = '*'+s.split("\n").length;
        m lines 3 $s:string %hs:388
        $string = '..'+s.length;
        m length 3 $s:string %hs:388,fs:6
    }
    else {
        $pow = 2;
        Rs&boost and pow = 4
        $string = ki(Rc&s,pow);
        $limit = 100;
        Rs&boost > 1 and limit *= Rs&boost;
        if (string.length > limit) {
            string = string.substr(0,100)
              +'..'+(string.length - 100)
        }
        m ki 3 $s:string
    }
};
# regroup Cee's children (before they're Cee'd)
me.wktion = &acgtRs{
    $wk = s;
    s = Rc&s;
    $p = R.y.up;
    if (p && ps&scan && ps&scan.C) {
        if (R.t == 'c') {
            if (wk.indexOf('sip')>=0) {
                wk = wk.filter(n => n != 'ip' && n != 'sip');
                $fa = 4s&famous;
                $slip = s.sip;
                $M = me&Mw,R,'sip';
                # tradeoff between things
                if (fa) {
                    each in fa {
                        s.sip.indexOf(i) != 0 and continue
                        m famous  $s:n.t %deco,fs:7,hs:999
                        slip = '.'+s.sip.substr(i.length+1);
                    }
                }
                m sip  $s:slip %fs:7,hs:999
            }
        }
    }
    return wk
};
#c Display R ender
# bunch of Rs with Mw etc get html'd under R.y.up
#   for the R:Thingyoudo under the R:C visualising
me.Display = &acgtrc{
    c ||= {};
    me&Mlimits,r;

    each iR rc&N {
        # unify the M
        Rs&M ||= [];
        me&Mwix,R;
    }

    # and anotheR to Cavon those M Cs,
    # and get every nl/dl comoverable.
    $t = 'Display';
    #rs&task and t += ":"+rs&task
    $zuctations = [];
    $d = Ron(r,t,r,&Rs{
        if (s == r) {
            # first accepts eg Rs&igV to drop history
            c && ex(R.sc,c);
        }
    },&Rs{
        Rc&nl = 0;
        !s.sc and debugger;
        # unaligns Rc&N/refs (not put in N)
        sc&not || ss&noDisplay and return R.c.not = 1;
        $rollsc = &t{
            s.sc[t] and R.sc[t] = s.sc[t]
        };
        # may be modulat, ie Ds&C = display stuff of D
        rollsc('C');
        $C = Rs&C || s;
        $rollCsc = &t{
            s.sc[t] and C.sc[t] = s.sc[t]
        };
        # R or modulat have y&Display
        sy&Display = R
        if (!Rs&modulat) {
            # must be from the A (R) doing Display
            rollsc('nofurtherDisplay');
            rollsc('printDisplay');
            # s = R;origin
            Ry&origin = s
            # < sc slosh
            rollCsc('hue');
            if (ss&down && !ss&nofurtherDisplay) {
                # origin may already have Displays to include
                # < put at M cv 6
                Rs&down ||= [];
                Rs&down.push(...ss&down);
            }
            # slep could be in there ^ want to update it?
            if (ss&sleeping || c.sleeping) {
                !Rc&b and ~>4 Missing sleeping Display b: me.cby(R).map(t => t.t).join(' ')
                Rs&originsleeping = 1;
                Rs&nofurtherDisplay = 1;
                !Rc&b and return
                # keeps history, wakers inside replace
                me&recycleRbitXz,R
                
                each in ss&z {
                    # or not if we're Display%sleeping after errors (me.Rom)
                    c.sleeping and continue
                    sc&N.indexOf(n) < 0 and continue
                    $v = me&Ret,R,{t:n.t,s:n};
                }
                return;
            }
        }
        each iD ss&M {
            me&Ret,R,{t:D.t,s:D,modulat:1}
        }
        isC(ss&J) and Rs&J = ss&J; return
        if (Rs&modulat && ss&z && sc&sortcv) {
            ss&z.sort(&ab{
                a = ay&cv || 0; a*=1;
                b = by&cv || 0; b*=1;
                return a-b
            });
        }
        each iD ss&z {
            Rs&nofurtherDisplay and continue
            if (!Rs&modulat) {
                # D is an R
                Ds&noDisplay and continue
            }
            $trick = 0;
            if (Dy&R == D) {
                if (Rs&modulat) {
                    # modulat may have R in it
                    !Ds&zuctedto and throw "didnt zuctedto"
                    Ds&zuctedto != s and throw "not zuctedto"
                    trick = 1;
                }
                elsif (Ds&zuctedto) {
                    # R is in modulat somewhere
                    zuctations.push([R,D]);
                    continue
                }
            }
            $r = me&Ret,R,{t:D.t,s:D};
            
            Rs&modulat && !trick and rs&modulat = 1;
        }
        #$C = Rs&C;
    });
    
    #c etc
    each iz zuctations {
        $pr = z[0];
        $D = z[1];
        $ri = dc&refs.indexOf(D);
        ri < 0 and ~Zuctations not: pr.t, D.t
        ri < 0 and continue
        #throw "zuctations not", pr, D
        $M = dc&refR[ri];
        $one = M[0];
        # put X in extra bit, where it will be if %tunnelled to
        #prc&X.x[D.t] ||= onec&X;
        #ah(pr,'zucthist',D.t,one);
        if (M && M.length > 1) {
            # while R%zuctedto)%Cit
            continue;
            ~Zuckmany: pr.t, D.t, M.length
            each in M {
                $c = ns&C;
                cs&bo = i == 0 ? '5px dotted yellow'
                    : '5px dotted brown'
            }
            #throw "zuctations many", pr, D, M
        }
    }
    
    # apply with the apply above
    #  supposedly %sleeping y&up aren't needed?
    ac(r,'applyRbitX',d);
    
    # the %rowish -> wholewidth + indent style
    # < stretch/shrink into a bunch of grapes, like W:Das
    # > runs out of width!
    each in dc&N {
        $s = nc&s
        $C = ns&C || s
        
        if (ss&rowish && !ss&zuctedto && !ns&modulat) {
            s&dis = 1
            nc&d && s&pl == null and s&pl = 1
        }
        
        # put from others that may not be awake
        each th ss&eCsc {
            t.endsWith('_origin') and continue
            ex(C.sc,h)
        }
    }
    me&Cavon,d;
    # Display joins to another Displaying thing,
    #   as foretold by an rc&inC = R we can Rs&down to
    #   or 
    #   so R:Display (d) appends to its cause
    #     which would be an R:C, also Displaying
    #  leaving out Knowing (r), but routing elvis to it:
    d.y.interpreted = r;
    # < Display etc collector, map the whole Rillage
    d.y.up = rc&inC && (rc&inC != r && rc&inC
        || ry&up.c.inC) || r.y.up;
    r.y.Display = d;
    me&Cupon,d;
    
    $N = ds&NinetySixer;
    each t,cb N {
        cb('NinetySixer');
    }
    #c lv
    # < make storable C patches (lv/c.el)
    $t = ds&C;
    !t and throw "Display0 !sC"
    ts&lv || ds&printDisplay and me&Display_to_lv,t,d;
    
    return d
};
# the top of a display gets to encapsulate it
#  Doming growing a skin when ready to compare
me.Display_to_lv = &acgttd{
    # if ts&lv || ds&printDisplay
    #  they could be differentiated, or not.
    # eg above wants lv patches along with C,
    #   to give it dimension
    # or lv wants to compress destructively
    $taskof = &R{ return Rc&N[0].sc.task };

    # rebuild from Rs&C/Rs&down
    # < stop/conjoin at y&lv in there...
    $got = [];
    $pD = &R{
        got.indexOf(R) > -1 and throw "loops:"+R.t
        got.push(R);
        # %modulat have C In c&s
        $C = Rs&C || Rc&s;
        !C and debugger;
        !C and throw "non sC:"+R.t
        $c = G&Cye,C;
        # < cy&C=C?
        if (cs&z) {
            # opt in to destroying C that was there,
            # looks like it might be ours if double-sleping?
            c.t == 'patch' || Rs&modulat and delete cs&z
            else {
                # lv over a builtup looking Rs&C
                debugger;
            }
        }
        each in Rs&down {
            # check we're still in R:Dispaly?
            nc&N != Rc&N && taskof(n) != taskof(R) and debugger;
            ac(c,'z',pD(n));
        }
        return c
    };
    $c = pD(d);

    # put through R:Lines,
    #   using Copy happens to clone it again
    # < put the travel-by-s&down and pick-s&C into Copy
    $l = me&Copy,d,c,{ov:12,t:'lv'};
    delete ls&ov;
    ls&Lines = 3;
    lc&N.map(n => delete ns&ball);
    me&Ring,l;
    !ls&string and throw "No lv Linesing"
    c = lc&s;

    # s&lv implies thereforth may c&el
    #   no c&el implies c&el=1, all that is
    # s&lv = version
    # y&lv = lv%Copy or so of that version
    ls&vmaj and ls&vmaj++
    else { ls&vmaj = 1 }
    cs&lv = ls&vmaj;
    cy&lv = l;
    #    or %Lines every time around
    # C.y.lv = R:Copy%Lines
    #   to be conjointed as you %Lines the C
    # every %ball to a %push should %Lines completely
    #   but needn't %ball all the way down

    $p = dy&up;
    $h = pc&N[0];
    $C = pc&s;
    if (hs&task != 'C') {
        # < why it's not dy&up?
        $r = dy&origin;
        rs&lv > 1 and ry&lv = c
        else {
            throw "figure up Cplant"
        }
    }
    else {
        # put it on the R:C&s, where we usually Rs&down to
        ac(C,'z',c);
    }
};
#c Eightwo
# osc again with separate nests of R running schemes
# the Js&s is an R:I
#  R:C scans C
#  CdaR etc think, R and scan more
#    making R:Knowing, R:Display
#      who might produce grounds...
#  R:C displays, bits from  R:Display tacked in


# to draw your own conclusion
# the hierarchy of ground reactions takes hold

# !!!!!!   !!!!!!!!!! !!!!!!!!!!   !!!   !!!!!!!!!! !!!!!!!!!!    
# the osc is about functioning...
# building the environment fully soon would be nice?
# bundling elvisory, runs, output checks...
#   testing without pumping html through the screen

# the total applier of what is meaningful
# the machine up to this point is lost vectoria notation
# here we shall draw into an over-unity, as in
#   GROWTHS

# dispatch C has experience
# it could be complete, as a work of art,
# or it could be ingredients for several concealations
# and then a work of art

# s might be an elvis/A going wide
# all the osc together escape linear code
    # atoms in locations, another lives
    
    # knowing atomic-level motion here,
    # and unfolding qua in another:
    # OSC 3, drawing out of what is
    #   to run rhythms over the atoms,
    #   thinking of their subatomic meanings
    # resuming whenever the list of atoms adjusts

    # < go wide and reuse elements moving around
    #   persisting moving atoms,
    #     based pictures of subatomics
    #     a b in the d.V index leaving?
    #   TES
    

# simpler Ring, until display enough to Ring it up
# t from R, looking at s
$Ron = &Rtsonc{
    $r = me&Re,R,{t:t,s:s};
    rc&middle = &sR{
        # 1 scan/title
        1 && o and o(R,s);
        # 2 resume history Rc&b
        me&arriveRbitX,R,R.t;
        # 3 generate furthers
        1 && n and n(R,s);
    };
    me&ing,'',r;
    # 4 X notices leavings
    $underdone = &{
        me&goneRbitX,r;
        me&applyRbitX,r;
    };
    c and c.done = underdone
    else { underdone() }
    return r
};
#c me.os
me.os = &acgts{
    # A:n C
    if (A&s != C) {
        throw "become s figure";
        C.y.A and A = C.y.A; # continue A:n
        else
        !s and s = C; # hist on the C itself
        # ^ could be the way to store elvis' progress as his own,
        # bringing their own s&s = R?
        #   a piece of reason to install where the state it was
    }
    # 2 J is name-recurring since n3
    s ||= s&J || A;
    $I = me&Resurrect,'I',ss&s;
    Iy&J = A.1;
    # < feeding I's history back around for runtime instruction
    #   C and e's history for storable such
    
    # 3 C are
    $care = {};
    $r = Ron(I,'C',C,&Rs{
        1s&Te && Rc&d == 0 and Rs&Te = 1s&Te
        # tv index, indexo find previum (Rc&b)
        R.t = s.t+' '+(s.y ? s.y.cv : '');
    }, &Rs{
        # generate furthers - notices J as yA1 different
        # < make CaR,R,s
        me&CaR,R,s;
    },care);
    
    # 6 details
    #  may do anything
    #$o = A&o ||= 'CdaR';
    A&o and me&Rdeal,r,A&o;
    # < bring them along
    care.done();
    
    # 7 encode visuals
    me&Cavon,r;
    # 8 unify visuals
    me&Cupon,r;
    # ^ committing them to dom on the screen
    
    # < use storable C patches (lv/c.el) (see Display/y&lv)
    # commit the tip of all reason:
    # < pass X society's maintainence expectations:
    # < recycle I/* that didn't awake,
    #     even I/C/*, co. CdaR and slep
    ss&s = I;
    # main R ness
    A&chR and rc&chR = A&chR;
    
    1s&Te and me&Tie,r,'os'
};
# GOING
# do more R for an R
me.Rdeal = &acgtRo{
    $o = o || s&Rdeal;
    o = o.split('-');
    each id o {
        !me[d] and throw "No os me."+d
        $r = me&$d,R;
        r and R = r
    }
    return R
};
# display R done
me.Rdealings = &acgtRr{
    Rs&boust = 'Lines';
    me&sunknown,R,r
};
#c IndofC for total sense
me.IndofC = &acgts{
    each iR sc&N {
        $b = Rc&b;
        $C = Rc&s;
        # replaces the C, breaking Elvising because no %medo on this one:
        # switch the elemental placer until we write on but it .C = origin
        $D = G&Cye,[C.t,'',{},{ml:Rc&d,dis:1}];
        Dc&s = me&picture,C;
        $r = Ron(R,'IndofC',D );
        me&Cavon,r;
        me&Cupon,r;
        # such that r.y.up has now s&down with out rs&on
    }
    
};
me.picture = &acgts{
    $Y = s.y.A;
    $usu = Y && Y.t == 'n';
    if (usu && sc&J && ss&J) {
        s = hup(s);
        sc&J == s.t and delete sc&J;
        sc&W == s.t and delete sc&W;
        #ss&W == s.t and delete ss&W;
        delete ss&z;


    }
    $k = ki(s);
    usu and k = k.replace(/,A;n/,'');
    return k
};
#c usuals
# 2-ish data scan
# < inc/with %slep, same mode...
# < for C universals
# < standard deviatable
# < resolving and diving like diamonds
me.CdaR = &acgts{
    # run the set of R into another Ring
    
    # univ contrib lowlevel stillness check
    # then stilling an os lest some push
    each iR sc&N {
        $b = Rc&b;
        $C = Rc&s;
        # < me.scan for all innard
        $diff = &di,ff,dd{
            typeof di != 'object' and return di != ff
            $wh = {gone:{},diff:{},new:{},same:{}};
            each kv di {
                null == ff[k] and wh.new[k] = {};
                ff[k] != di[k] and wh.diff[k] = {};
                wh.same[k] = {};
            }
            each kv ff {
                null == di[k] and wh.gone[k] = {};
            }
            each qua,k,ha wh {
                qua == 'same' and continue
                dd && dd.ignore == k and continue
                return 1
            }}
        };
        # < should be against an image of the past
        $x = b && bc&s || {};
        diff(C.c,x.c||{}) and me&chR,R,'CdaR-Diff-c'
        diff(C.sc,x.sc||{},{ignore:'z'}) and me&chR,R,'CdaR-Diff-sc'
    }
};
#c sunknown GOING
me.sunknown = &acgtRs{
    $b = Rc&b;
    $boust = Rs&boust;
    # look at.. a scan of the thing
    $s = s || c&s;
    typeof s != 'object' and throw "unknown!ob"
    $r = Ron(R,'Knowing',s,&Rs{
        Rc&d == 0 and R.t = C.t;
        # index by R.t set by daR
        Rc&nl ||= 175;
        Rc&dl ||= 15;
    }, &Rs{
        $p = Ry&up;
        Rc&inC = R;
        $C = Rs&C = G&Cye,[R.t,'',{}];

        # this R can be clicked big/small
        me&boostulate,R;
        boust and R.t == boust and Rs&boost = 1

        
        $scan = Rs&scan = me&scan,s,R;

        me&domesticate,R;

        # decision of presentation
        p && ps&isnk || Rs&isgk and Rs&isgk = 1
        p && ps&scan && ps&scan.sym == '[' && pc&d > 1 and Rs&isgk = 1;
        # boost overrides tendency to isgk weirdkeys
        Rs&isgk && Rs&boost and delete Rs&isgk; Rs&rowish = 1;
        R.t == 'y' and delete Rs&rowish;
        Rs&boost < 0 and delete Rs&rowish; Rs&isgk = 1;
        scan.sym == "'" and Rs&isgk = 1;

        if (Rs&isgk) {
            $M = me&Mw,R,'traw';
            # make block,inline have same indento
            $iN = (ps&z||[]).indexOf(R) - 1;
            $f = iN >= 0 && ps&z[iN];
            f && fs&rowish and s&ml = 1
            s&fs = 7;
            m sym 12 not
            $pow = 2;
            Rs&boost and pow = 4;
            $string = ki(s,pow);
            string.length > 100 and string = string.substr(0,100)+'..'+(string.length - 100)
            m ki 3 $s:string
            return
        }

        # bunch of keys claimed by Modus&ks=[]
        # < pluck them, bending the last representation outwards
        # < or popping it in the short term... Rs wakier
        #   wanting child boost read by the time we're here,
        #   to choose whether to Modu or RetR
        me&bagatagage,R;
        
        Rc&nofurther and return

        $ks = scan.ks || [];
        $wk = scan.weirdkeys || [];
        
        wk = me&wktion,R,wk;
        
        each ik wk {
            $n = me&Ret,R,{t:k,s:s[k],isgk:1};
            i == 0 and ns&ml = 1
        }

        ks && ks.length && ks.map(&k{
            $v = s [k];
            me&Ret,R,{t:k,s:s[k],rowish:1}; #]
        });

        if ((Rs&runny || Rc&d == 0) && scan.C && sy&tv && ss&z && !ss&J) {
            each in ss&z {
                me&Ret,R,{t:i,s:n,rowish:1,runny:1}
            }
        }
    });
    me&Display,r;
    return r
};
#c Displayingness GOING
me.Displayingness = &acgt{ return [
    ['RbitX','17',&acgtRs{ me&RbitX,R; },'if:RcX'],
    ['RbitX','4',&acgtRs{ me&RbitXgonism,R; },'if:h'],
    ['Displayingness','1',&acgtRs{
        $C = Rs&C = G&Cye,[R.t,'',{}];
        if (Rc&d == 0) {
            $p = R.y.up;
            $s = p && pc&s;
            isC(s) and Rs&fornt = s.t;
        }
        # GOING
        Rc&inC = R;
        #Rc&d == 0 and R.t = C.t;
        # index by R.t set by daR
        Rc&nl ||= 888;
        Rc&dl ||= 35;
    }],
    ['Displayingness','3',&acgtRs{
        Rs&elvis = 'Gazel';
        !1s&Te and return;
        # ^ is somewherish. posits and deposits.
        me&playstulate,R;
        me&boostulate,R;
        Rs&Te && Rs&Te.c &&
        me&tangulate,R;
    },'D'],
    # data dump R%sun
    ['sun','3',&acgtRs{
        $c = {task:'Cray'};
        Rs&sun == 2 and c.refpool = 1
        Rs&dupup and c.dupup = 1
        me&Reis,R,R.t,s||Rs&self,c;
    },'ift'],
    
    ['Displayingness','9',&acgtRs{
        Rs&noDisplay and return
        $the = me&Timethe,'Display';
        $d = me&Display,R;
        the();
    },'if:h'],
] };
# GOING
# applies Cee directly
me.Cray = &acgtRs{ return [
    ... me&Displayingness ,
    ['Ceetop','12',&acgtRs{
        Rs&Cee ||= 1;
    },'if:h'],
    ... me&Ceeingness,
] };
#c Rbitology GOING
# X is the space index...
#  of X.x.$bit = X (inwards)
#     X.z = [ R nodes
#
# at Display 17
me.RbitX = &acgtR{
    # too many places guess R.t
    #$bit = Rs&RXbit != null ? Rs&RXbit : R.t;
    $bit = R.t;
    # $X = {x:{$bit:$X},z:[R+]}
    # X.x.$bit = another X, inwards a $bit
    # X.z=[R that are here
    Rc&X ||= {};
    Rc&X.x ||= {};
    $X = Rc&X = Rc&X.x[bit] ||= {};
    X.z ||= [];
    if (X.z.length) {
        # dups allowed, assumes same ordering
        if (X.z[0] == s) {
            ~duup: ki(s,3), ki(X.z[0],3)
        }
    }
    X.z.push(R);
    
    # history at te top
    Rc&V ||= {};
    Rc&V.x ||= {};
    # someone gave you V that used to be X
    $V = Rc&V.x[bit] || {};
    $b = V && V.z && V.z.shift();
    # only goners remain
    b && !V.z.length and delete Rc&V.x[bit]
    # children inherit the bit past
    # care to leave history
    Rc&V = V = V ? me&RbitXtend,V : {};
    if (b) {
        Rc&b = b;
        by&future = R;
        # no further back
        bc&b and bc&b;
    }
};
# at Display 4
me.RbitXgonism = &acgtR{
    # atoms in locations, another lives
    $N = Rc&N;
    each iR N {
        $b = Rc&b;
        $s = Rc&s;

        $V = Rc&V;
        if (V) {
            V.z && !V.z.length and delete V.z
            each ip V.x {
                Rs&gone ||= [];
                Rs&gone.push(p);
            }
        }
        Rs&gone and me&chR,R,'Goners:'+ki(Rs&gone)
        !b and me&chR,R,'new!'
    }
};

#c Ja.gc GOING
me.Ja.gc = &acgt{
    me&Gomp;
    $d = 1s&deal = {};
    if (!d.total) {
        d.total = 0;
        d.have = [];
        d.disco = [];
        d.discotal = 0;
        d.err = [];
        $check = &kp{
            p ||= [];
            p.push(k);
            $v = localStorage[k];
            !v and return d.err.push("No "+k)
            d.have.indexOf(k) >= 0 and return
            d.have.push(k);
            $l = v.split("\n");
            each in l {
                $Wm = n.match(/(H):(\w+)\b/);
                if (Wm) {
                    check(Wm[2],p.slice());
                    continue
                }
                # the s&W usually 1, encodes to just 'W'
                $Wm = n.match(/^\s+(\w+)\t.*\t\bW(?::(.+))?\b[^\t]*$/);
                if (Wm) {
                    $t = Wm[1];
                    Wm[2] and continue
                    # ^ of W:lobbek's %oph'ing, We thing s%W:oph/
                    # d.err.push(p.join('/')+" has W:...: "+n)
                    check(t,p.slice());
                }
            }
        };
        check('Pass');
        
        each kv localStorage {
            d.total += v.length;
            d.have.indexOf(k) >= 0 and continue
            d.disco.push(k);
            #delete localStorage[k];
            d.discotal += v.length;
        }
    }
    each in d.err {
        n err  $s:n %dis
    }
    
    each kv d {
        typeof v == 'object' and continue
        n t  $s:k %hs:999
        typeof v == 'number' && v > 1000 and v = G&sca,v*0.000001 +'mb'
        n s  $s:v
        n sp  s:\n
    }
};
