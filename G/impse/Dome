  // brack time
   =alphabet layercake
     join our decisions of how
      into an over-realm, a computed individuals unity
      so decisions that cant be made by anyone
      can be made by that mind
     wording so it applies force around a structure
      the decision being to break or not
     NervOS fibre bundles arm sleepy processes
      limbs becoming available
    
    < %supr-ish list/pile process via me&ind, slepping
       a natural migration pathway, among slopes...
       < know users of the things changing,
    < writing Ghost/**%dige where not Know/**%dige
    
    o1:
      < ha that can think, stream news downstream (z gets read)
      < sa that can log, selection replayable, dome input slep
        to check the conditions for a decision are still so,
         without having to conduce the decision again
      < Babz for each in me&thing { # call me&thing once
      < Babz R&za -> me&za,R (single character == self)
    
    
    
    =elvis
  // o1 sahazaja io
        # i - enterer
        # < to react in a Ring,r hang way,
        #   returning/jumping somewhere to think/reapproach
        me.ha = &acgtj{
            return me&bracki,j,js&wou,...[...arguments].slice(5)
        };
        # o - reading,
        # from what is beginning,
        #  what was mid-way,
        #  what got to the end
        #   < without &bready? or just !sleep?
        # ja always now
        me.ja = &acgtj{
            return me&bracko,j,js&wou,...[...arguments].slice(5)
        }
        # sa last time
        me.sa = &acgtj{
            $z = js&wou;
            return me&bracko,j,zy&get_saz(j),...[...arguments].slice(5)
        }
        # za always >7
        me.za = &acgtj{
            $z = js&wou;
            return me&bracko,j,zy&get_zaz(j),...[...arguments].slice(5)
        }
        # and always array
        me.saa = &{ return me.sa(...arguments) || [] }
        me.zaa = &{ return me.za(...arguments) || [] }
        me.jaa = &{ return me.ja(...arguments) || [] }

        # io %wou, a feedback loop
        #   experience -> notion, notion -> etc
        me.sahazaja = &acgtj{
            jy&R and j = jy&R
            # < de-hard-code $k
            $k = 'wou';
            
            # %wou = $z/$row+, via me&ha,j,data etc
            $z = j.sc[k] ||= Cye([k,1,{}]);
            zy&R ||= j;
            
            # %brackwouology = brack opeology
            #  &brackology fills it out at the end
            me&brackope,j,k
            
            # sa last time
            $saz = me&ollbs,j,k
            zy&get_saz = &j{ return saz };
            
            # za always >7
            $zak = k+'_accepted';
            me&rollbs,j,zak;
            me&reaw,j,zak;
            zy&get_zaz = &j{ return j.sc[zak] };
        }
        
        # commit %wou to be za next time
        # usu via Domes_7
        me.node_accept = &acgtRrs{
            rs&wou_accepted = rs&wou
        }
  
  // o3 open
        # Ying|step|node all
        me.Ying_o2 =
        me.Steps_o3 =
        me.Nodes_o3 = &acgtRs{
            me&sahazaja,R;
            me&Domes_o3,R;
        }
        
        # as r/** wake up & want nodesing
        me.inode = &acgtj{
            if (jy&R) {
                # < might be eg Ace to arrive into
                $meant = j;
                j = jy&R;
            }
            $z = jc&s;
            $N = me.cbyb(j,
                &r{ return rs&ball && rc&s.y.N },
                &r{ return rs&Peace == 4 });
            # Ying is not running... eg %R:+Hoosh
            # < A.nodar || throw "nonoder"
            !N and return
            zy&path = N.map(r=>rc&s);
            $S = zy&path[0];
            $N = Sy&N;
            !N.includes(z) and N.push(z)
            zy&R = j;
            
            # pseudo Nodes init o3
            !js&wou and me&Nodes_o3,j
            
            # Step's R that last o3'd, not sleeping
            !Sy&p and throw "Step !y&p"
            !Sy&R and throw "Step !y&R"
            #T.act and me&ha,j,{noded:T.act}
            return Sy&R
        };
        # node s resolve to a %Ying/(pa/th)
        #  for inter-noding, eg %%settle or %%eto
        # < riding X, hoisting all the way up...
        #  < a/b/-c/d should revoke d's stuff on b, a
        me.tpath = &acgtR,to{
            $jo = toy&R;
            $N = me.cby(jo,&r{
                return rc&s == Rc&s
            });
            N[0].c.s != Rc&s and throw "!^^%Ying"
            N.shift();
            N = N.filter(r => rs&ball);
            !N.length and throw "!tpath"
            return N.map(r => r.t).join('/')
        };
        
  // 37 < Domes
   # < %%dome
   # < nodeein
   # < nodee test
   =solves
    having to state everything, or:
    leaving cos &bready drops state between
      usually youd export the ready state somewhere,
       eg the bunch of C to compile
      such that it can pull changes,
       eg CBing with a Know**%fully turnaround
    by:
      not accepting CBing while busy doing other stuff
      simply not getting around to that &nodeein,
       and not avoiding what it was doing,
        because any confusing/unhandled e
        should usu make a node hang/dev
   =cut
    // Domes_o3|7 - both ends of the deal
        # domes, transbrack init
        me.Domes_o3 = &acgtr{
            $s = rc&s;
            me&etos_o3,r,s;
            me&dome_o3,r,s;
        }
        # domes, transbrack accept
        # everyone &bready or -> conclusion
        # < deeper first?
        me.Domes_7 = &acgtRpr{
            $s = rc&s;
            me&settle_6,R,p,r,s;
            me&settle_7,R,p,r,s;
            me&node_accept,R,r,s;
            # when not &bready, ask R%Ying to come back:
            me&bready,r and me&ha,R,{waits:'wants',wants:r}
            # %%eto|from
            me&etos_6,R,p,r,s;
            me&etos_7,R,p,r,s;
            # %%dome replace if any new
            me&dome_7,R,p,r,s;
            # display
            return me&stepbrack,r;
        }
        
    // < %%dome - residing state
       =pod
        %%dome:$t,... - a row that resurrects
         # not: another $z to seem in this one via bracko
         @o3 sa'dome' -> ha, each nc&recycled=1
         @6:
           you ja your permanent-er state out of it
           eg %Ying has orders of $p waiting
           or commit log
           or %Paving sanity checking as we .5<->.1
         @7:
           any ha %dome:$t,... replace them
            or something configured
           one ha %dome:$t - to drop it
           no ha %dome:$t* - to keep them all
            maybe for a ttl
       =cut
        # < += %%dome from last time
        me.dome_o3 = &acgtrs{
        }
        # < %%dome replace if any new
        me.dome_7 = &acgtRprs{
            $N = me&ja,r,'dome';
            $synthz = {};
            $keeps = [];
            each in N {
                
            }
        }
        
    // %%eto - externalising state
        # $to += %%efrom...
        me.etos_o3 = &acgtrs{
            $ef = sy&efroms;
            !ef and return
            me&ioty,ef .map(&fo,{
                $h = fos&etos;
                # h may re-node_hoist before we 7, if from /**
                fos&using = hs&current;
                hc&el == 9 and foc&el = 9; return
                !hs&vers.includes(hs&current) and throw "vers!"
                !hs&from and throw "!from"
                hs&to != s and throw "to!"
                me&ioty,h .map(&n{
                    # each row is mixed in, +%%efrom
                    n = me&ha,r,n,{efrom:hs&from}
                    # < looking at s & n should notice this link:
                    ny&efrom = fo;
                });
            })
        };
        # $from %%eto
        #   -> $from sy&etos
        #   -> Ying%%etos
        # < brackstill config/slep
        me.etos_6 = &acgtRprs{
            # all %%eto from this node
            $eto = me&jaa,r,'eto' .filter (n => !ns&efrom);
            !eto.length && !sy&etos and return
            $fromt = me&tpath,R,r;
            # C:from/C:to/row
            # grouped by where they're going
            # with c&el=9
            $ing = sy&etos ||= Cye([fromt,1]);
            $gone = (ings&z||[]).slice();
            each in eto {
                $to = ns&eto;
                # %%eto=1 means to the step
                to == 1 and to = p
                # select s given p/r/s
                $jo = toy&R;
                to = joc&s;
                
                $tot = me&tpath,R,to;
                $h = fio(ing,tot);
                $gi = gone.indexOf(h);
                if (gi >= 0) {
                    gone.splice(gi,1);
                    # new bunch of rows
                    hs&z = [];
                }
                
                hs&to = to;
                hs&from  = s;
                ac(h,'z',n);
                
            }
            # revoke
            gone .map(&h{
                !fio(ing,h.t,0) and throw "notnt"
                if (hc&el != 9) {
                    hs&current = h;
                    hc&el = 9
                }
            });
            # brackstill version off the previous
            me&ioty,ing .map(&h{
                hs&vers ||= [];
                #!
                if (hc&el != 9) {
                    $la = hs&vers.slice(-1)[0];
                    $cha = me&brackstill,r,h,la;
                    if (cha) {
                        delete hs&accepted_boring;
                        # clone into vers[], h/* replaces
                        hs&vers.push(Cye(h));
                        #~>3 newvers: h.t
                    }
                    hs&current = hs&vers.slice(-1)[0];
                }
                !(hs&from || !hs&to) and throw "!to|from"
                if (hs&accepted == hs&current) {
                    # remove here once they accept 9ing it
                    if (hc&el == 9) {
                        ~>2 GC: h.t
                        fio(ing,h.t,9)
                    }
                    $neu = !hs&accepted_boring;
                    hs&accepted_boring = 1;
                    neu and ~>3 hoistcept: h.t, '<-', fromt
                }
                else {
                    # asking %Ying to transport
                    me&ha,R,{etos:h,s,fromt}
                    !cha and ~>3 oldnews: h.t, '<-', fromt
                }
            })
        }
        # $to %%efrom marked as accepted
        #  relaxes $from sending it
        me.etos_7 = &acgtRprs{
            $ef = sy&efroms;
            !ef and return
            $gone = [];
            me&ioty,ef .map(&fo,{
                $h = fos&etos;
                hs&accepted = fos&using;
                hc&el == 9 and gone.push(fo); return
                # something in the way it is now?
            })
            gone.map(fo => fio(ef,fo,9))
        }
        # Ying %%etos
        #   -> $to sy&efroms
        #   -> Ying%%waits:eto,wants:$to
        me.etos_8 = &acgtR{
            $froms = me&jaa,R,'etos';
            froms.map(&n{
                # ho = to with s&current from &node_hoist
                !ns&fromt and throw "!fromt"
                $h = ns&etos;
                $to = hs&to;
                $jo = toy&R;
                to = joc&s;
                # efroms - for|on the to node path
                $ef = toy&efroms ||= Cye([h.t,1]);
                ef.t != h.t and throw "misnodepath"
                #  /$fromt - the from node path
                $fo = fio(ef,ns&fromt);
                fos&etos = h;
                # jo tidies efroms, once el=9 accepted
                # send attention
                me&ha,R,{waits:'eto',wants:to}
                
                ~>5 efroms hoisting: ef.t, '<-', fo.t
            });
        }
   
  // 6 < frontends
   // &node_issleeping - if %sleepung-ish
    # potential to really stop mid-r:
    # < avoiding any more Ring r**,
    #    < wants Rc&ip.contains()
    #   as soon as ha ...waits
    #    winding them past mind they can't reach,
    #     recycling domes of stuff
    # < alterior sleeping - when %%waits stops Ring
    #   does it accept r as b? suppose, to display
    #    r/** want winding past their whole lives if strange
    #     winds to 9...Display while %sleeping?

    # should we not Doming_7 due to %sleep*
    # >0 if r is not able to commit (za)
    # >1 if r is not able to display
    me.node_issleeping = &acgtRr{
        if (rs&sleepung) {
            # displayable after sleepywind
            ~>3 node pung: r.t
            return 1
        }
        elsif (rs&sleeping) {
            # reawakened + tunneled through (Know)
            #~>3 node sleeping: r.t
        } 
        elsif (!Rc&N.includes(r)) {
            # not awakened
            #~>3 node avoid: r.t
        }
        else {
            return 0
        }
        return 2
    }
       
   // < &nodei|o|e - makes %%eto..., going somewhere
      // nodeio-doc 
       =elvis
       focused on:
       &nodeo - reading %%ein C with Q, immediate return
         maybe there are handlers
         an inter-node o backend
       &nodei - transports via %%eto, wanders off
       < conversely:
       &nodeo might turn into:
        i %%e:hunter who will bring back the goods
       &nodei might merely:
        find %ein serving async, immediate return
       
       &nodee,to,t,a,q
        is &nodei $to %%e:t,...q
        expecting %%efrom:to,e:t,...a
         supposing $to:
          &nodeein,t,&from,q{produce %%a-ish}
           which &nodei back to $from
           including %%e
       basically,
        $from %%stuff -> $to, esp if diff
        comes back to $from once &settle,
         or sooner if $to %%answer -> $from
       usu. &nodei,
        moving intention around
        ie,
        gets delivered, revoked
         attend when different, by way of:
       
       brackstilling
        has %%stuff changed?
        if still:
         &nodee can same answer same question
          immediate return potential
        if diff:
         the $to must attend,
          returning to $from once &settle
           or sooner if $to &nodei back to $from
          all %Ying managed
        helps:
         receivers of %%efrom,...
          eg CBing (value contest/news)
          accept versions of it when ready
          see 'check CBing &nodei is as it was'
          could -%%e%done or +%%rebase if diff
           if &nodeein +%done it when done
           or %%rebase = prescribed differencing,
            is applied, via a big-deal filter, eg:
              a %Compiling in its push-phase,
               can decide to redo, because CBing, already
               depending on the algorithm (||= C percolation)
                to be able to tune inputs near the end of their workload
                including just after it,
                 if the answer is invalidated
                is nice reflexive terrain
       
       eg.
        $from = a %Compiling sequencing operations:
         makes Know%fully and selects %%Live
          $Live = &nodee $to %%Live %%e:fully
           and e:fully is ein there, subplot:
            an anyone-elected %acty=3
            must produce %%Live,
         
         $from %%waits for a response?
          or %%fail if e%edone and !%%Live
         
         $to avoid doming their 'main thing'
           eg CBing
          until all %%e%done
           would new CBing before $from receives %%Live,
           so $from receives also the new CBing,
            bound to the %%Live used for thinging
       
       =elvis
      
      // < &node[eio]
        # %%e:action, expects reply re the same %%e
        # see &nodei re c+o
        me.nodee = &acgt,j,to,t,a,c,o{
            $jo = toy&R;
            to = ojc&s;
            c.e = t;
            # the %eto:to,e:C:question,...details
            $n = me&nodei,j,to,c,o;
            $e = ns&e;
            !isC(e) and throw "nodei!%%eto,e"
            # the %efrom:to,e:C:question,...answers
            $replying = me&ja,j,{e};
            $an = me&ja,j,ex({e},a);
            
            if (es&done) {
                !an and me&ha,j,{fail:'done',e}
                else {
                    if (hak(a) == 1) {
                        # eg returning %%Live sent back
                        an.length > 1 and throw "many rows"
                        return an[0].sc[haks(a)[0]]
                    }
                    # rows returning from this %%e
                    return an
                }
            }
            else {
                # waits?
                # %%eto hoisting should gently hurry up etc
            }
        }
        # %%e:handler, sync response
        #  %Ying will otherwise attend $to
        me.nodeein = &acgt,j,t,cb{
            # for e:t into j
            # cb = &from,q{produce %%a-ish}
        }
        # moving intention around
        #  row = c(identifying marks) + o(other stuff)
        #  so c finds the rolling %%eto,
        #   and reuse $e when o changes
        # < require %%dome? as T.Mw?
        me.nodei = &acgtj,to,c,o{
            # < bracko C.t == t
            $jo = toy&R;
            to = joc&s;
            $q = ex({eto:to},c);
            
            $sending = me&ja,j,q;
            ex(q,o);
            if (sending) {
                sending.length > 1 and throw "cant tell %%eto apart"
                $n = sending[0];
                c.e && !ns&e and throw "bug"
                ns&e && !c.e and throw "bug"
                # still this apparently
                #  may !e%done when %Ying brackstills it
                ns&e and q.e = ns&e
            }
            # < %Ying relays progress via %%eto?
            #    maybe if we %%uniq this it would return the recycled one
            #   or just via e, how else?
            $n = me&ha,j,q;
            
            return n
        };
        # S o $remote/$Q using|returning %%tw,...
        # < persistent query, knowing io it pipes into,
        me.nodeo = &acgtj,to,Q,qe{
            $qs = ex({tw:Q.t},Q.c);
            $jo = toy&R;
            $N = me&za,jo,qs;
            if (!N) {
                me&may,j,'input','s',{tw:Q.t,waits:'not-found'},qe
                .map(&n{
                    ~>3 CREATE: ki(n.sc.s,4.23)
                    #  < may already have {s,may:input} if el=2
                    #   < use %Pavings%ein to input
                });
                me&tsc,'non';
                return
            }
            if (N.legnth > 1) {
                # in the web you would want many answers,
                #  perhaps candidates get see s** to rank/sync
                me&tsc,'unc';
                me&waits,'unclear'
            }
            return N
        };
      
      // nodeio-scussion # further into %Compiling 
       =elvis
       # Know etc means a Know/** node
       # and that &nodei somewhere revisits somewhere
       Know builds tw, &settle
       Know have clients for CBing
        Ghost &nodeo Know their thing,
        Ghost &nodei Know their downstreamness,
         Ghost%dige if not as Know%dige implies
       Know !Ghost, 
        %%may create some Travel/$t c&W=Looking of it,
         to start doing something
       Know CBing per downstream,
        &nodei Ghost %%cha,
         which Ghost &nodei Travel %%cha
       
       Travel/$W,
         receives CBing &nodei %%cha,
          - decides to update itself,
          - gets the inputs ready,
          - runs the thing,
          - tractions a bunch of $n/$u etc
            artifacts to save
             by way of a %Search that accepts writes itself,
              then presenting a tree of things to:
             n all G&t it put, push to That/**
              a downstream Know, non-CBing
              < via another %twin
             u all G&t it used, to Know/**
            push must:
             check CBing &nodei is as it was,
               so a %%rebase might emerge to Travel/$W
                in/near &nodei brackstill
               which our work (bunch of %%e:push) hangs off
              ie know Qs&parent on push,
              different:
               $n - %%rebase strangeness,
                 our downstream changed without us
               $n+$u - Travel/$W again, must know current
                 eg $W loading/saving itself
               $u - new input since Travel/$W
                 eg %dige can CBing again after we push
            if push:
              push all $n, That/**%%e:push,n (->%Paving->G&t)
              note all $u, Know/**%%e:pulled,u (%dige = that used)
               disimplying Ghost/*/**%dige must be expressed
                  semi-syncd Ghost mappings should be resolved after Travel/$W
                   until everything is aligned with Know/**,
                   might end up chasing loops,
                    diff the Travel of several $W in time
               
            $n/$u sets for %twin/$W/* may be canonical or not
             when its not invoking all the G&t the $W gets up to
               
            ideally all those G&t + W:KnowThee%Ying itself
             are in an Over%Search
              branching things for KnowThee
              to be merged with the Uber%Search above that,
               saving each thing,
                can sorta undo if interrupted,
                 from memory or Uber git reset
               < getting the new tree of changed things ready,
                 then commit just changing a link
             
            then!
            back to:
            CBing &nodei as before, since the %dige is out
            which might be real fast since the gear
             is all ready to pass another %Live through
      
       =elvis
      
      // nodeio-Yingu-scussion # sort activity
       =elvis
       underneath &nodei:
        $from &nodei $to %%stuff
         put into $from%%eto:to,stuff
        %Ying hoists %%eto,stuff
         brackstilling %%stuff
          attending $to
       # < Yingterms:
         then (once $to &settle or sooner or later)
          attending $from
         sooner if:
          &nodee makes an %%e:e to round trip:
           $from exacting %%eto:to,e <-> %%efrom:to,e
          $to &nodei $from, related or not, attends $from
         later if:
          %%e can know if !e%edone etc
           see 'not accepting CBing while busy'
        
        if %%eto,dome=questions,
         persists them, as usual
          you periodically refreshing %%dome
         if %%dome, could anyway, see %%dome ttl
         
         hoisting progress could appear on it,
          eg $to accepted, then &settle
          the hoisting-out could be a Y,
           involved for $from dome init,
            and $to delivery, or anything
       
       ecoursing:
        where the e takes us/our stuff
        eg c&el makes adjustments on some $to ground,
         probably the same %%dome as the $from
         or to a corresponding idea:
        $to %%efrom,dome=questioned
         to wakey the $dome part of $to,
          like routes
        re %Slope:
         they plumb somewhere else,
          that $from can detect the state of
           follow our affect through the machine
           eg wanting to watch Babz %Compiling
            to bring meta back to the ghost
            ie cursoring details transient in the process itself,
             rather than even biggering the result
         $e might:
          encode and wander the network meanwhile
           coming back to pick up that $e again,
            contracting some %Search to keep a way in:
             matching a rebooted %%eto
              by brackstill == that $e that left
       
       =elvis
  
   // &bready - if no %%waits
    =elvis
     &waits,... modulates something%waits
      R%waits has it

     &bready and return # implements a waitsology
      R%waits -> %%waits
      %%wants:$n%%waits -> %%waits:wants,...
      %%waits -> pause|shy $R
       and inners, unless $n%%waits,
         or %%waits:wants them,
         fuzzy line? who is waiting for who
         top down if same cv?
       might be a recognisable solution
       might be retry loop,
       do others first (moreso if %%waits:wants)
    =elvis

    me.bready = &acgtR{
        # got to via %%wants:R below
        !Rs&wou and throw "notbegun"
        # R%waits -> %%waits
        each in Rs&waits {
            me&ja,R,{waits:n} and continue
            me&ha,R,{waits:n}
        }
        # %%wants:$n%%waits -> %%waits:wants,...
        me&jaa,R,'wants' .map(&n{
            # < %%waits bracktrick out the rest of the values,
            #   unless viewed from the right angle, through waits?
            ns&waits and return
            $z = ns&wants;
            !isC(z) and return
            # could be p/r/s
            $j = zy&R;
            if (!js&wou) {
                # not a node
                js&waits and me&ha,R,{waits:'wants',wants:z,notanode:1}
            }
            else {
                # < unpossiblate infinite recursion
                #   with me&ind bit on the T?
                me&bready,j and me&ha,R,{waits:'wants',wants:z}
            }
        })

        !me&ja,R,'waits' and return
        # < %%waits -> pause|shy $R
        # avoiding the rest of the activity
        return 1
    };
        
   // < &settle
    =elvis
     &settle is a node that is:
      often relative to a node that %%wants it,
       if so it should be %sleeping,
        not able to unsettle
      not pending elvising:
        as in %%wants:n,acty:1,settled,
         unless %%acty has transmit
      &halfsettled:
       @7:
        < &bready
        < brack seemingly stable: ja == za
      and:
       nodes below are at least &halfsettled
        eg: Settled/Unsettled/Chaos
         where Chaos is not brackstable etc but Unsettled is
       < should be able to climb bunch of index then a node,
         'nodes below' meaning the next layer of nodes inside
    
     Ying_8:
       has its own whats
        stays aware of either end
         eg that $to should &settle,
          then $from can have $to &settle
        $from 
         &settle_6 - wants $to to &settle
        $to
         &settle_7 - checks for &settle
          pushing &halfsettled to children
          versioning %wou for:
        $from
         &settle_7 - accept $to &settled
         
        
    =elvis
    me.settle = &acgtRr{
        $from = Ry&R.c.s;
        $to = ry&R.c.s;
        # log it, so Ying_8 can transport-think
        !me&ja,R,{settle:to} and me&ha,R,{settle:to}
        return 'not settled'
    }
    # %settle emits|completes
    #  emittor sy&settleto
    me.settle_6 = &acgtRprs{
        # all %%eto from this node
        $rows = me&jaa,r,'settle';
        !rows.length && !sy&settletos and return
        # $from:r emits these
        $c = {rows,k:'settle'};
        $ing = me&either_6,R,r,c;
        # nothing in the row matters,
        #  only the from-to direction,
        #   orders Ying wake towards settle
        #  and some kind of $to version to $from accept
        me&ioty,ing .map(&h{
            # asking %Ying to transport
            me&ha,R,{settles:h,s,fromt:ing.t}
            ~>3 settle_6 rowsout: ing.t, h.t
        })
    }
    me.settle_7 = &acgtRprs{
        if (sy&settlefroms) {
            # $to:r checks itself, makes version
        }
        if (sy&settletos) {
            # $from:r accepts version of $to
        }
    }
    # reemerge by...
    me.settle_8 = &acgtR{
        # deals $from nodes awake now,
        #  are probably the next $to,
        #  subject to all other directions
        $froms = me&jaa,R,'settles';
        $s = Rc&s;
        $set = sy&settles ||= Cye(['settles',1]);
        
        froms.map(&n{
            # ho = to with s&current from &node_hoist
            !ns&fromt and throw "!fromt"
            $h = ns&settles;
            $to = hs&to;
            $jo = toy&R;
            to = joc&s;
            # efroms - for|on the to node path
            $ef = toy&settlefroms ||= Cye([h.t,1]);
            ef.t != h.t and throw "misnodepath"
            #  /$fromt - the from node path
            $fo = fio(ef,ns&fromt);
            fos&settletos = h;
            
            # jo tidies efroms, once el=9 accepted
            # send attention
            me&ha,R,{waits:'settle',wants:to}

            ~>5 settlefroms hoisted: ef.t, '<-', fo.t
        });
        
    }
    
    
    # < convert etos_6 to:
    me.not_etos_6 = &acgtRr{
        # ...
        $c = {rows,k:'eto',mk:'etos'};
        c.onel9 = &h{
            hs&current = h;
        };
        $ing = me&either_6,R,r,c;
        # ...
    }
    # the (settle|etos)_(6|7|8) exchange
    # rows leaving r, grouped by where to
    #  eg sy&settletos/C:to/$row
    me.either_6 = &acgtRrc{
        !isst(c.k) and throw "give c.k"
        !isar(c.rows) and throw "give c.rows"
        $mk = c.mk || c.k+'tos';
        $s = rc&s;
        $fromt = me&tpath,R,r;
        # k,mk = settle,settletos | eto,etos
        $ing = s.y[mk] ||= Cye([fromt,1]);
        $gone = (ings&z||[]).slice();
        each in c.rows {
            $to = n.sc[c.k];
            !to and throw ""
            # %%eto=1 means to the step
            to == 1 and to = p
            # select s given p/r/s
            $jo = toy&R;
            to = joc&s;

            $tot = me&tpath,R,to;
            $h = fio(ing,tot);
            $gi = gone.indexOf(h);
            if (gi >= 0) {
                gone.splice(gi,1);
                # new bunch of rows
                hs&z = [];
            }

            hs&to = to;
            hs&from  = s;
            ac(h,'z',n);
        }
        # revoke
        gone .map(&h{
            !fio(ing,h.t,0) and throw "notnt"
            if (hc&el != 9) {
                hc&el = 9;
                c.onel9 and c.onel9(h);
            }
        });
        return ing
    }
  
  // 7
      // ending &Steps_7, &Ying_8
        # $p done: $p & $j+ Domes_7
        #  depending on !node_issleeping
        me.Steps_7 = &acgtRprs{
            $stepsleeping = me&node_issleeping,R,r;
            
            each iz sy&N {
                $j = zy&R;
                !me&node_issleeping,R,j &&
                    me&Domes_7,R,p,j
            }
            stepsleeping and return

            $g = me&Domes_7,R,p,r,s;
            me&walls,g,'b:3.3h9';
        }
        # Ying done, orgs comeback
        #  R%Ying Domes_o3 but not _7
        #   except to have za commit
        me.Ying_8 = &acgtRs{
            me&node_accept,R,R,s;
            
            me&etos_8,R;
            me&settle_8,R;
            me&waits_8,R;
            
            # < push stepbrack to the Outlog
            if (!me&node_issleeping,R,R ) {
                $g = me&stepbrack,R;
                me&walls,g,'b:3.3h9';
            }
        };
        
      // < conclusion
       =pod todo
        < # Yingterms
        < %%dome and other %%tricks
        < &settle, meaning a wants b to be settled,
          quickly decided, else
            comeback
            as&sleepy til met?
        < catching that %Pave elvis async already @315
           coming back to complete bunches at a time
        < io making sense of eg %%tw, %ein,
          but probably not &settle, too micro to wait
           blocking reads only for Pinnings: S o Thing
        < upper levels of %acty or R/r tugging lower
          %Paving would become acty=2,
           meaning something acty=1 (%%openey) succeeded
          and produce a %%Live (Qc&s)
        < %Paving basically top-down &settle,
           and some kind of r%acty=R%acty-1 tugging spread
          runs out of %acty=1->%openey far enough in
          so $p/* should &settle,
            but $p/*/*/* neednt be %openey (or settled?)
          > becoming %Paving_good|in all the way down|up
          might be up to r:Know to %%wants:r/*,acty:1,settled,
       
       // mostly
         most behaviour decisions wait for &settle
          waiting for confidence
          eg selecting nodes eg S o ... or &nodeo
            they/we should %bready

         most behaviour reflexes wait for &bready
          just needing a bit of resolution
          eg begin reaction as txn on brack
            as in %%may,... -> ...,%may, sorta
        
         and they form loops!
         
       // Yingterms - see nodeio-Yingu-scussion
        messaging / nodes / time
        find loops, pause/debug/trace
       
        %Yingu
        < display for Ying, out of time
        R%Ying @296 - repeatedly
         may be planned, e with %term
         or random e (click)
        
        arrange for next Ying to come back with
         %terms - arrival protocol
          eg visit only $to, not $to/**
           for any %%eto upwards
          otherwise figured by elvis %tunneling
        
        by sorting waves of wakers
        < p%priority or nodes refd by another waker first
        < deeper nodes first, all siblings at once
          supposing their reason to be is compatible,
           avoid re-%%waits when theres %%eto to deliver
        
        from now and before
        < undropped e when sccb throttles
        < come back in at least a little while
        
        noticing when we might
        < interrupt busy system
         < to refine eg &etos_6 &brackstill
        < give up on
         < &brackstill %%waits
          < until what it %%wants re-&settle
         < sheer change (lack of) in motion,
           if all %Zif-able, spotting increases etc.
        < go randomly visiting ($p/10s?)
          where further time plots emerge
       =elvis
       
       // R%Ying &waits_8 -> e come back
        # Ying%%waits,wants:$to - come back for $to etc
        me.waits_8 = &acgtR{
            $wakers = me&jaa,R,'waits','wants';
            me&reaw,R,'Outlog';
            $l = me&rollbs,R,'Outlog',[];
            
            # regroup!!
            
            l.push(wakers);
            !wakers.length and return
            
            # Ying and each node has %terms,
            #  they must accept the wave is done
            wakers = wakers.map(&n{
                return {wake:n,terms:{}}
            });
            me&Yinge,R,{wakers,terms:{}};
        }
        me.Yinge = &acgtRc{
            me&rollbs,R,'Iinint',0;
            $starting = Rs&Iinint++ < 5;
            
            $elvising = &{
                # visits those r**
                $wakers = c.wakers.map(&c{
                    $r = c.wake;
                    r = ry&R;
                    !isR(r) and throw "notR"
                    c.wake = me&yfuture,r;
                    c.ret = 1;
                    return me&elvis,R,'reYn',c
                });
                # on a single trip to %Ying
                # pack: es&z are e, simultaneously
                c.pack = R;
                me&elvis,R,"Yingvoids",c,wakers
            };
            # avoids usual timing of Elvoids:
            # < should ec&when exactly
            $del = starting ? 30 : 3000;
            $Co = me&rollbsc,R,'Corresp';
            # limit to one feedback loop
            $yeah = me&sccb,Co,'Yingvoids',elvising;
            G&yl,del,yeah;
        }
  
  // 8 - dial
        # transbrack comparator
        # < brackology with two z's, +- 
        me.brackstill = &acgtRzb{
            $cha = 0
            zc&allks = [];
            zc&allvs = [];
            me&ioty,z .map(&n{
                each kv n.sc {
                    $ki = zc&allks.push(k)-1;
                    # < more/less important k
                    !b || bc&allks[ki] != k and cha = 2
                    $vi = zc&allvs.push(v)-1;
                    if (!b || bc&allvs[vi] != v) {
                        isob(v) and cha ||= 1
                        else { cha = 2 }
                    }
                }
            })
            !b || bc&allks.length != zc&allks.length and cha = 2
            return cha
        }
        # display brackology
        me.stepbrack = &acgtjz{
            $g = me&brackology,j,z||'wou';
            me&walls,g,'b:2.2';
            # attaching C to r without doming:
            ac(j,'M',g);
            return g
        }
      
        # a heading for some %Part of it
        # < swallowing brack
        #  < knowing T.act here and when ha
        # acty:8 meaning dialectical,
        # acty:1 would be openey,
        #   buttons for the first layers of mind atop
        # they are cv-ish, yet individual doables...
        #   %%may:ha,openey:1,acty:1 - advertise route
        # then just increase %%acty to wander in to things
        #  eg when depending on something being awake
        #  eg acty=5 might be enough to know expected Wup affects
        me.acting = &acgtRt{
            t ||= T.act.t;
            $ope = me&rolltog,R,{may:t,tsc:'l',acty:8};
            return ope
        };
