# stored item pile system
# < not bumping into the ttl
4s&Searchttl = 3600
me.Sch_Pavings = &acgt{ return [
  
  // communitic
   # ephemeral: s not in R^^s:z (!z/s), see &bal
    ['eph',0.292,&acgtRs{
        me&reaw,R,'eph',1
    },'ift,D'],
   // twin - making Q
    # a join, C indexed, tw with multipliable specifics
    #  n Ghost 2 twin:Travel|Know#of/t
    # schema for Ghost/Travelt/Knowof/Knowt
    &{
        # Ying o2: init $p for s%twin
        me.attrise_twin = &acgtprs{
            rs&twin = ss&twin;

            $m = ss&twin.split('|');
            # < 404 should pause, non-compile
            # the index of C s/**:
            $M = ps&structure = []
            # < moving to s for s, not p for p
            $sM = sy&structure = []
            ps&remotes = m.map(&t{
                $m = t.split('#');
                t = m[0];
                # someone to %%ein the question
                $host = me&fiu,py&up,t,7;
                !hosty&s and debugger
                !host and me&waits,"twin!"+t; return
                # stack t as eg %of for the question
                $path = (m[1]||'t').split('/');
                each ix path {
                    $h = Cye([x,1])
                    M.push(h)
                    # end of a chunk of the path
                    !path[i*1+1] and hc&host = host
                    
                    # and again for sy&structure,
                    #  referring to s
                    $h = Cye([x,1])
                    sM.push(h)
                    !path[i*1+1] and hc&host = hosty&s
                }
                ah(host,'twinned',p.t,p)
                ah(hosty&s,'y','twinned',s.t,s)
                return host
            })
            sy&remotes = ps&remotes.map(p => py&s)
        };
        # describe leg of index into Q.c (and Q.t)
        #  eg $of/$t (the .5 ghost) to Q:$t with Qc&of
        me.Q_via_structure = &acgtpN{
            $i = N.length - 1;

            i < 0 and return
            $m = ps&structure;
            $here = m[i];
            !here and me&tsc,"beyond:",'','T'; return
            $host = herec&host;
            !host and return
            # N (C stack) maps onto the structure
            #  building Q attr
            $Q = G&Cye,['someQ',{host}];
            while (m[i]) {
                $h = m[i];
                !h and throw "noh"
                hc&host && h != here and break
                $j = N[i];
                !j and throw "noj"
                $z = jc&s;
                $k = h.t;
                h.t == 't' and Q.t = z.t
                else {
                    Q.c[h.t] = z.t
                }
                i--;
            }
            return Q
        }
    },
    ['twin',0.3,&acgtRs{
        ah(R,'adhere','twin',2);
    },'ift,D'],
    ['twin',0.32,&acgtRs{
        me&reaw,R,'twin';
        $win = me.cby(R,'^^^twin');
        $r = win.shift();
        $st = rc&s;
        if (!hak(win)) {
            # the step, C above index
            r != R and throw "R"
            if (!Rc&b) {
                # avoid initial everything %%broken
                rs&twinningup =
                Rs&numberclicked = 1; me&waits,"Loading..."
            }
        }
        
        $S = me&inode,R;
        # can give/take
        me&elnodes,s;
        
        $p = sty&p;
        $Q = me&Q_via_structure,p,win;
        # the py&R, non-last bits of index
        !Q and return
        
        $host = Qy&host
        sy&host = host
        sy&twinning = hosty&s
        $qe = {host}
        $la = sy&up && me.cbu(sy&up,s => sy&host)
        # %%inside:Ghost/$a (Travel/*) is Ghost..$z (Know/*)
        la and qe.inside = la
        # select Qish amongst host%%tw,of,s=efrom=Know..s
        #  indexed by %twmt over there
        $N = me&nodeo,R,host,Q,qe;
        each in N {
            # to eg Ghost via Ghost..s
            #  so s=Know..s,efrom=Ghost..s
            me&nodei,R,1,n,{},qe;
        }
        N.length || rs&twinningup and return
        me&nodei,R,1,{broken:1},{},qe
        # wait for them until we find this thing
        !me&ja,R,qe and me&settle,R,hosty&R
    },'ift,D'],
    
   // twmt - matching Q
    # they make a pile of names
    ['twmt',0.37,&acgtRs{
        me&reaw,R,'twmt,twmt_dl';
        $S = me&inode,R;
        #me&tsc,'twmt'
        
        $only = Ss&twmt_only;
        only && !only(R,s) and return ~>3 no-twmt: s.t
        
        # this side compiles for Q.c,
        #  otherwise they match Rs&*
        $q = {tw:s.t,s};
        Rs&Paving and q.of = Rs&Paving
        # 1 = for Step to collect
        $eto = Rs&twmt
        me&ha,R,q,{eto};
    },'ift,D'],
    
   // ordering peers
    # do Some:n/First:m before Later:n/Some:m
    # < supposing they emerged as changing all at once
    # probably in order already
    # may hang, choose to start:
    # < smallest changes and/or deepest/widest inclusion first
    # < include back and forth until settled?
    #   if inclusion changes behaviour of W its in,
    #   once we start compiling u for processes out there
    #   esp. n a using u a to define itself
    ['Omplateau','312',&acgtRs{
        $inside = &s{
            $j = sy&R;
            me&ha,j,'mot:later,fro:inside',{},{ste:s}
        };
        # < [s, ... map{zy&N} ss&z]
        $N = me&ioty,s,[''];
        $h = {};
        each is N {
            !sy&supr and throw "los"
            $b = h[s.t];
            h[s.t] = s;
            b and inside(s);
            each in sy&N {
                $b = h[n.t];
                h[n.t] ||= n;
                b and inside(n)
            }
        }
    },'ift,D'],
   // adhere
    &{
    # < using Be.C.Pave.inheritsc(_tricks)
    me.adhere ||= {};
    me.adhere.Paving = &Rr{
        $s = Rc&s;
        $z = rc&s;
        # inherit environment
        zs&directory and zs&directory = zs&directory.replace(/\/$/,'')
        ['args','directory','Paving','section'].map(&k{
            # r%dir = s%dir ||| R%dir
            # < omit s%dir when == R%dir
            # and eg %directory='' leaves
            $is = hak(z.sc,k) ? z.sc[k] : R.sc[k];
            # < s%dir=1 meaning it no %Pave
            if (k == 'directory' && Rs&director && is != '') {
                # %directory increases into t
                # < %dir=2: %director+%Pavings - container, !%Pave-ing
                # < %dir=1: %director - with %Pave-ing
                # %dir += R.t(/s%dir)
                $was = is
                $dir = Rs&directory
                is = dir ? dir+'/' : '';
                is += Rs&title || s.t;
                # any s%dir goes under this director
                dir && was != dir and is += '/'+was
            }
            is and r.sc[k] = is
        })
    };
    },
    ['adhere',0.31,&acgtRs{
        me&reaw,R,'adhere,noadhere';
        me&ioty,R,'ball' .map(&r{
            $mad = me.adhere;
            each tn Rs&adhere {
                rs&noadhere && rs&noadhere[t] and continue
                
                $tdl = R.sc[t+'_dl'];
                if (tdl != null) {
                    tdl == 0 and continue
                    r.sc[t+'_dl'] = tdl-1
                }
                
                rs&reneg and continue
                mad[t] and mad[t](R,r) and continue
                r.sc[t] ||= n;
                # leave eg Stories/Stori%adhere.twmt=Stori
                #  Stori%twmt=Stories, Stori/**%twmt=Stori
                rs&adhere && rs&adhere[t] and continue
                ah(r,'adhere',t,n)
            }
        });
    },'ift,D'],
  
  // %Pavings
    # contain %Paves, but aren't %tw themselves
    ['Pavings',0.301,&acgtRs{
        me&reaw,R,'Pavings';
        # borrow %Paving params
        me.adhere.Paving(R,R);
        # to give on to %Paving
        ah(R,'adhere','Paving',1);
        # < o R/*%ball(%Pavings
        me&ioty,R,'ball' .map(&r{
            $z = rc&s;
            if (zs&Pavings) {
                # except folderish, another %Pavings
                rs&Pavings = zs&Pavings;
                ah(r,'noadhere','Paving',1);
                ah(r,'noadhere','twmt',1);
                ah(r,'adhere','twmt',1);
            }
            else {
                # < engage the top level if we pc&ov>=2,
                #   some kind of energy to complete itself
                # or we will just %adhere without /%Pave+G&ting
                #me&tsc,"adrop:"+(rs&Paving&&"Pav"||".")
                # < show how they haven't got %Paving until they %adhere
                #   and have some way to capTure that A-moment
                rs&openey = 1;
            }
        })
    },'ift,D'],
   
   // %Paving Know..$s
    # %Paving splits into species
    #  no /%Pave (G&t) unless %openey (%Pavings/%Paving will)
    #  avoid download/decode unless %fully
    ['Paving',0.36,&acgtRs{
        # may be a %Pavings this-hereiting eg %Paving=ghost
        Rs&Pavings and return delete Rs&Paving
        # < %Paving/%Paving modes, created by %Releasor
        #    in directory of W
        #    dependency of W: I pile pile
        #    dependency of wjs
        #    chunk|extent of ghost|peek
        Rs&Paving == 1 and Rs&Paving = 'W'
        $of = Rs&Paving;
        me&reaw,R,'Paving,noGump,title,directory,director,species,args,section';
        $S = me&inode,R;
        # %adhere resolves meanings
        # < generalise levels of engagement (%%may,acty)
        # %openey Searches with /%Pave (G&t)
        me&ollbs,R,'trouble' and Rs&openey = 1
        Rs&boost > 0 and Rs&openey ||= 'boost'
        # only going to organise *%Q
        Rs&noGump and Rs&openey ||= 'noGump'
        !me&rollbs,R,'openey' and return
        # %fully gets %Pave's item
        me&rollbs,R,'fully';
        
        $M = [];
        # see if there's a HEAD-type method for this Qc&of
        if (of == 'W') {
            m W\.5 2  %species:5
            me&jaa,R,{eto:s},'species' .map(&k{
                k == '1' and return Rs&fully = 1
                k == '5' and return
                $n =
                m W 2
                n.t += "."+k
                ns&species = k
            })
            Rs&fully &&
                m W 1
        }
        else {
            m $of 1  
        }
        each in M {
            # Rs&* and rs&* -> Qc&*, Qc&of = %Pave
            ns&Pave ||= of;
            nc&R = 1;
            n $n
        }
    },'ift,D'],
  
   // %Pave
    # %Pave has a Q, could be a species
    ['Pave','291',&acgtRs{
        $p = Ry&up;
        $s = pc&s;
        # since Zaving@294, reuse foldy thing
        ah(p,'Zaving',R.t,R);
        # similar to %Zave,
        #  G&t,Q directly, no %Saveting
        #  no %Here
        #   until download+decode
        #   or a write is proposed
        #   or our cache (dige/versiona) could go there
        
        $Q = me&rollbsc,R,'Q';
        Q.t = Rs&title || ps&title || s.t;
        sy&tin and me&tsc,"<tin>"
        sy&tin and Q.t = sy&tin.t
        Qc&of = Rs&Pave;
        # < about getting back here with updates
        Qc&async = &{};
        Qc&ready = &CP{};
        ['directory','species','args','section'].map(&k{
            $is = R.sc[k] || p.sc[k];
            is and Q.c[k] = is
            else { delete Q.c[k] }
        });
        Qc&of == 'peek' and Qc&args ||= 'none'
        # compile to $t for Search
        Qc&directory and Q.t = Qc&directory+'/'+Q.t
        Qc&species and Q.t = Q.t+'/'+Qc&species
        # and for humans
        n of 101 $s:Qc&of %hs:348,fs:9
        Qc&section &&
        n section 1017 $s:Qc&section %fs:8,hs:394
        Qc&directory &&
        n directory 102 $s:Qc&directory %fs:8,hs:194
        n t 11 $s:Q.t %hs:348
        Qc&args &&
        n args 1117 $s:Qc&args %fs:8,hs:355
        Qc&species &&
        n species 112 $s:Qc&species %fs:8,hs:157
        
        
        # Q refinds P each G&t
        $w = me&t,R,Q;
        $P = Qs&P
        !P and debugger
        # per most of this besides s, el + hooks
        me&rolltog,R,{maydo:'Q'} &&
            me&zu,'Q',Q;
        
        if (Qs&errors) {
            # < slow %%waits or pause everything
            $er = me&tsc,'error'
            delete erc&s
            ers&dis = 1
            ers&wb = 1
            me&mtsc,er,"skull",'â˜ ','D'
            me&mtsc,er,"message",Qs&errors,'y'
        }
        # usu !s,!el,!ready -> s,el,ready 
        #  a not found will -> !s,el=9,ready
        # !ready while hitting a ttl, thing probably still
        # < @Search shouldn't let any P reach the ttl
        !Qs&ready and me&waits,'!ready','...'
        # $w may wander off, usu clones into %Gens%self
        # < following P into the future (%Differ)
        
        Qc&el &&
        n el 13 $s:Qc&el %hs:348,fs:9
        
        Qc&s && me&rolltog,R,{maydo:'s'} &&
            n s  $s:Qc&s %R:ball
        
        # < GOING, hoist %%Live?
        # have the thing, readyonly, copied from Pc&s
        # < Q can Qs&Want_Decode for itself
        Qc&s and Rc&s = Qc&s
        
        !(Qc&s || Qc&el == 9) and return
        
        if (Ps&suggest_species) {
            # eg species=5 undef, yet has a 1
            #  requires us to %Paving%fully
            !ps&fully and me&waits,"suggest_species:1"
            ps&fully = 1
        }
        # then something posits string to follow:
        Rs&commitstring = &s{
            # < require they know parent==Ps&dige
            Rs&Committing = Qs&string = s;
            me&t,R,Q;
        };
    },'ift,D'],
  
   // %Paving 5 <- %Pave-centricism
    &{
    # the main %Paving/%Pave's Q
    # may be W.5 until %fully, then W.1
    me.Paving_Q = &acgtR{
        !Rs&Zaving and throw "!always %Zaving"
        $Q;
        # last one is the main thing, see Paving 36
        each tr Rs&Zaving {
            me&ha,R,{wants:r}
            Q = rs&Q;
            # never happens
            !Q and me&waits,t+"!Q"
            !Qs&ready and me&waits,t+"!ready"
            # for pushing W, several things at once
            $species = rs&species || 1;
            ah(R,'species_Q',species,Q)
        }
        !Q and throw "!always has a Q"
        # has $w if found
        $w = Qc&s;
        if (Qc&el == '9') {
            w and throw "!always !w if el=9"
            # < GOING
            Rs&creatine = 1
            me&tsc,'el:9',0,'b'
        }
        else {
            # < compile errors?
            !w and me&waits,"!compile"
        }
        return Q
    }
    # know about the Thing independent of the species
    me.lookaQ = &acgtQ{
        $s = Qc&s;
        !s and throw "Q!s"
        $Thing = Cye([s.t,1]);
        # 5s&$species = $dige.
        #  ha means 1, historically.
        # < 5%dige: dige the rest of 5? 5/* Lines\n
        #   so we can peek the first line only
        $Wha = &s{ return ss&ha || ss&dige || s.sc[1] }
        if (Qc&species == 5) {
            Things&dige = Wha(s)
            o $s/W/*:s
            each in ays&s {
                ah(Thing,'Wind',n.t,Wha(n))
            }
            # < some piles reway, others remix
            #   some are way leading to many
            o $s/w/*:s
            each in ays&s {
                ah(Thing,'wind',n.t,ns&dige)
            }
        }
        elsif (Qc&species == 1 || !Qc&species) {
            # < can do similar for .4
            # < pointings that adjust for its compression
            each in sy&N {
                ns&W && !ns&z &&
                    ah(Thing,'Wind',n.t,Wha(n))
            }
            $dige = Qs&dige;
            !dige and throw "nodige"
            # W:spot/* %ha are 9 (see AWriter), %dige are 12
            if (Q.t.indexOf('spot/') == 0 &&
                dige.length == 12) {
                dige = dige.substr(0,9)
            }
            Things&dige = dige;
        }
        return Thing
    }
    },
    # waits for Pave
    ['Paving+openey',0.5,&acgtRs{
        # Storie/Around (a &bal) starts weird:
        !Rs&Zaving && me&bewind,R and return
        $ope = me&acting,R,'Pave';
        # < GOING: %supr etc
        sy&f = R;
        
        !Rs&Zaving and return me&waits,"!always%Zaving"
        $Q = me&Paving_Q,R
        !Qs&ready and me&waits,"!ready"
        # %Paving has a few things even if !ready
        Rs&Q = Q
        $w = Qc&s;
        # others grab &za,Live
        #  distant nodes cannot rely on R timing
        w and Rs&Live = w; me&ha,R,{Live:w,dome:'ready'}
        # waits for settling before CB compute
        #  which could be handled remotely
        !w || me&bready,R and return
        # avoid all @Gump, %%Paving_goodin
        Rs&noGump and return
   
   // look
        $Thing = Rs&Thing = me&lookaQ,Q;
        
        # it is all about %dige
        $commit;
        me&jaa,R,"eto,efrom","commit" .map(&dige,{
            commit and throw "multi %%commit"
            commit = dige
        })
        if (commit) {
            if (commit != Things&dige) {
                # immediately after Qsend?
                # or wandering before %%commit retracted
                me&waits,"pushing..."
            }
            else {
                # is as we indended it to be
                # %%commit sender acks & retracts
                ss&dige = Things&dige
            }
        }
        if (ss&dige != Things&dige) {
            # < part of CBing, could be anything
            $mix = {is:Things&dige, was:ss&dige}
            me&ha,R,{cha:'dige',Q},{dome:'feels'},mix
        }
        
        # skip two complications:
       // < CBing, more-structured Thing change
        # roll/sleepatch inner processes
        # < sleep by Q%dige?
        me&rolls,'grype',{s:Q.t+"@"+Qs&dige}
            && me&rollbs,'changey';
        # sync ss&dige and Thing's dige (however it appears)
        #  and whatever other Things project knowledge around

        # key behaviours, to stare at problems for longer:
        # hold changes to s that it has already
        # < we don't need to compile simple connections?
        #   trusted sources etc
        # ! if grype causes f%changey but applies the change
        #   (liesnotok=1 not to)
        #   grype rolled forgets it made the change
        #   f%changey can be forgot if R%tracting is interrupted
        # don't apply change from the Thing until Compiling wants to
        #Rs&liesnotok = 1;
        # hold waking Thing changes are projected into:
        # < without hiding the change
        #Rs&noprojcha = 1;
        # < GOING, see CBing
        if (me&rollbs,'commiting') {
            Rs&commiting++;
            # CBing may schema this
            #Rs&liesok = 1;
        }

        # %ting attr were auto upload/download by A:f
        # < configure it here sometimes
        me&CB_fixing,R,'ting';

        # %dige-ish group - change makes fs&changey
        # < particularly if it changes when we game look->get,
        #    would mean a 4 is not pointing to the 1 proper
        me&CB_fixing,R,'W',{w:Thing};
        
        # project info to children
        Things&Wind and me&CB_proji,R,'Wind','t,dige',Things&Wind
        # receive those projections
        me&CB_projo,R;
        
        # tally grypes about info here
        # < it's their %%cha if their projections are wrong
        me&CB_conclude,R;
        
        # GOING
        if (ope) {
            Rs&changey and me&zu,'changey',Rs&changey;
            Rs&trouble and me&zu,"Rtrub",Rs&trouble;
            #me&zu,'Loadism',load
        }
        # various leads to %changey -> /*%openey
        #  so all **%changey/*!%changey
        if (Rs&changey) {
            # dige here or inside solving
            me&tsc,"R%changey","cha",'G';
            s&bgh = 111;
            # 2 them
            me&ioty,R,'ball'
                .map(n => ns&openey ||= 1)
        }
        Rs&trouble and me&tsc,'trouble','trou','G'
        
       // < filtering s**
        # %el etc bring meanings, see %Paving/%Paving modes
        # eg which children to ignore
        # < bring back Compiling: for I-mixing
        #    without a specific W:way source for the new unity
        # < W/W:Protocations could be testrun data,
        #   supporting evidence, breakdowns etc macro-species
        $inc = me&CB_fixing,R,'inc';
        if (inc) {
            if (ss&el == 9) {
                Ds&bri = 0.6;
                me&mtsc,inc,'ig',0,'B'
                # < also ignored by the compiler
                Rs&ignore = 1;
                me&ha,R,'ignore';
                return
            }
            ss&el == 7 and me&mtsc,inc,'hmm',0,'B'
        }
        if (0) {
            # < applying the sort-out-code scheme
            # wanting a decision on each one
            # (1 keep, 7 transfiguration, 9 death)
            if (!ss&el) {
                me&tsc,'('
                me&rolltog,R,'9',0 and ss&el = 9
                me&rolltog,R,'7',0 and ss&el = 7
                me&tsc,')'
            }
        }
        
       
       // etc
        # specialised sense of which s/* matter
        Rs&zget = &Ry{
            me&ioty,R,'Paving' .map(&r{
                # see filtering
                rs&ignore and return
                y(r)
            })
        };
        ope and me&zu,'Thingstract',Thing
        ope and me&zu,'Paving',s
        
        # feels -> means when the Know.. is ready
        me&dome_traction,R,'feels'
        Rs&Paving_good = 1;
        me&ha,R,'Goodish';
    },'ift,D'],
   
   // repose
    # R%Paving_good waits for R/*%Paving_good, etc
    #  when we can rely on our children to complain,
    #  know if they're changey/trouble
    ['ball+Paving_good','52',&acgtRs{
        
        T.Mw = 'trac';
        $p = Ry&up;
        Rs&zget(R,&r{
            # don't mind el:9
            rs&creatine && !Rs&serious and return
            
            # completed 51
            !me&ja,r,'Goodish' and me&wants,R,'Goodish',rc&s

            # completed 52
            #  which they haven't this future
            !me&za,r,'Good' and me&wants,R,'Good',rc&s

        });
        # autothink:
        # < sending %trouble to solve %%waits,Good
        me&jaa,R,{waits:'Goodish'},'wants'
            .map(z => zy&R && ac(zy&R,'trouble',R.t+" wants %%Goodish"))
        
        # weakly supposing no signal means ok?
        $whatsup = me&bready,R;
        whatsup and whatsup = whatsup.map(n => ns&waits || "?")
        whatsup and return me&tsc,"!bready:"+whatsup.join(','),'','y'
        
        $x = me&Jx,R;
        # %%cha -> Gump
        xs&Gump &&
        me&jaa,R,'cha,Q,dome:feels' .map(&n{
            # %%n can be another brack row to &brackstill
            me&nodei,R,xs&Gump,{chag:'change',K:s,n},{dome:'means'}
        })

        # children at least here
        #  Ring usu. children almost here
        Rs&Paving_goodin = 1;
        me&ha,R,"Good"
        me&dome_traction,R,'means'
        # < which means all we need to %Compile is connected!
        # see %Paving/%Paving modes
        #!ps&Paving and me&ha,R,'stabilised','eto'
    },'ift,D'],

  &{
  // use
   
   
   // &Pave(Q|Live) - K%Paving lowlevel
        # Know..K%Q, for a species
        # < read %%Q,species for reliable
        me.PaveQ = &acgtRKc{
            c ||= {}
            $r = Ky&R;
            $of = rs&Paving
            !of and throw "!Paving"
            if (of == 'W') {
                # W have species
                $spQ = rs&species_Q
                !spQ && !rc&N[0].y.Display and r = rc&b; spQ = r && rs&species_Q
                !spQ and throw "Paving!species_Q"
                $species = c.species || 1
                $Q = spQ[species];
                # load a %Pave for any species that wants to be here
                !Q &&
                    me&nodei,R,r,{species},{dome:'tilpushed'}
            }
            else {
                hak(c) and throw "extra for Paving:"+of, s
                $Q = rs&Q
            }
            return Q
        }
        # read %%Live from a complete r%Paving
        me.PaveLive = &acgtRKc{
            c ||= {}
            $r = Ky&R;
            $of = rs&Paving
            !of and throw "!Paving"
            $L = me&zaa,r,'Live',1 [0]
            # r%Paving 5 may be yet to happen,
            #  ie distant nodes cannot rely on R timing
            #   unless any %Paving (%priority) grabs R-time
            #   ie J completing before returning from &n
            #  shows up by the time &zu,r draws it
            #  < &zu etc should slep now-later,
            #    drawing A time of interesting bits
            L && !rs&Live and me&tsc,"goestoshow:%Live-vs-%%Live"
            return L
        }
   
   // accept* - flock roles
        # Nine tallies Eigh+,
        #  may e:Accept many Eigh%%ready,ok?
        me.acceptables = &acgtRN{
            me&Acceptings,R,N
        }
        # when ready+cha, Eigh $got may %%acceptable -> Nine
        me.acceptable = &acgtRst{
            $q = {s,t}
            me&readyok,R,s,t,q and return
            # while ready!ok, click to stage
            me&Accepting,R,q (&{
                # staged
                me&accept,R,s
            })
        }
        # anyone can hoist %%acceptable=s,dige,...c somewhere
        #  see also %%Accepting=dige,...q
        me.accept = &acgtRsc{
            $Nine = me&find_Racceptables,R
            $dige = me&storable,s
            $q = ex({dige},c||{})
            q.acceptable = s
            # you might be inside a callback that mutates q
            ex(q,T.acceptmix||{})
            me&nodei,R,Nine,q
        }
        # find R^%acceptables host
        me.find_Racceptables = &acgtR{
            $f
            me.cbu(R,&r{
                r == R && !Rs&onitself and return
                $s = rc&s
                r = s && sy&R
                r && rs&acceptables and f = r; return 1
            })
            !f and throw "R!^%acceptables"
            return f
        }
   
   // &readyok, &Accepting(|s) permit|tally
        # &readyok || &Accepting (&{ act })
        
        # give %ready, the s==t for %ok
        #  may mutate q, which mixes into eg %%Pushable
        me.readyok = &acgtRstq{
            $dige = me&storable,s
            me&ha,R,'ready'
            if (t) {
                # Stori/t%dige avoids &moreThat. see %Eigh
                $alink = tc&pi && ts&dige && !me&ioty,t .length
                if (ts&dige == dige) {
                    me&tsc,"OK",'','g' .y.cv = 0.01
                    me&ha,R,'ok'
                    return 1
                }
            }
            else {
                # is new
                q.el = 2
            }
        }
        # tally things that e:word and %%ready|ok
        # < transactionism, history
        me.Acceptings = &acgtRN,word,wording{
            word ||= 'Accept'
            wording ||= word+'ing'
            $g = me&case,5
            $note = &sct{
                $n = me&mtsc,g,(t||s),s,c||'y'
                # &tsc s=0 becomes t
                nc&s = s
                return n
            }
            !N.length and me&tsc,"no-*"; return

            $unready = []
            $ready = arou(N,&r{ return !me&za,r,'ready' },unready)
            if (unready.length) {
                # should just be one open %Yingates at the end
                !unready[0] and debugger
                #unready.length > 1 and note("Lots-unready")
            }
            $unok = arou(ready,&r{ return !me&za,r,'ok' })
            if (unok.length) {
                $ro = note(word+"*?")
                me.nto(R,ro,&sT{
                    me&elpack,R,word+"*",word,unok
                    T.wake = 'not'
                })
            }

            g = note('prog','l')
            gs&ma = gs&lh = 2
            note(ready.length,'','ready')
            note('/','6','of')
            note(N.length,'','total')
            
            unok.length and note("!"+unok.length,'b','fail')
            else
            if (ready.length == N.length) {
                me&ha,R,{allok:word}
                note("OK",'g')
                return 1
            }
        }
        # while s!=t, posit a %%Accepting=dige,...q
        #  q starts with a storable, room for push coms
        # < &nodei up to unity, returns permits per %dige
        me.Accepting = &acgtRq,word,wording{
            word ||= 'Accept'
            wording ||= word+'ing'
            $k = haks(q)[0]
            $s = q [k]
            $dige = me&storable,s
            
            # the answer, a subset of q
            # < inc s?
            $a = {}
            a[wording] = q[wording] = dige
            a.go = 1
            
            # the unity (eg (Re)?Nine) of pushy flock
            #  may get q, as well as it leaving from R
            # it may receive %%Acceptable or see *:R
            #  and e:Accept us
            $j = delete q.eto
            j ||= R
            R == j ? me&ha,R,q : me&nodei,R,j,q
            
            $e = me&Dtunneling,R
            if (e && e.t == word) {
                # click to stage
                me&tsc,wording
                # sticks on until this process shakes it off?
                me&ha,R,a,{dome:wording}
            }
            
            if (me&ja,R,a ) {
                # staged
                return &y{ y () }
            }
            else {
                # not staged
                $ro = me&tsc,word+"?",'','y'
                me.nto(R,ro,&sT{
                    me&elvis,R,word
                    T.wake = 'not'
                })
            }
            return &{}
        }
     
   // *That, re* - connect, replicate!
     // &ipipe - harness
        # control between *That
        # < argument pipe to|beyond getThat
        # < pipe returns the pipey&3, they slope
        #   3 the one bunch of commits being merged,
        #    on the Story or /Test branch,
        #    which should historialise all %Paving action,
        #     as reversible lv potential
        me.ipipe = &acgtRq{
            $s = Rc&s
            q ||= {}
            # < selfThat should y&up to ipiper
            #   < could wander sy&R as well
            # < boundary %Peace=4
            $pp = me.cbu(sy&up,s => sy&pipe)
            pp and pp = ppy&pipe
            $pipe
            isst(q.pipe) and pipe = me&fiu,pp,s.t
            isC(q.pipe) and pipe = q.pipe
            pipe and throw "replace sy&pipe?"
            # and if pipey&up now != pp, moved into pp?
            else {
                if (!sy&pipe) {
                    sy&pipe = pp ? me&fiu,pp,s.t
                        : Cye([s.t,1])
                }
                pipe = sy&pipe
            }
            sy&pipe = pipe
            pipey&s = s
            $top = pipey&top = pp ? ppy&top : pipe
            return topy&s
        }
     // &get|selfThat - harness K)%Paving%%Live
        # use &nodeo %twmt
        me.getThat = &acgtRrQq{
            # to %%eto:K,...q,species:1,pipe=Test
            q ||= {}
            q.species ||= 1
            q.pipe ||= me&ipipe,R
            $K
            me&nodeo,R,r,Q,'el' .map(&n{
                $z = ns&s
                # < input Stories/$t, advert from Around/$t
                ns&ad and throw "advert"
                # species:1 to fully download
                me&ha,R,ex({eto:z},q)
                K and me&tsc,"MULTI"
                K = z
            })
            return K
        }
        # see Zave 68, has pull|push, diff sense
        me.selfThat = &acgtRKc{
            c ||= {}
            $k = 'self'+(c.t||'')
            me&reaw,R,k
            $go = me&acting,R,'Self'
            $x = me&Jx,R;
            $Q = me&PaveQ,R,K
            $L = me&PaveLive,R,K
            # Paving must attend to Qc&s <- Pc&s,
            #  almost reliably it will %%Live that time
            Qc&s != L and debugger
            !L and me&tsc,"el:2"

            $self = me&rollbs,R,k
            self && selfy&Live != L || go and $pully = 1
            if (pully && me&ja,R,{acceptable:1,dige:Qs&dige} ) {
                # %%acceptable has become %%Live
                me&ha,R,{digepushed:Qs&dige,dome:'digepushed'}
                me&tsc,"Pushed!"
                selfy&Live = L
                pully = 0
                selfy&reselfy and self = 0
            }
            pully && x.ro('pull?') and self = 0
            if (!self) {
                if (L) {
                    # all y&Clone=L**
                    self = me&Clone,L
                    selfy&Live = L
                    selfy&That = K
                }
                else {
                    self = Cye([K.t,1])
                    selfy&autoviv = 1
                }
            }
            R.sc[k] = self
            go and me&nu,k+"%Live",L
            go and me&nu,k,self
            return self
        }
        # return K = sy&That, s is|above t
        # < nearest pipe thing, not specific to
        #    but may be looking for a &selfThat
        me.last_selfThat = &acgtRt{
            $s = me.cby(t,s=>sy&That) [0]
            $that = sy&That
            !that and debugger
            return that
        }
     
     // &more|twineThat - harness K** across here
        # relative &selfThat - i ^that%Paving/#$z
        me.moreThat = &acgtRtzc{
            !ty&Clone and throw "climbing R etc"
            # i t^^y&That/#$z
            # < between sy&That..t (one level toc)
            #   would spacerise (non-%%eto,species:1) K in between?
            $that = me&last_selfThat,R,t
            $more = me&getThat,R,that,z.t,c
            !more and me&waits,"!more"; return
            
            $Q = me&PaveQ,R,more
            ts&dige && ts&dige != Qs&dige and me&tsc,"^~%dige"
            
            $self = me&selfThat,R,more
            selfy&Thence = more
            return self
        }
        # relative &getThat - o ^%%eto,...q/$s
        # for recursive ReNine, MayTwine?
        # nodeo to Stories|Stori, each having a %%tw pool
        # < deeper nodeo (%%tw,inside), on /Stori, see %twmt=there
        # < make A=&...{} that tries to apply to ...
        me.twineThat = &acgtRsh{
            h.upsc ||= T.act.t
            #h.word ||= 'Stori'
            !s and throw "somewhere"
            # ^%ReNine:p will have &getThat %%...q
            $p = me.cbu(Ry&up,h.upsc)
            $q = {}
            q.pipe = me&ipipe,R
            
            # from last thing along twine
            # p &getThat leaves %%...q,eto:K==from
            p and h.from ||= me&jaa,p,ex({eto:1},q),1 [0]
            # < pipe's:
            h.from ||= h.origin
            !h.from and me&waits,"!^%%pipe"; return
            # < why+not: loopy settling if:
            #me&settle,R,h.from and return me&tsc,'..^'
            
            # name looked up from from
            #  note s.t for Query, or sc&* would Q
            $t = me&getThat,R,h.from,s.t,q
            !t and me&waits,"!pipe"; return
            !ty&R and debugger
            # see %twin->%Pave. won't adhere properly if el:2 now.
            # < not yet node? %%waits,tillater
            # < maybe just &bready?
            me&settle,R,t and me&tsc,'..pipe'
            return t
        }
     
     // &reself|other
        # Nine makes toc, forwards %%acceptable=it,Eigh+
        me.acceptables_reself = &acgtRNh{
            # Nine is as %%acceptable router
            !Rs&acceptables and throw "R!%acceptables"
            $Test = me&find_Racceptables,R
            !h and throw "configure"
            me&reself,R,N,h,{acceptable:1}
        }
        # Test lays out %%acceptable for push (staging)
        me.acceptables_reother = &acgtRh{
            # Nine is as %%acceptable router
            !Rs&acceptables and throw "R!%acceptables"
            me&reother,R,h,{acceptable:1}
        }
        
        # regards self, constructs an other
        #  &accept will %%inside
        me.reself = &acgtRNhq{
            !q and throw "no q"
            $go = me&acting,R,'reself'
            $k = haks(q)[0]
            go and me&nu,'inc',N
            $x = me&Jx,R
            me&reaw,R,'sav'
            $sav = x.ro('sav',{})
            # each Eigh may send an %%acceptable
            # < &twlic ish, all jaa or N, to check they mesh:
            $todo = me&jaa,R,q,1
            !todo.length && !sav and return
            # < put them in dome:acceptable? when none:
            #   me&dome_traction,R,'acceptable',{el:2}
            
            $self = Rc&s
            $O = Cye(self)
            Oy&D = self
            selfy&reselfy = O
            $s = Rs&reself ||= Cye([O.t,1])
            h.sleep ||= h.other
            h.accept ||= h.other
            N .map(&r{
                $z = rc&s
                $many
                me&jaa,R,ex({efrom:z},q) .map(&n{
                    $t = n.sc[k]
                    many and throw "many "+k+" per z",z
                    many = 1
                    todo = arou(todo,s=>s==t,[])
                    
                    go and me&nu,'todon',n
                    T.acceptmix = {inside:s}
                    h&accept,s,O,r,z,n,t
                })
                delete T.acceptmix
                many and return
                h&sleep,s,O,r,z
            })
            todo.length and debugger
            h&self,s,O
        }
        me.reother = &acgtRhq{
            !q and throw "no q"
            $k = haks(q)[0]
            $N = me&jaa,R,q
            !N.length and return

            $insides = []
            N = arou(N,n => ns&inside,insides)
            !N.length and throw "all %%inside"
            N.map(&n{
                $t = n.sc[k]
                $z = h&self,n,t
                h.ytag && z and z.y [h.ytag] = t
                
                $inside = []
                insides = arou(insides,n => ns&inside == t,inside)
                inside.map(&m{
                    $l = ms&acceptable
                    $zz = h&other,n,t,z,l,m
                    h.ytag && zz and zz.y [h.ytag] = l
                })
            });
            insides.length &&
                me&zu,"unclaimed",insides
        }
   
   // &toPave - pushing %Paving
        # grew from %MayGansp, reused for %ReNine
        # R the thing (possibly a species under j)
        # j atomic thing, mediates pushes for all species|W** at once
        #   %%wantpush,Q,s? %%maypush! (for %MayGansp) GOING
        #   %%Pushable,Q,s,dige (for %ReNine)
        # Know..K (that) where to push (finds Q, c.species)
        # s what to push (usu Rc&s? only if ...)
            # < ideally all these Qings would quest e:W,
            #   prove compat (eg consensus, auth, parent|patch),
            #   and be merged, reversibly
            # &nodei also puts %%wantpush in this R,
            # < though you might ignore it because %%eto
            # < conversely, pay more attention to %%efrom
        # once R%ready (connected)
        #  do this until R%ok!
        # flock unity of them:
        me.toPaves = &acgtRN{
            me&Acceptings,R,N,'Push','Pushable'
        }
        me.toPave = &acgtRjKsc{
            c ||= {}
            me&storable,s
            !K and return me&tsc,"!K"
            # may have c.species for a specific Paving/Pave:
            $Q = me&PaveQ,R,K,c
            !Q and return me&tsc,"!Q"
            
            # storable counterpoint to s
            # < getting %string from t=P may not have Q readied
            $t = me&Qdiffthing,R,Q
            
            # until commit, note %%Pushable,...c,species
            $q = ex({s,t,Q},c)
            me&readyok,R,s,t,q and return
            
            if ('old permit') {
                # sent to ^%MayGansp unity
                $qe = ex({wantpush:1,Q,s},c)
                R == j ? me&ha,R,qe : me&nodei,R,j,qe
                # converted to permit &Acceptable
                me&ja,j,{maypush:1} and me&ha,R,{go:1,Pushable:ss&dige}
            }
            
            # compares to the P%dige%string
            me&diffany,R,s,t
            
            # click to commit there
            me&Accepting,R,q,'Push','Pushable' (&{
                me&pushPave,R,K,s,c
            })
        }
        # commit s%string, already permit
        # < %Parent careful, as it cycles (through Eigh)
        # < reliable Q%ready, fatal by now?
        #   or push button stays down until..?
        me.pushPave = &acgtRKsc{
            $Q = me&PaveQ,R,K,c
            $r = Qy&R
            if (!me&rollbs,R,'sent_string' ) {
                # Q asks
                ~>3 push: R.t, r.t, Q.t
                rs&commitstring(ss&string);
                Rs&sent_string = 1;
                # leave a note
                # < to get there exactly when Q ready
                c && K && !c.species &&
                    me&nodei,R,K,{commit:ss&dige},{dome:'someone'}
                # < check extras have commit
                # < let other users block updates, negotiate, pub
            }
            if (Qs&string == ss&string) {
                me&tsc,'pushed';
                debugger
            }
            else {
                $pu = me&tsc,'pushing'
                me.nto(R,pu,&{ 
                    ~>3 repush: R.t
                    delete Rs&sent_string })
            }
        }
        # choose storable instance of the thing to diff
        #  it might be mapped on a recent pusher nearby
        me.Qdiffthing = &acgtRQ{
            $t = Qs&P
            Qc&el == 9 and t = null
            return t
        }
        me.Qdiff = &acgtRsQ{
            $t = me&Qdiffthing,R,Q
            me&diffany,R,s,t
        }
        me.diffany = &acgtRsz{
            $g = me&opeolo,"diffany",{walls:1}
            $a = z || s
            $pa = gy&can('m',a.t)
            pas&mah = 30

            !z and me&mtsc,pa,'New!'
            else {
                $c = {t:z.t,Zif:1};
                c.got = s;
                c.exp = z;
                $di = me&Ret,R,c;
                me&zN,di;
                me&Ring,di,{und:di,ov:314};
                me&zuct,pa,di;
                pas&dis = 1;
                each in dis&waits {
                    ac(R,'waits',n)
                }
                Rs&summary = dis&summary;
            }
            return di
        }
  },
   
]}
  // CB
   # sc here, there, seeing change
   # < brack instead of %grype,
   #   see sans %grype, in CB_proji:
   #    %%wants - another node to have something
   #     ha {imps:t,wants:z,openey:1,cause:d}
   #     < (from),%%wants(to-node),(body),(%%cause.+)
   #       for z to receive %%openey reliably
   #        tells the %%inbox it is read
   #    %%may - do something maybe
   #     may,input,once {imps:t,s:C_to_input,cause:d}
   #     < click to do since s in q rather than a
   #       and we know how to may:input an s
   #     < bracktrick click many
   # grype:
   #   CB_proji proto %%wants another r:node:
   #     e-out logs R%grype/proj/o/#$t/$d
   #     mostly it ac(r,'trouble',d),
   #       which turns into r%openey on %Paving
   #     so it reads r%grype/proj/i/*/* (%%inbox)
   # apart from that,
   #  overall %%cha <- fs&changey
   
   // conclude
    # dialects of %grype/* conclude into fs&changey
    me.CB_conclude = &acgtR{
        Rs&traccon and me&nu,"grype/*",Rs&grype;
        each kn Rs&grype {
            # c&Km are display parts, non-persistent
            $Km = nc&Km;
            !Km and continue
            # take any Kn/%changey as fs&changey
            $N = me&ioty,Km,['groupthing','changey'];
            each id N {
                # < want things for fs&changey to be persistent
                #   see 'these should be elvised in there'
                if (Rs&changey && dy&cv > 0.7) {
                    Rs&changey = Rs&changey
                        .filter(c => c.t != d.t)
                }
                ac(R,'changey',d);
                dy&R = R;

                # sans %grype:
                #me&ha,R,{cha:d,grype:k}
            }
        }
        # modulat from the grype of late only
        if (Rs&changey) {
            $out = [];
            each in Rs&changey {
                !ny&R || Rc&N.indexOf(ny&R) >= 0 and continue
                ny&timingout ||= 0;
                ny&timingout++ > 2 and out.push(n)
            }
            Rs&changey = Rs&changey
                .filter(n => out.indexOf(n) < 0);
            !Rs&changey.length and delete Rs&changey
        }

    };
    
   // CB_fix|load
    # like KnowC for %balls
    # < generalise from sc
    # < about each other, up%ting<->%ting etc
    # < group all types
    $Be = me.Be;
    !Be and throw "!me.Be"
    # Km/Kn modulata for c.type amongst s.sc
    me.CB_have = &acgtcs{
        !c and throw "give c"
        $load = c;
        # everything it has:
        load.c ||= {};
        $Kc = Be.C[load.type];
        $Km = load.Km = G&Cye,[load.type,4,{Kc:Kc},'grouping'];
        each i,k Kc.scgk {
            $got = s && s.sc[k];
            got == null and continue
            load.c[k] = got;
            $Kn = fio(Km,k,[k,1,{s:k},'groupthing,fs:9,mar:0.3']);
        }
        !hak(load.c) and delete load.Km
        else {
            $M = Kms&z ||= [];
            $n =
            m KnowC_K 1 $s:Km.t,K:1 %hs:684,fs:7,mt:-1,label
            ny&cv = 0.001;
            M.unshift(M.pop());
            me&walls,Km,'bd:1.4,hu:3'
        }
        return load
    };
    # for %ball/%fix known by $type
    me.CB_fix = &acgtR,type{
        !Rs&ball and throw "!ball"
        $load = me&CB_have,{type},Rc&s;
        $Km = load.Km;
        !Km and return
        # < put the r%fix in R%Mw/fix anyway
        #   so it can be before R%z
        me&Mw,R,'fix' .push(Km);
        # adopt their %fix
        $N = me&ioty,R,['fix'];
        each in N {
            ns&fix != 'sc' and continue
            $Kn = fio(Km,n.t,0);
            !Kn and continue
            me&zuct,Kn,n;
        }
        Kmc&load = load;
        return Km
    };
    # %fix over time (was grype)
    me.CB_fixing = &acgtRkc{
        c ||= {};
        c.type ||= k;
        # < %grypes can outlive Qs&dige
        $g = me&rollbsc,R,'grype/'+k;
        # roll Km per R
        gy&R != R and delete gc&Km; gy&R = R;
        $Km = gc&Km ||= me&CB_fix,R,c.type;
        
        # history/$gk builds up, can be %changey
        if (c.w) {
            # R is auto-changey ghost, reflecting dige
            #  liesok=0 probably doesn't make a change,
            #  when we want to react to the difference
            $load = {type:c.type,auto:1,liesok:Rs&liesok};
            me&CB_load,load,R,null,c.w;
            each ik load.differs {
                $was = load.was[k];
                $is = load.is[k];
                $d = G&Cye,['Thing-has:'+k,1,{s:">"+was},'changey,histgk,fs:8,hue:2,bri:0.7'];
                me&walls,d,'b:2.2h666';
                ds&gk = k;
                if (was == is) {
                    # if waiting to apply the change
                    dc&s = "<"+load.c[k];
                    ds&bri = 1.3;
                }
                # puts new top on history
                me&givi,g,'history',d;
            }
        }
        
        !Km and return
        Kmc&g = g;
        
        # take interesting g/*/*:gk to their Kn(%fix
        # change history
        $N = me&ioty,g,['',''],['history',''];
        each id N {
            $Kn = fio(Km,ds&gk||d.t);
            !Kn and continue
            fio(Kn,d)
            dy&cv = 0.789;
        }
        
        return Km
    };
    # minimal s.sc realiser
    # for sc in c.type,
    #  ss&* should be as ws&*
    #   or blank if implied by wps&*
    me.CB_load = &acgtcg,wp,w{
        !c and throw "give c"
        $load = c;
        $f = load.f; # optional
        $s = g && gc&s;
        # bits to give G: nulls for things it needn't
        load.sc ||= {};
        # bits to give W: everything
        load.c ||= {};
        # of this type's group
        # < Wtype:* brings everything,
        #   to where osc watches osc
        $Kc = Be.C[load.type];
        
        each i,k Kc.scgk {
            # on %ting%$k
            $got = w && w.sc[k];
            # which is inheriting ^^%tracting
            # or not, if many tings per Thing,
            #  needing more explicit bits in recipe
            #  but something weirder might be afoot
            $exp = wp && wp.sc[k];
            # or not if it doesn't do that
            !Kc.scinherit and exp = null
            # weaker exp than inherit
            if (exp == null) {
                $def = Kc.scdefault && Kc.scdefault[k];
                def != null and exp = def
            }
            
            $was = s && s.sc[k];
            # W says everything
            $v = load.c[k] = got || was || exp;
            
            $value = got;
            # G implies what is implied
            if (exp != null && got == exp) {
                # not noted
                !was and value = null
                # or was explicitly something else
                elsif (was != got) {
                    debugger
                    throw k+' implied was !got'
                }
                else {
                    ~>7 redundant: g.t, '%'+load.type
                    value = null;
                }
            }
            load.sc[k] = value
        }
        
        !s || load.noknow and return load
        
        me&CB_loading,load,g,w;
        
        return load
    };
    # minimal s.sc actuated
    # unless lies && liesnotok
    me.CB_loading = &acgtcgw{
        $load = c;
        $s = g && gc&s;
        
        $differs = [];
            each kv load.sc {
            v == null and s.sc[k] != null and differs.push(k)
            else
            v != s.sc[k] and differs.push(k)
        }
        $lies = [];
        each ik differs {
            load.liesok and continue
            load.sc[k] == null and continue
            # we said something, it was something else
            s.sc[k] != null and lies.push(k);
        }
        
        # want extra carevision
        lies.length and load.auto = 0; load.lies = lies
        each ik differs {
            load.was ||= {};
            load.was[k] = s.sc[k];
        }
        
        if (differs.length) {
            load.differs = differs;
            # 
            # < Tool for pulling as branch
            #   something differ can understand
            #   all terrain replication vehicle
            if (load.conform) {
                # should not be changing
                load.auto = 0;
                me&waits,"recipe-doesnt-conform",'exp!',6
            }
            if (load.auto) {
                # enacts change
                each ik differs {
                    me&tsc,'~'+k,0,6;
                    $v = c.sc[k];
                    $was = s.sc[k];
                    if (was != null && v == null) {
                        ~>7 redundant: g.t, '%'+load.type
                    }
                    v == null and delete s.sc[k]
                    else {
                        s.sc[k] = v
                    }
                }
            }
        }
        each ik differs {
            load.is ||= {};
            load.is[k] = s.sc[k];
        }
        return load
    };
   
   // CB_proji|o
    # internode rumour mill
    #  s = $t/$scgk=$v
    # %Wind talking of children we should have
    # < &nodeo,Q($t,%Paving-ish) having %ting-ish
    #  < .5 changing %directory
    # redundancy -> difference -> mot cha
    # eg check child dige, sends trouble
    # or !exists, input
    # me&gromps,R,'Wind','t,dige',Things&Wind
    me.CB_proji = &acgtRtks{
        !Rs&ball and throw "!ball"
        # the proj/o/#$t/$d
        $g = me&rollbsc,R,'grype/proj';
        $reset = !fio(g,'o',0);
        #R.t.includes('ick') && reset and ~>4 reset: R.t
        # from here
        $go = fio(g,'o');
        # named $t
        $gt = fio(go,t);
        
        $ks = k.split(',');
        ks.length != 2 and throw "only 2-spheres"
        ks[0] != 't' and throw "for t,$scgk"
        # one $scgk, many R/$t
        $k = ks[1];

        # match against what we have
        # < should only be (%ting, but is implied
        #   we have no other stuff in the Know yet, but could
        #   supposedly the implications would change,
        #   as u climb
        $have = {};
        me&ioty,R,'ball' .map(&n{
            hak(s,n.t) and have[n.t] = n
        });
        
        $news = [];
        each tv s {
            $r = have[t];
            # < these should be elvised in there
            #   to sleep the pile. write these:
            #   e $r -proj-cha $lc
            $d = G&Cye,[t+"%"+k,1,{s:v},{proj:gt,nk:'sc',gk:k}];
            fio(gt,d);
            dc&R = R;
            if (r) {
                dc&r = r;
                $z = rc&s;
                
                !hak(z.sc,k) and ds&cha = 'new'
                else
                z.sc[k] != v and ds&cha = 'diff'
                
                # sans %grype:
                ds&cha and me&ha,R,{imps:t,wants:z,openey:1,cause:d};
                
                # < gone is dcR != yfuture at the receiving end
                #   with non-fatal not in Rc&N
                $og = me&rollbsc,r,'grype/proj';
                $ogi = fio(og,'i');
                me&givi,ogi,R.t,d;
                # >1 them, springs into lies fixing
                # anything should become %%openey if %%trouble?
                ds&cha && !Rs&noprojcha and ac(r,'trouble',d)
            }
            else {
                # sans %grype:
                # may input our belief, to wake up wrong
                $b = Cye([t,1]);
                b.sc[k] = v;
                $q = {imps:t,s:b,cause:d};
                me&may,R,'input','once',q;
                
                ds&cha = 'not';
                # create there
                $d = {may:'input_'+t,s:t,tsc:'y'};
                me&rolltog,R,d and me&input,R,t
                me&walls,d.n,'b:2.2h5';
                news.push(d.n);
            }
        }
        if (news.length) {
            # one thing here about the many not there
            $d = {may:'input_*',s:'Unhad:',tsc:'y'};
            if (me&rolltog,R,d ) {
                news.map(d => me&input,R,dc&s );
            }
            $n = d.n;
            ns&fs = 8;
            ny&cv = 0.4;
            news.map(d => me&modopt,R,n,d );
            me&walls,n,'b:2.2h5';
            me&mtsc,n,"\n";
        }
    };
    me.CB_projo = &acgtR{
        # the proj
        $g = me&rollbsc,R,'grype/proj';
        # into here /from.t/$d%proj
        $N = me&ioty,g,['','','proj'],['i','',''];
        each id N {
            $Kn = null;
            # the groupthing.t we're going for
            $t = ds&gk || '?';
            each in Rs&grype {
                n == g and continue
                $Km = nc&Km;
                !Km and continue
                if (ds&nk && ds&gk) {
                    # < generalise from sc
                    ns&nk && ns&nk != ds&nk and continue
                    Kn = fio(Km,ds&gk);
                }
                else {
                    throw "grimp match "+d.t
                }
            }
            if (!Kn) {
                # may not have gk yet:
                #   make extra grype (usually for type groups)
                #   listens to all grypes for %groupthing/%changey
                $ge = me&rollbsc,R,'grype/sc';
                $Km = gec&Km ||= G&Cye,['may',1,{},'almost,grouping'];
                Kn = fio(Km,[d.t,1,{s:t+'!'},'almost,groupthing,fs:7,mar:0.3']);
            }
            Kns&almost and Kns&opa = 0.5
            # noted, might match history of this gk
            $r = dc&R;
            # < want things for fs&changey to be persistent
            $n = G&Cye,["Projected-from-"+r.t,7894,{projin:d},'dis:2'];
            n.t += " to s&"+t;
            me&walls,n,'b:2.2h666';
            fio(Kn,n);
            # < make namepath looking
            #   also if Mlimits dub all ^^^^ means parent loop
            #     make larger recycle symbol
            $up = fio(n,['fromabove',1,{s:'^'},'hs:999']);
            if (ds&cha) {
                # projected difference
                # noticing out of date from our memory
                ns&changey = 1;
                ups&fs = 13;
                fio(n,['projected-from',2,{s:r.t},'fs:6,hue:166,mat:-1']);
                fio(n,['projected-'+t,3,{s:">"+dc&s},'fs:8,dis']);
            }
        };
    }

