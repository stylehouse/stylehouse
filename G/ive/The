me.Sch_The = &acgt{ return [
 ... me&Sch_Go ,
 // The** !!!
    
   =The %TX <-> This -pi
    basically
     the look and respond circuit
     user generating selections
      could mean any of the coordinates for it
      a multiple select should find language that expresses it
      
    many E**
     R'The' does -hat or -Bat
      makes $E** to $D**
       < from $D** as decoded
      < display entirely via $D
      encodes $D
     # used to|from:
     Run|Thy/
      This...$got
       usu -hat etc as a data dumper
       in-time activity
      The...$exp
       usu -Bat pile for E%TX input
       are essentially expectations
        might be a negative assertion
        might modulate the encoding
      any The informs its This
      Thy/This informs Run/The and more
       and thence Run/This...
     # experienced by:
      @Gnome, see w:Go
       essential it @Run/This|The
        inflating This** in time, reading out
     
    one E**
     < breaking up view controllers into composed units
        data sources, navigators, interactions, etc
      
     $E
      seeds of $R
      $E/* become @3
      E%TX and E%RX
       rudimentary ref recycling (&Eref*)
     $D for recording
      Dc&pi changes as it types up:
      -val
       -hash
        -C
         -n locatable from a namable node
       etc
      a one-line instant of data-point observation
      in the $D-sphere
       is the storable -log/**
     
     E%RX
      simple paths in ($t**) can be made
      < everything else
     
     < $D @6 sleps?
       may be able to 'OK', no modulat default
     
     < $D @7 converts to modulat
       $D sometimes rehydrates
        without needing the data (Rc&s)
         $D-got
          may make local expansion of sc&s it has
           but want a new -log to confirm it in-time
         $D-exp
          cannot expand
     
     < $D @8 is the click-unit
       somethings in the modulat may further instruct:
     
    =cut
  
  
  
  # through the valvework of:
 # to cluster state:
 // &Piing R:'The'
 
   # < Thy%client=Run:Gome
  // 1 %Piing nodes &Thee &Theing
    ['Piing',0.291,&acgtRs{
        $x = me&Thee
        
        !xs&Gome and me&tc,'noGome','G'
    },'ift,D'],
    &{
    # on eg s)%Piing, &bin for s**)%Piing, %E,onlyish etc
    me.Thee = &acgt{
        $R = me&R
        # recur id
        $c = {}
        $x = me&Theing,c
        xy&c = c
        # %Piing**
        !c.long and throw "Thee!long"
        me&bin,c.long
        # E**
        Rs&TheingE = 1
        Rs&onlyish = 1
        return x
    }
    # identity spreader, more of the above, &G(n)ome_Jx
    me.Theing = &acgtc{
        $R = me&R
        $s = Rc&s
        Rs&Theingx && c and throw "const"
        Rs&Theingx and return Rs&Theingx
        
        # finds ^^%client and (here|their|Ying)/*
        $x = me&Gnome_Jx,R
        Rs&Theingx = x
        c ||= {}
        # believing something
        # < R%tow going?
        ss&tow and Rs&tow = 1
        
        # receivable somewhere
        Rs&elvis = 'FishElvis'
        
        c.long ||= T.act.t
        c.long and me&reaw,R,c.long+',elvis,tow'
        c.short ||= c.long
        c.short and xy&go = me&acting,R,c.short
        c.in and me&bin,c.in
        
        return x
    }
    },
  // 2 %TheingE** nodes keep s|E** outspheres
    # so RsE outspheres. R%E(y&R=R)
    # R%TheingE**/Ec&top - containers also have E
    # R%E
    ['TheingE',0.291,&acgtRs{
        me&bin,'TheingE'
        me&reaw,R,'TheingE,E'
        Rs&rowish = 2
        
        me&rollbs,R,'E'
        $E = Rs&E ||= Cye([R.t,1])
        Ey&R = R
        Es&z ||= []
        
        # linking to the s**
        # < could rename Ey&outs?
        #    they may also Ey&Outs=Nine** 
        # ! impersonating E/-seven, is strange
        Ey&ers = s
        
        # < i $E^@s o R^/%E
        $p = Ry&up
        if (!ps&Piing) {
            Ec&uber = 1
            # < &Effected %hire,efrom=Nine
            #Rs&client = 1
        }
        
        # E**
        # what &Sopi &piinto does, Ey&C=s
        $p = Ry&up
        ps&E and Ey&up = ps&E
    },'ift,D'],
    # realising s//E, now that &Saturn eg sets sc&pi
    ['TheingE',0.2951,&acgtRs{
        $E = Rs&E
        # s->Ec&pi
        if (sc&pi) {
            # < going? out-E is not c&pi, only s and E/-pi
            Ec&pi = sc&pi
            # < GOING to look like a &Sopi, eg &piEight
            # outsphere s to outsphere E
            #   to inner outspheres (E/Six-Log)
            #   and inspheres (E/-seven for Ec&seven):
            s.y [ sc&pi ] = E
            Ey&C = s
        }
    },'ift,D'],
    # (s|E)**
    ['TheingE',0.296,&acgtRs{
        $E = Rs&E
        $x = me&Theing
        $p = Ry&up
        me&hideyfix,R
        xy&go and me&nu,"E",E
        # s**
        me&supsphere,s,x
        # E**
        ps&E and me&fiu,ps&E,E
    },'ift,D'],
    &{
        # used by %TheingE,
        #  Travel/$t%Travelable might be %eph
        me.supsphere = &acgtsx{
            $R = sy&R
            if (R) {
                $p = Ry&up
                $z = pc&s
                # %eph while %%Go-created, up permanence:
                if (Rs&eph && x) {
                    x.ro('%eph') and me&fiu,z,s
                    else return
                }
            }
            else {
                $z = sy&up
                !z and return
            }
            # may panic when sy&up not reciprocal
            !me&fiu,z,s,8 and me&tc,"Notabove!",'b'
            me&fiu,z,s,2
        }
    },
  
  // 3 %Piing** influx, &Piing
    # influx router
    ['Piing',0.295,&acgtRs{
        me&Piing_inst,R,s
    },'ift,D'],
    # on the -six (which is really -hat|Fez...)
    ['Ethinging',0.2951,&acgtRs{
        $E = Rs&E
        # keep a y&thing on the -six
        #  since the eg E-haty&thing may not persist
        # < perhaps -six y&thing@1?
        $t = Ey&thing ||= Cye([E.t,2])
        # and tend not to display,
        #  until Nine/TheFe Effects awakeness at us
        Rs&Ehidey = 1
    },'ift,D'],
    ['Piing',0.296,&acgtRs{
        $E = Rs&E
        if (Ec&uber) {
            # see &Sarn, decides a schema
        }
        else {
            # elvis anywhere
            hak(sy&Todo) and me&Piing,'-Bat'
            # do this node , ie -> A:n
            sc&pi and Ey&main = me&Piing,'-'+sc&pi
        }
    },'ift,D'],
    # < index u. L
    ['Piing',0.369,&acgtRs{
        $E = Rs&E
        # children (/**) first:
        me&Ring,R,{inside:R,ov:555}
        # finish R/%Pier:
        me&finishPiing
        # before %ball 38 draws /%fix-tures
        $e = Ey&main
        if (e) {
            $r = ey&R
            rs&lookat and me&Piing,'lookat-Bow',{s:rs&lookat}
            me&finishPiing
        }
    },'ift,D,sleeping'],
    &{
    # finish R%Piing/*%Pier
    me.finishPiing = &acgtr{
        if (r) {
            r = me&yfuture,r
            !rs&Piing and throw "R!s**"
        }
        r = r && [r] || []
        me&ioR,...r,'Pier' .map(&r{
            #~>3 Figaro: r.t, r.y.cv
            me&Ring,r
        })
    }
    },
  
  // &Piing_inst unpack intent
    &{
    # grows|culls **%Piing    proto &Superpath
    #  lifecycle management
    # %Piing 296 arrives This/
    # < see also %Travelables using &balforward
    #   &Pii (originally &Rsci inside it)
    #    was going to let Ec&uber know of i,
    #    and Gnome knows all Ec&ubers?
    #    same way lv would let E know it has ~
    me.Piing_inst = &acgtRs{
        $E = Rs&E
        
        # R%* to apply
        $scN = []
        $Names = me&Names_collector,R
        $Saturn = me&Saturn,<<'',[s]
            i @z <-+@mix @n||=@inst
                i &locate_Sarn@2 &being_inst $s** $sc={} $mix={}
            o <- %%inst
        
        # iterate the middle leg, which always has $sc
        #  $mix goes nowhere unless $s/@z
        Saturn.c.N.map(&a{
            # < these as io expr. ie @z && @n||=@inst +@mix-> @z
            #   everything right of && becomes required
            a.s != s and debugger

            $n = a.inst
            if (n) {
                $usu = ns&listen_node || ns&heard || ns&n
                !usu and debugger
            }
            
            if (a.here.pi == 'This') {
                # the dualism. is an allism.
                #  the This,The split is created in &Sarn
                # < but could add %%inst according to input
                a.Name = s.t
            }

            # R:here behaviour
            # < tractogram
            hak(a.sc) and scN.push(a.sc)
            Names.from_ax(a)
        })
        
        $sc = {}
        scN.map(c => ex(sc,c))
        me&sync_inst,R,s,sc
        Names.done()
    }
   // &sync_inst
    # controlled revoking of Thy...Lab styles
    me.sync_inst = &acgtRsc{
        me&rollbs,R,'inst_deletable'
        # remember and shutdown when ...
        $were = me&rollbs,R,'instcla'
        !were && !hak(c) and return
        were ||= {}
        $are = ex(ex({},were),c)
        $running = 0
        $gone = {}
        each kv are {
            if (!c[k]) {
                if (me&rollbs,R,k+'_gone' ) {
                    # they finished revoking etc last time
                    delete were[k]
                    gone[k] = 1
                    continue
                }
                R.sc[k+'_going'] = 1
                ah(R,'inst_going',k,1)
            }
            R.sc[k] = v
            me&reaw,R,k
            running++
        }
        ex(were,c)
        Rs&instcla = were
        if (hak(gone) && !running) {
            # < last one running causes %inst_gone
            Rs&inst_deletable = 1
            delete Rs&instcla
        }
        # allows %%inst... to come back
        # < &SuperLab reset needed
        running and delete Rs&inst_deletable
    }
    },
    ['inst_going',0.7,&acgtRs{
        me&tc,"(going:"+joint(haks(Rs&inst_going),',')+")"
    },'ift,D'],
    ['inst_deletable',0.7,&acgtRs{
        me&tc,"(Z)"
    },'ift,D'],
   // &Saturn nametypepath devise
    =pod
     i @Run/-This/-Eight/-seven/**
      pretty simple
       for %%inst,listen_node=Node/Path
        invent 'n:Node/Path'-Eight/now-seven/''-xat
     
     i @Thy/-This/#@Fine-Labine/@-Lab#@n%ThyLab/c&s=@n
      since an i, Names @Thy + @Lab may be defined
       otherwise (+usu &Shx) they would be demanded
      @Fine is found via etc
       it would otherwise want to exist
     in &Saturn, then:
      on s-Labine, the -Lab part must be solved:
       #@n takes $n
        and makes @Lab in its image (io #spacer)
      on s-Lab:
       %ThyLab is applied to $sc
       and its c&s holds the item, $n
        in some state of decoding...
    
    =cut
    # R%Sarndat = &Sarn schema on the Ec&uber
    ['Sarndat',0.29611,&acgtRs{
        $E = Rs&E
        !Ec&uber and throw "&Sarn inside &Sarn"
        me&reaw,R,'Sarndat'
        # just remembers %Sarndat=&Sarn defining schema
    },'ift,D'],
    &{
    # @Run and @Thy define their %%inst-ability with io
    #  to be completed by &Saturn delivering %%inst
    me.Sarn = &acgtscq{
        $g = me&Sarg,'Sarn',s,c,q
        return g
    }
    # tu: stuff the machine knows is happening
    # < eg being the first hop when %%efrom != s^
    # given protocols to handle:
    #  $s** building
    #  $sc  styles of $s (R%*)
    #  $inst = %%inst,n thing arriving
    #   once a from-index is built to womb it:
    me.Saturn = &acgtscq{
        $R = me&R
        $x = me&Jx,R
        q ||= {}
        # < io climbing: ^^%Sarndat{.path,_dist:pathi}
        #   that {} taking Sarndat,Sarndat_dist
        #   and should not usually:
        # includes everything in between
        $N = me.cby(R,'^^Sarndat')
        $Sarn = N[0].sc.Sarndat
        q.est = {Sarn,Sarn_dist:hak(N)-1}
        # n is being stretched by &Piing_inst relay
        $Saturn = me&Sarg,'Saturn',s,c,q
        $s = Saturn.c
        x.ro("Sat",{}) and me&Piing,'Satur-hat',{s,dl:4}
        
        return Saturn
    }
    },
   // &Saturn %%listen_node strategy
    # notify E%target
    #  set by &Saturn for an %%inst,listen_node
    ['listen_node_n',0.29611,&acgtRs{
        $E = Rs&E
        !E and throw "should E"
        me&reaw,R,'listen_node_n'
        # < &Saturn nodei:
        # < o %%listened,replyto:@Eight -> o E/-n/%target
        #   Names for @Eight, E is R%E,
        #    %target is where to ark=s position
        $En = me&fiu,E,'-n'
        $target = Ens&target
        # < &Names_get for -Eight, or a particular Ey&thing
        #   see fi&t for wanting formats|parts
        $Eight = me&Names_get,R,'Eight',1
        me&nodei,R,target,{listened:1,replyto:Eight}
        #me&nu,"listen",{E,En,target,Eight}
    },'ift,D'],
    # target replies with objects (that change)
    #  set by %ulog
    ['listen_node_listened','57',&acgtRs{
        me&reaw,R,'listen_node_listened'
        
        me&jaa,R,'listened' .map(&n{
            # < general repliable
            $to = ns&replyto || ns&efrom
            each kv R.sc {
                !k.endsWith('W') && (!isob(v) || isC(v) || !isC(v.A)) and continue
                # the &Saturn %%inst,listen_node there coops these:
                $s = {heard:k,s:v}
                k.endsWith('W') and s.piable = 'Womb'
                me&nodei,R,to,s
            }
        })
    },'ift,D'],
   
  // 8 %Piing node sleep|wake
    ['Piing',0.29599,&acgtRs{
        #me&notice_wakesleep,R,s,'Pi3'
    },'ift,D,sleeping'],
    # 
    ['Piing',0.55,&acgtRs{
        $x = me&Theing
        $E = Rs&E
        !E and throw "no E"
        #me&notice_wakesleep,R,s,'Pi6'
        
        if (Ec&uber) {
            # topmost
            me&PiiEuber_Epending_55,R,E,s
        }
    },'ift,D,sleeping'],
    &{
        me.notice_wakesleep = &acgtRst{
            $ind = indent(sy&path)
            t = t+" "+ind+s.t
            Rs&sleeping and ~>6 sl: t
            else {
                ~>3 aw: t
            }
        }
    },
  
&{
 
 // E life
  
  
  // < Aip
      =Aip
       things add on, inside, etc
        must add to the end (eg [3]->[4], [2,1]->[2,2])
        [1]/[1,1] # first inside turns up
        adding the second may tick eg Eight:
        [2]/[2,1] # second
        or simply grow:
        [1]/[1,2] # second
        simply growing, as opposed to:
         [2] <- [1,1], [2,1]
         the everyone-at-different times stitchup
         gc for [1] via etc
       belief-space:
       %wrinkly:
        there is a 0, for positioning before something else
         then it just gets turned up, unless more:
          [1,0,1,0,1,0,1,0,1] = final toppost to a list of 5
        periodically ironed out
        eg hap-time:
         step1    [1]
          /sprout [1,1]
         step01   [1,0,1]
        = seq-time:
         step01   [1,0,1]
         step1    [1]
          /sprout [1,1]
        putting itself before A in Aip timespace
         allows eg chunkology to endlessly divide
         giving weirder addresses to newer bits
         then the chunks>markers must reindex themselves
         whole point is enduring ids
        # ~~ lv el:8 are used to position else after it
       %replacey:
        there is 1, if we get all Aip to start at 2
        # ~~ el:2 definitive, el:1 more a contender
        to contend with something else
        a flag
         # does an empty A count? yes
         #  perhaps @Show takes e:A (keypress) as "no", C "yes"
         #   if we say we don't want A, it will happen, and then builds good
       %hyper:
        anything else you (and your network)
        want to encode 

       overall:
        space-safe space as time
         address infinite light cones
         safe for rename|move over the network
         give voice ways to move
        Ness or Point could be constructed for sub-times
         they should emerge or submerge from Thying
        variant for cvf() presented stuff
         geometry for evolution
      
      =cut
  
  // < time
      =time
       are Aip intralaced
       eg
        Story/Plot/Point, Ness (as ninec&Into)
         and same in @Pro
          # all the way down. %%Go moving around, flock urges...
        are A time we can connect A time to
         $seven may
          %ip.Ness=[1]
           us in the phenomenon of many -Ness
           when we el2, become part of Ness
            predictable sequence, compressed
          %ip.This=[4,3,2,4]
           if refreshing -hat
           and tracking all wake %Piing
           where the alignment completely falls off
            it is for joining disparate objects
          %ip.Eight=[2]
           if changing -hat
           versions all going %%oust to Eight
           test results usu dont change after observation
          %ip.seven=[2]
           if visiting same time another time
           test results usu dont loop time
           suppose seven/seven is many envelopes of time
            < looser enclosingness... brackology inter-cell juxtapositions
            seven are where|when
            Eight are who|what
             they could be structured variously
         some
          as decided by io expr anywhere # Fame
           eg @Gnome/@Reside wait-for-quiet after some spawning
            time:@Reside:some-spawning <- @Gnome time:quiet
            the linear time:@Reside
             tags :some-spawning along it
              mem time:quiet as it was then
              # similar to the way %%rec:Word:Piles:ons
          of the above %ip might be included in seven%D
           so we must other Eight++ to include that here
            the moment we see ~$six%string coming
             Y:Eight must be started, to give out an ip
              it can sample the Bstack, time it came from
               loads of webbing that debug might switch on
               < sorting graphs
            seems basically like an -Effect could move %%oust
             we always know up?
          which nine/Ness/seven is free to disregard
           ie when path fugues
            we repeat|play for mutation
            then merge like there was no sidetrack at all
             by simply lying to make the Fe exactly ok
             so all this info is free to be left out etc.

        eg the one true -seven happens in such Ness
         because that is what the time was when it el2
        time skews noted, over time
        we have events noticing the link, usu from a side
        it should end up conveniently [1] for Ness 1, etc
         and thus be compressed away
          if included (in Outs**) usu a run until then?
           almost instruction, yet doesnt take -Lab meditation?
           measuring time considered normal.
      
      =cut
  
  # front end
  // &Piing into $E** proper
    # R'Peace'|Outs|$s** spreads nodes that c&pi
    #  i $s/-somepi spreads nodes pi-ishly
    # can i -long/bran-ches/of/nodes-hat
    #  will z.t||=long, wont c&pi||=of 
    me.Pii = &acgtscq{
        $R = me&R
        Rs&Pier and throw "use &Ei in R'The'"
        # s,c =  givens,'new' or Rc&s,'new'
        isst(s) and c = s; s = Rc&s
        # &Rsci does &dupfiu if q.dupi, eg as A.h.sixer
        $v = me&Rsci,c,{v:s},q
        !v and debugger
        return v
    }
    
    # node leaps into R'The' with c.t|pi
    me.Piing = &acgtcq{
        isst(c) and c = me&t_tpi,{t:c}
        q and ex(c,peel(q))
       // Eplacing
        $x = me&Theing
        $R = me&R
        $s = Rc&s
        $E = Rs&E
        # last permanent E, of a node
        #  aka RE|PE|Ep herein, is sometimes E in E/e
        $RE = E
        $del = me&modelta
        
        # resolves sy&RXing (to the node), -> E below
        # < make clearer this is RE
        # < sort all these hooks
        me&PiiE_pre_Piering,R,E,s,c,x

        # A thus much while Piing@296, the rest @36
        c.ov ||= 333
        # the REy&main=E, what sc&* is about
        #  sc&* -> &Piing c.*
        #  nex(c,s,c) extends what isnt in c.* yet
        c.pi == sc&pi and nex(c,s.c,c)
        
        c.Pier ||= c.pi || sc&pi
        c.t == '' and c.t = "-"+c.Pier
        c.Top = 1
        $V = c.V = s
        # the first insphere E
        $E = c.E = Cye([c.t,1])
        # knows the outsphere E
        Ey&up = RE
        # stops climbing there
        Ec&top = E
        # outsphere itself (V)%ball) provides travel
        #  bunch of indexes for everything we could climb to
        #   ie avoid checking all Towering nodes for /$t etc
        # i %TX/* o Troom
        #  receives it here for E**
        V && Vy&RXing and fi&RXi,E,Vy&RXing
        
        # then starts matching, usu in &Eing
        $M = me&Pieri,RE,E
        
       // Ring args
        # separate the args for &Ring later
        $Ringc = tax({},c,'ov')
        # clearly rc&* = c.* > sc&* > Ec&* > defaults > Rc&*
        # rc&nl|dl comes from, in ascending precedence:
        #  Rc&* inheriting to rc&*
        #   a thing that R do
        #  -suchpi's sane defaults here
        #   better than inheriting nl|dl through a %Top
        #  &PiRet/&Pieringi
        #   may have Ec&nl|dl|rc_mix over it
        #  &PiRet
        #   then takes rcbits from c over any of that
        #    see 'sc&* -> &Piing c.*'
        # < let them suchpi@02, very-early R'The', here
        # < was not setting these properly (it's %Top not %top)
        #   they may want tuning
        c.soft_rcbits =
            c.pi == 'Womb' ? {dl:26,nl:166}
        #   was nl:166:
            : c.pi == 'Fez' ? {dl:26,nl:300}
            : c.pi == 'Bow' ? {dl:12,nl:122}
        # -hat etc should get it done by:
            : {dl:15,nl:300}
        
       // &PiRet
        # contains &Pieringi, which:
        #  E[cs]&knownbits -> r[cs]&*
        #   along with explicitly eg Ec&rsc_mix
        # &PiRet gets the last word on rcbits, from c
        #  as in, we dont copy sc&* or c.* to Ec&*
        #   it is already above on sc&* or otherwise implicit
        #    we only intimate the limits as they happen
        $r = me&PiRet,R,c
        fatal.isR(r)
        ac(R,'z',r)
        if (c.Top) {
            # &Piing is always %Top
            # < GONER:
            rc&top = r
            # capsule of %TX
            Ec&top != E and debugger
            # transact Ec&X.ref
            me&Eref_begin,r,E
            
            rc&d = 0
            delete rc&refR
            delete rc&refs
            # lets /Display** recycle Elements
            me&arriveRbitX,r,r.t
            # new J, normal mind
            rs&task ||= 'Pi_The'
        }
       
       // E box
        # < help node modulat break
        me&ts,"lines-breaker","\u0020"
        me&boxcap,'E:'+r.t (&ml{
            $con = ms&controls = {}
            lc&s = r.t
            me&walls,m,'b:1.2h6'
            ispi(sy&up,'seven') and mc&state_upon = '@seven'
        
            # the tendency to hide eg -seven/*
            if (Rs&Ehidey) {
                me&Effect,s,E,'hidey-six',{hid:1,ope:0}
            }
            # < TX to unhide?
            if (M.some(aq=>ahsk(aq,'sc','qua','ope'))) {
                me&Effect,s,E,'RX-ope',{RXope:1,ope:1,dom:1}
            }
            
            if (Ec&pi == 'Bat') {
                # always open
                me&Effect,s,E,'Batope',{ope:1}
                !V and debugger
                me&tt,'--mem' (1) and Vy&Todo = []
            }
            
            # the buttons (this &tt) override the jets (other Effect:ope)
            # < first async Effect (if possible - wasnt always hidden)
            # < also, could become -Bat tt, so it also ope=-1 etc
            # setting shares with %Foldabline
            # < for all -six from -seven, -Eight
            #    and -Eight could decide their relevance, last two?
            #     we keep subdividing Eight id when we want sub-time (-seven)
            me&tt,'D' () and con.D = 1
            # < this should make the tt:D glow
            !cvlt(Rs&boost,1) and con.D = 1
            con.D and me&Effect,s,E,'togope',{togope:1,ope:1,dom:1}
            
            # no -Effect layer
            # < may change. might sleep well?
            #    or Y:Easy instead, for extra tunnel sanity
            # < is too late, now E/e, Epending, etc
            me&tt,'R' () and rs&sleeping = 1
            
            
            # ope may be set to 0|1
            $ope = me&Effected,E,{ope:1}
            ope != null && !ope and rs&noDisplay = 1
            
            
        })
        $arrow = me&Effected,E,{arrowy:1}
        # < why not into C/*?
        arrow and me&textarrow
        
       // &Ring hence
        me&Ring,r,Ringc
        
        del()
        xy&go and me&zu,"r:"+r.t,r
        xy&go and me&zu,"E:"+r.t,E
        return r
    }
    
    # i E/e hence
    me.Ei = &acgtc{
        $R = me&R
        !Rs&Pier and throw "use &Ei in R'The'"
        $E = Rs&E
        !hak(c,'t') and throw "!t"
        c.t = ""+c.t
        $t = delete c.t
        $e = me&dupfiu,E,t
        c.cv and ey&cv = scaf(c.cv); delete c.cv
        c.pi ||= Rs&Ei_pi || Rs&Pier || 'blank'
        # &Ei c.* -> ec&*
        ex(e.c,c)
        return e
    }
    # lowlevels
    # after somehow &Pieri, this &Pieringi
    # 1 R/r for E/* from c
    me.PiRet = &acgtRc{
        # GOING
        if (Rc&nofurther) {
            me&strange,'nofurther'
            me&ha,R,"toomuch:nofurther"
            return
        }
        
        # 11 new
        # < GOING these would be only c.E.c.*?
        $soft = delete c.soft_rcbits
        $rcbits = tax({},c,'nl,dl')
        
        # R'Peace'-like Ringing
        # < Voicing
        $r = me&Ret,R,c
        c.Top and rc&N = []
        ry&cv = 0
        # used to put on tape or not depending on limits
        #  now %limit etc are the way, &PiRet already mediated by &Pieri
        # < splice in re ry&up, neighbours
        rc&N.push(r)
        # greater precedence than Rc&* inheriting to rc&*
        #  a thing that R do
        hak(soft) and ex(r.c,soft)
        
        # main act, pre-&Ring
        me&Pieringi,R,r,c
        
        ex(r.c,rcbits,r.c)
        if (!c.Top) {
            # some r.c.* settings need more to work elsewhere
            # < all the stuff heading for r.c mapped out
            $alter = grep((v,k) => R.c[k] != r.c[k], peel('nl,dl'))
            if (hak(alter)) {
                # < these create %adepth to operate over
                #   still contribute to the above nl etc
                # < seems like time would do this
                alter.nl and throw "< altering nl"
                if (alter.dl) {
                    rc&dlbias = Rc&d
                }
            }
        }
        
        # to &Eing
        return r
    }
    # 12 &Pieringi makes three spheres
    # < C/** should represent E/**? D/**?
    me.CED = &acgtR{
        # C display
        $C = Rs&C = Cye([R.t,1])
        Cy&R = R
        
        
        
        # E itself, usu passed in
        $E = Rs&E ||= Cye([R.t,1])
        Ey&R = R
        # E**
        $p = Ry&up
        ps&E and Ey&up = ps&E
        
        
        
        # D record
        $D = Rs&D = Cye([R.t,1])
        Dy&R = R
        Dy&E = E
        Ey&D = D
    }
    
  # schemes cling around the machinery
  // &Piing       <  doc points of %E** inspherings etc
     // outsphereings # besides those above
        # T from the outsphere
        me.PiiE_pre_Piering = &acgtREsc{
            # < to be many, versioning
            $tc = me&Thetower,R
            $es = tc.es
            delete sy&RXing
            es && esy&TXing and sy&RXing = esy&TXing
            # then get r:
            c.pre_Pieringi = &re{
                me&PiiE_pre_Pieringi,R,E,r,e
            }
        }
        # < hoist more &Piering
        
        # re has become, re the outspheres:
        me.PiiE_pre_Pieringi = &acgtREre{
            # E** was
            $be = me&fiu,E,e.t,8
            if (be) {
                ec&b = be
                me&tc,'b','6y' .y.cv = 0.297
            }
            # E** is
            # < only staged, via ^^^Piing
            # < recycles E/e? when %Piing%sleeping?
            me&fiu,E,e,1
            
            me&PiiE_Epending_1,R,E,r,e
        }
     // ^^^E%Epending[e]
        # ^^%Pier (r &Piing creates) pends at ^^^%Piing
        me.PiiE_Epending_1 = &acgtREre{
            # E** transmit stuff upward immediately
            #  e/ref/ is staging to PE/ref/ (in &Eref_begin)
            #  transact also unsorted list of innards,
            #   which may export what we will be looking for
            $Pr = me.cbu(r,'^^^Piing')
            $PE = Prs&E
            !PEc&uber and debugger
            $pend = Prs&Epending ||= []
            pend.push(e)
            ac(r,'commit',&{
                grepout(pend,e)
            })
            # < mEy&R shall have E staging /ref/ that would be in mEc&X
            #   they must be checked for positioning...
            #R.t == 'Bowler' and me&zu,"topE",{mE,tE}
            # ...&Pieringi does &Eref_begin
        }
        # topmost
        me.PiiEuber_Epending_55 = &acgtREs{
            $pend = Rs&Epending
            # < throw, this is likely to be missed
            hak(pend) and debugger
            hak(pend) and me&nu,"still-pending",{pend}
            hak(pend) and ~>3 still-pending: joint(pend)
        }
     // re the insphere
        me.PiiE_pre_Pieri = &acgtREre{
        }
            
            
  # io locale
  // &Risc
    # < climbing funcs.
    #    &Rsci does long paths
    # < This** would have a @log column, where we can find %says=such
    
    # < rename &Ris|&Ros ?
    # &Risc,This,'long/paths//-Log/etc%%Erefc'
    # < optional v, find R etc
    #  < for &ha,s,shade,mix, unless sy&brack
    # < a &Sarg io prototype. level up from &fiu
    me.Risc = &acgtvscq{
        # climbs s** if given R
        v = sof(v)
        
        # < $jaa = s.splot('%%')
        #    ie grep|grop
        #    < mop() removes from source 
        #   $user = ('@')splot.email
        #    ops on the front of a thing
        s = s.split('%%')
        $jaa = s [1]
        s = s [0]
        
        $to = me&Rsci,s,{el:8,v},q
        !to and return
        $v = to
        
        if (jaa) {
            jaa = jaa.split(" ")
            if (jaa[1]) {
                # eg '%%such 1' to return first value of each
                jaa[1][0] == '1' and $jaac = 1
                # eg '%%such 11' first value on first row
                jaa[1][1] == '1' and $dotheone = 1
            }
            jaa = jaa[0]
            $r = vy&R
            !r and return
            $N = me&jaa,r,jaa,jaac
            # fatal to many|N>1
            dotheone and N = theone(N)
            v = N
        }
        
        return v
    }
    # long/paths/-Log/etc
    #  no multiplicity
    #   ! -Log means C.t="-Log" if on RE, "Log" if not
    #     eg at RE/-Log, or Run/This
    #  used by &Pii sparely
    #  may // to RE, y&Ry&E
    #  may %%brack
    me.Rsci = &acgtscq{
        c ||= {}
        q ||= {}
        $R = c.R || me&R
        isst(s) and s = {path:s.split('/')}
        !s and s = {path:[]}
        c.gk and s.path.unshift('%'+c.gk)
        $putsz = hak(c,'s') || hak(c,'n')
        
        $z = c.v || R
        $last = hak(s.path)-1
        each it s.path {
            !isst(t) and debugger
            
            if (!hak(t)) {
                # s**-Log//-Log goes into the main &Piing E
                $RE = me&REof,z
                !RE and throw "handle creating RE elsewhere?"
                z = RE
                continue
            }
            $tc = me&t_tpi,{t}
            t = tc.t
            $gk = tc.gk
            $pi = tc.pi
            
            $v
            # see ! -Log means C.t="-Log"
            pi and t ||= (zy&ers?'-':'')+pi
            gk and v = z.sc[gk]
            # < bal Rc&s/$v, for c.R%ball
            #   or schedule|other nearby y&R
            elsif (i == last && q.dupi) {
                # ~~ &Ei, serialnumbers same $t
                v = me&dupfiu,z,t
                # < wants to resolve $n, one at a time?
                c.el == 8 and debugger
            }
            else v = me&fiu,z,t,c.el
            
            # i %limit/%toomuch=1 or &Rli,'toomuch',{s:1}
            $puts = putsz && i == hak(s.path)-1 && hak(c,'s')
            $putz = putsz && i == hak(s.path)-1 && hak(c,'n')
            if (putz && v) {
                if (gk) {
                    !isar(v) and throw "putz!ar"
                    if (c.el == 8) {
                        # o $l%somegk/$n tests for $n in %somegk
                        #  ie &Rti,'limit/%somegk',{n:e}
                        # returns the /$n as array
                        return me&Rscin,s,c,q,v && v
                        # if !v it may also fail @el==8:
                    }
                }
            }
            if (!v || (puts || putz) && gk) {
                c.el == 8 and return
                !gk and throw "never happens: &fiu creates el<8"
                
                if (puts) {
                    puts = 0
                    v = c.s
                }
                elsif (putz) {
                    v ||= []
                }
                else {
                    v = Cye([gk,2])
                }
                z.sc[gk] = v
            }
            if (isC(v)) {
                # care
                if (R == z) {
                    gk and vy&R = R
                    else {
                        # < bal Rc&s/$v
                    }
                }
                if (pi) {
                    !vc&pi and vc&pi = pi
                    vc&pi != pi and return
                }
                if (puts) {
                    puts = 0
                    vc&s = c.s
                }
                elsif (putz) {
                    putz = 0
                    $vz = vs&z ||= []
                    # returns the last C the /$n is in
                    #   $z:thing/%bunch:v/$n=stuff
                    return me&Rscin,s,c,q,vz && v
                    # < conserve/score?
                }
            }
            if (putz) {
                !gk and throw "never happens: isC putz"
                putz = 0
                # returns the /$n as array
                return me&Rscin,s,c,q,v && v
            }
            !v and return
            z = v
        }
        return v
    }
    # v=[] for /$n-ism, adding|finding c.n
    me.Rscin = &acgtscqv{
        if (c.el == 8) {
            if (isar(c.n)) {
                # has a list
                $all = 1
                $any = 0
                each in c.n {
                    v.includes(n) and any = 1
                    else all = 0
                }
                c.all && !all and return
                !any and return
                return 1
            }
            else {
                v.includes(c.n) and return 1
            }
        }
        else {
            if (isar(c.n)) {
                # < distribute in between includes
                each in c.n {
                    !v.includes(n) and v.push(n)
                }
            }
            else {
                !v.includes(c.n) and v.push(c.n)
            }
            return 1
        }
    }
    # c.t may say $t-$pi%qua
    #  used to grasp c.t|pi for &Piing
    #  and &Pii to i .../Some-such (setting sc&pi)
    me.t_tpi = &acgtc{
        $tpi = c.t.match(/^(.*)-(\w+)((?:%\w.*)?)$/)
        if (tpi) {
            c.t = tpi[1]+tpi[3]
            c.pi = tpi[2]
            if (c.t == '') {
                # may s.y.$pi
                # or $s/$pi
            }
        }
        $tgk = c.t.match(/^(.*)%(\w+)(.*?)$/)
        if (tgk) {
            c.t = tgk[1]+tgk[3]
            c.gk = tgk[2]
            if (c.t == '') {
                # may $s/*%qua
                # or $s%qua=C:qua
            }
        }
        
        return c
    }
    
  # elvising
  // &FishElvis + -Bat f
    me.FishElvis = &acgtRs{
        ~FishElvis
        try {
        !Rs&ball and debugger
        c&slope.includes(R) and $aft = R
        else {
            ~>5 FishE tving in: R.t
            $aft = c&slope.filter(r => r.t == R.t)[0]
            !aft and debugger
        }
        $N = ksaf(c&slope,{aft,inc:0})
        
        # expect R%elvis...R:$pi
        $pi = hak(N.filter(z => isR(z)))
        !pi and return me&Gazel,R,s
        
        $p = Ry&up
        $M = ps&z
        #ksaf(ps&z,{aft:R})
        
        $c = {A,C,R,s,N,M,el:2}
        me&Thetower,R,c
        c&tower = c
        $n = c.es
        ~>3 sol: dis(n), c.wake.t
        ny&Todo.push(C)
        
        T.wake = c.wake
        me.Lastev = c
        }
        catch(er){
            ~>3 noFish: ""+er
        }
    }
    # where|how elvising goes
    #  This/Has/A/Thing may home e in:
    #   This/Has/e%tow/A/Thing
    #   This/e%tow/Has/A/Thing
    #   The%tow/Has/A/Thing
    # < always a further step
    # < constituation of climbers, for rowing
    # s finds Trooms for itself
    me.Thetower = &acgtRc{
        c ||= {}
        # find Thyer/%Theing/...s
        c.above = me&climbaboveTheing,R .map(r => rc&s)
        # their next sibling with %tow
        c.tows = c.above.map(&s{
            $p = sy&up
            !p and return
            if (!(ps&z||[]).includes(s)) {
                $r = sy&R
                rs&eph and return
                debugger
            }
            return ksaf(ps&z,{aft:s})
                .filter(z => zs&tow)[0]
        })
        # The springs The 2, etc
        if (!hak(c.tows.filter(z=>z)) && c.el == 2) {
            c.tows[1] = me&makeextraThe,c
        }
        # each %tow/...s
        c.towing = []
        $nearest = reverse(c.tows).filter(z=>z)[0]
        each iz c.tows {
            !z and continue
            $s = c.above[i]
            $r = sy&R
            $path = c.above.slice(i*1+1)
            # This<->The is implied
            rs&Theeing and path.shift()
            # try to route
            # may create nearest %tow/**
            $el = z == nearest && c.el == 2 ? 0 : 8
            each ii,n path {
                !z and continue
                $e = me&fiu,z,n.t,el
                z = e
            }
            c.towing[i] = z
        }
        c.elvisors = reverse(c.towing).filter(z=>z)
        # first|deepest is where to elvis
        $es = c.elvisors[0]
        !es and return c
        esy&Todo ||= []
        c.es = es
        # nearest R above that, to wake elvisor
        $z = me.cbu(es,z=>zy&R)
        c.wake = zy&R
        # who has TX
        return c
    }
    # for R=The/Room/... to This/Room
    # < provide The/Room as you
    me.Battarget = &acgtR{
        # ^^/%Theing
        $N = me&climbaboveTheing,R
        $Thy = N.shift() .c.s
        $Theing = N.shift() .c.s
        # previous sibling
        $prevTheing = ksaf(Thys&z,{bow:Theing,near:1})[0]
        !prevTheing and return me&strange,"&Battarget:no-/</-Theing"
        # path into %TheTh**
        $z = prevTheing
        $M = [z]
        $not = 0
        while (1) {
            $r = N.shift()
            !r || !rs&TheingE and break
            $s = rc&s
            $n = me&fiu,z,s.t,8
            !n and not = 1; break
            M.push(n)
            z = n
        }
        not and me&tc,'targeting',"@"+joint(M,'/'),'y'
        not and me&tc,'targeting_fail',"!"+s.t,'B'
        else {
            $end = M.slice(-1)[0]
            Rs&target = end
        }
    }
    # find Thyer/%Theing/...R
    me.climbaboveTheing = &acgtR{
        return me.cby(R,'^^^Piing')
            || me.cby(R,'^^^Theing')
        $r = R
        $N = [r]
        while (1) {
            $p = ry&up
            !p and break
            N.unshift(p) > 10 and debugger
            rs&Theing and break
            r = p
        }
        return N
    }
    me.makeextraThe = &acgtc{
        $Thyer = c.above[0]
        $The = c.above[1]
        $zc = The.t.match(/^(.+) (\d+)$/)
        $t = zc ? zc[1] : The.t
        $i = zc ? zc[2]*1+1 : 2
        t = t+' '+i
        $es = me&fiu,Thyer,t
        ess&tow = 1
        # will be %Theing
        return es
    }
    # GOING receive+see e somewhere
    me.proto_Bat = &acgtc{
        #return
        if (c) {
            $ev = me.Lastev
        }
        else {
            $R = me&R
            $x = me&Theing
            $s = Rc&s
            !sy&Todo and return
            $e = sy&Todo.slice(-1)[0]
            !e and return
            $ev = ec&tower
        }
        if (1 || xy&go) {
            me&nu,"e",e
            $ev = ex({},ev)
            me&nu,"tower",ev
            $int = {N:1,M:1}
            each kv ev {
                !isar(v) and continue
                each in v {
                    ev[k+'_'+i] = n
                }
            }
        }
    }
  # see refs
  // &Eref*
   # see thingo / %%limit (ref)
   // lookup
    # < Shx o E/$ref:s
    # < generating the climb 
    
    # search for other R with ref, E^^
    #  X.ref only exist on the Ec&top %X
    =Erefc
      .got=[g+]
       g.* E**, who we are at either end
       
        # got.Efinder: -six** we climbed from
        #   where the ref is now
        # Erefc.R is .Efinder//R
        
        # Erefc.E -six or ^^, grouping refs
        #      .e is the first -six we climbed through
        # < does .E always go to Ec&uber?
        #   or is it just until we climb s** in lookup
        
        # Erefc.s = the object itself
        
        # got.Efound is the target E, at the end of got.tp
        # got.n is .Efound//R
        #  
        # < got.E always == Erefc.E?
      
      yep
    =cut
    me.Ereflookup = &acgtc{
      // ambleup
        # E are here^^^, e is here-only
        #  NOT the finder|found, see Efound
        $E = c.E
        $e = c.e ||= E
        $s = c.s
        $R = c.R
        $F = Rs&E
        c.got ||= []
        # look for the ref
        $x = fi&EXsim,E,{ref:s}
        # from R not being replaced
        $b = ec&b
        $br = b && by&R
        $z = x.z.filter(r => !br || brc&N != rc&N)
        each in z {
            # skip same node copied upwards
            c.got.some(g => g.n == n) and continue
            $tp = me&Rnodepath,n
            # you are Efinder sharing a ref with Efound
            #  (via g|c.E, where /$ref was found (via c.e)?)
            $Efinder = F
            $Efound = ns&E
            !Efound and debugger
            $g = {E,n,tp,Efinder,Efound}
            c.got.push(g)
        }
        if (!c.nowander) {
            # further up
            Ey&up and me&Ereflookup,ex(c,{E:Ey&up})
            if (Ec&uber) {
                # and anything awake that might be going to commit up there
                $Pr = me.cbu(R,'^^^Piing')
                each in Prs&Epending {
                    me&Ereflookup,ex(c,{E:n,nowander:1,is_pending:1})
                }
            }
        }
        E != e and return
        
      // angle
        # sort by R tree
        c.got.map(g => ex(g, me&Rcrux,R,g.n,c ))
        grop(g => g.not, c.got)
        $got = c.got.slice()
        
        # < -seven having a time sense greater than -eight
        #   -seven on a different -Nine are too far
        #   see otherable &EsyncThis as -log
        # ignore (grep out) those after this R^^^
        $poss = grop(g => g.seek <= 0,got)
        
        
        # the near later siblings of ancestors being linkable
        c.got_latersnear = grep(g => g.near && hak(g.downs) <= 2,got)
        hak(c.got_latersnear) and poss.push(...c.got_latersnear)
        
        
        # group by distance up from here
        #  then start climbing down again, sorting...
        $neu = []
        $NN = vpartN(poss,g => g.ups.length).vs
        each iN NN {
            neu.unshift( ... me&Erefclimb,N )
        }
        c.got = reverse(neu)
        
        # prefer closer... unless in a continuous blob of them:
        # eg A/4/y to the A/4/4 preceeding it, A/4 would do (they all ==)
        c.got.sort(&ab{
            return b.n.y.up == a.n && -1
        })
        
        return c
        # create distality
        # satisfy
        #  r%toomuch or %tiny doesnt count
    }
    me.Erefclimb = &acgtNc{
        N.length <= 1 and return N
        c ||= {}
        c.i ||= 0
        c.i *= 1
        # climb nearer|earlier first until satisfied
        #  if a later thing redraws it (differing)
        #   we want to follow on from that instead...
        # just sort it all into:
        $neu = []
        $eg = N[0]
        $h = vpartN(N,g => me&Rcrux_seek,c.i,eg.downs,g.downs )
        each iM h.vs {
            $k = h.ks[i]
            # < seeing a different R
            k == null and continue
            M.length > 1 and M = me&Erefclimb,M,{i:c.i+1}
            # < GONE?
            #N.map(g => g['seek_'+c.i] = k)
            neu.push(...M)
        }
        c.i > 25 and throw "lost"
        return neu
    }
    # find join between **R and **r
    #  resorts to comparing Rc&s or R.t to get it done
    # < into rowing
    #   proof that X-stitching needs to preserve $n-order
    #    by way of Jip, Aip, tip, etc
    # < for [r], with no particular R
    #    finding islands
    #   would be able to sort the whole thing as a tree
    #    currently different joins may compare c.seek
    me.Rcrux = &acgtRr,lookupc{
        $c = {ups:[R],downs:[r]}
        $loca = &nN{
            $ni = N.indexOf(n)
            if (ni < 0 && ns&ball) {
                # use the eternal C arriving on different R
                ni = N.findIndex(r => rs&ball && rc&s == nc&s)
                ni >= 0 and c.viaball = 1
            }
            ni < 0 and return
            # we might find r^3 is R^1, trim R^3-2
            N.splice(0,ni)
            return 1
        }
        $upsi = &nN{
            $p = ny&up
            !p || ps&Gens || ns&eph and return
            if (ps&ball && !ns&Pier && !me&fiu,pc&s,n.t,8 ) {
                $Rin = ps&z.includes(n)
                $RNsame = pc&N == nc&N
                $inprog = ny&cv <= 0.9 && ny&cv
                $pending = lookupc.is_pending
                if (Rin && RNsame) {
                    # must just not be in yet?
                    # < figure it out. Try@5 JugRice 2 showing up to 1
                    !pending and debugger
                    #~>3 sameosphere: p.t, n.t
                    c.sameosphere = 1
                    # for c.got/$g
                    c.not = 1
                }
                else {
                    #~>3 forgotsphere: p.t, n.t
                    c.forgotsphere = 1
                    # %eph allowed? go further.
                    # < also how undeleted Eref spring up later?
                    !pending and debugger
                    # catch usual in &Rcrux_seek
                    pc&s.c.pi != 'seven' and debugger
                }
            }
            N.unshift(p)
            return 1
        }
        while (1) {
            # upmost either
            $L = c.ups[0]
            $l = c.downs[0]
            # found in the other
            loca(L,c.downs) || loca(l,c.ups) and break
            # further y&up
            !(upsi(L,c.ups) || upsi(l,c.downs)) and break
        }
        while (c.viaball) {
            # try to resolve R.t to deepen the join
            # see resolve $n
            $L = c.ups[1]
            $l = c.downs[1]
            !L || !l || L.t != l.t and break
            c.ups.shift()
            c.downs.shift()
        }
        c.not and return c
        # on the join, is r before R (c.seek<0) or not (>0)
        c.seek = me&Rcrux_seek,0,c.ups,c.downs,c
        
        # c.near - linking within E%Top
        #  leads to %%limit:ref,,,toomuch?, see &Rlimiti_ref
        $Topof = N => grep(r => rs&Top, N)[0]
        $sameTop = uniq(map(Topof,[c.ups,c.downs])).length <= 1
        sameTop and c.near = 1
        
        return c
    }
    # get order of two [R**] that already join at $offset
    me.Rcrux_seek = &acgt,offset,left,right,Rcruxc{
        left == right and return 0
        offset *= 1
        $L = left[offset]
        $l = right[offset]
        if (L == l) {
            if (!left[offset+1] && !right[offset+1]) {
                me&strange,"Rcruxingnot:"+joint(left)
                return 1
            }
            # simply see where in R%z
            $Li = Ls&z.indexOf(left[offset+1])
            #Li < 0 and debugger
            $li = Ls&z.indexOf(right[offset+1])
            # eg left=[R,y,R] right=[R]
            Li < 0 && li < 0 and debugger
            return li - Li
        }
        elsif (Ls&ball && ls&ball) {
            $s = Lc&s
            s != lc&s and debugger
            !ss&z and debugger
            $rl = left[offset+1]
            $rr = right[offset+1]
            # look in the E sphere?
            $Li = ss&z.indexOf(rlc&s)
            $li = ss&z.indexOf(rrc&s)
            if (Li<0 || li<0) {
                # could be found in the E sphere (L%E/rl%E)
                #  they are likely -all -pis, have no order
                rls&Pier && rrs&Pier and return 0
                if (sc&pi == 'seven') {
                    if (!Rcruxc) {
                        # -Bat seems to get here, from &Eref(lookup/climb)
                        return null
                    }
                    # happens after this other warning
                    $knew = Rcruxc.sameosphere
                        || Rcruxc.forgotsphere
                    !knew and 'not always...'
                    # see zygomorph &Ereftakedown
                    # < supposed to be deleted or not yet s**?
                    #  < investigate with Aip, funtime
                    # < the last s remembering what ** are el:9
                    #    probably via sip
                    # throw out the match for now:
                    #~>3 notonsphere: s.t, rlc&s.t
                    Rcruxc.not = 1
                    return 0
                }
                debugger
            }
            return li - Li
        }
        elsif (Ls&ball || ls&ball) {
            debugger
        }
        else {
            # they dont join, even by C
            # < if R/$t ? yfuture the L?
            #debugger
        }
    }
   // misc
    # make relative pointer to g=c.got/$g
    #  for &Rlimito_ref saying eg ^3:5/Log//-hat/A/y
    me.Eref_got_pointer = &acgtg{
        # the amount of '^'
        $down = g.downs.slice(0)
        $ups = hak(g.ups.slice(1))
        $location = ups > 1 ? "^"+ups : '^'
        # allow '^/ref' - not inc ups|downs[0]
        ups <= 1 and down.shift()
        # 1
        $downs = ""
        $waspath = 0
        down.map(&r{
            # '//' when leaving node-sphere
            $path = rs&ball && rc&s.y.path
            !path && waspath and downs += '/'
            downs += '/'+r.t
            waspath = path
        })
        # going far makes '^4:This/etc'
        ups > 1 and downs = ':'+downs.substr(1)
        location += downs
        return location
    }
   // < commit
    # transact Ec&top
    me.Eref_begin = &acgtre{
        $p = ry&up
        $E = ps&E
        !E and throw "!E"
        # stop seeing refs from the old e in E%X
        $be = ec&b || me&fiu,E,e.t,8
        # see &Piing attaches E** @1, %Thyer GOING
        be == e and ey&R.sc.Piing and debugger
        else
        be and ec&b = be
        ac(r,'commit',&{
            # copy to E^^^%X
            $c = {E,e}
            ec&b and c.removing = [ec&b]
            me&Erefputup,c
            delete ec&b
            me&fiu,E,e
            es&glop and me&nu,"Glop",es&glop
        })
    }
    # commit Ec&top (top of &Piering) to RE^^^ (all along)
    me.Erefputup = &acgtc{
        $E = c.E
        $X = Ec&X || fi&EXsim,E,{}
        # add new
        $e = c.e
        $e_x = e && ec&X || {}
        each is e_x.refs {
            $x = e_x.ref[i]
            each in x.z {
                fi&EXsim,E,{ref:s},{n}
            }
        }
        # remove old
        each i,oe c.removing {
            $oX = oec&X
            $gonei = []
            each is oX.refs {
                $ox = oX.ref[i]
                !X.refs and continue
                $i = X.refs.indexOf(s)
                if (i < 0) {
                    each in ox.z {
                        $r = ny&R || n
                        $name = me&Rnodepath,r
                        #~>3 confuslet: name
                    }
                    continue
                }
                $x = X.ref[i]
                grepout(x.z,n => ox.z.includes(n))
                !hak(x.z) and gonei.push(i)
            }
            reverse(gonei).map(&i{
                X.refs.splice(i,1)
                X.ref.splice(i,1)
            })
        }
        # all along, ie {Run>This>Something}//ref
        Ey&up and me&Erefputup,ex(c,{E:Ey&up})
    }
    # drop Erefs for RE to RE^^^ (all along)
    # ie nuke a whole subnet of sip
    me.Ereftakedown = &acgtEc{
        # we leave the E /$ref inside, start at RE
        me&REof,E != E and throw "E!RE"
        fatal.isba(Ey&R)
        $s = Ey&R.c.s
        c ||= {}
        # will scan for this on deeper nodes
        $first = !c.wherefor
        c.wherefor ||= (s => sy&path[6])
        c.whatfor = c.wherefor(s)
        first and s != c.whatfor and debugger
        
        
        Eref = Ec&X.ref
        !Eref and return
        each i,ref Eref {
            grop(&r{
                !rs&Pier and debugger
                $e = rs&E
                $z = me&uptonode,e
                !isnode(z) and debugger
                # o @goners/**$z
                # < compiling that to use y&path
                c.wherefor(z) == c.whatfor and return 1
                # < for many?
                # grap(c.wherefor(z),goners) and return 1
            },ref.z)
        }
        # all along, ie {Run>This>Something}//ref
        Ey&up and me&Ereftakedown,Ey&up,c
    }
  
  # life of E
  // &Eing some E/* into life
    # 2 E/** sync, repeatedly
    # < in or out of time?
    me.Eing = &acgtc{
        # you must have the correct C to me&R:
        $R = me&R
        $E = Rs&E
        # @13 a bunch
        # < Babz Es&z[-1]
        $la = Es&z && Es&z.slice(-1)[0]
        if (Es&z && la && lay&R == null) {
            # < seems to move things when all ==
            Es&z.some(n => ny&cv != 0.1) and vsortz(Es&z)
            # applies E/* to PiRet, creating R%Pier@13
            me&Eing_some,R,E
        }
        # @2, etc!
        if (c) {
            num(c) and c = {ov:c}
            c.ov = scaf(c.ov)

            me&Ring,R,{inside:R,ov:c.ov}

            $allok = !me&ja,R,{toomuch:1}
                && !me&anystrange,R
            return allok
        }
    }
    # all E/* &Pieri once, if would &PiRet
    me.Eing_some = &acgtRE{
      // 1 c.would, &Pieri -> (un)?keen 
        $many = me&Rortopsc,R,'many_thresh' || 20
        $tolerance = 10
        many = hak(Es&z) > many+tolerance ? many : 0
        # wants to show yay many yonder of the snip
        $many_tail = me&Rortopsc,R,'many_tail' || 0
        # arriving e a bit may pos|neg it
        # < once space limit is found,
        #   sub negated for posited
        # < %limit:impl,E
        #   %limit:dim, being picky|squishy
        #    wanting 5 things x 5 characters
        #     may slice paths off %limit:ref modulat
        #      we want to make all ^ in a Cish relative to the C
        #      so eg neesd.y.fig says @/fer
        #   covered by %limit:dis
        #    when the .t is affected for layout...
        
        $c = {}
        each ie Es&z {
            ac(c,(ey&R == null ? 'would' : 'have'),e)
        }
        # < sync to a E&X.Eing sub-brack?
        #   so we can share %limit:dim to e&X.Eing
        #   and make all this &sortial for keenness
        each ie c.would {
            
            # 1
            ey&R = 0
            # < tuck the rest of this block into &Pieri, setting wouldc.keen
            #    and keep the aq it is for when we layout/unkeen
            # if any match (besides impl|ope<0),
            #  it promotes E to in, past any %limit
            $M = me&Pieri,E,e
            # TX about style|schema|layout are usu low intent
            #  should cause eg dim
            #   if light happens to get there
            # most other RXing as of &Pieri implies opening
            #  since stuff is routing into it, eg ope+1
            #   or eg something compare in there
            $serious = M.filter(aq => !aqs&layout)
            $keen = hak(serious) ? 1 : 0
            # aq%layout,impl may disaffect if:
            $Rope = (Rs&ope||0) >= 2
            each i,aq M {
                $qua = aqs&qua
                !qua and continue
                qua.ope and fatal.isnum(qua.ope); keen += (1*qua.ope)
                qua.impl && !(aqs&layout && Rope) and keen -= 2
            }
            # < more and less keen
            keen > 0 and ac(c,'keen',e)
            else
            keen < 0 and ac(c,'unkeen',e)
        }
        # unhad e logged:
        c.toomuch ||= []
      
      // 2 %limit:
        # stop R recursion when a %%limit,toomuch
        #  R may have decided that already,
        # < running into eg %limit:many while @1-ing R
        $stop = me&Ro,{limit:1,toomuch:1}
        # clicking on things opens them
        stop && gteqcv(Rs&ope,{gte:1}) and stop = 0
        # %limit:ref may stop woulding, probably unlimited keen e
        if (stop) {
            # empty would into toomuch
            c.toomuch.push( ... c.would.splice(0) )
            if (c.keen) {
                # just the keen
                # < unless a stopper is a hard limit, eg nl?
                c.would = grepout(c.toomuch,c.keen)
            }
        }
        # %%layout,toomuch,E
        if (hak(c.unkeen)) {
            $N = grepout(c.would,c.unkeen)
            each ie N {
                me&Ri,{layout:'unkeen',toomuch:1,E:e}
            }
        }
        # %limit:many prioritises space for keen e
        # < $many as per %limit:dim...
        many and $length = hak(c.have) + hak(c.would)
        if (many && length > many) {
            $more = many - hak(c.have)
            more < 0 and more = 0
            if (more > 0) {
                # c.would until the limit
                c.toomany = c.would.splice(more)
                if (many_tail) {
                    # wants to show yay many yonder of the snip
                    $yonder = c.toomany.slice(-many_tail)
                    yonder.map(e => ahk(c,['keen'],e))
                    Rs&say_toomany_before = yonder[0]
                    
                }
                if (c.keen && hak(c.toomany)) {
                    # prioritise space
                    $i = hak(c.would)-1
                    each ii,e c.keen {
                        c.would.includes(e) and continue
                        !c.toomany.includes(e) and debugger
                        while (1) {
                            $oe = c.would[i]
                            !oe and debugger
                            # demote a !keen would
                            # < next least keen
                            c.keen.includes(oe) and i--; continue
                            c.toomany.unshift(
                                ... c.would.splice(i,1))
                            # promote keen e from toomany
                            c.would.push(
                                # grepout comp object
                                ... grepout(c.toomany,e))
                            # < fatal grepout
                            i--
                            break
                        }
                    }
                }
            }
        }
        
      // 37 would &PiRet, too* limit
        each ie c.would {
            $rc = {t:e.t,s:ec&s,E:e}
            $r = ey&R = me&PiRet,R,rc
            # not @1
            !r || rc&not and debugger; me&Ri,{toomuch:'not',E:e}
        }
        
        if (hak(c.toomany)) {
            # can be %TX out of the shadow
            me&Ri,{limit:'many',excluding:hak(c.toomany),thresh:many,toomuch:1}
            each ie c.toomany {
                ac(c,'toomuch',e)
            }
        }
        # %limit:many+ref coalesce into non-happening E/e
        # < dont lose the exact origin of the !e
        if (hak(c.toomuch)) {
            # points vaguely to %%limit
            each ie c.toomuch {
                me&Ri,{toomuch:'limit',E:e}
            }
        }
    }
  
  // &Pieri @0 RX, construct
    # 3 realises R/r as E/e
    
    # @02 early realise
    # called from:
    #  &Piing on R%Piing
    #  &Eing on R%Pier via &Eing_some c.would
    # < features like g.unkeen should be available to both
    # < also nab brack as it goes (into &rowcap for it etc)
    # < the match...effect occasions reliably:
    #  < &Piero capable of matching on .t again?
    #    perhaps %RX want to deliver?
    # < exude io to the moment called from
    #   instead of just returning M of qua
    #    for everyone to unpack for their context
    me.Pieri = &acgtEe{
        # bunches of identity come awake
        # aq pile onto E/matched/ for any of these:
        $Xc = {}
        Xc.t = e.t
        
        ec&pi and Xc.pi = ec&pi
        
        if (hak(e.c,'s')) {
            $s = ec&s
            Xc.v = s
            # in-t
            isC(s) and Xc.Ct = s.t
        }
        
        # < Xc.Ct > .t sometimes, from -Bet
        # < path can say 0/CthingCsoCCalleisable
        #   for an array .t, then .Ct+
        fi&pio,e,Xc
        
        $M = fi&RXglob,e,'matched'
        
        # see &Eing_some c.would
        #  which uses M/aq%qua.ope for keenness
        # see &Piing
        #  does nothing with M
        #  yet aq pile onto E/matched/ for later being M
        # it is very early...
        #  effect qua in &Pieringi
        
        
        
        return M
    }
    
    # @1 R/r, pre-&Ring
    # non-lowlevels of &PiRet
    me.Pieringi = &acgtRrc{
        $E = c.E
        $s = isba(R) && Rc&s
        
        
        if (E) {
            # see also E&rc_mix below
            tax(r.sc,E.c,'dupl,noref,inline')
            # < not aka qua.Rsc_mix
            #    r refers to the sproutling A/r ?
            pex(r.sc,Ec&rsc_mix)
            
        }
        # may already E
        me&CED,r
        $C = rs&C
        $E = rs&E
        # R%wou for brack
        # < should be E%X?
        me&haja,r
        
        $cb = delete rs&pre_Pieringi
        cb and cb(r,E,C)
        
        # spreads base type, or Ec&pi @2
        rs&Pier ||= Rs&Pier || 'blank'
        # Ec&pi provided over %Pier inherited
        Ec&pi and rs&Pier = Ec&pi
        Ec&pi ||= rs&Pier
        $main = Ec&pi == rs&Pier
        
        if (E) {
            # see also sc&* -> &Piing c.*
            #  they end up in rs&*, eg %first_truest, %TXilay
            tax(r.c,E.c,'nl,dl')
            pex(r.c,Ec&rc_mix)
            isst(rc&dl) and rc&dl *= 1
            if (main && rs&TXilay) {
                $h = peel(rs&TXilay)
                each ts h {
                    me&TXilay,t,s
                }
            }
        }
        
        # it is very early...
        #  effect qua matched by &Pieri
        $M = fi&RXglob,E,'matched'
        each i,aq M {
            $qua = aqs&qua
            !qua and continue
            pex(r.c,qua.rc_mix)
            # there is a later @264 one of these called Rsc_mix
            pex(r.sc,qua.rsc_mix)
        }
    }
    # cargo from Displayingness 27
    me.PieringiDisplayingness27 = &acgtR{
        $p = Ry&up
        pc&N != Rc&N and return
        # not if they reneg from the mainstream
        #  of matter unfolding with typology
        # < a "legitimate child created" hook
        #  < tunneling things's siblings,
        #     sleeping them on arrival if slep etc.
        if (p && !Rs&reneg) {
            # may end up on random things
            #  see %Codon && (!%ball||%Gens) and delete %Codon
            # parent must have it
            each ik ps&inheritsc {
                R.sc[k] = p.sc[k]
            }
            # only onto eg %ball
            each kc ps&inheritscif {
                R.t == 'sustain' and ~>7 lala: k, dis(c), R.t
                !R.sc[k] and continue
                ex(R.sc,c)
            }
            # remember certain sc
            $b = Rc&b;
            b && bs&nextlifesc and ex(R.sc,bs&nextlifesc)
        }
    }
  
  // R'The' %Top, %Pier
    me.Pi_Pier = &acgt{ return [
       // %Top|%Pier back
        ['Pier',0.2,&acgtRs{
            me&Pieringo
        },'ift,D'],
        ['blank',0.21,&acgtRs{
            # diverges into types
            Rs&hat = 1
        },'ift,D'],
        
        # %TX awarenesses a point
        # dome suspicion
        ['Pier',0.264,&acgtRs{
            me&Piero
        },'ift,D'],
        
        # E/** expands, if not already
        ['Pier',0.3,&acgtRs{
            me&Eing,3
        },'ift,D'],
        
       // %Top &Topping
        # for all, without Ringing around
        ['Top',0.67,&acgtRs{
            me&Topping
            
            s&dis = 1
            C.y.cv = 0.22
            me&walls,C,"b:2.2"
            me&scroll,28
        },'ift,D'],
        ['Top',0.9,&acgtRs{
            # Display is via Ry&up.sc.z += R
            
            Rs&sleeping and return
            me&applyRbitX,R
            
            each iy Rs&commit {
                y ()
            }
        },'ift,D,sleeping'],
    ] }
    # ask R, or the //E^^^c&top
    me.Rortopsc = &acgtRk{
        hak(R.sc,k) and return R.sc[k]
        $r = Rc&top
        !r and throw "!top"
        return r.sc[k]
    }
    
    # @2 arrive in R%Pier
    me.Pieringo = &acgt{
        $R = me&R
        $C = Rs&C
        $E = Rs&E
        $V = Rs&V
        # E** happenings
        
        # < GONER? see &Pieringi
        # light appetite
        Ec&dl and Rc&dl = Rc&d + Ec&dl
        
        $p = Ry&up
        $pE = ps&E
        # note discontinuous $pi
        # < unexpected $pi from compressing usual $pi/$pi/$pi/$pi...
        if (!pE || pEc&pi != Ec&pi) {
            $n = me&tsc,'transpi','-'+Ec&pi,'G'
            Cy&transpi = n
            ny&cv = 0.105
        }

        $name = R.t
        Cy&label =
        n At 101 $s:name %label:t,deco,fs:6

        R.sc[Rs&Pier] = 1
    }
  
  // &Piero @264 RX
    me.Piero = &acgt{
        
        $R = me&R
        $E = Rs&E
        $D = Rs&D
        $s = Rc&s
        # more typespreads
        me&PieringiDisplayingness27,R
        
        $Xc = {}
        # < &typeup might immediately:
        Dc&pi and Xc.pi = Dc&pi
        # < replace Ec&s=R future?
        fi&pio,E,Xc
        
        $M = fi&RXglob,E,'matched'
        
        # < unfold schemes at &Eing
        $p = Ry&up
        ps&isdim and Rs&indim = 1
        if (hak(M)) {
            T.Mw = 'TX'
            # is it the end of a Ting
            $sym = M.some(aq => aqc&TX) ? '' : ''
            
            each i,aq M {
                $qua = aqs&qua
                !qua and continue
                # the %%RX,aq,...,...qua
                $brack = ex({},qua)
                
                $mix = qua.Rsc_mix
                mix and pex(R.sc,mix)
                
                if (qua.ope) {
                    fatal.isnum(qua.ope)
                    qua.ope *= 1
                    Rc&dl += qua.ope
                    Rs&ope ||= 0
                    Rs&ope += qua.ope
                }
                if (qua.biggish) {
                    me&modselect,R,{modt:'String',t:'string',cv:128}
                        .map(n => ns&fs = 22)
                }
                qua.impl and me&tc,"~impl~"
                qua.dim and Rs&isdim = 1
                
                me&Ri,ex({RX:2,aq},brack)
            }
            each i,aq M {
                $qua = aqs&qua
                !qua and continue
                if (qua.ope && qua.ope > 0) {
                    # < or if cold light
                    delete Rs&isdim
                    delete Rs&indim
                    if (Rs&Cish) {
                        Rc&dl += 1
                    }
                }
                if (qua.ope && qua.ope < 1) {
                    # < all %ope balance out
                    Rc&dl -= 1
                }
            }
            Rs&isdim and me&Ri,{layout:'dim'}
        }
        
        # ref sense similar, centralised
        me&Rlimiti,R
        
        return M
    }
  
  
  # classifies
  // E &typeup, &TXin
    # @21 spawn|mutate E**
    # E remains given|base type
    # D shifts into that mind with R%-pi
    me.typeup = &acgtR,pi{
        $D = Rs&D
        $E = Rs&E
        Dc&pi = pi
        #  supposing from-here R-ing?
        #  ie desc order of immediacy
        # < mindwind or dome? fail over when X clash?
        #   re-&pio if already
        #   leaving evidence for next life to test
        R.sc[pi] = 1
    }
    # @ 22 layouty TXi
    me.TXin = &acgttg{
        g = peel(g)
        $R = me&R
        $E = Rs&E
        $sol = &he{
            each kc h {
                $name = joint([t,e&&e.t,k])
                $z = delete c.z
                $init = delete c.init
                # c becomes aq%qua
                $aq = fi&TXi,e||E,name,{t:k},c
                
                ex(aq.sc,g)
        # < most matches want to apply only to E/*
        #   applying further is wander, ie E/**
        #   then there's one-per:
        #    putting the RX.ignore on the matcher
                ah(aq,'also','dl',1)
                # < use
                init and init(aq)
                # then more inside
                z and sol(z,aq)
            }
        }
        return &h{ sol(h) }
    }
    # &TXilay,'noy','y:impl'
    #  see -anA
    me.TXilay = &acgtts{
        s = peel(s)
        $style = {}
        each path,qua s {
            path = path.split('/')
            # path joined by /z
            $arqin = []
            path.map(t => arqin.push(t,'z'))
            #  ends at /$qua
            arqin.pop()
            if (isst(qua) && qua[0] == '%') {
                # apply it to r%*
                qua = peel(qua.slice(1))
                qua.rsc_mix = ex({},qua)
            }
            ahk(style,...arqin,peel(qua))
        }
        $actt = T.act.t
        me&TXin,actt+'-'+t,{layout:t} (style)
    }
  
  
  // R'The' &Topping, &specialfx
    # generate thingo and draw everything together
    # < composition, the painterly sense
  
    # @67 layout etc for all
    #  the unknown is long done with, so:
    # < slep, is deterministic
    me.Topping = &acgt{
        $R = me&R
        #me&Rlimits,R
        Rc&ha and debugger
        hak(Rc&N.filter(r => rc&not)) and debugger
        
        # < thingi, when notes merge onto parents
        #   could be earlier, sublate /* &Rthingo if simple
        T.Mw = 'Top'
        each ir Rc&N {
            $C = rs&C
            me&Topping_2,r
        }
        
        $C = Rs&C
        each ir Rc&N {
            if (rs&strange) {
                # < partly glowing map of t** from
                #  < a hud thing
                $tpath = joint(me.cby(rs&E,E => Ec&top),'/')
                $tc = me&tc,'strange:'+tpath,'16b'
                
                delete tcy&cv
            }
        }
        # generate thingo
        each ir Rc&N {
            $C = rs&C
            each kv me.magic {
                v.later and continue
                # magic brack listed here on &Ri
                $N = r.sc[k]
                !N and continue
                # calls &Rlimito, etc, in order
                me&mecy,['R',k,'o'],r,{N}
            }
        }
        T.Mw = 'Top'
        each ir Rc&N {
            me&modulatM,r,1
        }
        
        reverse(Rc&N).map(r => me&specialfx1,r)
        #Rc&N.map(r => me&specialfx2,r)
        
        # another minor wave of thingo
        each ir Rc&N {
            $C = rs&C
            each kv me.magic {
                !v.later and continue
                $N = r.sc[k]
                !N and continue
                # calls &Rlimito, etc, in order
                me&mecy,['R',k,'o'],r,{N}
            }
        }
        each ir Rc&N {
            # < c=1 may be reassigning cv (&cvdeal)
            $late = me&modulatM,r,1
            !hak(late) and continue
            # where some structure has taken over
            # < stream into, degrees of time availing reorg
            if (rs&Msink) {
                $lat = grepout(rs&M,late)
                hak(lat) != hak(late) and debugger
                # scooped into a row
                lat.map(n => ac(rs&Msink,'z',n))
            }
        }
        $M = Rs&M
        vsortz(M)
    }
    # upwards, cook modulat
    me.specialfx1 = &acgtR{
        $C = Rs&C
        $N = me&ioR,R
        
        # modulat trim
        me&Topping_37,R,N
        # tally R%M**c&s
        Rs&geolen = me&measure_modulat,Rs&M
        # modulat trim
        me&Topping_41,R,N
        
        Rs&nomirage and return
        
        # tally upwards
        $geo = Rs&geo = {}
        geo.self = Rs&geolen
        geo.insides = me&measure_modulat,N
        Rs&geolen = geo.self + geo.insides
        
        if (0) {
            $talk = geo.self
            geo.insides and talk += "+"+geo.insides
            $ge = me&tc,"geo:"+talk,talk,'6g'
            gey&cv = 0.79
        }
        
        $must_mirage = N.some(r => rs&rowy)
        if (!must_mirage &&
            (Rs&inline || hak(N) <= 1)) {
            return
        }
        
        # group into lines
        me&sfx_mirage,R,N
    }
    
   // Top modulat rejigs
    # pre-thingo, r%Mw still there
    me.Topping_2 = &acgtr{
        $N = me&ioR,r
        # who
        rs&shym && rs&Ctitle and me&moddelete,r,{modt:'shym'}
        if (!hak(N)) {
            if (rs&toomuch) {
                # hiding all the stuff
                if (rs&shym && !rs&Cish) {
                    rs&toomuch_shouldcount = 1
                    me&moddelete,r,{modt:'shym',t:'end'}
                }
                if (rs&indim && rs&Cish) {
                    me&moddelete,r,{modt:'Ctitle'}
                }
            }
            # instead of thing{ 1 }
        }

        # %limit unifies
        $too = N.filter(r => rs&limit)
        if (!(hak(too)+1 <3) && hak(too) > hak(N)*0.5) {
            # notice lots of children getting a %limit
            # < include mute if no toomuch,E like thingo does
            #    it might be exporting the %%limit
            #    through an Effect?
            $h = {}
            too.map(&j{
                js&limit.map(n => ac(h,ns&limit,j))
            })
            delete h.ref
            each t,hN h {
                # such limit must apply to more than half of the children
                hak(hN) < hak(N)*0.5 and continue
                # unified thingo, unless %%layout:dim
                if (!(rs&layout && me&Ro,r,{layout:'dim'} )) {
                    me&Ri,r,{super:'limit',limit:t}
                }
                # instead of */%%limit thingo, if:
                #  only %%limit:dl,toomuch?
                $only = n => me&honly,n.sc,{has:{limit:t},may:{toomuch:1}}
                each ij hN {
                    $thislimit = js&limit.filter(n => ns&limit == t)
                    !me&hall,thislimit,only and continue
                    me&Ri,j,{limit:t,sublated:r}
                }
            }
        }
    }
    # post-thingo, pre-measure
    me.Topping_37 = &acgtR{
        # trim modulat pre-measuring
        if (Rs&inlineable) {
            # Cish
            grepout(Rs&M,n => ns&modt == 'Hash')
        }
        if (Rs&tiny) {
            # show non-At labels
            grepout(Rs&M,n => ns&modt == 'Pier')
        }
        # any other callbacks
        each iy Rs&premeasurey {
            y (R)
        }
    }
    # post-measure
    me.Topping_41 = &acgtRN{
        # (light here-ish chases away %indim)
        $len = Rs&geolen
        if (Rs&isdim) {
            # are always containers of sketchables
            if (len < 9 && !hak(N)) {
                # contains nothing
                # < make sure...? %dim 
                # see if things are much ado
                $things = Rs&M.filter(n => nc&thing)
                #~>3 dim-empty: R.t, joint(things.map(n => nc&thing.ov))
                #Ry&up.t == 'asee' && R.t == 'y' and ~>3 fo: len
                Rs&M.filter(n => ny&cv >= 0.12)
                    .map(n => nc&not = 1)
                $len = me&measure_modulat,Rs&M
                me&Ri,{mirage:'empty',notonly:1}
            }
        }
        if (Rs&indim) {
            if (Rs&String && len > 9) {
                # shorten long strings
                # throw away detail, to $key:$sym$length
                #  eg str:'17
                # < like %Dscdotnk:
                # < not if diffing this thing
                #    mirage will want to wrap differings
                #    keeps D/D:c/D:strc&s=fulltext
                #     over D%'.c'="bu:3,nch:[3,str:'17,ing:4"
                # < long integers should round or x10^n
                $str = Rs&M.filter(n => n.t == 'string' && ns&modt == 'String')[0]
                $strlen = str && (''+strc&s).length
                if (strlen > 9) {
                    $talk = strlen
                    strc&s = "'"
                    # adjusting for shortening
                    len += 4 - strlen
                    # < group %toomuch near edge expandability
                    me&Ri,{mirage:'String',s:talk,toomuch:1}
                }
            }
        }
        Rs&geolen = len
    }
    
   // f modulat
    # tally R%M**c&s
    me.measure_modulat = &acgtNd{
        d = peel(d)
        d.cbfirst = 1
        $len = 0
        $leny = &sd{
            if (!d.nomem && ss&geolen != null) {
                # memo %geolen
                len += ss&geolen
                d and d.not = 1
                return
            }
            if (sc&not) {
                d and d.not = 1
                return
            }
            isst(sc&s) || num(sc&s) and len += (''+sc&s).length
        }
        !isar(N) and N = [N]
        each in N {
            # < just do it?
            ns&z && ns&z.length and me&ind,n,leny,d
            else leny(n,ex({},d))
        }
        
        
        
        
        
        
        return len
    }
    # structure swallows everything
    me.mirage_eats_modulat = &acgtR,mir{
        $fore = []
        $aft = []
        # hasn't been sorted yet:
        each in Rs&M {
            (ny&cv >= 0.6 ? aft : fore).push(n)
        }
        Rs&M = []
        $fo = me&fiu,mir,'mirmod0'
        $af = me&fiu,mir,'mirmod1'
        fos&z = fore
        foy&cv = 0.03
        foc&sortcv = 1
        afs&z = aft
        afy&cv = 0.77
        afc&sortcv = 1
        
        # further R%M/* are redirected into af/*
        Rs&Msink = af
        
        
        return [fo,af]
    }
   
   // mirage modulat rejigs
    me.sfx_mirage = &acgtRN{
        # begins as one long wrappy line
        # C.*(.*)? tend to share lines
        $p = Ry&up
        $inlineable =
            Rs&inlineable
            || p && ps&inlineable
        # < group for type division, length good
        # < keep order of C.*, arrays?
        $landscape = !inlineable
            && (Rs&geolen > 64
                # < maybe not:
                || 0 && N.some(n => ns&inline))
      
      // group onto lines[]
        $aline = 0
        $lines = [[]]
        $newline = &{
            lines.push([])
            aline = 0
        }
        $put = &r{
            lines.slice(-1)[0].push(r)
            !num(rs&geolen) and debugger
            aline += rs&geolen
        }
        $la
        $starts_inline = 0
        each ir N {
            i *= 1
            if (Rs&inlineable && i == 0) {
                # C 
                starts_inline = 1
                # suppose R modulat is of t
                aline += Rs&geo.self
                # then try to place y across from it:
            }
            # put sequences %inline+ on its own line
            $inlining_bound =
                la && (las&inline && !rs&inline
                    || !las&inline && rs&inline)
            
            if (inlining_bound || rs&rowy) {
                newline()
            }
            elsif (rs&inline) {
                # any amount of %inline+ on a line
                !la and starts_inline = 1
            }
            elsif (la && las&asfollows) {
                # any amount of R%asfollows before their target
                # < line could be too full for the rest compulsed
            }
            elsif (landscape || aline + rs&geolen > 32) {
                newline()
            }
            put(r)
            la = r
        }
      
      // further?
        # leaves whatever fits on a line
        # < convenient way to wrap R/* though
        $p = Ry&up
        hak(lines) == 1 and starts_inline = 1
        !inlineable && hak(lines) <= 1 and return
      
      // C:Miraging/$lines/$t%zuct=$r
        # and make so
        # < after all. aboves may try to re-lineout
        #   with less
        #  
        $mir = Rs&geo.mir = Cye(['Miraging',1])
        miry&up = C
        miry&lineser = mir
        $eei = 0
        each il lines {
            !hak(l) and continue
            $isinline = starts_inline && i == 0
            i /= 10000
            $al = me&fiu,mir,'aline'+i
            als&dis = 1
            als&line = 1
            als&miragia = 1
            als&geolen = 0
            each ir l {
                $it = me&fiu,al,'miragee'+eei++
                itc&zuct = r
                its&item = 1
                its&miragia = 1
                # style later
                its&geolen = rs&geolen
                als&geolen += its&geolen
            }
            isinline and als&dis = 2
            
            if (isinline && ps&inlineable) {
                # C.*.* inline doesnt indent
            }
            else {
                als&ml = 1
            }
        }
       
      // C:Miraging sfx
        # C.*.* space
        if (ps&inlineable && hak(lines) > 1) {
            # the c { several lines of c }
            # < o $mir/**%gee
            # if all of a casual size
            #  %indim makes eg /c biased toward a mirguts
            $mirgutive = (Rs&isdim || Rs&indim || ps&indim)
            $bias = mirgutive ? 2 : 1
            $toobig = Rs&geo.self > 9*bias
                || mirs&z.some(al => als&geolen > 32*bias)
            if (!toobig) {
                $fa = Rs&geo.fa = me&mirage_eats_modulat,R,mir
                s&dis = 3
                $lines = grepout(mirs&z,n => ns&line)
                # this is now where the lines are
                $gu = miry&lineser = me&fiu,mir,'mirguts'
                gus&miragia = 1
                gus&z = lines
                lines.map(al => delete als&ml)
                me&ioty,mir .map(&n{
                    ns&va = 1
                    ns&dis = 4
                })
                
                # R%asabove beginning aline sanity check
                #  should be, since -anA sorted them there?
                # < also check after &Topping_474 may reorder it
                #  < make R%asfollows=e, check followed by ey&R
                $begins = 1
                $someasabove = 0
                me&ioty,gu,['line','item'] .map(&it,{
                    $r = itc&zuct
                    !r || !rs&asabove and return begins = 0
                    !begins and throw "asabove not beginning aline"
                    someasabove = 1
                })
                
                # R%asabove in first aline, laters %ml+=0.5
                #  so it looks clingier than them
                someasabove && me&ioty,gu,'line' .slice(1) .map(&al,{
                    als&ml = 0.5
                })
            }
            
            # c { longline, shortline } redistribution
            me&Topping_474,R
        }
      
      // finally
        
        # effects re %line/%item positions
        me&Topping_477,R
        
        $eei = 0
        me&indo,mir (&sd{
            if (d.d == 2) {
                if (sy&cv == 0.1) {
                    sy&cv = dec(0.59+(eei++*0.000001))
                }
                ac(R,'M',s)
            }
            ss&item and me&zuct,s,sc&zuct
        })
    }
    
    # < the partitioning problem
    #   also putting any r%RX|toomuch on edges, for expansion
    #   the short, long, short -> medium, long
    #   divide by type, various levels
    #    the=many=things=1
    #   and an overall botheration
    #    resist reordering until really worth it
    #   C.* space:
    #   wanting c, sc on a line
    #    even if it means making more shorter lines
    #     up to a point...
    me.Topping_474 = &acgtR{
        $mir = Rs&geo.mir
        $gu = miry&lineser
        # the order of **%item
        $original = me&ioty,gu,['','']
        $lines = me&ioty,gu
        
        $sized = vsortz(lines.slice(), r => rs&geolen)
        $big = sized.pop()
        # biggest line with multiple items
        while (hak(bigs&z) <= 1) {
            big = sized.pop()
            !big and return
        }
        $small = sized.shift()
        !small and return
        $variance = bigs&geolen - smalls&geolen
        variance < 9 and return
        
        $later = lines.indexOf(small)
            > lines.indexOf(big)
        $eat = me&ioty,big
        later and eat.reverse()
        each in eat {
            # leaves the big line too small
            $pointless = (smalls&geolen + ns&geolen)
                - (bigs&geolen - ns&geolen) > 9
            pointless and continue
            # move it
            grepout(bigs&z,n)
            later and smalls&z.unshift(n)
            else smalls&z.push(n)
            smalls&geolen += ns&geolen
            bigs&geolen -= ns&geolen
            bigs&geolen - smalls&geolen > 9 and continue
            break
        }
        
        # the order of **%item
        $same = 1
        $now = me&ioty,gu,['','']
        each in now {
            original[i] != n and same = 0; break
        }
        if (!same) {
            original = joint(original.map(n => nc&zuct.t),',')
            me&Ri,{mirage:'reorder',s:'',original}
        }
    }
    # style based on position in *%lines/*
    me.Topping_477 = &acgtR{
        $mir = Rs&geo.mir
        $gu = miry&lineser
        each li,al gus&z {
            $lis = hak(als&z)
            lis == 0 and debugger
            $many = lis > 1
            each i,it als&z {
                $last = i == lis-1
                !its&item || !itc&zuct and debugger
                $r = itc&zuct
                $rC = rs&C
                if (many && !last) {
                    its&mr = 0.5
                    Rs&inlineable and its&mr = 1
                    rs&asfollows and delete its&mr
                }
                rCs&dis ||= 2
                !many and rCs&dis = 1
            }
        }
    }
  
  
 // thingo limitoids
  // &Rlimiti - ref+dl+nl policy
    # @12
    me.Rlimiti = &acgtR{
        $C = Rs&C
        $s = Rc&s
        
        if (s && typeof s == 'object' && !Rs&noref) {
            # soft dup limit, sets Rc&nofurther=1
            me&Rlimiti_ref,R,s
        }
        # sprawl limits
        # < find bunch of these at a thing, to %TX anti-dl
        if (Rc&dl && Rc&dl < Rc&d-(Rc&dlbias||0)) {
            me&Ri,{limit:'dl',toomuch:1}
            #return
        }
        if (Rc&nl && Rc&N && Rc&nl < Rc&N.length) {
            me&Ri,{limit:'nl',toomuch:1}
        }
        
        return 1
    }
  # magic words in brack engage, like Ring
  # globalised pseudo-Ringing parts of Ringing
  # affects of consciousness showing up somewhere
  // &Ri|o - magic-aware brack...
    # < brack at e, then give it to R when alive, or always on E?
    me.Rioing = &acgtr{
        $args = [...arguments].slice(4)
        isR(r) and args.shift()
        else r = 0
        R = r || me&R
        $c = {R,args}
        return c
    }
    # for &Ri,'limit:ref' -> &ha,... + R%limit=[]
    me.magic = {}
    me.magic.layout = {}
    me.magic.limit = {}
    me.magic.toomuch = {}
    me.magic.RX = {}
    me.magic.mirage = {later:1}
    me.Ri = &acgt{
        $c = me&Rioing,...[...arguments].slice(4)
        $n = me&ha,c.R,...c.args
        each kv n.sc {
            me.magic[k] and ac(R,k,n); break
        }
        return n
    }
    me.Ro = &acgt{
        $c = me&Rioing,...[...arguments].slice(4)
        $N = me&ja,c.R,...c.args
        return N
    }
    me.Roo = &acgt{
        return me&Ro,...[...arguments].slice(4) || []
    }
  // &Rthingo, show %%limit|toomuch...** etc
    # capsule, filler for %limit|%toomuch|...
    # < c.notes going to sym%title
    # < togcon port
    # defer to %limit if the only
    me.Rthingo = &acgtRc{
       // 1
        $C = Rs&C
        c.N ||= me&Ro,c.t
        # plant in R, otherwise T.Mw=overthingo
        # < Rthingos using &boxcap, avoid talk of Mw
        #   your m gets my&up=over-thingo? my&up.c.thing = c.up,
        !c.up and T.Mw = c.t
        
        # < arrive togcon
        c.do1 and c.do1(c)
        if (hak(c.N) == 1) {
            $n = c.N[0]
            ns&notonly && lt(c.ov,1) and return
        }
        # group by the %%limit
        # < later, so do18 may mess with c.N?
        $h = partN(c.N,n => n.sc[c.t])
        
        # < group by the next most groupey thing,
        #    this is probably the less groupey:
        h.one && c.up and h = partN(c.N,n => n.sc[c.up.t])
        $sublated = N => hak(N.filter(n => ns&sublated))
        me&hall,h.vs,sublated and c.ov ||= 0.01
        
        
        c.ov ||= 0.2
        sz(c.ov,0.1) and return
        
        # make capsule here
        $li = me&tc,c.t+'-cap'
        liy&cv = c.cv && scaf(c.cv) || 0.132
        delete lic&s
        $hu = (""+liy&cv).substr(-1)
        me&walls,li,'bd:1.4,hu:'+hu
        
        # move into it
        $lip = T.Mw
        if (isC(lip) && lipc&thing) {
            liy&up = lip
            lis&title = lipc&thing.t+'/'+c.t
        }
        else {
            # toplevel thingo
            ah(R,'thingo',c.t,li)
        }
        lic&thing = c
        T.Mw = c.li = li
        
        # sym
        if (c.sym) {
            $re = c.re = me&tc,c.t+'-sym',c.sym,c.symc||'b'
            rec&s = c.sym || ""
            res&fs = 17
            res&lh = 0.3
            liy&sym = re
            res&title = lis&title || c.t
        }
        
        c.do18 and c.do18(c,li,re)
        sz(c.ov,0.2) and return li
       // 2 rows
        each it h.ks {
            $N = h.vs[i]
            T.Mw = li
            hak(grepout(N,n => ns&sublated)) and continue
            # call $magicword/$ghostkey
            #  names are minds, have time
            $tc = {t,up:c,N}
            if (me&mecy,['R',c.t,'o_',t],R,tc ) {
                # only that unless opened
                sz(c.ov,0.3) and continue
            }
            T.Mw = li
            $talk = c.t+": "+t
            $t = me&tc,talk,t,'b'
            
            $sup = N.filter(n => ns&super)
            hak(sup) and me&tc,'super-','*','y'
            
            # say this
            $n = hak(N) && N[0]
            if (n && ns&s != null) {
                # see %toomuch_shouldcount, similar look
                ts&fs = 8
                tc&s = ns&s
            }
            
            # < conjoin a brackology here,
            #   having already stated toomuch:not
            ts&title = talk+" "+dis(N[0].sc)
            N[1] and ts&title += "\n    "+dis(N[1].sc)
            hak(N) > 2 and ts&title += "\n   + "+(hak(N)-2)
            
            # < defeatable, like qua.impl
            #    via specialised %ope for thingo ov control
            ns&casual && sz(c.ov,0.3) and tc&not = 1
        }
        
        # is also T.Mw - where &tc will be put
        return li
    }
    # venn thingos inside each other
    #  eg when t=layout
    #   layouty %%RX can be taken over by %%layout
    #  eg when t=up
    #   layout/dim merges into layout:
    #   the layout-sym:re %title += layout-cap:li/dim-cap%title
    #  see &Rthingo / if c.sym
    #   sets layout-cap:li c&thing.re = layout-sym:re
    me.thingodoptible = &acgtRtl{
        $c = lc&thing
        # thingos unpack when openish
        !lt(c.ov,3) and return
        if (t == 'up') {
            # way to hide a sub-thingo
            $into = c.up.li
            !into and debugger
        }
        else {
            $into = ahsk(R.sc,'thingo',t)
            !into and return
            me&modopt,R,into,l
        }
        # in-thing @18 might just conjoin symbol title
        !lt(c.ov,2) and return
        $re = ly&sym || l
        $ie = intoy&sym || into
        !ies&title and debugger
        !res&title and debugger
        $lines = res&title.split("\n")
        ies&title += "\n+ "+lines.shift()
            +"\n"+lines.map(s => "  "+s).join("\n")
        lc&not = 4
        
    }
    # in case of folding these thingo modulat up,
    #  return one big title string about all of them
    #  gather *-sym:re as mentioned above
    me.thingoestitle = &acgtN{
        $tw = {}
        map(&n{ me&indo,n (&nd{
            $c = nc&thing
            !c and return d.not = 1
            $re = c.re
            !re and return 'keep going inward'
            tw[res&title] = c
        })},N)
        return haks(tw).join("\n\n")
    }
    # flatten modulat to D%$sym=modc&s+
    # < generalise string accumulator?
    #    bracket multiple subthingos?
    me.Rthingo_toD = &acgtR{
        $E = Rs&E
        $D = Rs&D
        $h = {}
        $haves = &ks{
            $M = h[k] ||= []
            s != null and M.push(s)
        }
        each tg Rs&thingo {
            # D%$name=... can be a symbol
            $name = ""
            t != 'limit' and name += t
            me&indo,g,{name} (&sd{
                # layout-cap may not
                #  eg ^-Cish implies y ~:dim < 
                #  otherwise the RX-cap here   ^
                #   may vanish if it was only (layouty) (see &TXin)
                # can be c.not=1 (%%casual) and 4 (&thingodoptible)
                s.c.not && s.c.not != 2 and return d.not = 1
                
                s == d.promoted and return
                if (sc&thing && sy&sym) {
                    # subthing
                    $z = sy&sym
                    !isst(zc&s) and debugger
                    # dont visit sym
                    d.refs.push(z)
                    $was = d.promoted
                    if (was) {
                        # already in something promoted
                        #  append sym
                        # < more ()ing?
                        haves(d.name,zc&s)
                    }
                    else {
                        # promoted to h/$sym
                        d.promoted = 1
                        d.name = zc&s
                        # ensure layout-sym '~'
                        #  if unkeen-cap ('<') is c&not
                        #   < as implied by %Cish?
                        # also an ~ will not appear on anything being empty
                        # < however, Lol/figaro/y should maybe have 
                        #    or we are implying it's a new .y={} since then
                        # < a C with :^/fer should be /* nothing
                        #    if not being, trusting a previous self
                        #    need a way to indicate being empty
                        #  < calling it a self|other referer
                        #     when same|diff encoding (eg %Pier=hat)
                        #    needs to have equivalent in|out of time
                        # < these are bugs in Stories/TryPiWarmer-1
                        haves(d.name,null)
                    }
                    return
                }
                
                if (hak(s.c,'s')) {
                    haves(d.name,sc&s)
                }
            })
        }
        each kM h {
            D.sc[k] = hak(M) ? M.join(" ") : "1"
        }
    }
  
  // %%RX, %%layout
    # what arrives there in &Piero, is %%RX:2,aq,...qua
    me.RRXo = &acgtRc{
        $c = {t:'RX',sym:""}
        c.do18 = &c,li,re{
            $M = c.N.map(n => ns&aq)
            
            # icon flavours:
            # no further pointing
            !M.some(aq => aqc&TX) and rec&s = ''
            $layouty = !M.some(aq => !aqs&layout)
            if (!layouty) {
                # glow label
                # < effect At@101, t@12 etc based on match
                me&modselect,R,{modt:'Pier',t:'At'}
                    .map(t => ts&sha = '3 3 3 999')
            }
            
            each i,aq M {
                $ti = aq.t+"%"+dis(aqs&qua)
                res&title += "\n"+ti
            }
            # < -Bet open, expand elvising trace
            lt(c.ov,3) and c.ov = 0.18
            
            if (layouty) {
                res&bri = 0.7
                res&title += ' (layouty)'
                me&thingodoptible,R,'layout',li
            }
        }
        me&Rthingo,R,c
    }
    # how there is styled
    me.Rlayouto = &acgtRc{
        $c = {t:'layout',sym:"~"}
        c.do18 = &c,li,re{
            delete res&fs
        }
        me&Rthingo,R,c
    }
    # %layout:dim
    me.Rlayouto_dim = &acgtRc{
        c.do18 = &c,li,re{
            grepout(c.N,&n{
                return me&honly,n.sc,{has:{layout:'dim'}}
            })
        }
        me&Rthingo,R,c
        lt(c.ov,3) && !hak(c.N) and c.ov = 0.18
        me&thingodoptible,R,'up',c.li
        return 1
    }
    # unkeen: pagination, being an intended toomuch
    me.Rlayouto_unkeen = &acgtRc{
        ex(c,{sym:"<"})
        c.do18 = &c,li,re{
            # usu !E
            $blockE = c.N.filter(n => me&hal,n,'toomuch,E')
            if (hak(blockE)) {
                $bunch = joint(blockE.map(n => ns&E),',')
                res&title += " !E["+bunch+"]"
                # are sublated, unless we open
                lt(c.ov,3) and grepout(c.N,blockE)
            }
            lt(c.ov,3) and c.ov = hak(c.N) ? 0.2 : 0.12
            # %%layout,toomuch,E
            # accumulates to R%layout but not R%toomuch
            #  it is not quite %%toomuch,
            #   since %impl are compressions,
            #    eg don't visit C.t+.y.cv since %Ctitle says it
            #    < -isR may impl .y.R, and -isJ .y.1
            #   and ope<0 are purposeful exclusions
            #    < dim could make small limit:many
            #      become a less important unkeen
        }
        me&Rthingo,R,c
        me&thingodoptible,R,'up',c.li
        
        return 1
    }
  
  // %%toomuch, %%mirage
    # @67 assigns signage about being R%toomuch**
    me.Rtoomucho = &acgtRc{
        $c = {t:'toomuch',sym:"",cv:76}
        
        c.do1 = &c{
            $sugov = 0
            
            # the %limit magic may reduce %toomuch-ness to sym
            $known = &n{
                # only limit caused toomuch
                return me&hal,n,'limit,toomuch'
                    # toomuch caused only Eing stoppage
                    || me&hal,n,'toomuch:limit,E'
            }
            $simple = me&hall,c.N,known
            simple and sugov = 0.1
            
            # toomuch caused Eing stoppage
            $blockE = c.N.filter(n => ns&E)
            if (!hak(blockE)) {
                # didnt cause any Eing stoppage
                simple and sugov = 0.01
                c.do18 = &c,li,re{
                    res&fs = 9
                }
            }
            else {
                $bunch = joint(blockE.map(n => ns&E),',')
                if (Rs&Cish) {
                    simple && bunch == 't,y,c,sc' and sugov = 0.01
                }
                else {
                    c.do18 = &c,li,re{
                        $cou = me&tc,'!E-count','b'
                        couc&s = hak(blockE)
                        cous&fs = 8
                        cous&ml = -0.2
                        res&title += " !E["+bunch+"]"
                        if (Rs&toomuch_shouldcount && c.ov <= 0.2) {
                            #rec&not = 1
                            delete res&fs
                            cous&title = cou.t+' '+res&title
                        }
                    }
                }
            }
            
            sugov and c.ov ||= sugov
        }
        me&Rthingo,R,c
    }
    # note geometry
    #  similar to toomuch !E-count
    #   the mirage_shouldcount
    #  wants to eat %%length, %%lines, %%paragraphs...
    # make geometry
    #  scoop everything else into something
    me.Rmirageo = &acgtRc{
        $c = {t:'mirage',sym:"",cv:78}
        c.do18 = &c,li,re{
            delete res&fs
        }
        me&Rthingo,R,c
    }
    
  // %%limit (ref)
    # cultivate R %%limit:(ref|dl|nl|...)
    #  adding %toomuch stops E**
    #   an acute case of dimming light, ending thing
   // incur
    # realises where $s was before
    me.Rlimiti_ref = &acgtRs{
        # on Ec&top %X
        $tE = Rc&top.sc.E
        # previous mentions of it, nearest first
        $c = me&Ereflookup,{E:tE,s,R}
        # without being %toomuch or != $pi
        me&Rlimiti_ref_lookfor,R,c
        
        # any previousness causes some R%limit...
        if (c.any) {
            # the case for
            $lim = {limit:'ref',Erefc:c}
            # linkably close self, no more E/e
            c.near and lim.toomuch = 1
            c.redraw and delete lim.toomuch
            me&Ri,lim
        }
        if (c.self && hak(c.self.ups) < 6 && hak(c.self.downs) == 1) {
            # eg A/c/X/A ^3, but not A/y/flup ^3:-hat/0 0
            Rs&mayaswayabove = 1
        }
        
        # note this time
        #  effectively a &pio to many places
        $x = fi&EXsim,tE,{ref:s},{n:R}
    }
    # given two E, decide if same|compat c&pi
    # < complicated expr: brack/**Bow
    #    these could be low-import %TX
    #    imparting eg qua%Bowinbrack or so, that we now look for
    #    this is one of the distant optimisables ACGT is going for
    me.Eref_samepishow = &acgtEeg{
        ec&pi == Ec&pi and return 1
        $mutual = &s{
            $s = split(s)
            # absorb
            return uniq([Ec&pi,ec&pi,...s])
                .length == s.length
        }
        return mutual('brackios brackio brack Bow')
    }
    # given target e, decide if it shows itself
    #  ie is a self-worthy rendition, unobscured
    me.Eref_goodpishow = &acgte{
        $r = ey&R
        # these are bad for expression
        # note we only r%$magicword += n the first
        # so %%layout,toomuch,E can not count
        return !(rs&toomuch
            || rs&asabove || rs&asfollows)
    }
    # which Eref is best, classified to a suitability
    me.Rlimiti_ref_lookfor = &acgtRc{
        # find:
        #  other with any expression, even tiny|limited|other-$pi
        #  self with full writeup, same $pi
        # < which we can use to diff against, slep D** @4
        #    using leftover slepparatus from its typing up
        
        # find the show equivalent!
        #  ie same|compat c&pi + same c&s
        #   usu compress at such realities
        #   < the best suited to show it
        #     miragey strategies
        #      once gone deep but still early (@37?)
        #      for continuous constellation of things over there
        #     eg see # < Eref for sc/Glance_i
        # < many %%limit,Erefg,qua until satisfied
        #   iterating Ereflookup
        
        $E = Rs&E
        each ig c.got {
            $r = g.n
            if ( !me&Eref_samepishow,g.Efinder,g.Efound,g ) {
                c.other ||= g
            }
            elsif ( !me&Eref_goodpishow,g.Efound || Rs&tiny ) {
                c.almost ||= g
                # find a fuller further rendition
            }
            else {
                # this is the previous this
                c.self ||= g
                break
            }
        }
        # almost always -> self
        if (c.almost) {
            # even a partial do-over is self here
            # < Self, where lines are traced back
            # ! while we &PiRet 12, pre-Ringing
            #   this modulat goes into the above R
            !c.self and me&Ri,'limit:ref,oddity:no-full'
            c.other = c.almost
            #throw "no finding full thing"
        }
        # care
        if (c.self) {
            $g = c.self
            tax(c,g,'near')
            if (!c.near) {
                # out of time from here, climb data again
                # < know light cones provided by &Rsci
                # < slep or c.redraw
                #   which regen X, patchey D** with previous
                #c.redraw = 1
            }
        }
        # < getting here early via %TX
        # < GONER?
        ispi(E,'brack') || ispi(Ey&up,'brack') and c.redraw = 1
        c.any = c.self || c.other
    }
    
   // outsummation
    # @67 assigns signage about R%limit**
    me.Rlimito = &acgtR{
        $l = me&Rthingo,R,{t:'limit',cv:13}
    }
    #   ref
    me.Rlimito_ref = &acgtRc{
        me&Rthingo,R,ex(c,{sym:"",ov:0.12})
        Rs&tiny and c.ov = 0.11
        $li = T.Mw
        $re = liy&sym
        # limit:l/ref:n
        # &Ereflookup c via selection
        grepout(c.N,n => ns&oddity).map(&n{
            res&title += "("+ns&oddity+")"
            me&tc,"oddities","!",'6g'
        })
        $n = theone(c.N)
        $Erefc = ns&Erefc
        
        $types = ['self','other']
        $any = 0
        types.map(&k{
            $g = Erefc[k]
            !g and return
            any and return
            any = 1
            
            $r = g.n
            # < ups~downs over an area
            $location = me&Eref_got_pointer,g
            # fuller description as tooltip
            res&title += " "+k+":"+location
            
            # compress contiguations
            #  when as above, plus the same t
            # < exceptions want exclaiming -hat
            #   when we replace n.*.* to get attention
            $pc = me&jaa,Ry&up,{Erefc:1,limit:'ref'},1 [0]
            $pg = pc && pc[k]
            if (pg) {
                $wasdowns = g.downs.slice()
                $newdown = wasdowns.pop()
                if (heq(wasdowns,pg.downs) && newdown.t == r.t) {
                    # we C%limit/y%limit, just symbol
                    c.ov = 0.11
                }
            }
            sz(c.ov,0.12) and return
            
            $te = me&tc,location
            
            tes&deco = 1
            tes&hs = k == 'self' ? '999' : '888'
            tes&fs = 7
            tes&pointEref = 1
        })
        !any and me&tc,'!any'
        
        # change to c.ov < 3, 3 if auto 0.3
        sz(c.ov,0.12) and return 1
        
        $total = hak(c.got) + 1
        if (total > 2) {
            $says = total
            $talk = 'x'+says+', ...'
            me&tc,talk,says,'7y'
        }
        return 1
    }
  
  # < this chunk should close, is 21 long
  #    chunkology is compensating for the headings within?
  // %%other
   // < R%strange/** @2 # schema goes
    me.strange = &acgts{
        $R = me&R
        me&tc,s,'b'
        ac(R,'strange',s)
    }
    # r and r/*
    me.anystrange = &acgtR{
        R ||= me&R
        $ness = r => rs&strange
        ness(R) || me&ioR .some(ness) and return 1
    }
    
   // < R%c/** @3 # machine talk
    me.attendios = &acgttc{
        $R = me&R
        $E = Rs&E
        c.E ||= E
        c.path = me.cby(c.E,E => Ec&top)
        ac(Rc&top,t,c)
    }
  
  // misc f
   // data situations
    # match s=sc strictly against c={has:{limit:t},may:{toomuch:1}}
    me.honly = &acgtsc{
        each kv s {
            c.has && (c.has[k] == 1 || c.has[k] == v) and continue
            c.may && (c.may[k] == 1 || c.may[k] == v) and continue
            return 0
        }
        each kv c.has {
            !hak(s,k) and return 0
        }
        return 1
        
    }
    me.hall = &acgtNy{
        each in N {
            !y (n) and return 0
        }
        return 1
    }
    me.hany = &acgtNy{
        each in N {
            y (n) and return 1
        }
        return 0
    }
    # match brack row with order
    me.hal = &acgtnc{
        c = peel(c)
        # check it has them
        each tv c {
            !hak(n.sc,t) and return 0
            v != 1 && n.sc[t] != v and return 0
        }
        # check order
        $ks = haks(c)
        each kv n.sc {
            !hak(c,k) and continue
            $be = ks.shift()
            be != k and return 0
        }
        return 1
    }
   
    
  
 // R'The'
 
    me.Pi_The = &acgt{ return [
   ... me&Pi_Lab ,
   ... me&Pi_Pier ,

  // site office
    ['Fez',0.66,&acgtRs{
        $E = Rs&E
        R.t != "awoke" and return
        # < &hu could increase dl if nl is very low
        # < should be getting %indim here and lowering
        # E** path after R%Top
        $hert = slant(me.cby(R,'^^Top').slice(1))
        #~>6 breaking after: hert
        if (hert == '0/r/c/X') {
            #me&tc,"HERE"
            #me&hu,"Thinkab",{p:Ry&up,R},{dl:6}
        }
        #debugger
        me&tc,"U:"+hert,'6y'
                #T.oncily ||= 1
                #$found = a.ref == 'tothings' && T.oncily++ < 2
                #found and me&nu,"ref-find!",{Y,ref,Sarg:T.Sarg,a}
    },'ift,D'],
    # looking at their thingoes
    ['hat+Top',0.68,&acgtRs{
        $E = Rs&E
        #E.t != 'Bowler' and return
        $N = Rc&N.filter(r => rs&interux).slice(0,5)
            .map(&r{ return {r,th:rs&interux} })
        # < why too late to do any of this:
        #me&hu,"thingoes",N
        #me&tc,"hereth" .sc.fs = 39
        #me&modulatM,R
        #Rs&lookat = N
    },'ift,D'],

  // -Bat events
   // &protott prototype &tt for R'The'
    # < -Bat &tt. it must set up a oncer or so
    #    C%tt=1 or so tells -Bat** to qua a oncer etc
    #    < this must be received by an Aip you believe in
    #       to happen once
    #      which is how they usu would expect to work
    &{
        # i E/e @4
        me.Eiing = &acgtcv{
            $n = me&Ei,c
            v ||= 4
            me&Eing,v
            return n
        }
        # a dial
        me.protott = &acgtcv{
            v ||= 2
            v != 2 and debugger
            # < argulate c $t-otherpi%etc (usu c=$t)
            #   bringing other meanings to it too
            #    to preserve v=$num expr for longer (til v={...})
            $e = me&Eiing,{t:c,pi:'protott'}
            return defor(es&ope,0)
        }
    },
    ['protott',0.27,&acgtRs{
        $E = Rs&E
        s&hs = '344'
        s&fs = 14
        me&walls,C,'b:2.2h866'
        s&bgh = '831'
        # the value
        tax(E.sc,R.sc,'ope')
        ah(R,'noCy','transpi',1)
    },'ift,D'],

   // -Bat
    # many e
    ['Bat+V',0.3,&acgtRs{

        # outsphere (s of R%TheTt)
        $V = Rs&V
        $D = Rs&D
        $E = Rs&E
        $pathwithstep = me&climbaboveTheing,R
        $There = pathwithstep[1]
        $top2 = There.t.match(/^The( 2)?$/)
        top2 and Rc&nl = 3000
        s&ml = -5
        s&bgh = '010'
        me&Battarget,R

        # A:ev in:
        $N = Vy&Todo ||= []
        
        # < hold any with Ting
        $c = me&Nserial,N,{gk:'Bati',ll:25}
        $latest
        each ie c.back {
            $eB = me&Ei,{t:es&Bati,pi:'Bet',s:e,i,noencode:1}
            latest ||= eB
            c.neu.includes(e) and eBc&el = 2
            # < togs all come from somewhere
            #   this be a click path baked to [0]
            #i == 0 and eBs&ope = 2
        }
        me&Eing,6

        $N = me&ioR,'Bet'
        $n = me&Ei,{t:'Eel',pi:'Eel',s:N,dl:19}
        me&Eing,6
        
        # emits what-for
        !ns&aq and me&strange,"E!%aq"
        Vy&TXing = ns&aq
        
        # what now
        if (Rs&letswake) {
            # < -Ness defference
            $ta = Rs&target
            !ta and me&tc,'!target','G'
            else {
                $node = me.cbu(R,'TheingE')
                me&wants,node,'autoBat',ta
            }
        }
    },'ift,D'],

  //   -Bet event, -Belt slope
    # the e itself
    ['Bet',0.21,&acgtRs{
        $D = Rs&D
        me&walls,C,'bd:3.1'
        # < mutey picture of the C
        $en = me&tc,"e:"+s.t,'g'
        me&walls,en,'b:3.2'

        # qua to deliver, meaning of this event
        Ds&Xsc = {ope:1}
        ahsk(s.c,'mode','C') and Ds&Xsc.ope = -1
        # see -Belt/-Bit%D%Xc
        
        # style
        $l = Cy&label
        ls&fs = 15
        $pi = Cy&transpi
        pis&fs = 6

        #   pulling up the sc&tower.N
        $c = sc&tower
        c and me&Ei,{t:'tow',pi:'Belt',s:c.N}
        else me&Ei,{t:'inst',pi:'hat',s,dl:3,noref:1}
    },'ift,D'],
    ['Bet+ope',0.6,&acgtRs{
        $E = Rs&E
        sz(Rs&ope,1) and return
        me&Ei,{t:'sel',pi:'Spheres',s:E}
        me&Eing,6
    },'ift,D'],
    # a slope: $n/$n/$n... (15)
    ['Belt',0.21,&acgtRs{
        $N = s
        !isar(N) and return me&strange,"!array"
        # limit:many shall $n/$n/$n...$n/$n
        Rs&many_tail = 2
        each in N {
            $e = me&Ei,{t:i,pi:'Bit',s:n,noref:1}
            if (ns&miragia) {
                # quiet the miragey, layout containers
                # < undoably
                ec&pi = 'igBit'
            }
        }
    },'ift,D'],
    ['igBit',0.21,&acgtRs{
        Rs&tiny = 1
        Rs&inline = 1
        me&tc,"ignored-Bit:"+s.t,'','g'
    },'ift,D'],
  //     -Bit of slope, -isX
    ['Bit',0.21,&acgtRs{
        $D = Rs&D
        $E = Rs&E
        $Be = me.cbu(R,'Bet')
        # < /E/X, ark=X being strongly typed -X
        #   R/E/X then are arks, wideness
        #    at one point along the -Belt
        $e = me&Ei,{t:'s',pi:'isC',s:s}
        # < whats this up to
        !me&Eing,4 and return
        if (isR(s)) {
            Rs&isR = 1
            # < whittle down, pushing presentation,
            #   to be turned into an entirety if willed...
            #   or just R+E+X in the first -isC minimality
            # once that -isC is ok, spawn further:
            $tE = ss&E
            if (!isC(tE)) {
                $e = me&Ei,{t:'E',pi:'isC',s:tE}
                !me&Eing,4 and return
            }
            $X = tEc&X
            $e = me&Ei,{t:'X',pi:'isX',s:X}
            !me&Eing,4 and return me&strange,"Xnolike"
            # < Ro,e
            $r = ey&R
            $nec = rs&nec
            !nec and me&strange,"!nec"
            if (rs&nec_simple) {
                me&tc,"t-will-do",'t','6y'
                rs&noDisplay = 1
                Rs&inline = 1
                Rs&tiny = 1
            }
            Rs&nec = nec
            $Xc = Ds&Xc = {}
            each ic nec {
                Xc[c.k] = c.v
            }
            me&tt,'' () and me&fu,"Bit"+R.t,s
            if (!rs&nec_simple) {
                me&tc,"gotta:"+dis(Xc),'1q'
            }
        }
        else {
            # modulat, might something?
            Rs&tiny = 1
            Rs&inline = 1
            if (isC(s)) {
                # click titley bits to auto re-The
                ss&label and Bes&clickat = 'title'
            }
        }
    },'ift,D'],
    # R/E/X
    &{
        me.E_neighbours = &acgtE{
            $Ep = Ey&up
            Ep and return me&ioty,Ep
            # out the top of E space:
            $R = Ey&R
            $p = Ry&up
            $N = []
            each in ps&z {
                ns&E and N.push(ns&E)
            }
            return N
        }
        # find the X/* most identifying X amongst N[X]
        me.X_necessary = &acgtXN{
            $M = []
            each kv X {
                k == 'ref' and continue
                k == 'v' and continue
                $sk = k+'s'
                $refs = X [sk]
                !refs and continue
                each iv refs {
                    $found = hak(N.filter(
                        V => V[sk] && V[sk].includes(v)
                    ))
                    M.push({k,v,found})
                }
            }
            $most_iding = vsortz(M,a => a.found)
            $necessary = []
            each ic most_iding {
                necessary.push(c)
                c.found == 1 and break
            }
            return necessary
        }
    },
    ['isX',0.21,&acgtRs{
        if (Rs&refR) {
            # < reimplement as -Bet compiling
            # duplicate, reuse results
            $r = Rs&refR[0]
            !rs&nec and return me&strange,'!nec'
            sex(R.sc,r.sc,'nec,nec_simple')
            return
        }
        # look for the most identifying classifications
        $iE = s.A
        $Bet = me.cbu(R,'Bet')
        $Bit = me.cbu(R,'Bit')
        # amongst its neighbours, even at the outsphere
        $N = me&E_neighbours,iE
        if (!N.includes(iE)) {
            if (iEc&top && iEy&up
                && me&fiu,iEy&up,iE.t,8 ) {
                # where Ey&up becomes persistent (many R per E)
                # we are looking at a past version of E
                # < rowing perspectives for any part of X
                #    inside a past? transaction
            }
            else {
                me&strange,"!N/iE"; me&tc,'iEN:'+joint(N)
            }
        } 

        $NX = N.map(E => Ec&X).filter(X=>X)
        $nec = Rs&nec = me&X_necessary,s,NX
        if (hak(nec) == 1) {
            $ne = nec[0]
            if (ne.k == 't' && ne.v == iE.t) {
                Rs&nec_simple = 1
            }
        }
        else {
            # < boost or !simple:
            me&Ei,{t:'Es',pi:'hat',s:nec,dl:2}
        }
    },'ift,D'],

  //   -Spheres events look
    ['maybrack',0.22,&acgtRs{
        if (ss&X && ss&z) {
            $ve = me&brackology,R,s,{sc:{ope:2}}
            ac(R,'M',ve)
        }
    },'ift,D'],
    # < wants to generalise to CED|RsE walker
    #   the main thing of s=E-Bet becomes the target
    ['Spheres',0.22,&acgtRs{

        $E = Rs&E
        # s is an E-Bet to look at
        $r = sy&R
        !isR(r) || !rs&Bet and debugger
        s != rs&E and debugger

        # look at tow-Belt for .../$r/...$n
        $Belt = me&ioty,r,'Belt','tow' [0]
        $Bits = me&ioty,Belt,'Bit'
        
        # < grouping these first 3 things
        #    E:R spilling its relations
        
        # the e itself
        if (isC(sc&s)) {
            me&Ei,{t:'e',pi:'hat',s:sc&s,dl:1,rsc_mix:'maybrack'}
        }
        
        # its last R
        $Bit = Bits.filter(r => rs&isR).slice(-1)[0]
        $r = Bitc&s
        $fut = me&yfuture,r
        # < see -Bat &tt
        # < need more than yfuture to resolve new -seven
        #    see &forgetRunStep
        fut != r and me&protott,'future' and r = fut
        me&Ei,{t:'R',pi:'Bow',s:r,dl:1}
        
        # its last anything pointed - modulat clickable
        $Any = Bits.slice(-1)[0]
        if (Any != Bit) {
            $n = Anyc&s
            me&Ei,{t:'last-Bit',pi:'Bow',s:n,dl:1}
            if (n.t == 'ref-sym') {
                # expect interest in that
                me&protott,"other-Spheres?" and 'go on to do them'
                else {
                    # < brackology we can click in here
                    # < any n^^%thingo should finds its rows
                    # < &TXin (from here) to open %%Erefc
                    me&jaa,r,'limit:ref' .map(&ni{
                        me&Ei,{t:'limit:ref:'+i,pi:'brack',s:n,dl:2}
                    })
                    return
                }
            }
        }
        
        each kv r.sc {
            !isC(v) and continue
            me&Ei,{t:k,pi:'Bow',s:v,dl:1,rsc_mix:'maybrack'}
        }
        
        # default D open!
        fi&TXi,E,"Dope",{t:'D'},1
    },'ift,D'],
    ['Spheres',0.72,&acgtRs{
        $E = Rs&E
        me&pity,E .map(&e{
            $eC = ey&R && Aof(e,'C')
            !eC and return
            $la = eCy&label
            las&fs = 15
        })
    },'ift,D'],
  //   -Eel
    ['hat',0.23,&acgtRs{
        if (0 && R.t == 'Xc') {
            ~>5 lovely: Rc&d
            if (Rc&d == 7) {
                # < why the limit:dl
                me&tc,"here!"
                me&fu,'rlong',R
            }
        }
    },'ift,D'],
    ['Eel',0.21,&acgtRs{

        #me&walls,C,'bd:3.7'
        $D = Rs&D
        $E = Rs&E
        if (Ec&Xc) {
            Rs&rowy = 1
            # non-first -Eels have an Xc to match
            $glep = me&Ei,{t:'Xc',pi:'hat',s:Ec&Xc,dl:3,inline:1,noencode:1}
            

            $EN = me.cby(E,E => !Ec&Xc && -2)
            $p = Ry&up
            $pE = ps&E
            $name = joint(EN)
            # into D%TX...aq
            $aq = fi&TXi,D,"aq:"+name,Ec&Xc
            # onto E%aq
            Es&aq = aq
            # into E^%aq %TX..aq
            pEs&aq and fi&TXi,pEs&aq,aq,Ec&Xc
        }
        else {
            Es&aq = Cye(["Topeel",8])
        }

       // regrouping Bet
        $BitDXc = B => B && Bs&D && Bs&D.sc.Xc
        # next meaningful Belt Bit
        each ir s {
            !rs&Bet and debugger
            $Belt = me&ioty,r,'Belt','tow' [0]
            $Bits = me&ioty,Belt,'Bit'
            # find last position on Belt
            $Belti = (me&ja,Ry&up,{Belti:1,Bet:r},1 || -1)*1 + 1
            while (1) {
                # seek next position with a D%Xc
                $Bit = Bits[Belti]
                !Bit and break
                !BitDXc(Bit) and Belti++; continue
                break
            }
            !Bit and me&ha,R,{done:1,Bet:r}
            else {
                me&ha,R,{Belti,Bet:r,Bit}
            }
        }

        # group by same D%Xc
        me&jaa,R,'Belti,Bet,Bit' .map(&n{
            $Bet = ns&Bet
            $Bit = ns&Bit
            $Xc = BitDXc(Bit)
            $N = me&jaa,R,'Betgroup,Xc'
            each in N {
                $Betgroup = ns&Betgroup
                if (heq(ns&Xc,Xc)) {
                    me&ha,R,{Betgroup,Bet}
                    return
                }
            }
            # create new
            # an empty hash as id because ja k=1 returns all k
            $Betgroup = {}
            me&ha,R,{Betgroup,Xc}
            me&ha,R,{Betgroup,Bet}
        })

        $groups = me&jaa,R,'Betgroup,Xc'
        each in groups {
            $Xc = ns&Xc
            $Betgroup = ns&Betgroup
            $Bets = me&jaa,R,{Betgroup,Bet:1},'Bet'
            me&Ei,{t:'E'+i,pi:'Eel',s:Bets,Xc,cv:8}
        }

       // having Bets
        $BitDXsc = B => B && Bs&D && Bs&D.sc.Xsc
        $N = me&jaa,R,'done,Bet'
        $done = N.map(n => ns&Bet)
        !hak(done) and return
        !aq and return me&tc,"!ac"
        !aq and debugger
        $qua = {}
        each iB done {
            $Xsc = BitDXsc(B)
            Xsc.ope and Xsc.ope += qua.ope||0
            ex(qua,Xsc)
        }
        hak(qua) and aqs&qua = qua
        me&Ei,{t:'aq%qua',pi:'hat',s:qua,dl:2,inline:1,noencode:1}

        $letswake = 0
        done.map(&r{
            !rs&Bet and throw "done!Bet"
            $re = rs&E
            rec&el == 2 && rs&clickat == 'title' and letswake = 1
        })
        if (letswake) {
            me&tc,"letswake!",'G'
            $Bat = me.cbu(R,'Bat')
            ac(Bat,'letswake',E)
        }
        me&tc,"done:"+joint(done)

        #me&Ei,{t:'aq',pi:'hat',s:aq,dl:2}
    },'ift,D'],
   
  // -brackios? > -hat
    # test dump bunch
    #  {"title":s-brackio}
    ['brackios',0.21,&acgtRs{
        Rs&Top and pex(R.sc,'expect')
        # < indent here
        isfu(s) and return
         if (isC(s) || isar(s)) {
             if (isC(s) && sy&R && !sy&brack) {
                 # C is R%C
                 $r = sy&R
                 rs&C != s and debugger
                 $wou = rs&wou
                 !wou and debugger
                 # note the C//R%wou move
                 me&Ei,{t:s.t+'%wou',s:wou,pi:'brackio'}
                 return
             }
             s&ma = 0.3
             me&typeup,R,'brackio'
         }
         else {
             # < list of dumpy Pi. they are i (-Bat|The) or o (-hat)
             # famous pi can eg i.Bow = {"more titles":s +}
             $becomes = map((v,k) => k, peel('Bow,hat'))
             # i.such can become any pi
             $pifor = Rs&pifor || {}
             each ts Rc&s {
                 if (becomes[t]) {
                     # unpack eg i.Bow.* to i.*
                     # :suchpi/:title/:something
                     $pi = t
                     $h = s
                     each ts h {
                         me&Ei,{t,s,pi}
                     }
                 }
                 else
                 pifor[t] and me&Ei,{t,s,pi:pifor[t]}
                 else me&Ei,{t,s}
             }
         }
    },'ift,D'],
    # the unity of %wou or [brack+]
    ['brackio',0.21,&acgtRs{
        $D = Rs&D
        $rt = me.cbu(R,'Top')
        rts&first_truest = 1
        $N = s
        if (isC(s)) {
            D.t = s.t
            $r = sy&R
            if (r) {
                Ds&yr = r.t
                ry&cv and Ds&yr += '@'+cvs(ry&cv)
                rs&ver and Ds&yr += '.'+rs&ver
            }
            # < protocol for the brackio
            hak(s.c) and me&Ei,{t:'c',s:s.c,pi:'Hash'}
            $N = ss&z
        }
        each iz N {
            me&Ei,{t:i,s:z,pi:'brack'}
        }
    },'ift,D'],
    # each %wou/brack+ row
    ['brack',0.267,&acgtRs{
        $D = Rs&D
        !isC(s) and return me&strange,"!C"
        
        me&walls,C,'b:2.2'
        Rs&rowy = 1
        
        $remark = {}
        each kv s.c {
            isha(v) && !hak(v) and continue
            remark[k] = v
        }
        # < leading elsewhere... there are more of these, esp y&up
        # see &rec_traction / future in particular shouldn't exist
        sy&future and remark.yfuture = 1
        grep(k => k.startsWith('rec'), haks(s.y))
            .map(k => remark[k] = 1)
        ex(D.sc,remark)
        
        $En = me&Ei,{t:'sc',s:s.sc,pi:'Bow',rsc_mix:'brackin'}
        me&boxcap,"c","2" (&ml{
            my&cv = 0.78
            ms&pl = 2
            ms&fs = 6
            # c placed after sc for aesthetics
            me&blabdepeel,'c',remark
        })
    },'ift,D'],
   // -Bow%brackin**
    # E-brack/** limit .n.*
    # < if already Eref matching somewhere we saw it before
    #    check that it is the same
    # < de-crude inheritence
    #   is an Ec&X thing
    #   sleeping gets tricky, see &reaw etc
    ['brackin',0.262,&acgtRs{
        R.t == 'n' and me&Ri,{limit:'brackin',toomuch:1}
    },'ift,D'],
    ['brackin',0.264,&acgtRs{
        $E = Rs&E
        # after Hash 263
        $bows = me&iot,E,'-Bow'
        bows.map(E => Ec&rsc_mix = 'brackin')
    },'ift,D'],
   // -brack etc
    # styling: when to not mod -brack, brackets
    ['brack',0.35,&acgtRs{
        # < i e//C+%etc o -(brackio(s)?):e/E/-hat:e
        #    the -() gives match for pi on looser grammar than:
        #      o -brackio(s)? # the leg of s (Ec&s?) may be included
        #      o -brackio? # may include the -brackio somehow
        #       this form might allow wander to other E via ^-brackio
        #       stitching together possible joins for like items
        $E = Rs&E
        $Ep = Ey&up
        # < move in with &Eref_samepishow
        $usuup = Epc&pi == 'brackio' || Epc&pi == 'brackios'
        usuup and ah(R,'noCy','transpi',1)
        me&pity,E,'-Bow' .map(&e{
            $er = ey&R
            !er and return
            ers&nobrackets = 1
            ers&inline = 1
        })
    },'ift,D'],
    # styling
    &{
    # < io for C**
    me.injnl = &acgtm,start{
        $n = Cye(["endsaline",1,{s:"\n"},"ws"])
        isR(m) and $into = ms&M ||= []
        else {
            $into = ms&z ||= []
        }
        start and into.unshift(n)
        else into.push(n)
    }
    },
    ['brack',0.78,&acgtRs{
        $E = Rs&E
        $lim = me&modselect,R,{t:'limit-cap'}
        # < measure modulat, sometimes they sym only
        hak(lim) and $deeplim = lim
        lim.map(&m{
            # we could put $m\n
            me&injnl,m
        })
        #     or $m,(\n...) ?
        #hak(lim) and $firstdis1 = 0
        me&pity,E,'-Bow' .map(&e{
            # < $eC = o e//R/%C or return
            # < or:   o e)%C # implies s**->R** change
            $r = Aof(e)
            $eC = r && rs&C
            !eC and return
            # dont say -brack
            ah(r,'noCy','transpi',1)
            # or At:sc
            if (e.t == 'sc') {
                sc&drop and eCs&opa = 0.6
                ah(r,'noCy','label',1)
                # < &Eiot - selecting awake E**
                me&pity,e,'-Bow' .map(&e{
                    ey&R == 0 and return
                    $eeC = Aof(e,'C')
                    $la = eeCy&label
                    las&fs = 12
                })
            }
            eCs&dis = 2
            # sc following ref, make on its own
            # < isnt this css clear:left or something?
            # doesn't work:
            #firstdis1 and me&injnl,er,1; firstdis1 = 0
            #me&tc,eC,"Extrazity!"
            # of course the sc is the same
            # < the sc.* refs changing is interesting
            deeplim and me&modselect,e,{el:9,t:'limit-cap'}
        })
        me&modulatM,R
    },'ift,D'],
    // # mad plot to have -row open into two rows for sc,c
        # < sugggest this to mirage
        ['braceeek',0.36,&acgtRs{
            $N = me&pity,Rs&E,'-hat'
            $M = me&Sharg,'$s//RC',[N] .N
            M.map(C => s&dis = 3)
        },'ift,D'],
        
        
        
        
        &{
        # diag a little hash!
        me.blabdepeel = &acgtts{
            !hak(s) and return
            # use -hat if not peelable
            hak(grep(s => !iske(s), havs(s))) and return me&Ei,{t,s,pi:'hat'}
            $str = G&depeel,s
            me&tsc,t,str,'g'
        }
        },
    
  // -Log** > -hat
    ['Log',0.21,&acgtRs{
        $D = Rs&D
        $E = Rs&E
        if (Rs&Top) {
            # hide %ball modulat
            me&RE_singline
            # keep hoisting original string
            #  we do all -six twice by accident of the hoisting to -seven
            #  latest-ifies all visions of objects mutating along
            # < to get back to that exact moment,
            #    you could %TX a wait-forever at the &com
            # < a later Eref covering the new state is ideal
            #    so the -six can version but prefers others take the visual load
            #     its really -seven that should version anyway...
            # < R'Peace' %strange, and this &tc,'%string-wobs'
            Rs&first_truest = 1
        }
        me&firstsix_muteslaters,E
        
        each in ss&z {
            # make -Log/-row
            me&Ei,{t:i,s:n.sc,pi:'row',dl:3}
        }
    },'ift,D'],
    ['row',0.21,&acgtRs{
        $D = Rs&D
        $E = Rs&E
        # < the -Log/-row/-vat compression
        #    we D-scribe -row, -vat diverges to a type
        #     it is usually -String|Cish|Hash
        #      implied by the Dc&s="C Thing" or so
        me&Epigraph,'is,in:vat,Dpi'
    },'ift,D'],
    ['row',0.26301,&acgtRs{
        $D = Rs&D
        $E = Rs&E
        # right after -Hash spawns them, effect E/*:
        me&ioty,E .map(&e{
            # < know n:Run, Eref saying simply that (see nlist)
            #   as opposed to linking to the last -seven/0 with it
            $mute = e.t == 'node' && ec&s.t == 'Run'
                || me&laters_mutebykv,E,e.t,ec&s
            !mute and return
            
            $h = {}
            ahk(h,e.t,'impl',1)
            # < this label should make it into thingo:layout
            me&TXin,'rowmute' (h)
        })
    },'ift,D'],
    ['vat',0.21,&acgtRs{
        $D = Rs&D
        $E = Rs&E
        $p = Ry&up
        me&Epigraph,'is,ube'
        if (!Ec&ubervat) {
            if (ps&sym == 'A' && E.t == '4') {
                me&Ri,{limit:'A4',toomuch:1}
            }
        }
    },'ift,D'],
    # style
    ['vat',0.4,&acgtRs{
        $D = Rs&D
        $E = Rs&E
        if (Ec&ubervat) {
            if (E.t == 'says') {
                # < defeatable (like %impl) for modulat. &TXin it?
                Rs&inline = 1
                ah(R,'noCy','label',1)
                # < define this for -String
                map(n => ns&fs = 12,
                    # < &modo 'String/string@13', &modi for zuct-ing
                    me&modselect,R,{modt:'String',t:'string',cv:128})
            }
        }
        else {
            
        }
    },'ift,D'],
    
   // logc&muteslaters
    &{
    
        # some -Log finds first -Log in the &complace
        # < if time++ since &complace opened
        #    go further back (prev -seven:$time)
        # < better expressivity. o ^^-seven/-Log[0]//s...
        me.firstsix_muteslaters = &acgtE{
            # < o E-Log^:/-seven/-Log[0]/c&s
            #          ^ the opposite of /, ie -seven/-Log
            #            ^ means it should slope-over RE-Log
            #              the opposite of assuming we can RE->y&main
            #               through -Log[0]/E
            #  < some way to mean the first sibling etc
            #     of ours, in s** (outsphere), which the RE-sphere mimics
            # just to avoid hanging it on -seveny&initlog or so when we are it
            #  in case that causes a &forgetRunStep bug
            #  < X about stuff emit to -seven, for other -Log...
            $sLog = me.cbu(Ey&R,r => rs&Piing) .c.s
            $sev = sLogy&up
            $init = me&iot,sev,'-Log' [0]
            init == sLog and return
            $log = initc&s
            logc&fe_time == 3
            
            if (0) {
                $sev = me.cbu(E,E => Ec&pi == 'seven')
                $initRE = me&iot,sev,'-Log' [0]
                $initLog = me&iot,initRE,'-Log' [0]
                $LogE = ahsk(initLog,'y','R','y','E')
                me&fu,"fgako",LogE
                # ! REy&main is an R, which will do
                #  ! but is only there later!?
                # aka $D = &log
                $initlog = ahsk(initRE,'y','main','c','s')
            }
            
            logc&muteslaters and Es&mutinglaters = log
        }
        # mute if they are the same as the &complace -Log had them
        #  $k it something else to watch it mutate
        me.laters_mutebykv = &acgtEkv{
            $Log = me.cbu(E,E => Ec&pi == 'Log')
            $s = csof(Log)
            # we are a new wave of it (&complace in the same Eight)
            sc&muteslaters and return
            
            
            $log = Logs&mutinglaters
            !log and return
            $muteX = logs&X
            # < trust &Xsomp (no /$n, noises up X.notthere?)
            $kx = muteX.k[k]
            !kx and return
            !kx.refs and debugger
            $does = kx.refs.includes(v)
            !does and return
            
            return 1
        }
    },
   // &Epigraph
    &{
    # a short quotation or saying at the beginning of a book or chapter
    #  intended to suggest its theme
    # bunch trait declaration
    #  similar to &acting, or a bunch of &reaw|&rollbs|&bin
    me.Epigraph = &acgtc{
        $R = me&R
        $E = Rs&E
        # suppose these are known Ec&pi,
        #  the pi-dentity stuff is for can be guessed if eg c.in=1 from peel 'in':
        $pi = T.act.t
        # < remark if not schematic
        ah(R,'noCy','transpi',1)
        # < peel allowing ty+pes -> [ty,pes] ?
        #   then all these fuN(c.is).map(pi => ...)
        c = peel(c)
        # subclass
        #  eg act like a -hat
        c.is and me&typeup,R,notoneor(c.is,'hat')
        # E/* of such type
        #  eg the -Hash part of us will &Ei for s.*
        #   enforce -row/-vat as that happens
        if (c.ube) {
            c.in = c.ube = notoneor(c.ube,pi)
            # top of E^^^-vat
            Ey&up.c.pi != c.ube and $wasube = E.c['uber'+c.ube] = 1
        }
        c.in and Rs&Ei_pi = c.in
        
        c.Dpi and Rs&Dpiverbose = notoneor(c.Dpi,pi)
        
        !(c.ube && wasube) and Rs&nobrackets = 1
        # shatters the cell, via &sfx_mirage
        #Rs&inline = 1
    }
    },
    # not stating pi change
    ['noCy',0.88,&acgtRs{
        # a filtering map
        # < i R%M/--$n o C.y.$k o R%noCy/$k
        #     knowing %noCy has $k|$v? or %noCy.$k
        #      or %noCy[:k] # more keys-explicit
        haks(Rs&noCy) .map(k => C.y [k]) .filter(n=>n)
            .map(n => me&modselect,R,{el:9,n})
    },'ift,D'],
    # after becoming -Hash, go back to being a -row on D
    ['Dpiverbose',0.263,&acgtRs{
        $D = Rs&D
        $E = Rs&E
        Dc&pi = notoneor(Rs&Dpiverbose,Ec&pi)
    },'ift,D'],
  
  // -Womb -Fez -Bow > -hat
    # copy modulat straight to D**
    ['Womb',0.21,&acgtRs{
        $E = Rs&E
        $D = Rs&D
        
        !isC(s) and return me&strange,"!C"
        # which takes a lot of nodes:
        Rc&nl = 1500
        # which may occur in one big /*, esp if %Diff%Comp
        Rs&many_thresh = 1000
        # no specialfx layout E/*
        Rs&nomirage = 1
        # R** is only a lake of serialnumbers to see
        Rs&nofurtherDisplay = 1
        $p = Ry&up
        if (isR(s) || ps&Wombzuct) {
            # R embedded like so:
            if (ps&Wombzuct) {
                $r = sy&R
                # feed in %zuct/RC/*
                map(&st{ me&Ei,{t,s} },
                    grep(s => !sc&not, flatten(rs&M)))
            }
            else {
                $r = s
                Rs&Wombzuct = 1
                # checks
                $ups = pc&s
                !upsc&zuct and debugger
                !upss&miragia and debugger
                # < what if ups&zuct but no /s?
                
                # make note of this outside of %zuct%miragia
                Ds&R = s.t+' '+cvf(sy&cv)
                
                # then sleeve the R%C, like &modclone
                !ss&C and debugger
                me&Ei,{t:'RC',s:ss&C}
                
                return
            }
        }
        # show it all, on top
        #  same way &supetime does c.permasay
        #  further E** are just to transcribe it all to D**
        #   ie bits of s** dont nest in E**
        # < finding E** for things in there
        #    since there is now s**, then soon E**
        # < if we are the highest -Womb:
        if (Rs&Top) {
            me&boxcap,'modulat','1' (&ml{
                lc&not = 1
                ms&fs = 8
                ms&ws = 1
                # goes through the c&zuct=R, its R%C, then flatten(R%M)
                me&modclone,m,s
            })
        }
        # < measure modulat? chunks? showable? Plyable?
        
        # the D** picture
        D.t = s.t
        Dy&cv = sy&cv
        # osc K would say Dc&mc='zuct' if Dc&zuct was an object
        # < mirage seems to leak objects
        $down = &klr{
            k == 's' and r = nex({},r,'z')
            $can = tex({},r)
            $cant = hakd(r,can)
            ex(l,can)
            hak(cant) and D.c['m'+k] = spant(cant)
        }
        down('c',D.c,s.c)
        # could Dc&mc='zuct' and Dc&zuct='R Such 33'
        #  letting E/0 for the R itself (sc&zuct is always in ss&z)
        #  which gives us an Eref etc grip on its relation, R
        #   see R embedded like so
        
        !Rs&top and ah(E,'D_hides','c','pi')
        !me&Rortopsc,R,'ignore_sc' and down('s',D.sc,s.sc)
        
        
        # s**
        # < format for this
        each iz ss&z {
            Rs&Wombzuct and break
            zc&not and continue
            me&Ei,{t:i,s:z}
        }
    },'ift,D'],
    
    # fairly sprawly, for X**
    ['Fez',0.21,&acgtRs{
        # < no restating refs per ^^-seven
        me&typeup,R,'hat'
    },'ift,D'],
    # stops at C
    ['Fez+Cish',0.262,&acgtRs{
        !Rs&Top and me&Ri,'limit:Fez,toomuch'
    },'ift,D'],
    ['Fez+Hash',0.262,&acgtRs{
    },'ift,D'],
    
    # sprawly, C**
    ['Bow',0.21,&acgtRs{
        # < no restating refs per ^^-seven
        me&typeup,R,'hat'
        !Rs&Top && Ry&up.t == R.t and me&ha,R,"limit:repet,toomuch:t"
    },'ift,D'],
    # -hat allows qua.dim to sprawl open anyway
    #  it means we don't want to sprawl C
    ['Bow+indim',0.265,&acgtRs{
        #Rc&dl = Rc&d
        me&Ri,'limit:Bow,toomuch'
    },'ift,D'],
    ['Bow+Cish',0.2631,&acgtRs{
        if (Rs&sym == 'R') {
            me&Ri,'limit:Bow-R,toomuch'
            # dont sprawl into s** when looking at R
            me&TXin,'BowR',{layout:'R**'} ({
                c: {z:{
                    s: {ope:-1}
                }}
            })
        }
        me&TXin,'BowC',{layout:'C**'} ({
            # usu t,ycv are impl by %Ctitle drawing them
            #  and y,c are dim
            #   < which should stop .c.X{} from being > 5,
            y: {dim:1,z:{up: {impl:1}}},
            c: {dim:1,z:{
                s: {biggish:1}
            }},
            sc: {dim:1,z:{
                # <wants to be qua.usurped, knowing who
                z: {impl:1},
                title: {ope:1},
            }},
        })
        # < to E/y,c,sc,sc.z
        $z = ss&z
        # its many
        hak(z) and me&Ei,{t:'',s:z,rsc_mix:'nobrackets'}
    },'ift,D'],
    
    ['nobrackets',0.88,&acgtRs{
        $E = Rs&E
        s&bol = '1em solid black'
        
        $y = n => ns&label == 'bracket'
        me&moddelete,R,{y}
    },'ift,D'],
    
  // -Difmo
    ['Difmo',0.21,&acgtRs{
        $E = Rs&E
        $D = Rs&D
        #me&Ei,{t:'diff',pi:'hat',s,dl:3}
        !Rs&Top and return
        
    },'ift,D'],
    ['Difmo',0.22,&acgtRs{
        $E = Rs&E
        $D = Rs&D
        # from the RE, the titled -six
        #  &Ahdiff_what is vague about what s|z are (so is &finishPiing)
        $nav = map(s => me&REof,s , {gone:sy&s,new:sy&z})
        
        $Comp = ss&z.slice(0,9)
        $X = me&Ploy,nav,Comp
        Ey&Ploy = X
    },'ift,D'],
    &{
        me.Ploy = &acgt,nav,Comp{
            A = fi&At,"Ploy"
            $X = {A}
            $io = &xkv{
                # all indexes are k:v (&X_t)
                # ~~ c.wild: vx={v:x+}
                v == '.*' and return x[k]
                # or x+
                v == '*' and return havs(x[k])
                v == -1 and return havs(x[k]).pop()
                return fi&Xsimp,x,hashkv(k,v)
            }
            # push to eg sph|nod/$line=i++
            $iz = &Xkx{
                $many = io(X,k,'*')
                $i = hak(many)
                # we may mesh|multi-path|link X...x
                x and ahk(X,k,i,x)
                else {
                    # or new ..x as usu
                    x = io(X,k,i)
                }
                # meshing may eg i_line|mine
                # < crude avoidance of same-index sequence distribution
                #   having a subset at some locale
                x['i_'+k] = i
                return x
            }
            # X/$sphere=new = sph
            #  sph/$node flatly or /$in** = nod
            #   nod.sph = sph (also via nod.up**)
            #   nod.E|D
            #   nod/$line
            #  sph/$line
            $inode = &xe{
                $sph = x.sph || x
                # climb /$in** = nod, so nod.up reflects Ey&up
                $nod = iz(x,'in')
                nod.d = (x.d||0) + 1
                # link sph/$node flatly
                iz(sph,'node',nod)
                # nod knows:
                nod.sph = sph
                nod.E = e
                !ey&R and throw "undone E"
                nod.D = Aof(e,'D')
                # the RE doesnt have a D**
                # < should it? ~~ Js&top: $W@9/*
                #   and the RE/-hat|etc is an osc page
                #    so each page has an encoding defined as pi
                #     which may index pages by something else (t)
                #    and W formats are explained as eg $Wt/1.js
                #     which -js will be able to read,
                nod.D ||= nod.i_node == 0 && nod.E
                # eventually /$line of its diffside
                return nod
            }
            $inodlin = &nod,lin{
                $sph = nod.sph
                # join: one nod to many lin
                lin.nod = nod
                sph.line[lin.i_line] != lin and debugger
                # nod/$mine is a subset of sph/$line
                iz(nod,'mine',lin)
            }
            
            # start old|new E** sph and their /$line
            each te nav {
                $sph = io(X,'sphere',t)
                sph.sphere = t
                # via X-Fez**, the /$line is what to refer to
                $lin = iz(sph,'line')
                $nod = inode(sph,e)
                # node 0 for line 0
                inodlin(nod,lin)
            }
        // Ploy access
            $nonontrailinglinebreaks = &s{
                hak(s)-1 < s.indexOf("\n") and throw "many lin to one l"
            }
            $Nsph_for_l = &l{
                return l.t == 'same' ? havs(io(X,'sphere','*'))
                    : [io(X,'sphere',l.t)]
            }
            
            
        // Ploy loop
            $Ply = me&boxcap,'Ploy','1' (&Ply,{
                
                each il Comp {
                    # join: one lin to many l
                    nonontrailinglinebreaks(lc&s)
                    i == 0 && io(X,'sphere','*')
                        .map(sph => io(sph,'node',-1))
                        .map(nod => me&drawnod,nod)
                    
                    me&drawdiffbit,i,l
                    $ok = 1
                    Nsph_for_l(l) .map(&sph,{
                    # floppily contain rigid node**, floppy bits between
                    $next
                    me&boxcap,'l:'+i+':'+sph.sphere,2 (&m,la{
                        lac&not = 1
                        
                        # sph/$line/$bit .l|str
                        $lin = io(sph,'line',-1)
                        !lin and throw "nolin"
                        $bit = iz(lin,'bit')
                        bit.l = l
                        $str = bit.str = lc&s
                        # str never goes beyond \n
                        $newline = str.slice(-1)[0] == "\n"
                        
                        $nod = lin.nod
                        $no = &tc{ 
                            # stop l++
                            ok = 0
                            # nod complains
                            $x = iz(nod,'!'+t)
                            c and pex(x,c)
                            me&Ploy_fail,t,c,{sph,nod,lin,bit} 
                        }
                        $D = nod.D
                        $whole = Dy&toLines
                        !isst(whole) and return no('toLines',{l})
                        
                        me&Ploy_indent_sympathy,nod,lin,bit
                        
                    // D cmp str
                        # cursor whole to match
                        $at = nod.matchtil || 0
                        $str = bit.str
                        
                        # ignore str indent, coming from D** travel
                        bit.trimstart and str = str.slice(bit.trimstart)
                        # < dropping \n from bit, via this mechanism
                        #   rather than adding one to exp if non-match now
                        #    tho it does get us the \n between many nod/lin
                        #     that would be visible as exp[-1]=="\n"
                        bit.trimend and str = str.slice(0,hak(str)-bit.trimend)
                        # < more munging the expression
                        #    eg expect sequence number adjustment
                        #    eg between different compressions
                        #     one might deL->???->enL
                        
                        $len = str.length
                        $til = at+len
                        $exp = whole.slice(at,til)
                        
                        
                        if (exp != str && newline) {
                            # no \n in y&toLines
                            me&Ploy_mung,bit,'+'
                            exp += "\n"
                            til -= 1
                            $mungnl = 1
                        }
                        if (0 && exp != str && bit.i_bit == 0 && nod.d > 1) {
                            # bit starts an indented line
                            me&Ploy_mung,bit,'ind'
                            # < spec as C/* indent, two spaces. see Text/Lines
                            $fore = exp
                            # turns 0->fatal, 1->'', 2->'  ', 3->'    '
                            $space = indent(nod.d)
                            exp = space + exp
                            til -= space.length
                            if (exp != str) {
                                return no('eq-ind',
                                    {lin,bit,str,fore,space,exp,whole}
                                )
                            }
                            # < sort out indent funcs
                            #    we seem to have .d starting at 1->'', etc
                            #    Lines wants to indent by ' ' sometimes
                            #   this one does it to exp, multiliney
                            #   not too straight forward when exp may end in \n
                            #    it should follow input strings form?
                            #     and separate casting blah->blah\n
                            #indents((nod.d-1)*2,exp,
                            #    !ahsk(bit,'mung','+') && 'notailn'
                            #)
                            1
                        }
                        # should yield the whole line?
                        mungnl && til != whole.length and debugger
                        
                        if (exp != str) {
                            return no('eq',{lin,bit,str,exp,whole})
                        }
                        
                    // done?
                        nod.matchtil = til
                        $newnode = til == whole.length
                        if (newnode && newline) {
                            delete nod.matchlen
                            nod.ok = 1
                            
                            # more nodes
                            $E = nod.E
                            $N = me&ioty,E .filter(e => ey&R)
                                .map(e => inode(nod,e))
                            # < working
                            #$N = pam(me&ioty,E , e => ey&R && inode(nod,e) )
                            hak(N) and next = N[0]
                            else {
                                # climb until so
                                $N = me&Ay,nod,'/^^',{},{} (&nda{
                                    d.d > 2 and debugger
                                    # be a node
                                    !n.i_node && n != sph and debugger
                                    !n.i_node and return d.not = 1
                                    # n/[a+1]: another one after
                                    n.in[a.i_in] != a and debugger
                                    next = n.in[a.i_in*1+1]
                                    # keep going up
                                    !next and return
                                    # we have a node
                                    d.not = 1
                                })
                            }
                            !next and return no("nextless")
                            isC(next) and return no("nextC",{next})
                            nod = next
                        }
                        if (newline) {
                            # < until a multi-lines y&toLines
                            !newnode and debugger
                            # we will use this next time around
                            $lin = iz(sph,'line')
                            inodlin(nod,lin)
                        }
                    })
                    # out of l
                    next and me&drawnod,next
                    })
                    
                    !ok and me&tc,"Abort",'G'; break
                }
            })
            return X
        }
    // munging
        # line may start with spaces, to imagine into exp
        me.Ploy_indent_sympathy = &acgt,nod,lin,bit{
            $bit0 = bit.i_bit == 0
            # leading bits, until [^ ] is found
            bit0 and lin.indent_sympathy = 0
            lin.indent_sympathy == null and return
            # nod/lin 0 == first line of D
            $lin0 = lin.i_mine == 0
            $no = &{ delete lin.indent_sympathy }
            
            # we only ever make C-indents (Linesing C/*) outside of D
            !bit.str.startsWith('  ') and return no()
            # count ^( )+
            $level = hak(ksaf(bit.str,{bow:s => s != ' '}))
            $Cindent = Math.floor(level/2)
            
            # the first line of D has the real indent
            if (nod.Cindent) {
                lin0 and debugger
                $differ = Cindent - nod.Cindent
                differ < 0 and debugger
                # lin>0 should have at least ' ' more than lin0
                nod.Cindent*2 == level and debugger
                # < until BQ things have indents inside them:
                differ > 2 and debugger
                
                Cindent = nod.Cindent
            }
            elsif (lin0) {
                nod.Cindent and debugger
                nod.Cindent = Cindent
            }
            
            # < check what comes off is ' '+
            bit.trimstart = Cindent*2
        }
        # note if|how we change exp to make things fit
        me.Ploy_mung = &acgt,bit,t,v{
            ahk(bit,'mung',t,v||1)
        }
    // drawing
        # not to be confused with $bit, which it maps to
        me.drawdiffbit = &acgttl{
            $name = cint(t,l.t)
            me&boxcap,name,'5y' (&m,la{
                me&walls,m,'bd:1.1'
                lac&s = 
                    l.t == 'new' ? '++' :
                    l.t == 'gone' ? '++' :
                    l.t == 'same' ? '==' : l.t
                
                $to = me&drawString,lc&s,'y'
                tos&ws = 1
                me&walls,to,'bd:2.2,bg:000'
            })
        }
        me.drawnod = &acgt,nod{
            $E = nod.E
            me&boxcap,E.t,'1' (&ml{
                lc&not = 1
            me&boxcap,E.t,'1' (&ml{
                me&walls,m,'bd:3.3h4'
                ms&ml = (nod.d-1) * 0.6
                me&drawsym,'E'
                $sph = nod.sph
                sph.sphere == 'gone' and ms&bg = '#300'
            })
            })
        }
        me.drawsym = &acgtt{
            $sym = me&tsc,"sym",t
            $m = T.ab
            grop(sym, ms&z)
            ms&z.unshift(sym)
            pex(sym.sc,'fs:13,lh:0.8,hs:757')
            
        }
        
        me.drawbunchliner = &acgtc{
            each kv c {
                isst(v) and me&drawtextliner,{},k,v
                else me&drawnontextliner,k,v
            }
        }
        me.drawnontextliner = &acgtts{
            !isst(t) and throw "drawnontextliner!title"
            return me&boxcap,t,'5' (&ml{
                me&walls,m,'bd:1.3h4'
                # &Ploy_identify may have munged:
                me&tsc,'s',dis(s),'6y'
            })
        }
    // fail
        me.Ploy_fail = &acgttcs{
            # display in modulat
            me&boxcap,"fail",3 (&ml{
                me&walls,m,'ba:3.1h6'
                #ls&dis = 3
                ls&hue = 200
                me&tsc,"error:",'!'+t,'G'
                map(c => me&Ploy_identify,c , {s,c})
                me&boxcap,"ar",3 (&ml{
                    ls&dis = 4
                    me&drawbunchliner,c
                })
                me&boxcap,"co",3 (&ml{
                    ls&dis = 4
                    ms&hue = 33
                    me&drawbunchliner,s
                })
            })
        }

        # turn c={k:sph|nod|lin +} to idc
        me.Ploy_identify = &acgtc{
            each ts c {
                # leave non-objects in
                !isha(s) and continue
                $h = {}
                $looks
                map(&vk{
                    if (isob(v)) {
                        if (looks == 'bit' && k == 'mung') {
                            # know this object displays
                            h[k] = me&loosedepeel,v
                            return
                        }
                        # or leave out objects
                        return
                    }
                    $ma = k.match(/^i_(\w+)$/)
                    if (ma) {
                        h[ma[1]] = v
                        looks = ma[1]
                        return
                    }
                    # a word or so
                    h[k] = v
                },s)
                c[t] = h
            }
        }
        me.loosedepeel = &acgtc{
            return coint(armap(&vk{
                v == 1 and return k
                iske(v) || isC(v) and return cint(k,v)
                return cint(k,dis(v))
            }, c))
        }
    },
  
  // -hat > -Hash etc
    # expects it to be C
    ['isC',0.21,&acgtRs{
        me&walls,C,'bd:1.5'
        Rs&hat = 1
        isC(s) and return Rs&tiny = 1
        # was supposed to be C but isn't
        # < central fault aggregator
        me&strange,"!C"
    },'ift,D'],
    # diverges into types
    ['hat',0.21,&acgtRs{
        $sym = isR(s) ? "R" :
            isC(s) && isst(s.t) ? "C" : 0
        $Cish = sym
        if (Cish) {
            # isA, isJ
            isA(s) and sym = asym = 'A'
            isJ(s) and sym = asym = 'J'
        }
        elsif (isob(s)) {
            if (isar(s)) {
                # becomes a -Hash below
            }
            else {
                # also X, x
                $asym = me&diverge_ob,R,s
                sym = asym || sym
            }
        }
        elsif (isfu(s)) { sym = "" }
        if (sym) {
            Rs&sym = sym
            n sym 11 $s:sym fs:13,lh:0.8,hs:757
        }
        # < needs to go on another layer with all the layout stuff
        if (Rs&tiny) {
            # minimal typing up for labels
            #  in diagrams (-Bat) rather than datadumps (-hat)
            if (isC(s)) {
                # also stops recursion
                # < usu muted %%limit:tiny
                Rs&Ctitle = 1
                return
            }
            else {
                # stops recursion
                # < be %%layout:dim
                me&Ri,'limit:tiny,toomuch'
            }
        }
        Cish and me&typeup,R,'Cish'
        else
        # includes -Array, since typeof [] == 'object', ie /$k/$v
        isob(s) and me&typeup,R,'Hash'
        else
        isfu(s) and me&typeup,R,'Fun'
        else
        1 and me&typeup,R,'String'
        
        asym and me&typeup,R,'an'+asym
    },'ift,D'],
    ['Cish',0.263,&acgtRs{
        Rs&Hash = 1
        Rs&inlineable = 1
        Rs&Ctitle = 1
    },'ift,D'],
    ['Ctitle',0.2632,&acgtRs{
        # C display whittles down to symbol + name
        # < unless a cold light,
        #    trying to look like JSON
        # < by adopting ranges of sub-R types
        !isst(s.t) and me&strange,'!t'
        n t 12 $s:s.t label,deco
        # y&cv
        # < or c|s&cv|ov?
        Rs&sym == 'A' || Rs&sym == 'J' and 1
        else
        !hak(s.y,'cv') and cv = '!cv'; me&strange,'!cv'
        else {
            $cv = s.y.cv
            cv == '' and cv = "''"
            else
            !num(cv) and cv = dis(cv); me&strange,'cv?'
            else
            cv <= 0 || cv >= 1 and me&strange,'cv?'
            else {
                cv = (cv+'').substr(2)
            }
            cv != 1 &&
            n y.cv 122 $s:cv label,deco,hs:999
        }
        if (!Rs&strange) {
            me&TXin,'Cishade',{layout:'C'} ({
                t: {impl:1},
                y: {dim:1,z:{
                    cv: {impl:1}
                }},
                c: {dim:1,z:{
                    s: {ope:1}
                }},
            })
        }
    },'ift,D'],
  // -Hash etc
        ['Hash',0.263,&acgtRs{
            $D = Rs&D
            $E = Rs&E
            # Object has border
            #  inc At, key of it somewhere
            me&walls,C,'b:2.2'
            
            # its brackets, 23-77
            # %shym = a %sym that can be mirrored
            isar(s) and Rs&shym = '['; me&typeup,R,'Array'
            else Rs&shym = '{'
            
            # < G&n should Mw by T.Mw||T.act.t
            #   as &tsc does
            T.Mw = 'shym'
            $bracket = me&modbracket,Rs&shym
            # its many
            #  is fairly safe to spew out lots of E/*
            #   that should inform limits of &Eing_some
            #   < should be able to communicate pagination
            #   100 * usual %many_thresh shall %strange (flow-stopper)
            $hard_many = 2000
            each kv s {
                me&Ei,{t:k,s:v}
                hard_many-- < 1 and me&strange,"MANY:E/*"; break
            }
            bracket()
        },'ift,D'],
        # < G&arfgunc
        ['Fun',0.263,&acgtRs{
            !me&Rortopsc,R,'expect' and me&strange,"looking-at-functions"
            # adds D%:
            #me&Ri,"limit:,toomuch"
        },'ift,D'],
        # < larger spaces of
        # < Theing how to string|array until...
        # < wants a proper large-string
        #   better yet, -ind knowing the climb etc
        ['String',0.263,&acgtRs{
            $D = Rs&D
            $E = Rs&E
            # see Text
            $clue = me&Stringclue,s,{R}
            # become -Null|Num|etc
            clue.pi and me&typeup,R,clue.pi
            
            # < &tt doing uncrush first, etc
            $n =
            n string 128
            ns&fs = 8
            ns&hs = clue.hs
            
            if (clue.odd) {
                # add marks
                me&Stringchew,n,clue
            }
            else {
                nc&s = clue.say
            }
        },'ift,D'],
        
  //     -anA
        # > hide if -Aipscape they are in implies them
        ['anA',0.265,&acgtRs{
            $D = Rs&D
            $E = Rs&E
            $verb = &t{
                0 and me&tc,t,'6y'
            }
          // sort|group tycsc|misc
            # sort A.* into:
            # A t|y|c|sc
            #  A.y may envelope misc A.*
            #   for a tidy A.*, since A.y=A
            # < &pity,E,Ec&pi - to pick up the main items, amongst crowd
            #    ie R%ball and attendant R%Zaving etc
            $N = me&ioty,E
            $asabovey = grep(e => ec&s == Ec&s,N)
            $M = []
            map(t => M.push(... grop(e => e.t == t, N)),
                ['t','y','c','sc'])
            $norm = M.slice()
            $y = theone(grep(n => n.t == 'y', M))
            !hak(M) and debugger
            # now N are misc A.*
            $misc = N.slice()
            
            $impl = []
            $send = &Ntc{
                N = fuN(N)
                # these should be ignored but remain in E/*
                c == 'impl' and impl.push(...N)
                if (!c) {
                    # shooting %asfollows around
                    #  may $t={some:$object}
                    c = peel(t)
                    t = '%'+coint(haks(c))
                    c.rsc_mix = ex({},c)
                }
                each ie N {
                    me&TXilay,t,hashkv(e.t,c)
                }
            }
            
            # group A.1-9 after %asabove, even if some of them are %asabove
            $numbers = grop(e => num(e.t),misc)
            # < by the first number only?
            numbers = me&sortial,numbers,e=>e.t,'flat'
            
            $asabove = grop(asabovey,misc)
            
            # < might reoder to %asfollows
            # < clue it all to mirage liner
            misc = flatten([asabove,numbers,misc])
            
          // A.y
            # if we are A.y
            if (me&Ro,'RX,anAy') {
                # have only misc A.* here
                send(norm,'anAy-covered','impl')
                # dont be %toomuch to E/*
                me&nottoomuch_Eref,'^'
                # not so much decor
                me&moddelete,R,{modt:'Ctitle'}
            }
            elsif (y) {
                # A.y==A
                yc&s != s and debugger
                if (hak(misc) <3) {
                    # hide A.y, have misc A.* in its place
                    send(y,'noy','impl')
                    $sprinklemisc = y
                }
                else {
                    # move misc to A.y
                    verb('anA')
                    send(misc,'misctoy','impl')
                    send(y,'misctoy','anAy')
                }
            }
          
          // %asabove|follows
            # to E/*
            send(asabovey,'asabove')
            
            # E/* about to Eref each other
            #  they may all get %impl in a move to A.y
            #   some being %impl would be a problem
            #    < check R%asfollows target @4
            $refNs = grep(N => hak(N)>1, me&sortial,misc,e=>ec&s )
            each iN refNs {
                # if one+ is a number, they stay there
                $numbed = grep(numbers,N)
                if (hak(numbed)) {
                    # < should allow A.1=.3, .2 ?
                    me&listbetween,N,numbed and debugger
                    # lead N with them (become first instance)
                    N = uniq([...numbed,...N])
                }
                # first instance becomes where to move
                #  they may all be %asabove or not, etc
                $was = misc.slice()
                me&listin,misc,N[0],N,1
                $asfollows = N.slice()
                $eventually = asfollows.pop()
                send(asfollows,'asfollows')
            }
          
          // etc
            if (hak(misc)) {
                sprinklemisc and me&listin,M,sprinklemisc,misc
                else M.push(...misc)
            }
            # commit rearrange to E/*
            me&listin,Es&z,M[0],M,1
        },'ift,D'],
        &{
            # for things '=' adjacent things
            # a kind of noise-obscuring white symbol
            #  that eventually eats all the thingoes
            me.swallowupper = &acgttsc{
                $R = me&R
                c = peel(c)
                # < cv sort doesnt seem to work
                #   would be 1008 for left of At@101, 789 for right
                #   then they should go with things slicing out labelly columna
                c.float = haks(tax({},c,'left,right'))[0]
                c.fs = 15
                $m = Cy&swalsym = me&tsc,t,s,'G'
                ex(m.sc,c)
                
                me&Ri,{layout:t,casual:1}
                
                ac(R,'premeasurey',&{
                    # mute id shared with adjacent thing we '='
                    me&moddelete,R,{t:'sym',modt:'hat'}
                    me&moddelete,R,{modt:'Ctitle'}
                    
                    # folds thingoes
                    $N = me&modselect,R,{y:n=>nc&thing}
                    # not Displayed, still says them in D**
                    #  except for %%RX, which joins the %%layout we created
                    #   with a casual '~' that doesnt say 'asfollows' etc
                    # < defeatable, like qua.impl
                    N.map(n => nc&not = 2)
                    # fold thingoes into the = sign's title (tooltip, hover diag)
                    ms&title = me&thingoestitle,N
                    
                    $c = map(v => ex({},v), sex({},R.sc,'M,Mw'))
                    c.N = N
                    
                    #me&fu,hert,c
                })
            }
            me.nottoomuch_Eref = &acgtt{
                $N = me&Ro,'limit:ref,toomuch'
                !N and return
                each in N {
                    $Erefc = ns&Erefc
                    $refself = Erefc.self
                    t == '^' && !(hak(refself.ups) == 2 && hak(refself.downs) == 1) and continue
                    delete ns&toomuch
                }
            }
        },
    
        
  //     %asabove, %indim
        # export some &Topping_37, is deep-first after thingo
        ['asabove',0.55,&acgtRs{
            me&swallowupper,'asabove','=','left'
            # mirage will want to start lines with them
            #    many of them can =look=like=sense
        },'ift,D'],
        ['asabove',0.66,&acgtRs{
            $hert = slant(me.cby(R,'^^Top').slice(1))
            if (1 || hert == '0 1/y') {
            }
            #me&tc,"Schal:"+hert,'1G'
        },'ift,D'],
        
        ['asfollows',0.55,&acgtRs{
            me&swallowupper,'asfollows','=','right'
            # mirage them on a line
        },'ift,D'],
        
        # dim space, eg /c
        ['isdim',0.265,&acgtRs{
            $E = Rs&E
            # qua.impl ip if sip
            $ips = grep(map((v,t) => me&fiu,E,t,8 , peel('ip,sip')))
            if (hak(ips)) {
                spant(ips.ip.c.s) != ips.sip.c.s and debugger
                else me&TXilay,'onlysip','ip:impl'
            }
        },'ift,D'],
        
        # A/c/X/A ^3
        ['mayaswayabove',0.55,&acgtRs{
            $E = Rs&E
            if (me&ioty,Ey&up .indexOf(E) == 0) {
                # mirage will tack it near the opening
                Rs&inline = 1
            }
            
            # mute similar to %asabove
            # < curly cell, leading back up to...
            #    flab pinched around to the Efound
            ac(R,'premeasurey',&{
                # mute sym:A if we are /A
                $sym = me&modselect,R,{t:'sym',modt:'hat'} [0]
                sym && symc&s == R.t and symc&not = 3.14
                
                # we have said %Ctitle
                me&moddelete,R,{modt:'Ctitle'}

                # folds thingo:limit:ref
                #  s/^(^\d*):.*/$1/
                $lim = theone( me&modselect,R,{t:'limit-cap',y:n=>nc&thing} )
                $point = theone( me&ioty,lim,['','pointEref'] )
                !point and debugger
                pointc&s = split(pointc&s,':',1)[0]
                
                # fold thingoes into the = sign's title (tooltip, hover diag)
                #ms&title = me&thingoestitle,N

            })
        },'ift,D'],
        
  //     -anX..-anx
        &{
            # -Hash may be -anX|x
            me.diverge_ob = &acgtRs{
                $sym
                isC(s.A) and sym = 'X'
                elsif (s.up) {
                    # X...x.up=X
                    $ux = me&hat_x_upwards,R
                    # < use Xip
                    # mostly:
                    $uptoX = ux == s.up
                        # when X...x has been copied to X...other=x
                        #  crux at the X (having .A)
                        # < further than X|A
                        # < strongly suppose this is an x anyway
                        || grap(
                            me.cby(s.up,s => s.A),
                            me.cby(ux,s => s.A),
                        )
                    uptoX and sym = 'x'
                }
                return sym
            }
            # -hat^^ with X|x
            me.hat_x_upwards = &acgtR{
                $r = me.cbu(R,r => r != R && (rs&anX || rs&anx))
                return r && rc&s
            }
        },
        ['anX',0.263,&acgtRs{
        },'ift,D'],
        # < -hat -anx .z.* may be X|x from elsewhere (no s.up to R^^anx)
        #   x may be lodged in a variety of weird places,
        #   note such features of program memory lateralisings
        ['anx',0.263,&acgtRs{
            Rs&nobrackets = 1
            # must .up to an X|x we know?
            # < X|x if present
            #R.t == 'awoke' and debugger
            $ux =  me&hat_x_upwards,R
            $wander = ux != s.up
            $p = Ry&up
            if (wander) {
                Rs&noxup = 1
                $no = me&tc,"noxup",'y'
                if (R.t == 'up' && ps&noxup) {
                    # reveals where it thinks it is
                    # kind of terminating the noxup-ness
                    nos&fs = 6
                }
            }
            $style = {}
            !wander and style.up = {impl:1}
            !hak(s.z) and style.z = {impl:1}
            me&TXin,'anx',{layout:'anx'} (style)
        },'ift,D'],
        
    
 // R'The' compress -> $D ->
   // %thingo -> $D @68
    ['thingo',0.68,&acgtRs{
        me&Rthingo_toD,R
    },'ift,D'],
   // -String|-Cish -> $D @2637
    ['String',0.2637,&acgtRs{
        $D = Rs&D
        Dc&s = s
        if (Rs&Longstring) {
            Ds&Longstring = 1
            Dc&s = Rs&Longstring
        }
    },'ift,D'],
    # < i Dc&s = "(@sym )?@t( @cv)" o &modulat 11-131 .t:*
    #   < knowing sym must be \w, cv \d,
    #   < putting other @* after,
    #    < in a form including the .t, stuff about it,
    #      even the entire modulat, or this part of it
    ['Cish',0.2637,&acgtRs{
        $D = Rs&D
        # ground usually labels itself around here
        $N = me&modselect,R,{gte:11,lte:13}
        # should be simple labels, with .s?
        $cont = N.filter(n => hak(ns&z))
        hak(cont) and debugger
        # make a title
        Dc&s = N.map(n => nc&s) .join(" ")
        # usu "C $t"->"$t" but not if then $t="R blah"
        #return; #
        $comp = Dc&s.startsWith('C ') && !Dc&s.match(/^C \w /)
        comp and Dc&s = Dc&s.replace(/^C /,'')
        # < totally corresponding D-decompression
    },'ift,D'],
    # < when Nine/$t brings D** to resolve to nearby same
    #    having trained on common %Cish modulata,
    #     they can be reconstructed,
    #      even to the %%limit-level,
    #       so your remote data-dumper is cued for The++
    ['thaw+Cish',0.312,&acgtRs{
        $sym = Dc&s.match(/^(\w) /)
        sym && sym[1] &&
            n sym 11 $s:sym[1] fs:13,lh:0.8,hs:757
    },'ift,D'],
    &{
        # see if we can make some compression
        # < eg `a acs` in G as of now
        me.acsume = &acgtsc{
            c.starts && !s.startsWith(c.starts) and return

        }
    },
   
   
   // Describe how eg -Eight hoists
    &{
        # notices Ey&thing to use (+link) or update
        me.compLines_Eything = &acgtEd{
            $t = Ey&thing
            !t and return
            # on the node Somewhence-seven,
            #   E:-seven** encodes itself by %encodeD
            #    and then also R%E**, by %hoisten
            #   R%E:Somewhence**
            #    up on the outEsphere, finds its way into:
            #     R%E/Bowler etc
            #    ignoring R%E**//R%hoisten, ie E:-seven
            # Etop...E is E...e, a y&thing join
            $Etop = d.Etop
            !Etop and debugger
            if (d.d > 1 && ty&cv >= 0.2) {
                # this part of the climbing encode is isolatable
                #~>5 Eything: d.d, t.t, ty&cv
                me&Fame_Ething_add,Etop,E
                if (ts&first_string || ts&string) {
                    # stops, %string trusted
                    d.nofurther = 1
                    return me&unfixstring,ts&first_string||ts&string
                }
            }
                # everyone sets a thing at the top
                #~>5 Eythingset: d.d, t.t, ty&cv
                # E-seven always wants E:now (its out-E)
                # deal nodewake if Etop is already an out-E
                if (!ts&dige && Etopy&ers) {
                    # 
                    $R = Etopy&R
                    $oR = me.cbu(R,'Piing')
                    R != oR and debugger
                    $i = 3
                    while (i--) {
                        !oR || !oRs&E and break
                        $pE = oRs&E
                        pEy&thing and break
                        oR = oRy&up
                    }
                    !pEy&thing and debugger
                    #~>5 INIT to: pE.t, '<-', E.t
                    $z = oRc&s
                    !isnode(z) and debugger
                    me&wants,R,'pre_Fame_Ething',z
                }
                # < thing awake to see %string change?
                #d.d != 1 and ~>5 Yondfirst: Etop.t, E.t
                # %string made here
                d.for_string = &sdN{
                    ts&string = N.join("\n")+"\n"
                    ts&dige = dig(ts&string)
                    # and percolated to the out-C
                    $CC = Cy&C
                    !CC and return
                    #debugger
                    # supposing C=node%E Ey&C = outsphere
                    CCs&outC = 1
                    sex(CC.sc,t.sc,'string,dige')
                }
        }
        # after you encode t, check dependers to wake
        me.Fame_Ething_add = &acgtEe{
            $Et = Ey&thing
            $R = Ey&R
            if (!Rs&Piing) {
                # -Lab/Lab(i|o)
                Rs&Pier == 'Lab' and return
                debugger
            }
            $s = Rc&s
            !isnode(s) and debugger
            $t = ey&thing
            ac(t,'use',s,'dige',ts&dige||'...')
            #~>5 Eything: Et.t, t.t
        }
        # after you encode t, check dependers to wake!
        me.Fame_Ething = &acgtE{
            $t = Ey&thing
            $R = me.cbu(Ey&R,'Piing')
            each iz ts&use {
                $vers = ts&use_dige[i]
                #~>3 ^^^^Eything: z.t, E.t
                vers == ts&dige and continue
                ~>3 Eythingup: z.t, '>5 lovely', E.t
                me&wants,R,'Fame_Ething',z
            }
        }
    },
    ['Top',0.44,&acgtRs{
        $E = Rs&E
        Cy&cv = 0.22222
        # draw this E-etc
        Rs&encodeD = 1
        # draw together outsphere Ep/*
        #  merging outsphere: Ep//s**//E, &Piing inners: Ep/-etc 
        # < could do everything with pi?
        $Ep = Ey&up
        $Rp = Epy&R
        Rps&Ethinging and Rs&hoisten = 1
    },'ift,D'],
    # &ind to innermost eg E-Fez first, making string
    ['encodeD',0.7,&acgtRs{
        $E = Rs&E
        $D = Rs&D
        # storable encoding
        $t = Ey&thing = Dy&thing ||= Cye([D.t,2])
        # the R//E should have a thing,
        #  since /E**y&thing may not persist,
        #  whole node tends to happen
        $outR = me.cbu(R,'Piing')
        $outE = outRs&E
        outEy&thing ||= Cye([outE.t,2])

        $d = {what: &sd{
            # E**yD
            return sy&D
        }, compLines: &DdC{
            # D is now C, D is a copy to encode
            $E = Cy&E
            Ec&noencode and return d.not = 1
            # found another encoded thing
            $re = me&compLines_Eything,E,d
            re and return re
            # eg %Lab(i|o) (middle|end) of @Lab
            Ec&encode_thing_here and me&reusable_thing_string,d,E

            #delete Cc&top
            #Cy&D = D
            #Cc&pi == 'row' && fi&bug,'Firstlog' and debugger
            #me&dopi,D,d,C,c
            Dc&pi ||= Ec&pi
            # < &Ring a sliver of @7 time for everyone now
            each nk,gk Es&D_hides {
                delete D[nk][gk]
            }
            delete Dc&cv
            delete Dc&TX
            #comp_log(D,d,C)
        } }
        d.Etop = E
        me&Linets,t,E,d
        # < versioning
        if (Rs&first_truest) {
            $six = me&uptonode,E
            $ft = me&yio,six,'first_truest'
            $first = ft.o('first')
            if (first) {
                ts&first_string = first
                if (first != ts&string) {
                    sixs&now_string = ts&string
                    $wob = me&tc,"",'B'
                    wobs&warn = 'string-wobs'
                    ac(sixy&R,'M',wob)
                }
            }
            else first = ts&string
            ft.i('first',first)
        }
        me&Fame_Ething,E
        d.not and me&strange,"&Linets:not"

        #me&hu,'encod',"Stevewas"
    },'ift,D'],
    ['funktime',0.44,&acgtRs{
        $h = 40
        $i = 5
        while (i--) {
            me&tc,"Funk",'B' .sc.hue = h
            h += 30
        }
    },'ift,D'],
    ['This',0.44,&acgtRs{
        $E = Rs&E
        $D = Rs&D
    },'ift,D'],
    ['Eight',0.44,&acgtRs{
        $E = Rs&E
        $D = Rs&D
        Rs&hoisten = 2
    },'ift,D'],
    ['seven',0.44,&acgtRs{
        $E = Rs&E
        $D = Rs&D
        $t = Ey&thing ||= Cye([E.t,2])
        Ds&Seeving = 3
        Rs&hoisten = 2
    },'ift,D'],
    ['hoisten',0.7,&acgtRs{
        $E = Rs&E
        $D = Rs&D
        # climb from the node's %E (out-E)
        $p = Ry&up
        $Ep = ps&E
        # supposing we (eg -seven) are the only encoder
        $t = Epy&thing ||= Cye([Ep.t,2])
            # compress the E, start!
            # < linking to sevens? T outspheres
            $d = {what: &sd{
                # can change s (C) for d.compLines, but not d.for_string
                # can also not:
                # E**yD
                $r = sy&R
                # doesn't see other E//R%hoisten=2 (-Eight|-seven)
                !r || rs&hoisten == 2 and return
                
                $main = ahsk(d,'up','s','y','main')
                #main && main != s and return

                $E = r && rs&E
                E != s and throw "E!=s"
                #Ec&b and debugger
                $rp = r && ry&up
                $z = rp && rps&ball && rpc&s

                # < o p&pi == r%Pier o :p/$s//r
                if (E && !rs&Piing) {
                    # should we go into such &Piering
                    if (rp && rps&ball) {
                        $sp = rpc&s
                        if (spc&pi == rs&Pier) {
                            # being the main r%Pier
                        }
                        else {
                            ~>5 hoistavoid: rp.t, r.t
                            return
                        }
                    }
                    !rs&Pier and debugger
                }
                return E
            }, compLines: &DdC{
                $re = me&compLines_Eything,C,d
                re and return re
                # upper Ec&cv vanishes
                delete Dc&cv
                delete Dc&top
                delete Dc&b
                # < should use D...
                delete Dc&X
                delete Dc&TX
                delete Dc&RX
                $tar = delete Ds&target
                tar and debugger
                #Ds&target = "C:"+tar.t

                # climb E** after s**/-seven
                #Cc&pi == 'seven' and d.s = C
            }}
        d.Etop = Ep
            me&Linets,t,Ep,d
        me&Fame_Ething,Ep
    },'ift,D'],
        
        
   
   // etc
    
    ] }
    # datadump, once inside R%Pier
    me.hu = &acgttsc{
        c = ex({t,pi:'hat',s,dl:3,noencode:1},c||{})
        c.nl = 400
        $e = me&Ei,c
        me&Eing,3
        $r = ey&R
        $C = rs&C
        s&hue = 30
        s&bgh = '731'
    }
},
 
 
 // GOING
    &{
   // slope io: &Rsci dialects
    // dialects
        # not readable?
        me.Rli = &acgtscq{
            c = ex(c||{},{gk:'limit'})
            return me&Rsci,s,c,q
        }
        me.Rlo = &acgtscq{
            c = ex(c||{},{el:8})
            return me&Rli,s,c,q
        }
        me.Rti = &acgtscq{
            c = ex(c||{},{gk:'toomuch'})
            return me&Rsci,s,c,q
        }
        me.Rto = &acgtscq{
            c = ex(c||{},{el:8})
            return me&Rli,s,c,q
        }
   # GOING Sopi
   // -hat - top thing
    me.pihat = &acgtscq{
        $R = me&R
        $go = Rs&goThy
        return me&Sopi,s,'hat',c,q ({
            1: &Ecq{
                Ec&top = 1
                c.nopiinto = 1
                fi&piinto,E,c
                # < for a Cy&thing here
                $t = Ey&thing ||= Cye([E.t,1])
            },
            7: &Ecq{
                sy&data = hash
                
                # the redo:
                $sd = me&disp_suit,s
                Ec&N = []
                me&fiu,E,'topval',9
                
                # do:
                $f = fi&pii,E,{t:"topval",pi:'val',s:hash}
                me&windup_tape,E,6,q
                me&disp_tape,E
                
                go and me&nu,"Slu",E
                $R = me&R
                ac(R,'M',sd)
            },
        })
    }
   // misc
    # chase <ov on tape
    me.windup_tape = &acgtEcq{
        num(c) and c = {ov:c}
        c.ov = scaf(c.ov || 9)
        $seen = 0
        while (Ec&N.length > seen) {
            seen = Ec&N.length
            each ie Ec&N {
                ec&cv == c.ov and continue
                fi&piing,e,c.ov,q
                # sets cv=ov even if no mindbit is there
                ec&cv = c.ov
            }
        }
    }
    me.disp_tape = &acgtEcq{
        # uplink del modulata
        each in Ec&N {
            # n:s - outsphere
            $d = me&disp_suit,n
            each iz ns&z {
                dy&here(z)
            }
            # ny$pi = E - insphere, has others
            $nE = me&mustpis,n
            # n up to some E
            $pE = ny&up
            $pn = me&mustpiE,pE
            # here inside higher middle
            $pd = pny&disp
            !pd and debugger
            pdy&yond(d)
        }
    }
    # housing for stuff around stuff inside
    me.disp_suit = &acgts{
        $d = sy&disp = Cye([s.t,8])
        dy&up = s
        
        $be = me&fiu,d,'beginning'
        me&tc,be,s.t,'q'
        $mi = me&fiu,d,'middle'
        mis&ma = 0.2
        $en = me&fiu,d,'end'
        
        # heres on either side of yond
        dy&here = &z{
            $to = zy&cv < 0.67 ? be : en
            ac(to,'z',z)
        }
        dy&yond = &z{
            ac(mi,'z',z)
        }
        return d
    }
    me.mustpis = &acgts{
        $E = fi&getpi,s
        E == s and debugger
        Ey&up != s and debugger
        return E
    }
    me.mustpiE = &acgtE{
        $s = Ey&up
        $e = fi&getpi,s
        E != e and debugger
        return s
    }
   // -hash etc
    me.pival = &acgtscq{
        return me&Sopi,s,'val',c,q ({
            2: &Ecq{
                if (isob(sc&s)) {
                    fi&piing,s,{E,pi:'hash',ov:2},q
                }
                else {
                    ss&insideEnd = 3
                    Es&Leafit = 3
                    $M = ss&z
                    $di = dis(sc&s)
                    m thinking  $s:di %fs:8,hs:584
                }
            },
        })
    }
    me.pihash = &acgtscq{
        return me&Sopi,s,'hash',c,q ({
            2: &Ecq{
                $M = ss&z
                m thinking  s:{ %deco,fs:8
                each kv sc&s {
                    $row = fi&pii,E,{t:k,pi:'valend',s:v}
                    rows&seenity = 3
                }
                m thinking 7 s:} %deco,fs:8
            },
        })
    }
    me.pivalend = &acgtscq{
        return me&Sopi,s,'valend',c,q ({
            2: &Ecq{
                ss&insideEnd = 3
                Es&Leafit = 3
                $M = ss&z
                $di = dis(sc&s)
                m thinking  $s:di %fs:8,hs:584
            },
        })
    }
    
    },
  // %TheeThy, landscape
    # some events, to|from the book
    ['TheeThy',0.296,&acgtRs{
        #me&Thee,'TheeThy'
        me&reaw,R,'TheeThy'
        me&bin,'Theing'
        me&tc,"TheeThy"
        # < i $s/-This/Something-Eight/Somewhence-seven
        $This = me&fiu,s,'This'
        Thisc&pi = 'This'
        $eight = me&fiu,This,'Something'
        eightc&pi = 'Eight'
        $seven = me&fiu,eight,'Somewhence'
        sevenc&pi = 'seven'
        
       // some data
        # init
        # the -eight remotely
        # i This/Bowler/\E-hat
        #$This = me&fiu,s,'This'
        $Bow = me&fiu,seven,'Bowler'
        $dat = Bowc&s = me&PiRet_data
        dat.moreso = dat.asee
        Bowc&pi = 'hat'
        
        $Bow = me&fiu,seven,'Lol'
        $da = Bowc&s = {more:'some',figaro:dat.asee}
        da.furhtin = {llatin:4}
        Bowc&pi = 'hat'
        
        $Bow = me&fiu,seven,'Room'
        $da = Bowc&s = {fer:dat.asee,even:'more',figaro:dat.asee}
        da.furhtin = {llabin:4}
        $i = 0
        while (i < 60) {
            da = da.th = {}
            i++
        }
        da.is = 'all'
        # < &Eing preferring this to more level$n
        #   diversity seeking
        $ej = Bowc&s.neesd = Cye(['Nees',3
            ,{mo:3,tor:68,functions:"of an elabourate sort",s:"Thsideratea"}])
        ejy&fig = dat.asee
        ejy&vig = 2
        Bowc&s['leveridge'] = Cye(['Nose',7,{s:'li'}])
        $i = 0
        while (i < 55) {
            Bowc&s['lever'+i] = 'thing'
            i++
        }
        Bowc&pi = 'hat'
       //
        # the -nines
        #  autoviv etivity for relatives in This (Bowler)
        #   to be packed into some Nine/$t**
        $The = me&fiu,s,'The'
        Thes&tow = 1
        me&ha,R,'some,doing,ness'
        me&ha,R,'some,doing'
    },'ift,D'],
   // testing
    &{
    me.PiRet_data = &acgt{
        $hash = {
            fig: {vig: 'vort'},
            lw: {vig: 'vurt'},
        }
        $N = [1]
        N.map(&i{
            each kv hash {
                1 < i && isob(v) and v = ex({},v)
                v = hash[k+i] = {le:v}
                k == 'fig' && i == 1 and v.ol = {de:3,do:4}
                k == 'fig' && i == 1 and v.owel = {de:3,do:4,da:5}
            }
            hash['water'+i] = 'par importo'
        })
        $as = hash.asee = Cye(['Think',4,{dia:'dem'},{luc:'cho'}])
        ass&t = {le:3}
        return hash
    }
    # art busier
    me.tivity = &acgt{
        $R = me&R
        $x = me&Jx,R
        me&rollbs,"Fishtivity"
        x.ro("tivit") and Rs&Fishtivity = 5
        if (Rs&Fishtivity) {
            Rs&Fishtivity--
            me&waits,"ForItivity"+Rs&Fishtivity
        }
    }
    },
  //   /This|The%Theing /%TheEight/%TheSeven
    # Nine-ish container of /Eight-ish namespace
    ['Theing',0.291,&acgtRs{
        $x = me&Theing
        # This has 8,7,6 scheme, The may amorph while %tow
        $then = ss&tow ? 'TheThe' : 'TheEight'
        me&bin,then
        
        Rs&onlyish = 1
        me&tc,"Gool","G"
        Rs&TheingE = 1
        #me&piThis,s,2
    },'ift,D'],
    # in The%tow, anyone with sy&Todo may become -Bat
    ['TheThe',0.291,&acgtRs{
        me&bin,'TheThe'
        sy&Todo and Rs&TheTh = 1
    },'ift,D'],
    
    
    ['TheEight',0.292,&acgtRs{
        $x = me&Theing,{in:'TheSeven'}
        # inspheres on sy&$pi=E/**
        sc&nopiinto = 1
        me&hideyfix,R
        #s&nofurtherDisplay = 1
        me&piEight,s,{nopiinto:1},2
    },'ift,D'],
    ['TheEight',0.321,&acgtRs{
        
        # complete -eight
        #!Rs&wakeful and Rs&Fin = 1
        #me&piEight,s
        if (1) {
                # compress the entirety
                # < linking to sevens? T outspheres
                $d = {what: &sd{
                    # changes s (C) for d.compLines, but not d.for_string
                    # E**yD
                    $E = sy&R && sy&R.sc.E
                    return E
                }, compLines: &DdC{
                    $t = Cy&thing
                    if (t) {
                        if (ty&cv >= 0.2) {
                            # stops, %string trusted
                            !ts&string and throw "!string"
                            d.nofurther = 1
                            return me&unfixstring,ts&string
                        }
                        else {
                            # %string made here
                            d.for_string = &sdN{
                                ts&string = N.join("\n")+"\n"
                                ts&dige = dig(ts&string)
                                # and percolated to the out-C
                                Cy&C and sex(Cy&C.sc,t.sc,'string,dige')
                            }
                        }
                    }
                    # upper Ec&cv vanishes
                    delete Dc&cv
                    delete Dc&top
                    # < should use D...
                    delete Dc&X
                    delete Dc&TX
                    delete Dc&RX
                    # climb E** after s**/-seven
                    Cc&pi == 'seven' and d.s = C
                }}
                me&Linets,s,s,d
        }
    },'ift,D'],
    ['TheSeven',0.292,&acgtRs{
        $x = me&Theing,{in:'TheTh'}
        me&hideyfix,R
        $E = Rs&E
        # for a storable thing here, as EsyncThis hoists -sevens
        $t = Ey&thing ||= Cye([E.t,1])
        #me&piSeven,s,{nopiinto:1},2
    },'ift,D'],
    ['TheSeven',0.32,&acgtRs{
        sy&R = R
        
        $go = me&acting,R,'FSev'
        Rs&elvis = 'FishElvis'
        
        #s&hue = 138
        # -seven...-ologise also colours it
        
        #me&piSeven,s,{},7
    },'ift,D'],
  //     /%TheTh has R'The'
    # each thing
    ['TheTh',0.296,&acgtRs{
        sy&R = R
        sc&pi ||= 'Bat'
        $x = me&Theing,{in:'TheTh'}
        $E = Rs&E
        
        $tc = me&Thetower,R
        $es = tc.es
        delete sy&RXing
        es && esy&TXing and sy&RXing = esy&TXing
        
        #$c = me&Thetower,R
        #me&proto_Bat,c
        
        if (sc&pi) {
            $c = {}
            ~>6 pi: R.t, sc&pi
            $r = me&Piering,c
            rs&sleeping and return
            $e = rs&E
            me&fiu,E,e,2
            #Ey&thing = ey&thing
        }       
        me&fiu,Ey&up,E,2
    },'ift,D'],
    ['TheTh',0.6,&acgtRs{
        ~>6 The: R.t, joint(Rs&z)
    },'ift,D,sleeping'],
] }
