me.Sch_The = &acgt{ return [
 // The**
    
    =The
     little %TX -pi circuit
     user generating selections
      could mean any of the coordinates for it
      a multiple select should find language that expresses it
     use R
     do y&thing y&up?!
      and other waitsing
     < brackology broke?
       spheres less large
    =cut
    =neupi
     R'The' does -hat or -Bat
      makes $E** to $D**
       < from $D** as decoded
      < display entirely via $D
      encodes $D
     # used to|from:
     Run|Thy/
      This...$got
       usu -hat etc as a data dumper
       in-time activity
      The...$exp
       usu -Bat pile for E%TX input
       are essentially expectations
        might be a negative assertion
        might modulate the encoding
      any The informs its This
      Thy/This informs Run/The and more
       and thence Run/This...
     # experienced by:
     Gnome/
      Fories/ is storage for any:
      TheF/$t/$t%TheFine/$ti%TheFe tick over
       $ti goes OK
        has $exp=$ti-Ness/-eight/-seven/etc
        and $got=-Ness/... that &EsyncThis from This/*/*/etc
        the $exp%dige lets you avoid opening W:$ti until fail
      Thy/
       < %TX staged $ti <-> The...$exp
        
      
     
     < breaking up view controllers into composed units
        data sources, navigators, interactions, etc
      
     $E
      seeds of $R
      $E/* become @3
      E%TX and E%RX
       rudimentary ref recycling (&Eref*)
     $D for recording
      Dc&pi changes as it types up:
      -val
       -hash
        -C
         -n locatable from a namable node
       etc
      a one-line instant of data-point observation
      in the $D-sphere
       is the storable -log/**
     
     E%RX
      simple paths in ($t**) can be made
      < everything else
     
     < $D @6 sleps?
       may be able to 'OK', no modulat default
     
     < $D @7 converts to modulat
       $D sometimes rehydrates
        without needing the data (Rc&s)
         $D-got
          may make local expansion of sc&s it has
           but want a new -log to confirm it in-time
         $D-exp
          cannot expand
     
     < $D @8 is the click-unit
       somethings in the modulat may further instruct:
     
    =cut
    =phil
     Ya/$story
      /Fories... deps load
      ...Fine W:$story instance
      /Thy... backstage %Piing
      hires:
      ...@Run
       /This... to -hat type views
        will Ring instantly (per -log) when @Run
       /The... control for This
     
     < The..#$D
       your clicks being configured
       selected one shows CED columns over slope rows
     
     fi&balein
     see 'switched off Fe->Lab'
    =cut
  
  // @Gnomp/@Gnome perceiver # < separate from w:Travel
   
   
   # n Ya 6  %Gnomp
   // @Gnomp/@Gnome allowing S connect
    ['Zuist',0.296,&acgtRs{
        me&acting,R,'Zuist'
        me&nu,"Zuist",Rs&Zuist
    },'ift,D'],
    ['Gnomp',0.296,&acgtRs{
        me&acting,R,'Gnomp'
        Rs&wakeperc = 1
        me&baleg,'TryPiWarmer','Gnome'
        # %%active:Gnome here
        # < parallel tests? shouldn't interfere? (unpredictably)
        $c = {quietready:1}
        (Rs&boost||0) < 0 and delete c.quietready
        me&activator,c and return
    },'ift,D'],
    &{ 
     # other time
     // Gnomp** glob quiet_wake check
        # Gnomp &quietready ambiently checks any @active
        me.Gnomp_any_quiet_wake = &acgtR{
            $any = me&zaa,R,'active',1 .filter(&z{
                $r = zy&R
                !rs&Gnome and debugger
                zy&want_quiet_wake and debugger
                # they also must bs&wakeful to get there
                $want = me&Gnome_want_quiet_wake,r,z
                want and ~>2 anyquiet: z.t, want
                return want
            })
            !any.length and return 0
            return 1
        }
        # Gnome's &activate allows wanting to quiet wake
        #  sympathise parts of &SuperGnome!
        # < why these must be &saa?
        me.Gnome_want_quiet_wake = &acgtRs{
            # from the last &SuperGnome
            
            # really wants a quiet
            #  even if the want was generated while quiet
            # < how rare
            # < a real quiet, not artificial?
            #   comparative quiet momenting of here, there
            #   gives a workflow
            me&sa,R,'Superquiets,Pending' and return 'drew'
            
            # take any quiet opportunities when %%pur
            # < or just when %%pur,pre?
            if (me&sa,R,'pur' ) {
                # which allows loop of quiet wake=%%active
                me&rollbs,R,'purloop'
                if (!Rs&purloop) {
                    # < generalise, for Superquiets,Pending etc
                    #    add a &brackstill?
                    #   and an infinite noise source would use a clock
                    Rs&purloop = 1
                    return 'pur'
                }
                ~>2 purloop:
            }
            
            # any tractorbeams
            # < -pipe between -thing
            $N = me&saa,R,'supe,sute,sensitivity,otherable'
            $is = N.some(&n{
                $args = ns&otherable.split(',')
                args = args.map(&k{
                    $arg = theone(me&saa,R,k+',supe,sute,arg' )
                    # < expected args
                    !arg and return 0
                    !arg.sc[k] and return 0
                    return arg.sc[k]
                })
                # has given args
                args.some(v => !v) and return 0
                return me&mearg,ns&sensitivity,[R,...args]
            })
            is and is = 'sens:'+is
            return is
        }
    },
    # and any SC,Run in between
    ['Gnome',0.296,&acgtRs{
        me&acting,R,'Gnome'
        Rs&client = 1
        me&Names_set,R,'Gnome',s
        # %%active:Lab|Nine here
        #  early so **Nine can activate this time
        me&activator
    },'ift,D'],
    ['Gnome',0.5,&acgtRs{
        # invent Go (Gome gets permit)
        # < ++ for a new @Cat
        #   known replacements, reset strategy
        me&ha,R,{Go:s.t,tid:1}
        me&tc,"\n"
        
        !me&SuperGnome,R,s,{} and return
        # < de-activate? or put &activate in a
        #    sute perm,til=testcomplete
        delete Rs&wakeful
    },'ift,D'],
    # %Superpost then &wants %pre 
   &{
   // &Superdef & %%active
       =doc
        time barrel:
         you may find yourself Ying@8, able to quiet_wake
          esp. if that wasnt the last thing you did
          
         you may find yourself -hat matching some %TX
          or just streaming &Superdef of This
          
         you may find yourself pushing &Superdef
          because &Superdef led you to activate Lab++ time
         
         you look around at the flock:
         
        Gnomp vator, the top level
        Gnome vator + vate
        -Lab|-Nine vate
         
         any vate can be found out of time
          eg when vator decides to Go it
          eg potential quiet_wake look for a reason to be
           ie &Super* usu want to when %%pur
           # < types of neediness, a fugue of %%pur
           #   that should resolve before vator time++
         and its %%Superdef may allow async etc (WAFFLE)
          may allow async etc, but now:
           -Lab to -nodei
            when +-%%got_active,
             wants a wake for &SuperLab
              because &nodei
              and just to make things tick
           -Lab to -not
            # < -not, the annotation
            may just be watching for something
             in any &Superdef available ^^
             doing pictures into bales of Eight
              immediately|by whatever is %RXing this hook
             trusting til <4s later, we shall have:
          artificial %%quiet,
           can be imposed every 4s or so
            by latering the sooners
           causing a wave of &Super
            that can trust to thus batch redraw
             for a fast stream of 'ok' 
          # < -not(es) are to acquire coords, might be encoded
          #   win prizes for rambling poetry
        
        vator:
         state machine
          for things moving around
          satisfy conditions to various time++
           eg E**//R!%strange
           eg ThyThe clean (push may caution merge)
         step 1 -> step 2 in five easy light cones
         all %%Superdef... anywhere clue operation
          -Labi push ThyThe
          -Labo push ThyNine (if saving)
          -The recv
           # < rolling wake This
           extra e put to likely -Lab (may ++)
          %Gnome time:Such,how
           the way to advance time
           # currently all -Lab Go
          %Gnome proc:Thy-around
           when time, do Thy/** stuff first
         so
          each
           makes an o, about eg -Lab for time
          when ~o
           i time, put that is
            appears on copies of y&thing+
            interacting with time
          
          have a time rowing
           for art withit
          near &Superdef:
           making hoist Eight/Seven/~fig
            before ThisNine
           shall be a Ec&top thing,
            %Piing reusing &Superdef bits
             to transmit y&thing to each other
              in such a way that time++ whenever ~o
              
         
         &SuperGome See
           decide when to This time++
            by Thy time++ (-Lab Go)
            so push etc and all is well
            we then Run time++,
             ie visits the bloop
            expecting This time++
           makes This time++,
            when expected, or it tinkerfugues (auto pause)
            when quiet,
             or whenever tighter grabs of time occur,
              eg next whole -Ness/*/* is got
            -Ness++ new phenomena to get
           eventually
           deciding Nine is complete
            when no more Thy++ is possible
           
           other types of time,
            eg The++ after This++, before Ness++
             showing what arrived (%RX per -Lab...)
              ie basic assertions
               could be into This/not/time on arrive
             push The...y&thing to Thy...-Lab//The
              ie -Lab may know how the entire The should look
               push y&thing there makes it a storable with Outs,
                Outs could be empty, hoping %dige ok
                anything could be lv, incrementaling
                 Nine @2 takes init The|This time and ignores it?
                  to degrees - makes Nine/-Lab/This/such/situation
                   findable for situ->Story guidance mechanism
                   # < feedback
              
              or supplying a flock of figurines
               to dialectical furnishing drawing up
                Such-Lab reports its findings
                 which may actually show up in This/'Such-Lab'/time
                   since they are -Ness-y
                  & hoist turnaround, still under that The++ time,
                   so as to not wake Such-Lab when This++ for report
                   then:
           lead
            neatly
             back
              to: This ->
           receivers:    
            -Lab++ if any
             see The++ after This++, before Ness++
             might have things to light up in:
            -Ness++ pulls, up-to-date
             spills guts if trouble,
              wait to continue? @Gnome settings
               ideal time to fork(), point to start showing dev
                further Nine++ once -Ness wobble could bignoise
            -Nine++ stages
              -Ness complete
              -Lab reveal|pull
          
          and Thy..Lab putting into @Inc|@Pro|@Run
           which will mostly model settings
           to be pasted up via &Superpath
            at times when &Superdefs are allowed to change:
             by going into -Lab to send -nodei from it
              ticking &SuperLab over for it
             by delivering all &Superdefs
              making landel
              which causes a bunch of activity,
               we might Thy** before but when we -Ness
               eg  $initial_The|Lab|This
                which we might have stored
               eg $postNess_The might be called for
                 
              sending us around to:
          &Superdef feeds streams
           eg -Nine reads -Eight**
            < additional -hat perceptions, at times
           eg -Lab reads -The, also writing
            based on -Lab revealed after done -Ness
          is a rowing of stuff
           various dimensions of it affect differently
           following -Nine/-Lab
            should == if we pushed it
        etc
       =cut
     // for &Super* times
        # vate:r%Piing <- %%Superdef for a vate
        me.Superdef = &acgtc{
            $R = me&R
            if (Rs&Piing || Rs&TheFine) {
                # outsphere
                # < organise &Super* via &Superpath
                $r = R
                c.wakenode ||= 1
            }
            else {
                # or in &Piing
                # eg -Lab/-Labi defining what it would push
                # via the ^^%Piing, it vate, may have %%got_active
                $r = me.cbu(R,'Piing')
            }
            $q = {}
            # < make canonical name (resolving $n)
            q.Superdef = 1
            Rs&E and q.E = Rs&E
            # c eg:
            #  f=nodei,to:@Run,wakenode
            #   wakenode means r must experience +-%%got_active
            #    which checks its <32 working one more time
            #     < something for vator to ttl before act
            #  f=Flight,of=inst,to:@Thys,wakenode
            #   as above, more clearly wishes it was &Superpath...
            # async,
            # < y&thing or wishes of a land|time
            #   may introduced in c (no callback)
            #   < it may be used to define &Sarg+
            #     about what|how, hooks etc
            me&ha,r,q,{},c
            
            # ...round trip to @Gome &Supervator to see us
            #  and make sense of situ, de-%strange, etc
            # < ability to act active|not immediately
            #   thinking on behalf of Supervator,
            #    othering sutes?
            #    what if %strange returns?
            #    or the this r%%Superdef could be new|gone|diff
            #     via resolving $n, brackstill for this r%%Superdef
            #     dome=$Superdef each one? traction them in &SuperLab?
            
            # then, %%got_active
            #  stays active
            #   < forces acting on us may like to:
            #      suddenly freeze outgoings
            #      try to avoid waking $to
            #     as in a compile error
            #   < to sleep -Lab? see &Eref_begin etc
            #     we could maybe dome=$Superdef+'o'
            #     if all it is doing is &nodei
            #     or it can be outsourced to @Gome...
            #      would clean up zombie &nodei from deleted Thy**
            if (me&ja,r,'got_active' ) {
                c.got_active = 1
            }
            return &y{
                # < notice whether they call this? see (no callback)
                # < capture y for later via %active/..., see async to -Lab
                c.got_active and y (r,R)
            }
        }
        # @4 draws vate %%Superdef
        me.Supervate = &acgtc{
            $R = me&R
            !me&ja,R,'got_active' and return
            s&bgh = '311'
        }
        # @5 draws|decides who is active
        me.Supervator = &acgtc{
            $h = T.sute
            $R = me&R
            # that seem ready, by @5
            me&boxcap,"vator:",'1p' (&{
                # vator has a proper list of %active=C...
                $act = Rs&active
                # contrib via %%active
                $N = me&jaa,R,{active:1,eto:Rc&s}
                
                # &rowcap doesn't start anything until called back
                $row = me&rowcap,N,'active'
                row('seems ready',&s{
                    # < and E^^^c&uber
                    $g = me&Sharg,<<'',[s]
                        o &wants //R** if %strange o $s//E/*

                    # ends up with none that are strange
                    hak(g.N) and me&tc,"%strange",'B'
                })
            
                me&Superready and return

                actc&vators ||= 0
                actc&vators ++
                me&tc,dis(sex({},act.c,'vators,times'))

                $acha = 0
                row('@',&sn{
                    ns&dis = 5
                    # < a follow?
                    $z = me&fiu,act,s.t
                    zc&vators ||= 0
                    zc&vators ++
                    zy&C && zy&C != s and debugger
                    zy&C = s
                    # gather opinions on there
                    $defs = me&jaa,sy&R,'Superdef'
                    each in defs {
                        ns&wakenode and zc&wakenode = 1
                    }
                    # &Sargfunc_wants also demands some
                    if (!hak(defs)) {
                        zc&wakenode = 1
                        me&tc,"!def?",'b'
                        return
                    }

                    # < make it active when time
                    $ov = 0.2
                    if (zc&ov != ov) {
                        me&tc,numf(zc&ov||0)+'->','y'
                        zc&ov = ov
                    }
                    me&tc,'@'+numf(zc&ov||0),'q'
                    me&tc,'.'+zc&vators,'b'

                    if (zc&ov != zc&cv) {
                        me&tc,'/'+numf(zc&ov||0),'q'
                        
                        !zc&wakenode and me&tc,"(#<otherable)",6
                        # < bring back &diagno
                        me&wants,R,"ovpush",s
                    }
                })
            })
        }
     // f
     // &activator: Gnomp, Gnome hoist bunches
        # R%active, the list is had
        #  eventually and through several ports
        
        me.activator = &acgtc{
            $R = me&R
            # for the %%active opining it
            me&reaw,R,'active'
            me&rollbs,R,'active'
            $act = me&Rsci,'%active'
            # vator spec
            c ||= {}
            ex(act.c,c)
            if (c.quietready) {
                # Gnomp routes ambient attention seeking hooks
                #  with a side project:
                #   does some proto &Superquiet initially,
                #   to quiet wake once &Resides etc concludes
                # sees opportunities to wake at certain times
                # < beyond forcing a possibly repetitious quiet_wake
                me&quietready,R and return 1
            }
            else {
                # follow above vator
                me&active_to,R,c
            }
            # to inherit quiet-awareness,
            #  following the real &quietready on Gnomp
            #  or follow Gnomp on Gnome, etc
            me&howdidIgethere,c
            
            # < compute state, to draw it in &Supe*
            #   with what has changed per self time
            #    as things would be logged
        }
        # if quiet
        me.howdidIgethere = &acgtc{
            $R = me&R
            # determine %is_quiet from ...
            if (Rs&quiet_waker) {
                # Gnomp has or has-not
                Rs&is_quiet and c.quiet = 1
            }
            else {
                # our activator
                !c.to and debugger
                $r = me&yfuture,c.to
                # < this will be on our tunnel
                if (rs&is_quiet) {
                    Rs&is_quiet = c.quiet = 2
                }
            }
            # < we could wake=[exactly-who-needs]
            #   we currently pull attention into Gnome,
            #   then hope that will want other things...
            # < Gnome quiet may want to then wake Lab as if quiet
            #    this could be synth quiet or synthart quiet
            if (Rs&is_quiet) {
                # display how we were activated
                $t = me&Mwty,R,'Peace','ie'
                ts&opa = 0.5
            }
        }
        # for vator or vate
        me.active_to = &acgtRc{
            $to = c.to = me.cbu(Ry&up,'active').c.s
            to && !isnode(to) and debugger
            return to
        }
     // &activate: Gnome, Lab are clients
        =pod
         < type of &acquire connects above:
           Gnomp/Gnome%client
            using &(Gnomp|Gnome)_(any|want)_quiet_wake
           Gnome%client...Lab|Nine
            similarly.
            we have a c
             it says how|when Lab is to realise %%active
             it might be now,
              we might have to synth a %%got_active
            and any Lab%%Superdef,fortime...
             clues us to feed eg oute y&thing to The
              an otherable task (sender doesnt wake)
             or ++%%wakenode, if &SuperLab must perceive,
              Lab itself recv|become %%got_active
               and eg &nodei, which sender must wake for
            after the %%got_active,
             which may not be delivered from your $to
              if the act of it was otherable
            you continue once The settles,
             having Thy 1, The 1
             about to This 1
           so &Superdef
            can take eg oute y&thing to The
             so we have Thy 1
             living The to recv it
            without living Lab to send it
            so if you randomly live Lab,
             %%got_active is synthesised in
            but when &activate while so,
             we shall make one up for it
             
         Gnome, Lab get on the list
         and realise their activation
         
        =cut
        
        #     then posit things activation entails, etc
        #  prepare to join quiet wake of Ya%Gnomp
        # importantly Gnomp has &quietready
        #  hooking into the above outside-times
        #   from a &Ying_8 having no next move
        # also, form an orderly todo list
        #  which can decide things any time
        #  bringing light cones into the world
        me.activate = &acgtc{
            $R = me&R
            $s = Rc&s
            # tend to wake from above, 
            #  helps if ^:Gnomp%wakeperc
            #  no effect on Thy..Lab...
            
            # to%%active=us
            $q = {active:s}
            c = ex(c||{},q)
            # make a reading
            $z = me&o_activate,c
            # many calls to &activate per R
            $oc = Rs&first_activate ||= c
            oc && oc != c and c.oc = oc
            else c.init = 1
            
            # anyone interested in being active can:
                if (c.init) {
                    # 0 send %%active
                    me&nodei,R,c.to,q
                    # how we are waking
                    me&howdidIgethere,c
                }
                
            # 0 extra-not-active, rarely
            #   < proper paused-ness, Yingwake|elvis avoiding them
            #   similar to SC%Con meaning %%Control co is needed
            #   halting &Supe*, 
            #    which may cause eg &Resides to stop
            #     < in a way it continues? see reaw.*bal_*
            c.ov < 0.1 and return 1
            
                # 1 may be wakeful, when onlyish
                #   plumbing quiet moments into Gnomp/Gnome
                #   because we dispatch to Gnomp when quiet,
                #   < could ideally write up wakers ourselves
                # tend to wake from above, 
                #  helps if ^:Gnomp%wakeperc
                #  no effect on Thy..Lab...
                Rs&wakeful = 1
                # < only when our want_quiet_wake went off
            
            c.ov < 0.2 and return 0
            # must have an $act/$z
            # < %commit this... when &Superdef are sent
            zc&cv = zc&ov
            me&ha,R,'got_active'
            
            
            return 0
        }
        # vate reads level of one %%active
        me.o_activate = &acgtc{
            $s = c.active
            $R = sy&R
            !R and debugger
            $to = me&active_to,R,c
            !to and debugger
            $r = me&yfuture,to
            $act = c.act = me&Rsci,'%active',{el:8,v:r}
            !act and debugger
            actc&times ||= 0
            actc&times ++
            
            actc&stop_all and c.ov = 0; return
            c.ov = 0.1
            # cones
            $z = me&fiu,act,s.t,8
            !z and return
            
            zc&ov ||= c.ov
            c.ov = zc&ov
            
            return z
        }
        
  // &Superarg, -> &Gnome_Jx # < separate from w:Travel
        # < ceremoniously knowing
        me.Superarg = &acgtsc{
            $h = T.sute
            # c must be so between Superarg-arg are params
            $c = ex({Superarg:1},peel(c||{}))
            # %%rec... are permanent, remain while going faulty
            #  per %%supe,sute,rec, like a %%dome
            !c.flighty and c.rec = c.flighty||'Superarg'
            # can be found:
            $k = haks(s)[0]
            !k and debugger
            c.Superarg = k
            if (c.viatw) {
                $sk = c.viatw
                # < from other $sutes?
                $z = me&Superarg_find,sk
                if (z) {
                    $v = me&fiu,z,k,8
                    !v && hak(z.y.tv) and debugger
                    !v and c.fail = "viatw!t:"+k
                    else s [k] = v
                }
                else c.fail = "viatw!arg:"+sk
            }
            c.arg = 1
            # c must be so the k:v after arg
            #  so s mixes onto the end:
            h.ha(c,s)
            c.fail and return
            $v = s [k]
            # becomes usable to &Sarg
            h.ar [k] = v
            # < make presentable
            $spc = " @"+k
            me&tc,spc,'6g'
            return v
        }
        # find names from surrounds
        #  for any Cat** or Gnome**
        #   via Cat%client=Gnome
        # we have a more non-fatal &Gome_Jx
        # not waiting on much to get ready
        
        # &Gome_Jx is used:
        #  w:Travel: only in &SuperGome
        #  w:Story: for %*Fine, we use
        #  w:The:
        #   &SuperGnome Reside (can not?)
        #   Pi%Lab -n
        #    < conceptually brackstract for one-line rurl (relative url)
        #   &Theing, for all %Piing
        #    < halts %Yingulog, can't find ^^%client
        #       should look down %active
        
        # revisit &fabioty
        
        # replacing map, [] or {}, waves of y(v,k)
        self.rap = &N{
            $ys = [...arguments].slice(1)
            $array = isar(N)
            each iy ys {
                $M = []
                each in N {
                    array and i *= 1
                    M.push(y (n,i))
                }
                each in N {
                    N[i] = M.shift()
                }
            }
            return N
        }
        me.Gnome_Jx = &acgtR,cl{
            $arg = {}
            if (cl) {
                # GOING, wrapped in &Gome_Jx
                $GOING = 1
                arg.Gnome = cl
            }
            else {
                # o R^^?%client
                $cl = me.cbu(R,'client')
                if (!cl) {
                    # we may Ying/*(/*)?%active%client
                    # < do we need to be before Peace makes %Ace(.4=Ying)?
                    # < some locales may not grant %active automatically?
                    $Ying = me.cbu(R,'Ying')
                    each ir Yings&z {
                        !rs&active and continue
                        rs&client and cl = r; break
                        each ij rs&z {
                            !rs&active and continue
                            js&client and cl = j; break
                        }
                    }
                }
                # if %client is someone else
                #  eg @Cat)%client = @Gnome)%client=1
                $hi = cl && isC(cls&client) && cls&client
                if (hi) {
                    # @Gnome:hi hired @Cat:cl
                    arg.Hire = cl
                    arg.Hired = hi
                    arg.Gnome = hi
                }
                else {
                    arg.Gnome = cl
                }
            }
            rap(arg,r => ry&R)
            
            $cl = arg.Gnome
            !cl and throw "!client"
            !isR(cl) and debugger
            !(cls&Gnome || cls&Piing) and debugger
            # < xs&Gome going
            arg.Gome = arg.Gnome
            
            # < your use case may be sensitive to rough landings
            # < Superarg that arent nodes
            ex(arg,me&Superarg_arrive,cl )
            rap(arg,r => ry&R)
            
            # arg.Gome gives Gome/*, eg xs&Fories
            $x = me&Jx,R,{c:arg}
            
            # the Run/This > Thy/This, etc
            xs&Run && xs&This && xs&This.y.up != xs&Run and debugger
            
            if (GOING) {
                # what &Gome_Jx does
                Rs&Gomex = x
            }
            return x
        }
        
        
      // f
        # find one such %%Superarg=$k (exclusive gk)
        me.Superarg_find = &acgtkc{
            $jaa = T.sute && T.sute.jaa
            !jaa and $j = me&R; jaa = (c) => me&jaa,j,c
            $is = theone(jaa({Superarg:k}))
            c and c.n = is
            is && !iss&fail and return is.sc[k]
        }
        # bind and check all
        # reading but sometimes other to R%Gome
        me.Superarg_arrive = &acgtj{
            $ar = {}
            me&zaa,j,{Superarg:1} .map(&n{
                $kv = ksaf(n.sc,{aft:'arg'})
                !hak(kv) || hak(kv) > 1 and debugger
                $k = kv[0]
                $v = n.sc[k]
                # failing names should !v
                ns&fail && v and debugger
                ns&fail and return
                sex(ar, n.sc, kv)
                # and check it
                if (ns&viatw) {
                    # parent is still attached
                    $z = me&Superarg_find,ns&viatw
                    if (z) {
                        $vv = me&fiu,z,k,8
                        # < catch new Run/This etc
                        vv != v and debugger
                    }
                }
            })
            return ar
        }
        # chase parent of a %%Superarg,fail
        #  -> %%pur,pre=$Parent to &want
        me.Superarg_purfor = &acgtnc{
            if (ns&viatw) {
                # wake parent
                $v = me&Superarg_find,ns&viatw
                v and c.pre = v
            }
        }
    
  // Supe@Gnome
   // 1 'Reside' @Gome
       # 
        me.Goget = &acgtRsce{
        }
        me.SuperGnome = &acgtRsce{
            $x = me&Jx,R
            c.t ||= 'Gnome'
            $su = me&supetime,R,c.t
        # non-%%arg, esp as Go is a row
        #  brack only allows other rows as %%n
        $Go
        $x
        su('Reside',{perm:&zaa,jaa,ha,ar{
            
            x = me&Gome_Jx,R
            !x and debugger
            s != xs&Gome and me&tc,"~Gome"
            
        # i @Go <- %%Go ?
          # the entire @Gome 
            Go = theone(me&jaa,R,'Go' )
            !Go and return ha('pur:!Go')
            # acquire %%active
            #  mostly so we keep coming back if jaa(pur)
            #   ie busily attends to !ok &Super* 
            # < later that will be for any wanting-%%active,
            #   %%active-proper once &Superdef allows
            # < we may be pushing Nine some other agenda
            me&activate and return ha('pur:!active')
            
          # begin @Nine + @Thy
            # < s/ies/y/
            me&bal,'Fories','Fories,eph'
            # event grabulator
            me&bal,'Thy','TheThy,eph'
            # < TheF defaults to $t.t
            $r = me&bal,'TheF','TheF,eph'
            $TF = rc&s
            TFs&about ||= [R.t]
            me&Ring,R,{inside:R,ov:0.4}
            
            # til quiet (once)
            me&Superquiets,R
        me&Superready and return
          # < meaning Gome/* are ready
            x = me&Gome_Jx,R
            # storage pile
            !xs&Fories and ha('pur:!Fories')
            # the bunch of Nines we have open
            $F = xs&TheF
            !F and ha('pur:!F')
            ha('arg',{F})
            # < have Thy first clue from F
            !xs&Thy and ha('pur:!Thy')
        me&Superready and return
      // 
   // 2 -> Travel... < &Sarg
            # < &Sarg behind io
        # < these... chaining Go, mixing things in
        =pod
         Gump... %%Go,tid,Goting... -> Ya
         Gnome %%Go,tid,Gome,Goting... -> Travel
         Travel...
        =cut
        # i @Gome:s # declares a Name
            me&Superarg,{Gome:s}
        # i @Travel <-+{@Gome,Catfunc:PiiCat} $Go
          # get @Cat to control
            if (x.ro('++')) {
                me&wants,R,'Gnome-tid++',xs&Travel
                ss&tid = (ss&tid||0) + 1
            }
            Go = Cye(Go)
            if (ss&tid) {
                !Gos&tid and debugger
                Gos&tid += "."+ss&tid
            }
            # < mutate $tid, gather the right @Cat
            me&nodei,R,xs&Travel,Go,{},{Gome:s,Catfunc:'PiiCat'}
        # i @Travelable @Cat o &wanta %%Travelable,Cat,n
        #  declares Names, also sanity for a single row
        #  will %%pur if Named things not ready looking
            # fires back with Travel/$Travelable/$Cat
            # < show this to Josh
            $n = theone(me&jaa,R,'Travelable,Cat,n'
                .filter(n => me&etoward,ns&n,Go ))
            !n and return ha('pur:!Cat')
            # must be inherited from the Go we currently have
            #  ~Go might $tid++, becoming a fresh $Cat
            #   Gump or so might have motivation to reuse Gome
            #    TheFine can be shook loose in a similar fashion
            #     it has reself|Leave buttons around to do so
            #     essentially copying itself from W again,
            #      to erase (branch from) any Accepting
            #       we were thinking of committing
            
            # along with @Gome, we now know:
            $t = me&Superarg,{t:ns&Travelable}
            $Cat = me&Superarg,{Cat:ns&Cat}
        me&Superready and return
            # %%Control -> $Cat/* may now
            me&nodei,R,Cat,{Control:1,n}

            # Cat/* checkable anywhere via &Gome_Jx
            $Run = me&Superarg,{Run:0},{viatw:'Cat'}
        me&Superready and return
            !x.ro('maynotRun',{}) and me&nodei,R,Run,'mayRun'

            $This = me&Superarg,{This:0},{viatw:'Run'}
            $The = me&Superarg,{The:0},{viatw:'Run'}
        me&Superready and return
            x = me&Gome_Jx,R
            $Run = xs&Run
            !Run and return ha('pur:!Run')
            # &Superarg puts in ar
            Run != ar.Run and return ha('pur:~Run')

            # < enable @Intro
            #   it would go to ...
            #me&nodei,R,xs&Introtivity,{Intro:1,Cat:SC}
        }})&&
   // 3 'See'
        #  until %%Releasor exits
        #   < should only have to pause until pushed:
        #    to store J osc via Duolish** &SuperGansp
        su('See',{until:&zaa,jaa,ha,ar{
            #x.ro('init',{}) and me&nodei,R,not,'initdata'
            # Reside guaratees:
            $Run = ar.Run
            $F = ar.F
            
            me&Supervator,{}

            #'everything' and return ha('pur:!everything')
            

            # changes xs&This=Run/Thisy&This...
            $This = me&Gome_This,R
            !This and return ha('pur:!This')
            ha({sensitivity:'Gome_Thischa_other',otherable:'F'})
            me&Gome_Thischa_self,R,F,ha

            # observe Proto !now not over finishline

            Rs&goGome and me&nu,"Fins",{Run,This,F}

            x.ro('end') and return
            return ha('pur:notend')
        }})&&
        su('Done',{until:&zaa,jaa,ha,ar{
            # n|u all done
            me&tc,"all-done"
        }})
            
        return su('done')
        }
 },
  
  // Supe@Lab
   // 3 'Lab' @Lab
    &{
        me.SuperLab = &acgtRsce{
            $x = me&Jx,R
            c.t ||= 'Lab'
            $su = me&supetime,R,c.t
            su('One',{until:&zaa,jaa,ha,ar{
                # < &activate would know about %%inst leaving
                c.el == 9 and return me&tc,"cancel"
                me&activate and return ha('pur:noteven')
                me&Supervate,{}
                ha('pur:☸')
            }})&&
            su('Done',{until:&zaa,jaa,ha,ar{
                # n|u all done
                me&tc,"all-done"
            }})
            
            return su('done')
        }
    },
  
  // @Gnome/(@Thy...@Lab)%Piing
    # where non -Ness Fine/$t are staged for Piing/The...
    ['TheThy',0.2901,&acgtRs{
        me&reaw,R,'TheThy'
        me&acting,R
        # < for %Gome
        !me.cbu(R,'Gnome') and return me&tc,"!Piing",'b'
        Rs&wakeful = 1
        Rs&Piing = 1
    },'ift,D'],
    ['TheThy+Piing',0.292,&acgtRs{
        # @Thy, which always runs with @Gnome,
        # < posits a new @Lab time
        Rs&Sarndat = me&Sarn,<<'',[R]
            i @Thy/-This/#@Fine-Labine/@-Lab#@n%ThyLab/c&s=@n
        
    },'ift,D'],
    # receives %%inst as an Ec&uber
    ['ThyLab',0.295,&acgtRs{
        me&activate
    },'ift,D'],
    ['ThyLab',0.5,&acgtRs{
        $c = {}
        Rs&ThyLab_going and c.el = 9; me&tc,"--shutdown"
        !me&SuperLab,R,s,c and return
        # < drain process
        c.el == 9 and Rs&ThyLab_gone = 1; me&tc,"Deletables"
    },'ift,D'],
    
  // Pi%Lab
    &{
    me.Pi_Lab = &acgt{ return [
       // -Lab
        # loads Nine/-Lab, into -Bat preparator!
        #  or, posit Nine/-Lab from -Bat
        #   will need to select all etivity about time...
        #   
        ['Lab',0.22,&acgtRs{
            
            $V = Rs&V
            $E = Rs&E
            $D = Rs&D
            me&tc,'Lab','g'
            # outsphere: loads Nine/s-Lab
            $e = me&Ei,{t:'Outs',pi:'Labe',s:s}
            Ey&OutsE = e
            me&Eing,9
            
            # insphere: -Bat preparator
            $e = me&Ei,{t:'Ins',pi:'Labi',s:ey&D}
            Ey&InsE = e
            me&Eing,9
            
            # outsphere: -Bat compressor
            $e = me&Ei,{t:'Ino',pi:'Labo',s:ey&D}
            Ey&InoE = e
            me&Eing,9
            
            if (V) {
                # let TheFine sense this state, like -Eight%dige
                #  its &piLab will use instead:
                $details = [Ey&InsE,Ey&InoE]
                Vs&dige = dig(details.map(e => ey&thing)
                    .map(t => ts&dige).join("")
                )
            }
        },'ift,D'],
        ['Lab',0.55,&acgtRs{
            $E = Rs&E
            $D = Rs&D
            
            #me&hu,"Lavee",E,{dl:1}
        },'ift,D'],
       
       // %bell etc
        # < -hat with separate lum + layout tricks for %z
        ['bell',0.23,&acgtRs{
            $E = Rs&E
            $D = Rs&D
            if (!isC(s)) {
                $b = Ec&b
                $z = Rc&s = Ec&s = b && bc&s || Cye([E.t,1])
                me&tc,'eph','6y'
                zc&s = s
            }
        },'ift,D'],
        ['bell',0.265,&acgtRs{
            $E = Rs&E
            $D = Rs&D
            # for D impersonating s
            me&Dapes,R
            # < Rsci backed me&Eo,'^E%bell'
            !Ry&up.sc.bell and Rs&top_bell = 1
            if (Rs&top_bell) {
                Rs&encodeD = 1
                $be = me&tsc,"show-C",'🔔','g'
                # < make this about doing -hat for them
                #   -Bet finds specifics, default s**-ness
                # < the -hat wants to be minimal,
                #   no same .t, simple $c%$sc
                # < find that function for doing this:
                (Rs&ope||0) >= 1 and Rs&show_s = 1
            }
            
            # s
            # < o %show_s o R^^%top_bell
            $tob = me.cbu(R,'top_bell')
            tobs&show_s and Rs&show_s = 1
            if (Rs&show_s) {
                if (!Rs&strange) {
                    me&TXin,'Csubtle',{layout:'C'} ({
                        s: {z:{
                            y: {ope:-1},
                            sc: {z:{
                                z: {impl:1},
                            }},
                        }},
                    })
                }
                me&hu,"s",s,{dl:1}
            }
            
            # s**
            if (Rs&climbD) {
                $N = me&climbD,s
            }
            else {
                $N = me&ioty,s
            }
            N.map(&n{
                me&Ei,{t:n.t,s:n,noref:1}
            })
            Rs&rowish = 1
        },'ift,D'],
        &{
            # for D impersonating s
            me.Dapes = &acgtR{
                $D = Rs&D
                $s = Rc&s
                D.t = s.t
                each kv s.c {
                    D.c[k] = v
                }
                each kv s.sc {
                    k == 'z' and continue
                    D.sc[k] = v
                }
                !Dc&pi and delete Dc&pi
            }
            # D** is only via E**
            # < warn when D**... they should compress
            me.climbD = &acgtD{
                $E = Dy&E
                !E and throw "D!E"
                # also, same pi, for E** strewn with not-things
                return me&ioty,E
                    .filter(e => Ec&pi == ec&pi && ey&D)
                    .map(e => ey&D)
            }
        },
        # after Top@44 fills in E**y&thing
        ['bell+show_s',0.45,&acgtRs{
            $E = Rs&E
            # for Ey&thing encoding here
            Ey&thing and Rs&show_thing = 1
        },'ift,D'],
        ['show_thing',0.45,&acgtRs{
            $E = Rs&E
            me&hu,"Eything",Ey&thing.sc.string
        },'ift,D'],
       
       // -n 
        ['n',0.321,&acgtRs{
            $E = Rs&E
            $D = Rs&D
            $x = me&Gome_Jx,R
            me&Pi_n,R,s,E,x
            me&tc,"Hasann"
            Rs&strange and Ds&strange = joint(Rs&strange,', ')
        },'ift,D'],
        &{
        me.Pi_n = &acgtRsEx{
            # name|path in nodelist
            # < nodelist <- &Gome_Jx aliases, eg client
            # < pick something from xs&*
            $name = isC(s) ? sc&s : s
            !isst(name) and return me&strange,"!name:"+name
            # Node/with/tpath
            $nodepath = name.split('/')
            if (hak(nodepath) > 1) {
                name = nodepath.shift()
                $twpath = nodepath
            }
            # @Node
            $n = x.sc[name]
            !n and return me&strange,"!find:"+name
            # /with/tpath
            each it twpath {
                $z = me&fiu,n,t,8
                if (!z && ny&R) {
                    $r = ny&R
                    # < %eph-lenient o s/z connections
                    z = me&ioty,r .filter(r => r.t == t)
                        .map(r => rc&s) [0]
                }
                !z and return me&strange,"!climb:"+n.t+"/"+t+"("+i+")"
                n = z
            }
            Es&target = n
        }
        },
       
       // %Labe decompress
        ['Labe',0.22,&acgtRs{
            $E = Rs&E
            $D = Rs&D
            Rs&bell = 1
        },'ift,D'],
        &{
            # decompress strategies
            # apply to E/e
            me.defaultDpi = &acgtEc{
                isst(c) and c = {pi:c}
                c.Epi ||= T.act.t
                $N = me&pity,E,'-'+c.Epi
                N.map(&e{
                    $D = ey&D
                    $s = ec&s
                    # &Ei'd this act
                    !D and return
                    $api = Dc&pi || sc&pi
                    api and return
                    # may be implied from above
                    ec&Dpi = c.pi
                })
            }
            # sc&pi -> Dc&pi and R%$pi=1 for a while
            me.typeup_Dpi = &acgtRs{
                $E = Rs&E
                $D = Rs&D
                # may be implied from above
                Ec&Dpi and Dc&pi = Ec&Dpi
                $api = Dc&pi || sc&pi
                # sc&pi -> Dc&pi and R%$pi=1
                api and me&typeup,R,api
                api == 'Lab' and delete Rs&Lab
                !api and me&strange,"Labe!pi"
                Rs&pretendpi = api
            }
        },
        ['Labe',0.31,&acgtRs{
            $E = Rs&E
            $D = Rs&D
            me&typeup_Dpi,R,s
            # < do all @260* before R/* do
            if (Rs&nodei) {
                # ways to spec $to:
                #  /eto, /-n, c&s, .t
                $to = me&fiu,s,'eto',8
                if (to) {
                    # C:eto implies -n
                    $toE = me&pity,E,'-Labe'
                        .filter(e => ec&s == s)[0]
                    toEc&Dpi = 'n'
                }
                to ||= me&pity,s,'-n' [0]
                if (!to) {
                    to = sc&s || s.t
                    me&Ei,{t:"eto",Dpi:'n',s:to,implied:1}
                }
                # -nodei/-row implied
                me&defaultDpi,E,'row'
                me&tc,'nodei','y'
            }
            if (Rs&row) {
                # < no E/* implies D%* is the row.sc
                # < it might have -row/-n, eto or not
                me&tc,'row','y'
            }
            if (Rs&n) {
                me&tc,'n','y'
            }
            me&Eing,6
        },'ift,D'],
        ['Labe+pretendpi',0.319,&acgtRs{
            delete R.sc[Rs&pretendpi]
        },'ift,D'],
       // %Labi make to|from -Bat
        ['Labi',0.22,&acgtRs{
            $E = Rs&E
            Rs&bell = 1
            Rs&climbD = 1
            $p = Ry&up
            if (ps&top_bell) {
                # due to Nine/-Lab (top of the outsphere)
                # wanting to include %tige,dige
                Ec&encode_thing_here = 1
            }
        },'ift,D'],
        ['Labi',0.32,&acgtRs{
            $E = Rs&E
            $D = Rs&D
            me&typeup_Dpi,R,s
            # < %bell generic adjustments to D**
            #    %Labo then pushes, it appears in %Labe
            #     so Ting finish when effect is incorporated
            #     y&thing may have commit log for such
            
            me&Eing,6
        },'ift,D'],
        ['Labi+nodei',0.326,&acgtRs{
            $E = Rs&E
            $D = Rs&D
            # destination
            $eto = me&fiu,E,'eto'
            !eto and me&strange,"!eto"
            $t = eto && etos&target
            !t and me&strange,"eto!target"
            !isnode(t) and me&strange,"eto%target!node"
            # stuff to send
            $rows = me&climbD,D .filter(d => dc&pi == 'row')
            !hak(rows) and me&strange,"!-row"
            
            # externalisings defined, undertaken
            me&Superdef,{f:'nodei',to:t,wakenode:1} (&rR{
                # r%Piing//..R%Pier%Labi
                each in rows {
                    me&nodei,r,t,n.sc
                }
            })
            me&anystrange and return Ds&fail = 1
        },'ift,D'],
        ['Labi+pretendpi',0.329,&acgtRs{
            delete R.sc[Rs&pretendpi]
        },'ift,D'],
       // %Labo compress again
        ['Labo',0.22,&acgtRs{
            $E = Rs&E
            Rs&bell = 1
            Rs&climbD = 1
            $p = Ry&up
            if (ps&top_bell) {
                # due to Nine/-Lab (top of the outsphere)
                # wanting to include %tige,dige
                Ec&encode_thing_here = 1
            }
        },'ift,D'],
        
        
        
        ['Labo',0.37,&acgtRs{
            $E = Rs&E
            $D = Rs&D
            Ec&noencode and return me&tc,'eph','6y'
            me&typeup_Dpi,R,s
            if (Rs&nodei) {
                $eto = me&fiu,E,'eto',8
                !eto and return me&strange,"!eto"
                $z = etoy&D
                # < trying to follow|update how %Labe did it
                zc&s == s.t and etoc&noencode = 1
            }
        },'ift,D'],
        ['Labo+pretendpi',0.379,&acgtRs{
            delete R.sc[Rs&pretendpi]
        },'ift,D'],
    ] }
    },
  
  # < here's a twinning io structure deal
  // @Nine <-> @Thy + @Ply
    &{
    # Gnome/Thy/This/#@Fine/Lab
    # see &EsyncThis c.ThyF, puts @Lab -> E/Ness/* -> Nine/*
    me.Fine_pre_nine = &acgtREsx,Ninec{
        $Thy = xs&Thy
        # stuff we're projecting to The
        $Thys = me&fiu,Thy,'This',8
        $ThyF = Thys && me&fiu,Thys,s.t,8
        #return me&tc,"Avoiding-ThyF-return"
        # < create that per Fine so we can capture The for it
        if (ThyF) {
            Ninec.ThyF = ThyF
            sy&ThyF = ThyF
        }
        me&Names_set,R,'Fine',s
    }
    # Nine%TheFine has E-nine'd
    me.Fine_aft_nine = &acgtREsx{
        # e Thy/This for $Nine/
        $Thy = xs&Thy
        $Thys = Thy && me&fiu,Thy,'This'
        !Thys and debugger; return me&tc,'!Thys','b'
        
        me&SuperNine,R,s,{}
        
        # ThyF, for next Fe-ature
        $N = me&ioty,R,'TheFe'
        $sN = me&ioty,s
        each ir N {
            $n = rs&exp
            !n and break
            $was = grepout(sN,n)
            hak(was) != 1 and debugger
            if (nc&pi == 'Ness') {
                $r = ny&R
                #$r = me&lastnonsleepingR,n
                $ok = r && me&ja,r,'Dige' && me&ja,r,'ready' && me&ja,r,'ok' 
                !ok and me&tc,"waitsfor:"+r.t,6
                !ok and break
                continue
            }
            return 'switched off Fe->Lab'
            # externalisings defined, undertaken
            me&Superdef,{f:'Flight',of:'inst',to:Thy,wakenode:1} (&{
                # %%n%tige brackstills
                me&nodei,R,Thy,{inst:1,n}
            })
        }
    }
    # Accepting ~ Nine/Fe, forward cha
    # < real as the E|exp**:n walk
    me.Fe_mergent = &acgtREstz{
        # unexpected Fe
        !t and return
      // env
        # < o E, /Ness:/#@t
        $EN = me&fiu,E,'Ness',7
        # < to tv
        $Ness = me&fiu,EN,t.t,7
        # Ness/** y&C to This/**
        $This = me&fiu,E,'This',7
        
        $Diff = theone( me&ioty,R,'Diff' )
        !Diff and return me&tc,"!Diff",'y'
        # z is just the outsphere exp
        # get a Q for the insphere exp
        #  shortly after its outsphere mis-diges
        #   due to including the insphere dige
        $exp = Diffs&exp
        !expc&of == 'W' and debugger
        # then the C** insphere (with y&deLines)
        $w = expc&s
        !isC(w) and debugger
        
        # <<<<
        # slep follow Diff, following Ness + $got
        $Comp = Diffs&Comp
        me&rollbs,R,'Ply,DiffDigs'
        (Diffs&boost||0) > 0 and delete Rs&Ply
        Rs&DiffDigs != Diffs&Digs and delete Rs&Ply
        Rs&DiffDigs = Diffs&Digs
        if (1 || !Rs&Ply) {
            # < -six+ to enervate
            Rs&Ply = me&Plymergent,R,E,s,Ness,Comp
        }
        # < is parsing the diff (from and) into two trees,
        #     to $z|$exp
        #      < &deL giving y&toLines
        #     and $t|$got, which we Lineso'd from things in This/**
        #      applying lv kind of mind
        #     so eg $got...seveny&thing is joined on
        #      as a pool of sense to help finding stringsat the -Ness/#@Eight
        # < -Effect to /This/
        $out = 34
        Comp = Comp.slice(out,out+8)
        me&bal,'mergent',{eph:1,Zuist:{Ness,Comp}}
        #{Ness,t,z,exp,Diff,This}
    }
    // Plymergent f
      // draw thing
        # wild repurposing the symbols of &Rthingo
        me.thingosym = &acgts{
            $sym = me&tc,s,'b'
            syms&lh = 0.5
            syms&fs = 20
            return sym
        }
        # < nibble-sized view of thing?
        #    2-nibble top Line's t,y + whole textsize
        me.textsize = &acgts{
            !isst(s) and throw "textsize!st"
            $lin = s.split("\n")
            lin.slice(-1)[0] == '' and lin.pop()
            return 'x'+hak(lin)+'*'+s.length
        }
        # any string
        # < know where in l|E...
        me.drawtextliner = &acgtdts{
            !isst(t) and throw "drawtextliner!title"
            !isst(s) and throw "drawtextliner!text"
            $Om = T.ab
            me&boxcap,t,'5' (&ml{
                me&walls,m,'bd:1.1'
                Om.y [t] = m
                $to = me&tc,s,'y'
                tos&ws = 1
                me&walls,to,'bd:2.2,bg:000'
                Om.y [t+'s'] = to
            })
        }
        # < to having diff chunks floating around!
        me.textarrow = &acgtO{
            !isC(O) and debugger
            $b = me&tc,O,"=>",'B'
            bs&fs = 20
            bs&lh = 0.6
            bs&ab = 1
            bs&ml = -2
            $got = grepout(Os&z,b)
            #hak(got) != 1 and debugger
            Os&z.unshift(b)
            return b
        }
        # passing y&thing acknowledged
        me.drawtextthing = &acgttdn{
            $oth = ny&thing
            oth && me&boxcap,t,'5' (&ml{
                me&walls,m,'bd:2.2h6'
                othy&cv != 0.1 and me&tc,cvf(othy&cv),'G'
                !me&mergent_oktothing,d,n and me&tc,"!used"
                $sum = me&textsize,oths&string
                me&thingosym,'⦄' .sc.fs = 15
                me&tc,sum,'y'
            })
        }
        # y&thing sanity check: into z requires zy&thing used on slope
        # < was %%oust to slope
        me.mergent_oktothing = &acgtdz,fatal{
            # it must exist in order to z
            $th = zy&thing
            if (!th) {
                !fatal and return null
                throw "tosphere!thing"
            }
            
            if (!hak(ths&use)) {
                !fatal and return 0
                throw "tosphere!use"
            }
            $slopers = d.slope.map(z => zy&ers)
            !hak(slopers) and throw "!slopers"
            if (!hak(grepout(slopers,ths&use))) {
                if (!slopers.slice(-2)[0]) {
                    # sloper no ers, perhaps because it was synthesized
                    $nu = zy&up
                    nu && nu.t != d.slope.slice(-2)[0].t and debugger
                    if (nu && ths&use.includes(nuy&C)) {
                        !fatal and me&tc,"//^//",'G'
                        return 1
                    }
                }
                !fatal and return 0
                throw "tosphere!used"
            }
            
            return 1
        }
      // close
        # if no Lines can be found
        # eg E...-inx/up|z are hidden from stringify
        me.mergent_avoids_unLinesed = &acgtdn{
            # anything goes so long as marked by layout symbol '~' above
            # < could be on the thing above, value =~ / \*$/
            !ahsk(n,'y','up','y','D','sc','~') and return
            me&drawtextnofurther,d,'layout:hid'
            # relies on returning from anywhere()
            return 1
        }
        # &Rthingo-ish complaint
        me.drawtextnofurther = &acgtdt{
            !isst(t) and throw "complain"
            me&thingosym,'⛔'
            me&tc,t,'6y'
            d.nofurther = 1
            # fade line
            $O = d.O
            $Om = d.Om
            Os&opa = 0.6
            # shrink everything inside, since indent O%ml depends on O%fs
            each in Os&z {
                ns&fs = 6
                # < make faster grounding for T.ab<-{&tc}
                #   these are attached now because they are the label or more T.ab
            }
            # (toL s/string//)
            Omy&toLs and Omy&toLs.sc.dis=0
            return 1
        }
      // mo
      
    me.Plymergent = &acgtREs,Ness,Comp{
      // Ply box, all[] from anywhere(n**)
        # see ds&morenth
        # < trace ourselves through every ^^^*y&thing%string
        #    kind of like a report vortex
        #    lets go as it wanders off the -Ness/*/*
        #     seeing slope into W
        #   ind slice it for all Lines at l%moren
        #  < real as the E|exp**:n walk
        #    many **:n to navigate with Comp
        #     exp having gone, E having new
        #    $exp** to resurrect relics from,
        #     for D->modulat totality,
        #      so we can then Diff the modulats, and make good visual
        me&boxcap,'Ply','1' (&ml{
        ms&dis = 1
        # l = Comp[upto]
        $upto = 0
        # [d+]
        $all = []
        # Ness** as long as possible
        #  y&thing are for the outsphere
        #  y&C=This/Eight** follow E** down
        #   once Ness** runs out
        # < wander into Ness**, with diff )
        $anywhere = &nd{
            d ||= {}
            # < for a set of trees
            d.n = n
            d.slope = (d.slope||[]).slice()
            d.sc = {z:[]}
            d.up and d.up.sc.z.push(d)
            all.push(d)
      
      // Ply stuff<->things!
            me&boxcap,"Ply"+n.t,'1' (&ml{
            ls&deco = 1
            lc&s = n.t
            ms&ml = 1
            $O = d.O = m
            $pl = me&tc,"place"
            plc&s = ''
            # intoable insphere, y&C from Ness**
            # in (Ness|This|exp)**//E-seven**
            #  slope begins This/here**

            $z
            $Om
            # notice outsphere features...
            me&boxcap,"Out",'g' (&ml{
                d.Om = Om = m
                me&walls,m,'bd:2.2h3'
                ms&fs = 6
                
                # gives Omy&toL(s)?
                ny&toLines
                    && me&drawtextliner,d,"toL",ny&toLines

                # < swathes of %moren may be entirely
                me&drawtextthing,'thing',d,n
                
                $D = ny&D
                D && Dy&thing && Dy&thing != ny&thing
                    && me&drawtextthing,'Dthing',d,D

                z = ny&C
                z || d.ins and d.slope.push(z||n)
                # < isn't always E?
                z and ds&E = z
                else
                d.ins and ds&E = n
                
                # < &Saturn into here!
                # at Ness..-seven the ** dries up
                if (!d.ins && !hak(ns&z)) {
                    if (!z) {
                        # we may be on a missing -seven
                        ds&goneseven = 1
                        d.nofurther = 1
                        return me&tc,"GONE",'b'
                    }
                    d.ins = d
                    ds&pi = 'seven'
                    # must =be a 
                    !z and return me&tc,"GONE",'b'
                    !hak(zs&z) and throw "deadend"
                    me&mergent_oktothing,d,z,'fatal'
                    me&tc,"yC",'G'
                }
                if (d.up && d.ins == d.up) {
                    # the RE
                    ds&pi = 'six'
                    me&walls,O,'bd:4.2h3'
                    # < which E** are selected
                    # see TheingE 2951: sets y&C
                    #  like there is up in Ness/*/*, see &EsyncThis
                    !z and me&drawtextnofurther,d,"non-main"
                }
                if (d.up && d.up.sc.pi == 'six') {
                    # the Ey&main itself
                    ds&pi = 'five'
                }
                ds&pi and me&tc,pl,"-"+ds&pi,'G'
            })
            d.nofurther and return
            
      // E<->l
            # lingering l, or nothing
            $l = null
            me&boxcap,"E",'g' (&m{
                me&walls,m,'bd:2.2h3'
            // Comp/l and E...n...Lines
              
              // l = Comp[upto]
                # eitherings, any substring of Lines
                l = Comp[upto]
                if (d.morend) {
                    $nd = d.morend
                    # n's l is not in Comp/*, last one that was:
                    $ul = nd.l
                    nd.moreni ||= 0
                    l = uls&moren [nd.moreni]
                    me&tsc,'morening',"^"
                }
                !l and return me&tc,"off","b"
                d.l = l
                
                # last l%ope, l/* (indentitively) is folded into l%moren
                if (ls&moren) {
                    me&tc,"x"+hak(ls&moren),'6d'
                    # < &strange <-> T.ab
                    d.morend and debugger; me&tc,"inside-morend",'!','b'
                    d.morend = d
                    if (d.ins == d.up) {
                        # -six whole y&thing check
                        ds&morenth = 1
                    }
                }
                
                $skipgone = &L{
                    # L == l that may be gone!
                    L.t != 'gone' and return
                    me&tc,"Agone",'6y'
                    # wash up on the next E in iteration
                    ac(d,'goners',L)
                    ac(d,'subComp',L)
                    ac(d,'chaComp',L)
                    # pull until we uncover a same, continue as
                    l = Comp[++upto]
                    l = skipgone(l) || l
                    # dedupes (see this line in while(l) below)
                    l.t != 'same' and ac(d,'chaComp',l)
                    # line-splitting not near folds
                    l && ls&moren && l.t != 'same' and debugger
                    return l
                }
                l = skipgone(l) || l
                
                # everything we visit should be open, may %moren
                ls&ope == '1' and 'ok'
                else
                ls&ope and me&tc,dis({ope:ls&ope}),'y'
                else {
                    me&tc,'shut','y'
                }
                
              // Lines = ny&toLines or so
                # into R'The'
                $D = ny&D
                D and me&tc,"D",'G'
                $th = ny&thing
                
                $Lines = ny&toLines
                #D && Dy&toLines and me&tc,"DtoL"
                D && Dy&thing and me&tc,"Dth"
                D && Dy&thing and Lines = Dy&thing.sc.string; me&tc,"Dth",'6y'
                if (ds&morenth) {
                    # -six whole y&thing check
                    Lines = ths&string
                    !Lines and debugger
                }
                if (!Lines) {
                    Lines = th && ths&string
                    Lines and me&tc,"th",6
                }
                if (!Lines) {
                    Lines = D && Dy&toLines
                    Lines and me&tc,"DtoL",6
                }
                if (!Lines && D) {
                    $Dth = Dy&thing
                    Lines = Dth && Dths&string
                    Lines and me&tc,"Dth",6
                }
                
                !Lines && me&mergent_avoids_unLinesed,d,n and return
                !Lines and return me&tc,"lost-string",'b'
                !hak(ns&z) and me&tc,'/$','g'
                
              // could be easy
                # < func text lib
                # if we indent this
                $indLines = indents(ls&level,Lines)
                # and we aren't looking at folded or interesting l
                if (!d.morend && l.t == 'same'
                    # it should look like the rest of l
                    && ls&string == indLines) {
                    ds&good = me&tc,"2"
                    # and we associate d (for E**) with it
                    ac(d,'subComp',l)
                    upto++
                    return
                }
                
              // or break apart Lines, gradually l
                $Lin = Lin_Lines(indLines)
                $Li = 0
                $nd = d.morend
                nd = nd != d && nd
                $ul = nd && nd.l
                while (l) {
                    
                    $aLine = Lin[Li]
                    # non-first bit
                    Li && nd and l = uls&moren [nd.moreni]
                    aLine == null and break
                    l.t != 'same' and ac(d,'chaComp',l)
                    if (ls&string.length && !hak(ls&string.split('')
                        .filter(s => s != ' ')) ) {
                        me&tc,"Aspacey",'6y'
                    }
                    skipgone(l) and continue
                    
                    ul && ul != l && ls&moren and me&tc,"(moremore)",'6y'
                    
                    # first bit should look good
                    if (ls&string == aLine+"\n") {
                        Li++
                        ac(d,'subComp',l)
                        if (nd) {
                            nd.moreni ++
                            # if we're in ul%moren/l, we can't be l%ope
                            #  so checks the entirety of y&thing if possible
                        }
                        elsif (ds&morenth) {
                            # check off a bunch more l in this while
                            #  already has Lines from y&thing
                            if (!th) {
                                ds&good = me&tc,"1+"
                                me&tc,"no-th",'b'
                                Li == 1 and upto++; return
                                break
                            }
                            $ul = l
                            # start using uls%moren
                            $nd = d
                            d.moreni = 0
                            # eventually seek next Comp/l
                            upto++
                        }
                        else {
                            ds&good = me&tc,"1"
                            Li == 1 and upto++; return
                            break
                        }
                    }
                    else {
                        # or at least starts with l
                        me&tc,",."+Li,'c'
                        if (!nd && !ls&string.endsWith("\n")) {
                            if (aLine.startsWith(ls&string)) {
                                ac(d,'subComp',l)
                                # sub-Line at a time
                                me&tc,"+",'6y'
                                aLine = aLine.substr(ls&string.length)
                                $waslev = ls&level
                                # go forwards, skipping goners
                                l = Comp[++upto]
                                l = skipgone(l) || l
                                $islev = ls&level
                                # level might increase onto a change
                                # < really?
                                if (waslev < islev) {
                                    $morelev = islev-waslev
                                    me&tc,"ind+="+morelev,'6y'
                                    aLine = indents(morelev,aLine,1)
                                }
                                Lin[Li] = aLine
                                continue
                            }
                        }
                        break
                    }
                }
             
              // non-easy OK
                Li and me&tc,"("+Li+")",'6y'
                if (!l) {
                    ds&good = me&tc,"7"
                    # already counted upto++ going into ul%moren (either of two ways)
                    return
                }
                if (hak(Lin) > 1) {
                    # others may then!
                    me&tc,"+more"
                }
            
            // lingering confusedly?
                $interesting = 1
                ||
                (n.t == 'maaaagic' && n.y.up.t == 'origin_X')
                ||
                (n.t == 'A' && n.y.up.t == '-Fez'
                    && n.y.up.y.up.t == 'node_hand_U')
                ||
                (n.t == 'maaaagic')
                
                if (interesting) {
                    me&drawtextliner,d,"l",ls&string
                    me&drawtextliner,d,"a",aLine
                    #me&drawtextliner,d,"L",Lines
                }
                
                
                # maybe just the start of it
                if (Lines) {
                    if (ls&string.includes(Lines)) {
                        me&tc,"oooook@"+upto
                        return
                    }
                }
            })
      
      // stat
            # < dodgy
            $next = ds&pi == 'seven' ? zs&z : ns&z
            
            if (ds&good) {
                # mute toL!
                $Ls = Omy&toLs
                Ls and Lsc&not = 1
                me&tc,"OK"
            }
            
            if (ds&chaComp) {
                me&boxcap,"~",'1g' (&m{
                    each il ds&subComp {
                        me&drawtextliner,d,l.t+":"+i,ls&string
                    }
                    # and the non-same ones
                    #  may inc the non-match after, not in %subComp
                    me&tc,"["+joint(ds&chaComp)+"]"
                })
            }
            
      // recursion?
            if (hak(next)) {
                $not = 0
                # don't recurse unless Comp says
                $ln = Comp[upto]
                if (!d.morend && ln && l && lns&level <= ls&level) {
                    # may end on a single line E, so no l%moren
                    #  eg X.A is a one-liner, yet we can see n/* t,y,c,sc
                    return me&thingosym,'⦄E...' .sc.fs = 15
                }
                # < should only l%moren instead of !l%ope
                !(l && ls&ope) and return me&thingosym,'⦄l' .sc.fs = 15
                else
                # see ds&morenth for -six whole y&thing check
                #  doesn't involve E**, what we avoid here:
                # since E** feeds Lines one-C at a time, avoid the folds.
                #  essentially ignoring a bunch of stuff already marked as boring.
                #  they must be opened back in Diff.
                ls&moren and return me&thingosym,'⦄m' .sc.fs = 15
                # and not far
                #hak(d.slope) > 5 and return me&thingosym,'⦄>'
            }
            
            each iz next {
                anywhere(z,ex(ex({},d),{up:d}))
            }
            
            })
        }
        
      // aft !
        anywhere(Ness)
        # get -seven/-six with change inside
        $radiate = &vd{
            ds&changey ||= 0
            ds&changey += v
            d.up && radiate(v*0.3,d.up)
        }
        reverse(all).map(&d{
            $cha = hak(ds&chaComp)
            cha and radiate(cha,d)
        })
        
        # < boxlink Diff|Ply**
        #   scopes the change could be viewed from
        # < -six should redirect %%ope, as it is REy&main
        $Es = []
        each id all {
            !ds&changey and continue
            # we only make -seven/-six/-five out to d%pi
            #  they may not reflect the Ec&pi
            #  eg RE-Fez/E-Fez are -six/-five to d
            !ds&pi and continue
            # mark Ply**
            me&textarrow,d.O
            # to visit d%E
            $E = ds&E
            !E and debugger
            # sending to $node:-six/E-Fez
            me&Effect,s,E,'showy-'+ds&pi,{show:1,ope:1}
            Es.push(E)
        }
        #me&nu,"Wouldvis",Es
        
        # /box:Ply
        })
        return
        each in Nesss&z {
            $eight = ny&C
            each ie ns&z {
                $seven = ey&C
                # log size
                $sev = me&uptonode,seven
                #me&nu,"Seven...",{eight,seven,sixs:sixs&z}
                # targeting the y&main by it being six
                each i,six sevens&z {
                    each jE sixs&z {
                        3 < (i*1) and continue
                        me&ha,R,"Hahza:"+i
                    }
                    each jE sixs&z {
                        3 < (i*1) and continue
                        # sending to $node:-six/E-Fez
                        me&Effect,s,E,'showy-six',{show:1,ope:1}
                    }
                }
            }
        }
        if (0 && 'look-around-lines') {
            $mai = Comp.findIndex(l => ls&string.includes("maaaagic"))
            
            
            
            
            
            
            
            
            
            me&boxcap,'wonk','1' (&ml{
                $some = Comp.slice(mai-3,mai+3)
                each in some {
                    me&boxcap,'line','1G' (&ml{
                        lc&s = n.t
                        lc&s.length == 3 and lc&s += "!"
                        $t = me&tc,'doov','g'
                        tc&s = enj(ns&string)
                        ts&ws = 1

                    })
                }
            })
        }
    }
    },
  
  # see w:Story for %TheFine
  # < sub the doer and &Gome_Resides
  // Super@Nine (empty)
    &{
        me.SuperNine = &acgtRsce{
            $x = me&Jx,R
            c.t ||= 'Nine'
            $su = me&supetime,R,c.t
            su('One',{until:&zaa,jaa,ha,ar{
                # < &activate would know about %%inst leaving
                c.el == 9 and return me&tc,"cancel"
                me&activate and return ha('pur:noteven')
                me&Supervate,{}
                ha('pur:☸')
            }})&&
            su('Done',{until:&zaa,jaa,ha,ar{
                # n|u all done
                me&tc,"all-done"
            }})
            
            return su('done')
        }
    },
    # just enough %Piing-ness to be able to activate
    ['TheFine',0.291,&acgtRs{
        !me.cbu(R,'Gnome') and return
        
        me&rollbs,R,'E'
        $E = Rs&E ||= Cye([R.t,1])
        Ey&R = R
        Es&z ||= []
        # < be %Piing
        # Rs&Piing = 1
    },'ift,D'],
  
  # namespace bridge:
  // %Names:C
    # fame distribution
    ['Names',0.87,&acgtRs{
        me&reaw,R,'Names'
        $Na = Rs&Names
        me&acting,R and me&nu,"Names",Na.sc,'forement'
    },'ift,D'],
    &{
    # &Saturn -> %Names
    me.Names_collector = &acgtR{
        $g = {}
        $nameN = []
        g.from_ax = &a{
            $na = sex({},a,'Name,name')
            !hak(na) and return
            !isC(a.s) and throw "what is it"
            na.s = a.s
            nameN.push(na)
        }
        g.done = &{
            !hak(nameN) and return
            $la
            each i,na nameN {
                $c = {}
                hak(na,'Name') and $t = na.Name
                else {
                    $t = na.name
                    # not known to aboves & beyonds,
                    #  may give up name inwardly to an above Name
                    # < except when led into, eg @Thy/@This, @Thy...@seven
                    #   which is more about using @Thy's Sarndat to climb ...
                    #    we are really looking for phrasing,
                    c.local = 1
                }
                !isst(t) and throw "!name"
                la != null && la != t and throw "~name"
                me&Names_set,R,t,na.s,c
            }
        }
        return g
    }
    # < &sc_collector, agreement diag
    
    # name a node, climb the name into place
    # < whoever might like to know, esp if ~s
    me.Names_set = &acgtRtsc{
        !isst(t) and throw "t!string"
        !isnode(s) and throw "s!node"
        c ||= {}
        $Na = me&rollbsc,R,'Names'
        # <<<
        # i %Names:Na (knowing somewhere it should C:Names)
        # i R/%Names/$t/$s/$n-naming
        #  and the usu reverse: i $s/$t
        #  and the usu noticing etc
        # the -naming defines scope (c&local or not)
        # < seems like a /believe/ join to &Saturn
        #   they would all end up with z-indexes
        #    last io to do highest,
        #    .Name includers having the .pathi they occurred
        #     (for the use case in the scope of many &Saturn)
        $was = ahsk(Na,'sc','tw',t)
        ah(Na,'tw',t,s)
        c.local and ah(Na,'tlocal',t,1)
        s == was and return
        # < climbs & puts. notice other disconnected?
        #  < when %%active, puts @Lab|@Nine for @Gnome,
        #    which makes it a %%Superarg,
        #     which all share to @Gnome%Names
        #     where we can find them
        
    }
    # create outcrop of names looked up in here
    me.Names_get = &acgtRtc{
        c == 1 and c = {fatal:1}
        c = peel(c)
        $Na = me&rollbsc,R,'Names'
        $s = ahsk(Na,'sc','tw',t)
        if (s == null) {
            $j = me.cbu(R,j => js&Ying || j != R && (js&Names || js&client))
            js&Ying and j = null
            if (j) {
                if (js&Names) {
                    s = me&Names_get,j,t,{c,outer:1}
                }
                # also goes across this link, eg to @Gnome
                # < becomes %%hire
                $cl = js&client
                if (cl && isC(cl) && !s) {
                    cl = me&yfuture,cl .c.s
                    s = me&Names_get,j,t,{c,outer:2}
                }
            }
        }
        # note being asked this
        !c.outer and ah(Na,'task',t,1)
        # < who from?
        else ah(Na,'tasked',t,1)
        # remember what it was, to contrast later
        if (s) {
            $was = ahsk(Na,'sc','tgot',t)
            ah(Na,'tgot',t,s)
        }
        else
        # < fix throw ..., tinystring display
        c.fatal and throw "!Names:"+t
        return s
    }
    },
  // sy&Fames:C
    # reverse of Names, for being y&thing-consequent
    
  
  # nine wants to join reality:
  # < Travel..@Run by %%hire, %Piing** by %%inst
  // Travel..@Cat/@Run %Piing**
   // Travel..@Cat
    # space depot, needs Run%%mayRun
    # see %Travelables, which is R^2 of here
    # @Cat ~ %SummerCat, has %client=Gnome
    ['PiiCat',0.2901,&acgtRs{
        me&reaw,R,'PiiCat'
        me&acting,R
        
        $n = sy&Gorow
        !n and debugger
        
        # < switch off Ec&uber)%client
        $cl = Rs&client = ns&Gome
        
        $tr = Ry&up
        # Travel/$t/$s
        $t = trc&s
        t != sy&up and debugger
        #me&Garn, < < '',[R]
        #    i @Run/-This/-Eight/-seven/**%Ethinging
        me&haveGorowgetControl,R,s,t and return
        
        # rebuild %SummerCat?
        # each has a This|The?
        me&bin,'PiiOther'
        me&fiu,s,'Inc'
        me&fiu,s,'Pro'
        me&fiu,s,'Run'
    },'ift,D'],
    
    ['PiiOther',0.2901,&acgtRs{
        me&acting,R
        me&supsphere,s
        R.sc['Pii'+s.t] = 1
    },'ift,D'],
    # a Paving for this way. see %SummerCat/Inc%Aearch
    ['PiiInc',0.2901,&acgtRs{
        # < @Intro routes news
        # < each resource may be directed
        #return
        
        # load up w:$story
        $w = me&fiu,s,'wjs'
        me&bal,'wjs','Pavings:1'
        ws&args = 's'
        ws&Paving = 'wjs'
        $cl = me&Rsc,R,'^^client'
        !cl and debugger
        cl and me&fiu,w,cl.t
    },'ift,D'],
    # have steps, todos
    #  e heading for A:n rather than Run/The...
    ['PiiPro',0.2901,&acgtRs{
    },'ift,D'],
   // @Run %Piing**
    # @Run ~ %Jrunto
    #  exp by random clicks and %%initdata
    # see TheThy 2901
    ['PiiRun',0.2901,&acgtRs{
        !me&ja,R,'mayRun' and return me&tc,"!mayRun..."
        Rs&Piing = 1
        # < &Gnome_Jx: its def @Run should match up
        #   it basically discovers its way to @Gnome, @Cat, etc
        #   from anywhere in @Thy, @Cat, etc
        #   it wants to read %%hire
    },'ift,D'],
    &{
        # builds a @Run/**r
        # < returning r** with E@36?
        me.inramp = &acgtzsc{
            # z must be the above s
            s = me&Pii,z,s
            !zy&R and debugger
            zy&R != z and z = zy&R
            C = zs&C
            !C and debugger
            # s may be string
            $spec = isst(s) ? [s] : [s.t,s]
            while (1) {
                $r = me&bal,...spec
                if (!rs&sleeping) {
                    if (wasat != null) {
                        grepout(zs&z,r)
                        zs&z.splice(wasat,0,r)
                    }
                    break
                }
                # drop the recycling
                $wasat = zs&z.indexOf(r)
                grepout(zs&z,r)
            }
            s = rc&s
            if (c) {
                tax(s.c,c,'s,pi')
                ex(s.sc,c)
            }
            if (!Rc&N.includes(sy&R)) {
                # they get sy&R @293
                me&Ring,r,{und:r,ov:0.31}
            }
            return s
        }
        # for This/such-Eight/so-seven/[thing-Fez,{sc&s,...sc}]
        me.legramp = &acgtS{
            $N = [...arguments].slice(5)
            each il N {
                !isar(l) and l = [l]
                # < l[1] (s+)
                $next = me&inramp,S,...l
                !next and debugger
                S = next
            }
            return S
        }
        # such-Eight opens for a process that will add -six
        me.openEight = &acgtt{
            A.time != A and debugger
            $time = A.time.c.time
            A = G&Aye,'-Eight...'
            $R = me&R
            $s = Rc&s
            $Eight = me&legramp,s,'-This',t+'-Eight'
            $Ya = A
            return &{
                A = Ya
                A = G&Aye,'-Eight...-six'
                $args = [...arguments]
                $six = me&legramp,Eight,time+'-seven',...args
                return six
            }
        }
        me.Runpin = &acgttv{
            $time = v
            A = G&Aye,'Run@'+time
            A.time = A
            A&time = time
            # only do S 1 if time
            # ! dont use R%Ace because of missing 4c&Srupto
            #   strange fact of R-life, so far very little A
            A&Sonly = time
            ~>7 Atry: time
            me&way,R,t
        }
    },
    ['PiiRun',0.298,&acgtRs{
        $x = me&Jx,R
        if (x.ro("Run") || 0 && !Rc&b) {
            # synth a thing
            ss&time ||= 0
            $time = ss&time + 1
            me&Runpin,"TryPiWarmer",time
            # may not make it back
            ss&time = time
        }
    },'ift,D'],
    ['PiiRun+Piing',0.293,&acgtRs{
        Rs&Sarndat = me&Sarn,<<'',[R]
            i @Run/-This/-Eight/-seven/**%Ethinging
        
    },'ift,D'],
  
  # through the valvework of:
 # to cluster state:
 // &Piing R:'The'
 
   # < Thy%client=Run:Gome
  // 1 %Piing nodes &Thee &Theing
    ['Piing',0.291,&acgtRs{
        $x = me&Thee
        !xs&Gome and me&tc,'noGome','G'
    },'ift,D'],
    &{
    # on eg s)%Piing, &bin for s**)%Piing, %E,onlyish etc
    me.Thee = &acgt{
        $R = me&R
        # recur id
        $c = {}
        $x = me&Theing,c
        xy&c = c
        # %Piing**
        !c.long and throw "Thee!long"
        me&bin,c.long
        # E**
        Rs&TheingE = 1
        Rs&onlyish = 1
        return x
    }
    # identity spreader, more of the above, &G(n)ome_Jx
    me.Theing = &acgtc{
        $R = me&R
        $s = Rc&s
        Rs&Theingx && c and throw "const"
        Rs&Theingx and return Rs&Theingx
        
        # finds ^^%client and (here|their|Ying)/*
        $x = me&Gnome_Jx,R
        Rs&Theingx = x
        c ||= {}
        # believing something
        # < R%tow going?
        ss&tow and Rs&tow = 1
        
        # receivable somewhere
        Rs&elvis = 'FishElvis'
        
        c.long ||= T.act.t
        c.long and me&reaw,R,c.long+',elvis,tow'
        c.short ||= c.long
        c.short and xy&go = me&acting,R,c.short
        c.in and me&bin,c.in
        
        return x
    }
    },
  // 2 %TheingE** nodes keep s|E** outspheres
    # so RsE outspheres. R%E(y&R=R)
    # R%TheingE**/Ec&top - containers also have E
    # R%E
    ['TheingE',0.291,&acgtRs{
        me&bin,'TheingE'
        me&reaw,R,'TheingE,E'
        Rs&rowish = 2
        
        me&rollbs,R,'E'
        $E = Rs&E ||= Cye([R.t,1])
        Ey&R = R
        Es&z ||= []
        
        $p = Ry&up
        if (!ps&Piing) {
            Ec&uber = 1
            # < &Effected %hire,efrom=Nine
            #Rs&client = 1
        }
        
        # E**
        # what &Sopi &piinto does, Ey&C=s
        $p = Ry&up
        ps&E and Ey&up = ps&E
    },'ift,D'],
    # realising s//E, now that &Saturn eg sets sc&pi
    ['TheingE',0.2951,&acgtRs{
        $E = Rs&E
        # s->Ec&pi
        if (sc&pi) {
            # ! impersonating E/-seven, is strange
            Ey&ers = s
            # < going? out-E is not c&pi, only s and E/-pi
            Ec&pi = sc&pi
            # < GOING to look like a &Sopi, eg &piEight
            # outsphere s to outsphere E
            #   to inner outspheres (E/Six-Log)
            #   and inspheres (E/-seven for Ec&seven):
            s.y [ sc&pi ] = E
            Ey&C = s
        }
    },'ift,D'],
    # (s|E)**
    ['TheingE',0.296,&acgtRs{
        $E = Rs&E
        $x = me&Theing
        $p = Ry&up
        me&hideyfix,R
        xy&go and me&nu,"E",E
        # s**
        me&supsphere,s,x
        # E**
        ps&E and me&fiu,ps&E,E
    },'ift,D'],
    &{
        # used by %TheingE,
        #  Travel/$t%Travelable might be %eph
        me.supsphere = &acgtsx{
            $R = sy&R
            if (R) {
                $p = Ry&up
                $z = pc&s
                # %eph while %%Go-created, up permanence:
                if (Rs&eph && x) {
                    x.ro('%eph') and me&fiu,z,s
                    else return
                }
            }
            else {
                $z = sy&up
                !z and return
            }
            # may panic when sy&up not reciprocal
            !me&fiu,z,s,8 and me&tc,"Notabove!",'b'
            me&fiu,z,s,2
        }
    },
  // 3 %Piing** influx, &Piing
    # influx router
    ['Piing',0.295,&acgtRs{
        ~>7 insted: R.t
        me&Piing_inst,R,s
    },'ift,D'],
    # on the -six (which is really -hat|Fez...)
    ['Ethinging',0.2951,&acgtRs{
        $E = Rs&E
        # keep a y&thing on the -six
        #  since the eg E-haty&thing may not persist
        # < perhaps -six y&thing@1?
        $t = Ey&thing ||= Cye([E.t,2])
        # and tend not to display,
        #  until Nine/TheFe Effects awakeness at us
        Rs&Ehidey = 1
    },'ift,D'],
    ['Piing',0.296,&acgtRs{
        $E = Rs&E
        if (Ec&uber) {
            # see &Sarn, decides a schema
        }
        else {
            # elvis anywhere
            hak(sy&Todo) and me&Piing,'-Bat'
            # do this node , ie -> A:n
            sc&pi and Ey&main = me&Piing,'-'+sc&pi
        }
    },'ift,D'],
    # < index u. L
    ['Piing',0.369,&acgtRs{
        $E = Rs&E
        # children (/**) first:
        me&Ring,R,{inside:R,ov:555}
        # finish R/%Pier:
        me&ioR,'Pier' .map(&r{
            ~>3 Figaro: r.t, r.y.cv
        })
        me&ioR,'Pier' .map(r => me&Ring,r )
        # before %ball 38 draws /%fix-tures
        $e = Ey&main
        if (e) {
            $r = ey&R
            rs&lookat and me&Piing,'lookat-Bow',{s:rs&lookat}
            me&ioR,'Pier' .map(r => me&Ring,r )
        }
    },'ift,D,sleeping'],
  // &Piing_inst unpack intent
    &{
    # grows|culls **%Piing    proto &Superpath
    #  lifecycle management
    # %Piing 296 arrives This/
    # < see also %Travelables using &balforward
    #   &Pii (originally &Rsci inside it)
    #    was going to let Ec&uber know of i,
    #    and Gnome knows all Ec&ubers?
    #    same way lv would let E know it has ~
    me.Piing_inst = &acgtRs{
        $E = Rs&E
        if (Ec&uber) {
            me&ja,R,'initdata' and me&Run_initdata,R,s,E
        }
        # R%* to apply
        $scN = []
        $Names = me&Names_collector,R
        $Saturn = me&Saturn,<<'',[s]
            i @z <-+@mix @n||=@inst
                i &locate_Sarn@2 &being_inst $s** $sc={} $mix={}
            o <- %%inst
        
        # iterate the middle leg, which always has $sc
        #  $mix goes nowhere unless $s/@z
        Saturn.c.N.map(&a{
            # < these as io expr. ie @z && @n||=@inst +@mix-> @z
            #   everything right of && becomes required
            a.s != s and debugger

            $n = a.inst
            if (n) {
                $usu = ns&listen_node || ns&heard || ns&n
                !usu and debugger
            }

            # R:here behaviour
            # < tractogram
            hak(a.sc) and scN.push(a.sc)
            Names.from_ax(a)
        })
        
        $sc = {}
        scN.map(c => ex(sc,c))
        me&sync_inst,R,s,sc
        Names.done()
    }
    # to make stuff up < GOING for w:TryPiWarmer
    me.Run_initdata = &acgtRsE{
        !Ec&uber and debugger
        $This = me&Pii,'-This'
        $The = me&Pii,'-The'
        
        # to begin once
        me&za,R,'initdata' and return
        me&tc,"INIT",'g'
        each iz [This,The] {
            me&wants,R,'Run_initdata',z
        }

        $seven = me&Pii,This,'Something-Eight/Somewhence-seven'
        # test data for -hat ref noticing, limits, specialfx
        # init
        # the -eight remotely
        # i This/Bowler/\E-hat
        #$This = me&fiu,s,'This'
        $Bow = me&fiu,seven,'Bowler'
        $dat = Bowc&s = me&PiRet_data
        dat.moreso = dat.asee
        Bowc&pi = 'hat'

        $Bow = me&fiu,seven,'Lol'
        $da = Bowc&s = {more:'some',figaro:dat.asee}
        da.furhtin = {llatin:4}
        Bowc&pi = 'hat'

        $Bow = me&fiu,seven,'Room'
        $da = Bowc&s = {fer:dat.asee,even:'more',figaro:dat.asee}
        da.furhtin = {llabin:4}
        $i = 0
        while (i < 60) {
            da = da.th = {}
            i++
        }
        da.is = 'all'
        # < &Eing preferring this to more level$n
        #   diversity seeking
        $ej = Bowc&s.neesd = Cye(['Nees',3
            ,{mo:3,tor:68,functions:"of an elabourate sort",s:"Thsideratea"}])
        ejy&fig = dat.asee
        ejy&vig = 2
        Bowc&s['leveridge'] = Cye(['Nose',7,{s:'li'}])
        $i = 0
        while (i < 55) {
            Bowc&s['lever'+i] = 'thing'
            i++
        }
        Bowc&pi = 'hat'

        $seven = me&Pii,This,'Someact-Eight/Somewhence-seven'
        $Bow = me&Pii,seven,'Bowler-hat'
        Bowc&s = {as:dat.asee,fol:33,vanas:dat.asee,vaees:dat.asee}
    }
   // &sync_inst
    # controlled revoking of Thy...Lab styles
    me.sync_inst = &acgtRsc{
        me&rollbs,R,'inst_deletable'
        # remember and shutdown when ...
        $were = me&rollbs,R,'instcla'
        !were && !hak(c) and return
        were ||= {}
        $are = ex(ex({},were),c)
        $running = 0
        $gone = {}
        each kv are {
            if (!c[k]) {
                if (me&rollbs,R,k+'_gone' ) {
                    # they finished revoking etc last time
                    delete were[k]
                    gone[k] = 1
                    continue
                }
                R.sc[k+'_going'] = 1
                ah(R,'inst_going',k,1)
            }
            R.sc[k] = v
            me&reaw,R,k
            running++
        }
        ex(were,c)
        Rs&instcla = were
        if (hak(gone) && !running) {
            # < last one running causes %inst_gone
            Rs&inst_deletable = 1
            delete Rs&instcla
        }
        # allows %%inst... to come back
        # < &SuperLab reset needed
        running and delete Rs&inst_deletable
    }
    },
    ['inst_going',0.7,&acgtRs{
        me&tc,"(going:"+joint(haks(Rs&inst_going),',')+")"
    },'ift,D'],
    ['inst_deletable',0.7,&acgtRs{
        me&tc,"(Z)"
    },'ift,D'],
   // &Saturn nametypepath devise
    =pod
     i @Run/-This/-Eight/-seven/**
      pretty simple
       for %%inst,listen_node=Node/Path
        invent 'n:Node/Path'-Eight/now-seven/''-xat
     
     i @Thy/-This/#@Fine-Labine/@-Lab#@n%ThyLab/c&s=@n
      since an i, Names @Thy + @Lab may be defined
       otherwise (+usu &Shx) they would be demanded
      @Fine is found via etc
       it would otherwise want to exist
     in &Saturn, then:
      on s-Labine, the -Lab part must be solved:
       #@n takes $n
        and makes @Lab in its image (io #spacer)
      on s-Lab:
       %ThyLab is applied to $sc
       and its c&s holds the item, $n
        in some state of decoding...
    
    =cut
    # R%Sarndat = &Sarn schema on the Ec&uber
    ['Sarndat',0.29611,&acgtRs{
        $E = Rs&E
        !Ec&uber and throw "&Sarn inside &Sarn"
        me&reaw,R,'Sarndat'
        # just remembers %Sarndat=&Sarn defining schema
    },'ift,D'],
    &{
    # @Run and @Thy define their %%inst-ability with io
    #  to be completed by &Saturn delivering %%inst
    me.Sarn = &acgtscq{
        $g = me&Sarg,'Sarn',s,c,q
        return g
    }
    # tu: stuff the machine knows is happening
    # < eg being the first hop when %%efrom != s^
    # given protocols to handle:
    #  $s** building
    #  $sc  styles of $s (R%*)
    #  $inst = %%inst,n thing arriving
    #   once a from-index is built to womb it:
    me.Saturn = &acgtscq{
        $R = me&R
        $x = me&Jx,R
        q ||= {}
        # < io climbing: ^^%Sarndat{.path,_dist:pathi}
        #   that {} taking Sarndat,Sarndat_dist
        #   and should not usually:
        # includes everything in between
        $N = me.cby(R,'^^Sarndat')
        $Sarn = N[0].sc.Sarndat
        q.est = {Sarn,Sarn_dist:hak(N)-1}
        # n is being stretched by &Piing_inst relay
        $Saturn = me&Sarg,'Saturn',s,c,q
        $s = Saturn.c
        x.ro("Sat",{}) and me&Piing,'Satur-hat',{s,dl:4}
        
        return Saturn
    }
    },
   // &Saturn %%listen_node strategy
    # notify E%target
    #  set by &Saturn for an %%inst,listen_node
    ['listen_node_n',0.29611,&acgtRs{
        $E = Rs&E
        !E and throw "should E"
        me&reaw,R,'listen_node_n'
        # < &Saturn nodei:
        # < o %%listened,replyto:@Eight -> o E/-n/%target
        #   Names for @Eight, E is R%E,
        #    %target is where to ark=s position
        $En = me&fiu,E,'-n'
        $target = Ens&target
        # < &Names_get for -Eight, or a particular Ey&thing
        #   see fi&t for wanting formats|parts
        $Eight = me&Names_get,R,'Eight',1
        me&nodei,R,target,{listened:1,replyto:Eight}
        #me&nu,"listen",{E,En,target,Eight}
    },'ift,D'],
    # target replies with objects (that change)
    #  set by %ulog
    ['listen_node_listened','57',&acgtRs{
        me&reaw,R,'listen_node_listened'
        
        me&jaa,R,'listened' .map(&n{
            # < general repliable
            $to = ns&replyto || ns&efrom
            each kv R.sc {
                !k.endsWith('W') && (!isob(v) || isC(v) || !isC(v.A)) and continue
                # the &Saturn %%inst,listen_node there coops these:
                $s = {heard:k,s:v}
                k.endsWith('W') and s.piable = 'Womb'
                me&nodei,R,to,s
            }
        })
    },'ift,D'],
   
  // 8 %Piing node sleep|wake
    ['Piing',0.29599,&acgtRs{
        #me&notice_wakesleep,R,s,'Pi3'
    },'ift,D,sleeping'],
    # 
    ['Piing',0.55,&acgtRs{
        $x = me&Theing
        $E = Rs&E
        !E and throw "no E"
        #me&notice_wakesleep,R,s,'Pi6'
        
        if (Ec&uber) {
            # topmost
            me&PiiEuber_Epending_55,R,E,s
        }
    },'ift,D,sleeping'],
    &{
        me.notice_wakesleep = &acgtRst{
            $ind = indent(sy&path)
            t = t+" "+ind+s.t
            Rs&sleeping and ~>6 sl: t
            else {
                ~>3 aw: t
            }
        }
        self.indent = &ds{
            d == 0 and throw "d!>0"
            isar(d) and d = hak(d)
            s and throw "< splitindjoint"
            # 1:'',2:'  ',3:'    '...
            return new Array(1*d).join('  ')
        }
    },
  
&{
  
  // time!
  
  // &Piing into $E** proper
    # first, $s** spreads nodes pi-ishly
    # can i -long/bran-ches/of/nodes-hat
    #  may z.t||=long, wont c&pi||=of 
    me.Pii = &acgtsc{
        $R = me&R
        Rs&Pier and throw "use &Ei in R'The'"
        isst(s) and c = s; s = Rc&s
        $v = me&Rsci,c,{v:s}
        return v
    }
    
    # node leaps into R'The' with c.t|pi
    me.Piing = &acgtcq{
        isst(c) and c = me&t_tpi,{t:c}
        q and ex(c,peel(q))
        $x = me&Theing
        $R = me&R
        $s = Rc&s
        $E = Rs&E
        
        # resolves sy&RXing, which -> E below
        me&PiiE_pre_Piering,R,E,s,c,x

        # A thus much, more @36
        c.ov ||= 333
        # last permanent E, of a node
        #  aka RE|PE|Ep herein, is sometimes E in E/e
        $RE = E
        $del = me&modelta
        
        c.Pier ||= c.pi || sc&pi
        c.t ||= "-"+c.Pier
        c.Top = 1
        !hak(c,'s') && hak(s.c,'s') and c.s = sc&s
        $V = c.V = s
        # the first insphere E
        $E = c.E = Cye([c.t,1])
        # knows the outsphere E
        Ey&up = RE
        # stops climbing there
        Ec&top = E
        # outsphere itself (V)%ball) provides travel
        #  bunch of indexes for everything we could climb to
        #   ie avoid checking all Towering nodes for /$t etc
        # i %TX/* o Troom
        #  receives it here for E**
        V && Vy&RXing and fi&RXi,E,Vy&RXing
        
        # then starts matching, usu in &Eing
        $M = me&Pieri,RE,E
        
        $q = {}
        c.ov and q.ov = delete c.ov
        $r = me&PiRet,R,c
        !r and debugger
        ac(R,'z',r)
        
        # the tendency to hide eg -seven/*
        if (Rs&Ehidey)
            me&Effect,s,E,'hidey-six',{hid:1,ope:0}
        # < TX to unhide?
        if (M.some(aq=>ahsk(aq,'sc','qua','ope')))
            me&Effect,s,E,'RX-ope',{RXope:1,ope:1,dom:1}
        
        me&boxcap,'E:'+r.t (&ml{
            lc&s = r.t
            me&walls,m,'b:1.2h6'
            me&tt,'D' ({always:&v{
                v and me&Effect,s,E,'togope',{togope:1,ope:1,dom:1}
            }})
            me&tt,'R' ({always:&v{
                # only controller of this, so no -Effect layer
                v and rs&sleeping = 1
                # < is too late, now E/e, Epending, etc
            }})
        })
        # ope may be set to 0|1
        $ope = me&Effected,E,{ope:1}
        ope != null && !ope and rs&noDisplay = 1
        
        me&Ring,r,q
        
        del()
        xy&go and me&zu,"r:"+r.t,r
        xy&go and me&zu,"E:"+r.t,E
        return r
    }
    # ty toggling
    me.tt = &acgttc{
        $m = T.ab
        $R = me&R
        $s = Rc&s
        
        return &y{
            # check state
            $qua = ahsk(s,'y','tt',m.t,t)
            $was = qua
            $l = me&ty,t,c (&zTe{
                z != l and debugger
                # invoked when toggled
                qua = was ||= ahk(s,'y','tt',m.t,t,{})
                qua.on = !qua.on ? 1 : 0
                if (y.async) {
                    # < know we are to Effect somewhere, and
                    #  < apply an async Effected handler
                    # < for overriding an R%noDisplay=1 default,
                    #   we must sync R without it first
                    #    subsequent togglings may just &Csse dis:0
                    #   < Babz: tie io expr this?
                    #      with X flock of impulse, joinables...
                    T.wake = 'not'
                    debugger
                }
                else {
                    # will then visit R
                }
                ~>7 tt: m.t, t, qua.on
            })
            qua ||= {}
            y.always and y.always (qua.on)
            # < style in y.async
            qua.on and ls&bri = 1.6
        }
        
    }
    # i E/e hence
    me.Ei = &acgtc{
        $R = me&R
        !Rs&Pier and throw "use &Ei in R'The'"
        $E = Rs&E
        !c.t and throw "!t"
        c.t = ""+c.t
        $t = delete c.t
        $e = me&dupfiu,E,t
        c.cv and ey&cv = scaf(c.cv); delete c.cv
        c.pi ||= Rs&Pier || 'blank'
        ex(e.c,c)
        return e
    }
   // lowlevels
    # after somehow &Pieri, this &Pieringi
    # 1 R/r for E/* from c
    me.PiRet = &acgtRc{
        # GOING
        if (Rc&nofurther) {
            me&strange,'nofurther'
            me&ha,R,"toomuch:nofurther"
            return
        }
        
        # 11 new
        # GOING these would be only c.E.c.*
        $rcbits = tax({},c,'nl,dl')
        hak(rcbits) and debugger
        $r = me&Ret,R,c
        ry&cv = 0
        
        # main act, pre-&Ring
        me&Pieringi,R,r,c
        
        ex(r.c,rcbits)
        
        
        # to &Eing
        return r
    }
    # 12 &Pieringi makes three spheres
    # < C/** should represent E/**? D/**?
    me.CED = &acgtR{
        # C display
        $C = Rs&C = Cye([R.t,1])
        Cy&R = R
        
        # E itself, usu passed in
        $E = Rs&E ||= Cye([R.t,1])
        Ey&R = R
        # E**
        $p = Ry&up
        ps&E and Ey&up = ps&E
        
        # D record
        $D = Rs&D = Cye([R.t,1])
        Dy&R = R
        Dy&E = E
        Ey&D = D
    }
    
  
  // 
  
 
  // &Piing       <  doc points of %E** inspherings etc
     // outsphereings # besides those above
        # T from the outsphere
        me.PiiE_pre_Piering = &acgtREsc{
            # < to be many, versioning
            $tc = me&Thetower,R
            $es = tc.es
            delete sy&RXing
            es && esy&TXing and sy&RXing = esy&TXing
            # then get r:
            c.pre_Pieringi = &re{
                me&PiiE_pre_Pieringi,R,E,r,e
            }
        }
        # < hoist more &Piering
        
        # re has become, re the outspheres:
        me.PiiE_pre_Pieringi = &acgtREre{
            # E** was
            $be = me&fiu,E,e.t,8
            if (be) {
                ec&b = be
                me&tc,'b','b'
            }
            # E** is
            # < only staged, via ^^^Piing
            # < recycles E/e? when %Piing%sleeping?
            me&fiu,E,e,1
            
            me&PiiE_Epending_1,R,E,r,e
        }
     // ^^^E%Epending[e]
        # ^^%Pier (r &Piing creates) pends at ^^^%Piing
        me.PiiE_Epending_1 = &acgtREre{
            # E** transmit stuff upward immediately
            #  e/ref/ is staging to PE/ref/ (in &Eref_begin)
            #  transact also unsorted list of innards,
            #   which may export what we will be looking for
            $Pr = me.cbu(r,'^^^Piing')
            $PE = Prs&E
            !PEc&uber and debugger
            $pend = Prs&Epending ||= []
            pend.push(e)
            ac(r,'commit',&{
                grepout(pend,e)
            })
            # < mEy&R shall have E staging /ref/ that would be in mEc&X
            #   they must be checked for positioning...
            #R.t == 'Bowler' and me&zu,"topE",{mE,tE}
            # ...&Pieringi does &Eref_begin
        }
        # topmost
        me.PiiEuber_Epending_55 = &acgtREs{
            $pend = Rs&Epending
            # < throw, this is likely to be missed
            hak(pend) and debugger
            hak(pend) and me&nu,"still-pending",{pend}
            hak(pend) and ~>3 still-pending: joint(pend)
        }
     // re the insphere
        me.PiiE_pre_Pieri = &acgtREre{
        }
            
            
   
  // &FishElvis + -Bat f
    me.FishElvis = &acgtRs{
        ~FishElvis
        try {
        !Rs&ball and debugger
        c&slope.includes(R) and $aft = R
        else {
            ~>5 FishE tving in: R.t
            $aft = c&slope.filter(r => r.t == R.t)[0]
            !aft and debugger
        }
        $N = ksaf(c&slope,{aft,inc:0})
        
        # expect R%elvis...R:$pi
        $pi = hak(N.filter(z => isR(z)))
        !pi and return me&Gazel,R,s
        
        $p = Ry&up
        $M = ps&z
        #ksaf(ps&z,{aft:R})
        
        $c = {A,C,R,s,N,M,el:2}
        me&Thetower,R,c
        c&tower = c
        $n = c.es
        ~>3 sol: dis(n), c.wake.t
        ny&Todo.push(C)
        
        T.wake = c.wake
        me.Lastev = c
        }
        catch(er){
            ~>3 noFish: ""+er
        }
    }
    # where|how elvising goes
    #  This/Has/A/Thing may home e in:
    #   This/Has/e%tow/A/Thing
    #   This/e%tow/Has/A/Thing
    #   The%tow/Has/A/Thing
    # < always a further step
    # < constituation of climbers, for rowing
    # s finds Trooms for itself
    me.Thetower = &acgtRc{
        c ||= {}
        # find Thyer/%Theing/...s
        c.above = me&climbaboveTheing,R .map(r => rc&s)
        # their next sibling with %tow
        c.tows = c.above.map(&s{
            $p = sy&up
            !p and return
            if (!(ps&z||[]).includes(s)) {
                $r = sy&R
                rs&eph and return
                debugger
            }
            return ksaf(ps&z,{aft:s})
                .filter(z => zs&tow)[0]
        })
        # The springs The 2, etc
        if (!hak(c.tows.filter(z=>z)) && c.el == 2) {
            c.tows[1] = me&makeextraThe,c
        }
        # each %tow/...s
        c.towing = []
        $nearest = reverse(c.tows).filter(z=>z)[0]
        each iz c.tows {
            !z and continue
            $s = c.above[i]
            $r = sy&R
            $path = c.above.slice(i*1+1)
            # This<->The is implied
            rs&Theeing and path.shift()
            # try to route
            # may create nearest %tow/**
            $el = z == nearest && c.el == 2 ? 0 : 8
            each ii,n path {
                !z and continue
                $e = me&fiu,z,n.t,el
                z = e
            }
            c.towing[i] = z
        }
        c.elvisors = reverse(c.towing).filter(z=>z)
        # first|deepest is where to elvis
        $es = c.elvisors[0]
        !es and return c
        esy&Todo ||= []
        c.es = es
        # nearest R above that, to wake elvisor
        $z = me.cbu(es,z=>zy&R)
        c.wake = zy&R
        # who has TX
        return c
    }
    # for R=The/Room/... to This/Room
    # < provide The/Room as you
    me.Battarget = &acgtR{
        # ^^/%Theing
        $N = me&climbaboveTheing,R
        $Thy = N.shift() .c.s
        $Theing = N.shift() .c.s
        # previous sibling
        $prevTheing = ksaf(Thys&z,{bow:Theing,near:1})[0]
        !prevTheing and return me&strange,"&Battarget:no-/</-Theing"
        # path into %TheTh**
        $z = prevTheing
        $M = [z]
        $not = 0
        while (1) {
            $r = N.shift()
            !r || !rs&TheingE and break
            $s = rc&s
            $n = me&fiu,z,s.t,8
            !n and not = 1; break
            M.push(n)
            z = n
        }
        me&tc,'targeting',"@"+joint(M,'/'),'y'
        not and me&tc,'targeting_fail',"!"+s.t,'B'
        else {
            $end = M.slice(-1)[0]
            Rs&target = end
        }
    }
    # find Thyer/%Theing/...R
    me.climbaboveTheing = &acgtR{
        return me.cby(R,'^^^Piing')
            || me.cby(R,'^^^Theing')
        $r = R
        $N = [r]
        while (1) {
            $p = ry&up
            !p and break
            N.unshift(p) > 10 and debugger
            rs&Theing and break
            r = p
        }
        return N
    }
    me.makeextraThe = &acgtc{
        $Thyer = c.above[0]
        $The = c.above[1]
        $zc = The.t.match(/^(.+) (\d+)$/)
        $t = zc ? zc[1] : The.t
        $i = zc ? zc[2]*1+1 : 2
        t = t+' '+i
        $es = me&fiu,Thyer,t
        ess&tow = 1
        # will be %Theing
        return es
    }
    # GOING receive+see e somewhere
    me.proto_Bat = &acgtc{
        #return
        if (c) {
            $ev = me.Lastev
        }
        else {
            $R = me&R
            $x = me&Theing
            $s = Rc&s
            !sy&Todo and return
            $e = sy&Todo.slice(-1)[0]
            !e and return
            $ev = ec&tower
        }
        if (1 || xy&go) {
            me&nu,"e",e
            $ev = ex({},ev)
            me&nu,"tower",ev
            $int = {N:1,M:1}
            each kv ev {
                !isar(v) and continue
                each in v {
                    ev[k+'_'+i] = n
                }
            }
        }
    }
   
  // &Eref*
   // lookup
    # < Shx o E/$ref:s
    # < generating the climb 
    
    # search for other R with ref, E^^
    #  X.ref only exist on the Ec&top %X
    me.Ereflookup = &acgtc{
        $E = c.E
        $e = c.e ||= E
        $s = c.s
        $R = c.R
        $F = Rs&E
        c.got ||= []
        # look for the ref
        $x = fi&EXsim,E,{ref:s}
        # from R not being replaced
        $b = ec&b
        $br = b && by&R
        $z = x.z.filter(r => !br || brc&N != rc&N)
        each in z {
            # skip same node copied upwards
            c.got.some(g => g.n == n) and continue
            $tp = me&Rnodepath,n
            c.got.push({E,n,tp})
        }
        if (!c.nowander) {
            # further up
            Ey&up and me&Ereflookup,ex(c,{E:Ey&up})
            if (Ec&uber) {
                # and anything awake that might be going to commit up there
                $Pr = me.cbu(R,'^^^Piing')
                each in Prs&Epending {
                    me&Ereflookup,ex(c,{E:n,nowander:1})
                }
            }
        }
        E != e and return
        
        # sort by R tree
        c.got.map(g => ex(g, me&Rcrux,R,g.n ))
        # < -seven having a time sense greater than -eight
        #   -seven on a different -Nine are too far
        #   see otherable &EsyncThis as -log
        # ignore those after this R^^^
        $poss = c.got.filter(g => g.seek < 0)
        # group by distance up from here
        #  then start climbing down again, sorting...
        $neu = []
        $h = vpartN(poss,g => g.ups.length)
        each iN h.vs {
            neu.unshift( ... me&Erefclimb,N )
        }
        c.got = reverse(neu)
        
        # prefer closer...
        
        return c
        # create distality
        # satisfy
        #  r%toomuch or %tiny doesnt count
    }
    me.Erefclimb = &acgtNc{
        N.length <= 1 and return N
        c ||= {}
        c.i ||= 0
        c.i *= 1
        # climb nearer|earlier first until satisfied
        #  if a later thing redraws it (differing)
        #   we want to follow on from that instead...
        # just sort it all into:
        $neu = []
        $eg = N[0]
        $h = vpartN(N,g => me&Rcrux_seek,c.i,eg.downs,g.downs )
        each iM h.vs {
            $k = h.ks[i]
            # < seeing a different R
            k == null and continue
            M.length > 1 and M = me&Erefclimb,M,{i:c.i+1}
            N.map(g => g['seek_'+c.i] = k)
            neu.push(...M)
        }
        c.i > 25 and throw "lost"
        return neu
    }
    # find join between **R and **r
    #  resorts to comparing Rc&s or R.t to get it done
    # < into rowing
    #   proof that X-stitching needs to preserve $n-order
    #    by way of Jip, Aip, tip, etc
    # < for [r], with no particular R
    #    finding islands
    #   would be able to sort the whole thing as a tree
    #    currently different joins may compare c.seek
    me.Rcrux = &acgtRr{
        $c = {ups:[R],downs:[r]}
        $loca = &nN{
            $ni = N.indexOf(n)
            if (ni < 0 && ns&ball) {
                # use the eternal C arriving on different R
                ni = N.findIndex(r => rs&ball && rc&s == nc&s)
                ni >= 0 and c.viaball = 1
            }
            ni < 0 and return
            # we might find r^3 is R^1, trim R^3-2
            N.splice(0,ni)
            return 1
        }
        $upsi = &nN{
            $p = ny&up
            !p || ps&Gens || ns&eph and return
            ps&ball && !ns&Pier && !me&fiu,pc&s,n.t,8 and debugger
            N.unshift(p)
            return 1
        }
        while (1) {
            # upmost either
            $L = c.ups[0]
            $l = c.downs[0]
            # found in the other
            loca(L,c.downs) || loca(l,c.ups) and break
            # further y&up
            !(upsi(L,c.ups) || upsi(l,c.downs)) and break
        }
        while (c.viaball) {
            # try to resolve R.t to deepen the join
            # see resolve $n
            $L = c.ups[1]
            $l = c.downs[1]
            !L || !l || L.t != l.t and break
            c.ups.shift()
            c.downs.shift()
        }
        # on the join, is r before R (c.seek<0) or not (>0)
        c.seek = me&Rcrux_seek,0,c.ups,c.downs
        return c
    }
    # get order of two [R**] that already join at $offset
    me.Rcrux_seek = &acgt,offset,left,right{
        left == right and return 0
        offset *= 1
        $L = left[offset]
        $l = right[offset]
        if (L == l) {
            if (!left[offset+1] && !right[offset+1]) {
                me&strange,"Rcruxingnot:"+joint(left)
                return 1
            }
            # simply see where in R%z
            $Li = Ls&z.indexOf(left[offset+1])
            #Li < 0 and debugger
            $li = Ls&z.indexOf(right[offset+1])
            # eg left=[R,y,R] right=[R]
            Li < 0 && li < 0 and debugger
            return li - Li
        }
        elsif (Ls&ball && ls&ball) {
            $s = Lc&s
            s != lc&s and debugger
            !ss&z and debugger
            $rl = left[offset+1]
            $rr = right[offset+1]
            # look in the E sphere?
            $Li = ss&z.indexOf(rlc&s)
            $li = ss&z.indexOf(rrc&s)
            if (Li<0 || li<0) {
                # could be found in the E sphere (L%E/rl%E)
                #  they are likely -all -pis, have no order
                rls&Pier && rrs&Pier and return 0
                debugger
            }
            return li - Li
        }
        elsif (Ls&ball || ls&ball) {
            debugger
        }
        else {
            # they dont join, even by C
            # < if R/$t ? yfuture the L?
            #debugger
        }
    }
   // misc
    # make relative pointer to g=c.got/$g
    me.Eref_got_pointer = &acgtg{
        # the amount of '^'
        $down = g.downs.slice(0)
        $ups = hak(g.ups.slice(1))
        $location = ups > 1 ? "^"+ups : '^'
        # allow '^/ref' - not inc ups|downs[0]
        ups <= 1 and down.shift()
        # 1
        $downs = ""
        $waspath = 0
        down.map(&r{
            # '//' when leaving node-sphere
            $path = rs&ball && rc&s.y.path
            !path && waspath and downs += '/'
            downs += '/'+r.t
            waspath = path
        })
        # going far makes '^4:This/etc'
        ups > 1 and downs = ':'+downs.substr(1)
        location += downs
        return location
    }
   // < commit
    # transact Ec&top
    me.Eref_begin = &acgtre{
        $p = ry&up
        $E = ps&E
        !E and throw "!E"
        # stop seeing refs from the old e in E%X
        $be = ec&b || me&fiu,E,e.t,8
        # see &Piing attaches E** @1, %Thyer GOING
        be == e and ey&R.sc.Piing and debugger
        else
        be and ec&b = be
        ac(r,'commit',&{
            # copy to E^^^%X
            $c = {E,e}
            ec&b and c.removing = [ec&b]
            me&Erefputup,c
            delete ec&b
            me&fiu,E,e
            es&glop and me&nu,"Glop",es&glop
        })
    }
    # commit Ec&top (top of &Piering) to E^^
    me.Erefputup = &acgtc{
        $E = c.E
        $X = Ec&X || fi&EXsim,E,{}
        # add new
        $e = c.e
        $e_x = e && ec&X || {}
        each is e_x.refs {
            $x = e_x.ref[i]
            each in x.z {
                fi&EXsim,E,{ref:s},{n}
            }
        }
        # remove old
        each i,oe c.removing {
            $oX = oec&X
            $gonei = []
            each is oX.refs {
                $ox = oX.ref[i]
                !X.refs and continue
                $i = X.refs.indexOf(s)
                if (i < 0) {
                    each in ox.z {
                        $r = ny&R || n
                        $name = me&Rnodepath,r
                        ~>3 confuslet: name
                    }
                    continue
                }
                $x = X.ref[i]
                grepout(x.z,n => ox.z.includes(n))
                !hak(x.z) and gonei.push(i)
            }
            reverse(gonei).map(&i{
                X.refs.splice(i,1)
                X.ref.splice(i,1)
            })
        }
        Ey&up and me&Erefputup,ex(c,{E:Ey&up})
    }
  
  
  
  // &Eing E/* into life
    # 2 E/** sync, repeatedly
    # < in or out of time?
    me.Eing = &acgtc{
        # you must have the correct C to me&R:
        $R = me&R
        $E = Rs&E
        # @13 a bunch
        # < Babz Es&z[-1]
        $la = Es&z && Es&z.slice(-1)[0]
        if (Es&z && la && lay&R == null) {
            # < seems to move things when all ==
            Es&z.some(n => ny&cv != 0.1) and vsortz(Es&z)
            # applies E/* to PiRet, creating R%Pier@13
            me&Eing_some,R,E
        }
        # @2, etc!
        if (c) {
            num(c) and c = {ov:c}
            c.ov = scaf(c.ov)

            me&Ring,R,{inside:R,ov:c.ov}

            $allok = !me&ja,R,{toomuch:1}
                && !me&anystrange,R
            return allok
        }
    }
    # all E/* &Pieri once, if would &PiRet
    me.Eing_some = &acgtRE{
      // 1 c.would, &Pieri -> (un)?keen 
        $many = hak(Es&z) > 30 ? 20 : 0
        # arriving e a bit may pos|neg it
        # < once space limit is found,
        #   sub negated for posited
        # < %limit:impl,E
        #   %limit:dim, being picky|squishy
        #    wanting 5 things x 5 characters
        #     may slice paths off %limit:ref modulat
        #      we want to make all ^ in a Cish relative to the C
        #      so eg neesd.y.fig says @/fer
        #   covered by %limit:dis
        #    when the .t is affected for layout...
        
        $c = {}
        Es&z.map(e => ac(c,(ey&R == null ? 'would' : 'have'),e))
        # < sync to a E&X.Eing sub-brack?
        #   so we can share %limit:dim to e&X.Eing
        #   and make all this &sortial for keenness
        each ie c.would {
            
            # 1
            ey&R = 0
            # if any match (besides impl|ope<0),
            #  it promotes E to in, past any %limit
            $M = me&Pieri,E,e
            # TX about style|schema|layout are usu low intent
            #  should cause eg dim
            #   if light happens to get there
            # most other RXing as of &Pieri implies opening
            #  since stuff is routing into it, eg ope+1
            #   or eg something compare in there
            $serious = M.filter(aq => !aqs&layout)
            $keen = hak(serious) ? 1 : 0
            each i,aq M {
                $qua = aqs&qua
                !qua and continue
                qua.ope and keen += qua.ope
                qua.impl and keen -= 2
            }
            # < more and less keen
            keen > 0 and ac(c,'keen',e)
            else
            keen < 0 and ac(c,'unkeen',e)
        }
        # unhad e logged:
        c.toomuch ||= []
      
      // 2 %limit:
        # stop R recursion when a %%limit,toomuch
        #  R may have decided that already,
        # < running into eg %limit:many while @1-ing R
        $stop = me&Ro,{limit:1,toomuch:1}
        # %limit:ref may stop woulding, probably unlimited keen e
        if (stop) {
            c.toomuch.push( ... c.would.splice(0) )
            if (c.keen) {
                # just the keen
                # < unless a stopper is much over a hard limit, eg nl
                # grepout comp array of objects
                c.would = grepout(c.toomuch,c.keen)
            }
        }
        # %%layout,toomuch,E
        if (hak(c.unkeen)) {
            $N = grepout(c.would,c.unkeen)
            each ie N {
                me&Ri,{layout:'unkeen',toomuch:1,E:e}
            }
        }
        # %limit:many prioritises space for keen e
        # < $many as per %limit:dim...
        many and $length = hak(c.have) + hak(c.would)
        if (many && length > many) {
            $more = many - hak(c.have)
            more < 0 and more = 0
            if (more > 0) {
                # c.would until the limit
                c.toomany = c.would.splice(more)
                if (c.keen && hak(c.toomany)) {
                    # prioritise space
                    $i = hak(c.would)-1
                    each ii,e c.keen {
                        c.would.includes(e) and continue
                        while (1) {
                            $oe = c.would[i]
                            # demote a !keen
                            # < next least keen
                            c.keen.includes(oe) and i--; continue
                            c.toomany.push(
                                ... c.would.splice(i,i+1))
                            # promote the keen from toomany
                            c.would.push(
                                # grepout comp object
                                ... grepout(c.toomany,oe))
                            # < fatal grepout
                            i--
                            break
                        }
                    }
                }
            }
        }
        
      // 37 would &PiRet, too* limit
        each ie c.would {
            $rc = {t:e.t,s:ec&s,E:e}
            $r = ey&R = me&PiRet,R,rc
            # not @1
            !r || rc&not and debugger; me&Ri,{toomuch:'not',E:e}
        }
        
        if (hak(c.toomany)) {
            # can be %TX out of the shadow
            me&Ri,{limit:'many',excluding:hak(c.toomany),thresh:many,toomuch:1}
            each ie c.toomany {
                ac(c,'toomuch',e)
            }
        }
        # %limit:many+ref coalesce into non-happening E/e
        # < dont lose the exact origin of the !e
        if (hak(c.toomuch)) {
            # points vaguely to %%limit
            each ie c.toomuch {
                me&Ri,{toomuch:'limit',E:e}
            }
        }
    }
   
  // R'The' stylemotifs
    # @21 spawn|mutate E**
    # E remains given|base type
    # D shifts into that mind with R%-pi
    me.typeup = &acgtR,pi{
        $D = Rs&D
        $E = Rs&E
        Dc&pi = pi
        #  supposing from-here R-ing?
        #  ie desc order of immediacy
        # < mindwind or dome? fail over when X clash?
        #   re-&pio if already
        #   leaving evidence for next life to test
        R.sc[pi] = 1
    }
    # @ 22 layouty TXi
    me.TXin = &acgttg{
        g = peel(g)
        $R = me&R
        $E = Rs&E
        $sol = &he{
            each kc h {
                $name = joint([t,e&&e.t,k])
                $z = delete c.z
                $init = delete c.init
                # c becomes aq%qua
                $aq = fi&TXi,e||E,name,{t:k},c
                
                ex(aq.sc,g)
        # < most matches want to apply only to E/*
        #   applying further is wander, ie E/**
        #   then there's one-per:
        #    putting the RX.ignore on the matcher
                ah(aq,'also','dl',1)
                # < use
                init and init(aq)
                # then more inside
                z and sol(z,aq)
            }
        }
        return &h{ sol(h) }
    }
    
  // R'The' stylemo
    # 3 realises R/r as E/e
   // &Pieri, +r, &Pieringi
   
    # @02 early realise
    # either by &Piering, from R%Piing
    #  or &Eing_some c.would, from R%Pier &Eing
    # < also nab brack as it goes
    me.Pieri = &acgtEe{
        # < many
        # bunches of
        $Xc = {}
        Xc.t = e.t
        
        ec&pi and Xc.pi = ec&pi
        
        if (hak(e.c,'s')) {
            $s = ec&s
            Xc.v = s
            # in-t
            isC(s) and Xc.Ct = s.t
        }
        
        # < Xc.Ct > .t sometimes, from -Bet
        # < path can say 0/CthingCsoCCalleisable
        #   for an array .t, then .Ct+
        fi&pio,e,Xc
        
        $M = fi&RXglob,e,'matched'
        
        
        
        
        return M
    }
    
    # @1 R/r, pre-&Ring
    me.Pieringi = &acgtRrc{
        $E = c.E
        if (E) {
            # see also E&rc_mix below
            tax(r.sc,E.c,'dupl,noref,inline')
            Ec&rsc_mix and ex(r.sc,peel(Ec&rsc_mix))
        }
        # may already E
        me&CED,r
        $C = rs&C
        $E = rs&E
        # R%wou for brack
        # < should be E%X?
        me&haja,r
        
        $cb = delete rs&pre_Pieringi
        cb and cb(r,E,C)
        
        # spreads base type, or Ec&pi @2
        rs&Pier ||= Rs&Pier || 'blank'
        # Ec&pi provided over %Pier inherited
        Ec&pi and rs&Pier = Ec&pi
        Ec&pi ||= rs&Pier
        
        if (c.Top) {
            rc&top = r
            # capsule of %TX
            Ec&top != E and debugger
            # transact Ec&X.ref
            me&Eref_begin,r,E
        }
        if (c.Top) {
            rc&N = []
            rc&d = 0
            rc&dl = 15
            rc&nl = 300
            delete rc&refR
            delete rc&refs
            # lets /Display** recycle Elements
            me&arriveRbitX,r,r.t
            # new J, normal mind
            rs&task ||= 'Pi_The'
        }
        if (E) {
            tax(r.c,E.c,'nl,dl')
            Ec&rc_mix and ex(r.c,Ec&rc_mix)
        }
        # 13 puts on tape or not
        # < splice in re ry&up, neighbours
        rc&N.push(r)
    }
    
  // Pi%Pier, &Ring thence
    me.Pi_Pier = &acgt{ return [
       // %Top|%Pier back
        ['Pier',0.2,&acgtRs{
            me&Pieringo
        },'ift,D'],
        ['blank',0.21,&acgtRs{
            # diverges into types
            Rs&hat = 1
        },'ift,D'],
        
        # %TX awarenesses a point
        # dome suspicion
        ['Pier',0.264,&acgtRs{
            me&Piero
        },'ift,D'],
        
        # E/** expands, if not already
        ['Pier',0.3,&acgtRs{
            me&Eing,3
        },'ift,D'],
        
       // %Top &Topping
        # for all, without Ringing around
        ['Top',0.67,&acgtRs{
            me&Topping
            
            s&dis = 1
            C.y.cv = 0.22
            me&walls,C,"b:2.2"
            me&scroll,28
        },'ift,D'],
        ['Top',0.9,&acgtRs{
            # disp
            
            Rs&sleeping and return
            me&applyRbitX,R
            
            each iy Rs&commit {
                y ()
            }
        },'ift,D,sleeping'],
    ] }
    
    # @2 arrive in R%Pier
    me.Pieringo = &acgt{
        $R = me&R
        $C = Rs&C
        $E = Rs&E
        $V = Rs&V
        # E** happenings
        
        # light appetite
        Ec&dl and Rc&dl = Rc&d + Ec&dl
        
        $p = Ry&up
        $pE = ps&E
        # note discontinuous $pi
        # < unexpected $pi from compressing usual $pi/$pi/$pi/$pi...
        if (!pE || pEc&pi != Ec&pi) {
            $n = me&tc,'new:Ec&pi','-'+Ec&pi,'G'
            ny&cv = 0.105
        }

        $name = R.t
        n At 101 $s:name %label:t,deco,fs:6

        R.sc[Rs&Pier] = 1
    }
    
  // &Piero @264
    # @264 realise minded id
    me.Piero = &acgt{
        
        $R = me&R
        $E = Rs&E
        $D = Rs&D
        $s = Rc&s
        
        $Xc = {}
        # < &typeup might immediately:
        Dc&pi and Xc.pi = Dc&pi
        # < replace Ec&s=R future?
        fi&pio,E,Xc
        
        $M = fi&RXglob,E,'matched'
        
        # < unfold schemes at &Eing
        $p = Ry&up
        ps&isdim and Rs&indim = 1
        if (hak(M)) {
            T.Mw = 'TX'
            # is it the end of a Ting
            $sym = M.some(aq => aqc&TX) ? '⇃' : '⥙'
            
            each i,aq M {
                $qua = aqs&qua
                !qua and continue
                $s = {RX:2,aq}
                if (qua.ope) {
                    Rc&dl += qua.ope
                    Rs&ope ||= 0
                    Rs&ope += qua.ope
                }
                if (qua.biggish) {
                    me&modselect,R,{modt:'String',t:'string',cv:13}
                        .map(n => ns&fs = 22)
                }
                qua.impl and me&tc,"~impl~"
                qua.dim and Rs&isdim = 1
                me&Ri,s
            }
            each i,aq M {
                $qua = aqs&qua
                !qua and continue
                if (qua.ope && qua.ope > 0) {
                    # < or if cold light
                    delete Rs&isdim
                    delete Rs&indim
                    if (Rs&Cish) {
                        Rc&dl += 1
                    }
                }
            }
            Rs&isdim and me&Ri,{layout:'dim'}
        }
        
        # ref sense similar, centralised
        me&Rlimiti,R
        
        return M
    }
  
  
  // R'The'   specialfx
    # magic words in brack engage, like Ring
    # globalised pseudo-Ringing parts of Ringing
    
    # @67 layout etc for all
    me.Topping = &acgt{
        $R = me&R
        #me&Rlimits,R
        Rc&ha and debugger
        hak(Rc&N.filter(r => rc&not)) and debugger
        
        # < thingi, when notes merge onto parents
        #   could be earlier, sublate /* &Rthingo if simple
        T.Mw = 'Top'
        each ir Rc&N {
            $C = rs&C
            me&Topping_2,r
        }
        
        $C = Rs&C
        each ir Rc&N {
            if (rs&strange) {
                # < partly glowing map of t** from
                #  < a hud thing
                $tpath = joint(me.cby(rs&E,E => Ec&top),'/')
                $tc = me&tc,'strange:'+tpath,'16b'
                
                delete tcy&cv
            }
        }
        # generate thingo
        each ir Rc&N {
            $C = rs&C
            each kv me.magic {
                v.later and continue
                # magic brack listed here on &Ri
                $N = r.sc[k]
                !N and continue
                # calls &Rlimito, etc, in order
                me&mecy,['R',k,'o'],r,{N}
            }
        }
        T.Mw = 'Top'
        each ir Rc&N {
            me&modulatM,r,1
        }
        reverse(Rc&N).map(r => me&specialfx1,r)
        #Rc&N.map(r => me&specialfx2,r)
        
        # another minor wave of thingo
        each ir Rc&N {
            $C = rs&C
            each kv me.magic {
                !v.later and continue
                $N = r.sc[k]
                !N and continue
                # calls &Rlimito, etc, in order
                me&mecy,['R',k,'o'],r,{N}
            }
        }
        each ir Rc&N {
            # < c=1 may be reassigning cv (&cvdeal)
            $late = me&modulatM,r,1
            !hak(late) and continue
            # where some structure has taken over
            # < stream into, degrees of time availing reorg
            if (rs&Msink) {
                $lat = grepout(rs&M,late)
                hak(lat) != hak(late) and debugger
                # scooped into a row
                lat.map(n => ac(rs&Msink,'z',n))
            }
        }
        $M = Rs&M
        vsortz(M)
    }
    # upwards, cook modulat
    me.specialfx1 = &acgtR{
        $C = Rs&C
        $N = me&ioR,R
        
        # modulat trim
        me&Topping_37,R,N
        # tally R%M**c&s
        Rs&geolen = me&measure_modulat,Rs&M
        # modulat trim
        me&Topping_41,R,N
        
        # tally upwards
        $geo = Rs&geo = {}
        geo.self = Rs&geolen
        geo.insides = me&measure_modulat,N
        Rs&geolen = geo.self + geo.insides
        
        if (0) {
            $talk = geo.self
            geo.insides and talk += "+"+geo.insides
            $ge = me&tc,"geo:"+talk,talk,'6g'
            gey&cv = 0.79
        }
        
        $must_mirage = N.some(r => rs&rowy)
        if (!must_mirage &&
            (Rs&inline || hak(N) <= 1)) {
            return
        }
        
        # group into lines
        me&sfx_mirage,R,N
    }
    
   // Top modulat rejigs
    # pre-thingo, r%Mw still there
    me.Topping_2 = &acgtr{
        $N = me&ioR,r
        # who
        rs&shym && rs&Ctitle and me&moddelete,r,{modt:'shym'}
        if (!hak(N)) {
            if (rs&toomuch) {
                # hiding all the stuff
                if (rs&shym && !rs&Cish) {
                    rs&toomuch_shouldcount = 1
                    me&moddelete,r,{modt:'shym',t:'end'}
                }
                if (rs&indim && rs&Cish) {
                    me&moddelete,r,{modt:'Ctitle'}
                }
            }
            # instead of thing{ ⦄1 }
        }

        # %limit unifies
        $too = N.filter(r => rs&limit)
        if (!(hak(too)+1 <3) && hak(too) > hak(N)*0.5) {
            # notice lots of children getting a %limit
            # < include mute if no toomuch,E like thingo does
            #    it might be exporting the %%limit
            #    through an Effect?
            $h = {}
            too.map(&j{
                js&limit.map(n => ac(h,ns&limit,j))
            })
            delete h.ref
            each t,hN h {
                # such limit must apply to more than half of the children
                hak(hN) < hak(N)*0.5 and continue
                # unified thingo, unless %%layout:dim
                if (!(rs&layout && me&Ro,r,{layout:'dim'} )) {
                    me&Ri,r,{super:'limit',limit:t}
                }
                # instead of */%%limit thingo, if:
                #  only %%limit:dl,toomuch?
                $only = n => me&honly,n.sc,{has:{limit:t},may:{toomuch:1}}
                each ij hN {
                    $thislimit = js&limit.filter(n => ns&limit == t)
                    !me&hall,thislimit,only and continue
                    me&Ri,j,{limit:t,sublated:r}
                }
            }
        }
    }
    # post-thingo, pre-measure
    me.Topping_37 = &acgtR{
        # trim modulat pre-measuring
        if (Rs&inlineable) {
            # Cish
            grepout(Rs&M,n => ns&modt == 'Hash')
        }
        if (Rs&tiny) {
            # show non-At labels
            grepout(Rs&M,n => ns&modt == 'Pier')
        }
    }
    # post-measure
    me.Topping_41 = &acgtRN{
        # (light here-ish chases away %indim)
        $len = Rs&geolen
        if (Rs&isdim) {
            # are always containers of sketchables
            if (len < 9 && !hak(N)) {
                # contains nothing
                # < make sure...? %dim 
                # see if things are much ado
                $things = Rs&M.filter(n => nc&thing)
                #~>3 dim-empty: R.t, joint(things.map(n => nc&thing.ov))
                #Ry&up.t == 'asee' && R.t == 'y' and ~>3 fo: len
                Rs&M.filter(n => ny&cv >= 0.12)
                    .map(n => nc&not = 1)
                $len = me&measure_modulat,Rs&M
                me&Ri,{mirage:'empty',notonly:1}
            }
        }
        if (Rs&indim) {
            Rs&z and me&strange,"indim-z"
            if (Rs&String && len > 9) {
                # shorten long strings
                # throw away detail, to $key:$sym$length
                #  eg str:'17
                # < like %Dscdotnk:
                # < not if diffing this thing
                #    mirage will want to wrap differings
                #    keeps D/D:c/D:strc&s=fulltext
                #     over D%'.c'="bu:3,nch:[3,str:'17,ing:4"
                # < long integers should round or x10^n
                $str = Rs&M.filter(n => n.t == 'string' && ns&modt == 'String')[0]
                $strlen = str && (''+strc&s).length
                if (strlen > 9) {
                    $talk = strlen
                    strc&s = "'"
                    # adjusting for shortening
                    len += 4 - strlen
                    # < group %toomuch near edge expandability
                    me&Ri,{mirage:'String',s:talk,toomuch:1}
                }
            }
        }
        Rs&geolen = len
    }
    
   // f modulat
    # tally R%M**c&s
    me.measure_modulat = &acgtN{
        $len = 0
        $leny = &sd{
            if (ss&geolen != null) {
                # memo %geolen
                len += ss&geolen
                d and d.not = 1
                return
            }
            if (sc&not) {
                d and d.not = 1
                return
            }
            isst(sc&s) || num(sc&s) and len += (''+sc&s).length
        }
        !isar(N) and N = [N]
        each in N {
            ns&z && ns&z.length and me&ind,n,leny,{cbfirst:1}
            else leny(n)
        }
        
        
        
        
        
        return len
    }
    # structure swallows everything
    me.mirage_eats_modulat = &acgtR,mir{
        $fore = []
        $aft = []
        # hasn't been sorted yet:
        each in Rs&M {
            (ny&cv >= 0.6 ? aft : fore).push(n)
        }
        Rs&M = []
        $fo = me&fiu,mir,'mirmod0'
        $af = me&fiu,mir,'mirmod1'
        fos&z = fore
        foy&cv = 0.03
        foc&sortcv = 1
        afs&z = aft
        afy&cv = 0.77
        afc&sortcv = 1
        
        # further R%M/* are redirected into af/*
        Rs&Msink = af
        
        
        return [fo,af]
    }
   
   // mirage modulat rejigs
    me.sfx_mirage = &acgtRN{
        # begins as one long wrappy line
        # C.*(.*)? tend to share lines
        $p = Ry&up
        $inlineable =
            Rs&inlineable
            || p && ps&inlineable
        # < group for type division, length good
        # < keep order of C.*, arrays?
        $landscape = !inlineable
            && (Rs&geolen > 64
                # < maybe not:
                || 0 && N.some(n => ns&inline))
      
      // group onto lines[]
        $aline = 0
        $lines = [[]]
        $newline = &{
            lines.push([])
            aline = 0
        }
        $put = &r{
            lines.slice(-1)[0].push(r)
            !num(rs&geolen) and debugger
            aline += rs&geolen
        }
        $la
        $starts_inline = 0
        each ir N {
            i *= 1
            if (Rs&inlineable && i == 0) {
                # C 
                starts_inline = 1
                # suppose R modulat is of t
                aline += Rs&geo.self
                # then try to place y across from it:
            }
            # put sequences %inline+ on its own line
            $inlining_bound =
                la && (las&inline && !rs&inline
                    || !las&inline && rs&inline)
            
            if (inlining_bound || rs&rowy) {
                newline()
            }
            elsif (rs&inline) {
                # any amount of %inline+ on a line
                !la and starts_inline = 1
            }
            elsif (landscape || aline + rs&geolen > 32) {
                newline()
            }
            put(r)
            la = r
        }
      
      // further?
        # leaves whatever fits on a line
        # < convenient way to wrap R/* though
        $p = Ry&up
        hak(lines) == 1 and starts_inline = 1
        !inlineable && hak(lines) <= 1 and return
      
      // C:Miraging/$lines/$t%zuct=$r
        # and make so
        # < after all. aboves may try to re-lineout
        #   with less
        #  
        $mir = Rs&geo.mir = Cye(['Miraging',1])
        miry&up = C
        miry&lineser = mir
        $eei = 0
        each il lines {
            !hak(l) and continue
            $isinline = starts_inline && i == 0
            i /= 10000
            $al = me&fiu,mir,'aline'+i
            als&dis = 1
            als&line = 1
            als&miragia = 1
            als&geolen = 0
            each ir l {
                $it = me&fiu,al,'miragee'+eei++
                itc&zuct = r
                its&item = 1
                its&miragia = 1
                # style later
                its&geolen = rs&geolen
                als&geolen += its&geolen
            }
            isinline and als&dis = 2
            
            if (isinline && ps&inlineable) {
                # C.*.* inline doesnt indent
            }
            else {
                als&ml = 1
            }
        }
       
      // C:Miraging sfx
        # C.*.* space
        if (ps&inlineable && hak(lines) > 1) {
            # the c { several lines of c }
            # < o $mir/**%gee
            # if all of a casual size
            $toowide = Rs&geo.self > 9
                || mirs&z.some(al => als&geolen > 32)
            if (!toowide) {
                $fa = Rs&geo.fa = me&mirage_eats_modulat,R,mir
                s&dis = 3
                $lines = grepout(mirs&z,n => ns&line)
                # this is now where the lines are
                $gu = miry&lineser = me&fiu,mir,'mirguts'
                gus&miragia = 1
                gus&z = lines
                lines.map(al => delete als&ml)
                me&ioty,mir .map(&n{
                    ns&va = 1
                    ns&dis = 4
                })
            }
            
            # c { longline, shortline } redistribution
            me&Topping_474,R
        }
      
      // finally
        
        # effects re %line/%item positions
        me&Topping_477,R
        
        $eei = 0
        me&indo,mir (&sd{
            if (d.d == 2) {
                if (sy&cv == 0.1) {
                    sy&cv = dec(0.59+(eei++*0.0001))
                }
                ac(R,'M',s)
            }
            ss&item and me&zuct,s,sc&zuct
        })
    }
    
    # < the partitioning problem
    #   also putting any r%RX|toomuch on edges, for expansion
    #   the short, long, short -> medium, long
    #   divide by type, various levels
    #    the=many=things=1
    #   and an overall botheration
    #    resist reordering until really worth it
    #   C.* space:
    #   wanting c, sc on a line
    #    even if it means making more shorter lines
    #     up to a point...
    me.Topping_474 = &acgtR{
        $mir = Rs&geo.mir
        $gu = miry&lineser
        # the order of **%item
        $original = me&ioty,gu,['','']
        $lines = me&ioty,gu
        
        $sized = vsortz(lines.slice(), r => rs&geolen)
        $big = sized.pop()
        # biggest line with multiple items
        while (hak(bigs&z) <= 1) {
            big = sized.pop()
            !big and return
        }
        $small = sized.shift()
        !small and return
        $variance = bigs&geolen - smalls&geolen
        variance < 9 and return
        
        $later = lines.indexOf(small)
            > lines.indexOf(big)
        $eat = me&ioty,big
        later and eat.reverse()
        each in eat {
            # leaves the big line too small
            $pointless = (smalls&geolen + ns&geolen)
                - (bigs&geolen - ns&geolen) > 9
            pointless and continue
            # move it
            grepout(bigs&z,n)
            later and smalls&z.unshift(n)
            else smalls&z.push(n)
            smalls&geolen += ns&geolen
            bigs&geolen -= ns&geolen
            bigs&geolen - smalls&geolen > 9 and continue
            break
        }
        
        # the order of **%item
        $same = 1
        $now = me&ioty,gu,['','']
        each in now {
            original[i] != n and same = 0; break
        }
        if (!same) {
            original = joint(original.map(n => nc&zuct.t),',')
            me&Ri,{mirage:'reorder',s:'⇆',original}
        }
    }
    # style based on position in *%lines/*
    me.Topping_477 = &acgtR{
        $mir = Rs&geo.mir
        $gu = miry&lineser
        each li,al gus&z {
            $lis = hak(als&z)
            lis == 0 and debugger
            $many = lis > 1
            each i,it als&z {
                $last = i == lis-1
                !its&item || !itc&zuct and debugger
                $r = itc&zuct
                $rC = rs&C
                if (many && !last) {
                    its&mr = 0.5
                    Rs&inlineable and its&mr = 1
                }
                rCs&dis ||= 2
                !many and rCs&dis = 1
            }
        }
    }
  
  
 // The things
  // &Ri|o - magic-aware brack...
    # < brack at e, then give it to R when alive, or always on E?
    me.Rioing = &acgtr{
        $args = [...arguments].slice(4)
        isR(r) and args.shift()
        else r = 0
        R = r || me&R
        $c = {R,args}
        return c
    }
    # for &Ri,'limit:ref' -> &ha,... + R%limit=[]
    me.magic = {}
    me.magic.layout = {}
    me.magic.limit = {}
    me.magic.toomuch = {}
    me.magic.RX = {}
    me.magic.mirage = {later:1}
    me.Ri = &acgt{
        $c = me&Rioing,...[...arguments].slice(4)
        $n = me&ha,c.R,...c.args
        each kv n.sc {
            me.magic[k] and ac(R,k,n); break
        }
        return n
    }
    me.Ro = &acgt{
        $c = me&Rioing,...[...arguments].slice(4)
        $N = me&ja,c.R,...c.args
        return N
    }
    me.Roo = &acgt{
        return me&Ro,...[...arguments].slice(4) || []
    }
  // &Rthingo, show %%limit|toomuch...** etc
    # capsule, filler for %limit|%toomuch|...
    # < c.notes going to sym%title
    # < togcon port
    # defer to %limit if the only
    me.Rthingo = &acgtRc{
       // 1
        $C = Rs&C
        c.N ||= me&Ro,c.t
        # plant in R, otherwise T.Mw=overthingo
        # < Rthingos using &boxcap, avoid talk of Mw
        #   your m gets my&up=over-thingo? my&up.c.thing = c.up,
        !c.up and T.Mw = c.t
        
        # < arrive togcon
        c.do1 and c.do1(c)
        if (hak(c.N) == 1) {
            $n = c.N[0]
            ns&notonly && lt(c.ov,1) and return
        }
        # group by the %%limit
        # < later, so do18 may mess with c.N?
        $h = partN(c.N,n => n.sc[c.t])
        
        # < group by the next most groupey thing,
        #    this is probably the less groupey:
        h.one && c.up and h = partN(c.N,n => n.sc[c.up.t])
        $sublated = N => hak(N.filter(n => ns&sublated))
        me&hall,h.vs,sublated and c.ov ||= 0.01
        
        
        c.ov ||= 0.2
        sz(c.ov,0.1) and return
        
        # make capsule here
        $li = me&tc,c.t+'-cap'
        liy&cv = c.cv && scaf(c.cv) || 0.132
        delete lic&s
        $hu = (""+liy&cv).substr(-1)
        me&walls,li,'bd:1.4,hu:'+hu
        
        # move into it
        $lip = T.Mw
        if (isC(lip) && lipc&thing) {
            liy&up = lip
            lis&title = lipc&thing.t+'/'+c.t
        }
        else {
            # toplevel thingo
            ah(R,'thingo',c.t,li)
        }
        lic&thing = c
        T.Mw = c.li = li
        
        # sym
        if (c.sym) {
            $re = c.re = me&tc,c.t+'-sym',c.sym,c.symc||'b'
            rec&s = c.sym || ""
            res&fs = 17
            res&lh = 0.3
            liy&sym = re
            res&title = lis&title || c.t
        }
        
        
        c.do18 and c.do18(c,li,re)
        sz(c.ov,0.2) and return li
       // 2 rows
        each it h.ks {
            $N = h.vs[i]
            T.Mw = li
            hak(grepout(N,n => ns&sublated)) and continue
            # call $magicword/$ghostkey
            #  names are minds, have time
            $tc = {t,up:c,N}
            if (me&mecy,['R',c.t,'o_',t],R,tc ) {
                # only that unless opened
                sz(c.ov,0.3) and continue
            }
            T.Mw = li
            $talk = c.t+": "+t
            $t = me&tc,talk,t,'b'
            
            $sup = N.filter(n => ns&super)
            hak(sup) and me&tc,'super-','*','y'
            
            # say this
            $n = hak(N) && N[0]
            if (n && ns&s != null) {
                # see %toomuch_shouldcount, similar look
                ts&fs = 8
                tc&s = ns&s
            }
            
            # < conjoin a brackology here,
            #   having already stated toomuch:not
            ts&title = talk+" "+dis(N[0].sc)
            N[1] and ts&title += "\n    "+dis(N[1].sc)
            hak(N) > 2 and ts&title += "\n   + "+(hak(N)-2)
        }
        
        # is also T.Mw - where &tc will be put
        return li
    }
    # venn thingos inside each other
    me.thingodoptible = &acgtRtl{
        $c = lc&thing
        # thingos unpack when openish
        !lt(c.ov,3) and return
        if (t == 'up') {
            # way to hide a sub-thingo
            $into = c.up.li
            !into and debugger
        }
        else {
            $into = ahsk(R.sc,'thingo',t)
            !into and return
            me&modopt,R,into,l
        }
        # in-thing @18 might just conjoin symbol title
        !lt(c.ov,2) and return
        $re = ly&sym || l
        $ie = intoy&sym || into
        !ies&title and debugger
        !res&title and debugger
        $lines = res&title.split("\n")
        ies&title += "\n+ "+lines.shift()
            +"\n"+lines.map(s => "  "+s).join("\n")
        lc&not = 1
        
    }
    # flatten modulat to D%$sym=modc&s+
    # < generalise string accumulator?
    #    bracket multiple subthingos?
    me.Rthingo_toD = &acgtR{
        $E = Rs&E
        $D = Rs&D
        $h = {}
        $haves = &ks{
            $M = h[k] ||= []
            s != null and M.push(s)
        }
        each tg Rs&thingo {
            # D%$name=... can be a symbol
            $name = "⛔"
            t != 'limit' and name += t
            me&indo,g,{name} (&sd{
                # layout-cap may not
                #  eg ^-Cish implies y ~:dim < ⇃
                #  otherwise the RX-cap here   ^
                #   may vanish if it was only (layouty) (see &TXin)
                s.c.not and return d.not = 1
                
                s == d.promoted and return
                if (sc&thing && sy&sym) {
                    # subthing
                    $z = sy&sym
                    !isst(zc&s) and debugger
                    # dont visit sym
                    d.refs.push(z)
                    $was = d.promoted
                    if (was) {
                        # already in something promoted
                        #  append sym
                        # < more ()ing?
                        haves(d.name,zc&s)
                    }
                    else {
                        # promoted to h/$sym
                        d.promoted = 1
                        d.name = zc&s
                        # ensure layout-sym '~'
                        #  if unkeen-cap ('<') is c&not
                        #   < as implied by %Cish?
                        # also an ~ will not appear on anything being empty
                        # < however, Lol/figaro/y should maybe have ♲
                        #    or we are implying it's a new .y={} since then
                        # < a C with ♲:^/fer should be /* nothing
                        #    if not being, trusting a previous self
                        #    need a way to indicate being empty
                        #  < calling it a self|other referer
                        #     when same|diff encoding (eg %Pier=hat)
                        #    needs to have equivalent in|out of time
                        # < these are bugs in Stories/TryPiWarmer-1
                        haves(d.name,null)
                    }
                    return
                }
                
                if (hak(s.c,'s')) {
                    haves(d.name,sc&s)
                }
            })
        }
        each kM h {
            D.sc[k] = hak(M) ? M.join(" ") : "1"
        }
    }
  
  // %%RX, %%layout
    # what arrives there
    me.RRXo = &acgtRc{
        $c = {t:'RX',sym:"⇃"}
        c.do18 = &c,li,re{
            $M = c.N.map(n => ns&aq)
            
            # icon flavours:
            # no further pointing
            !M.some(aq => aqc&TX) and rec&s = '⥙'
            $layouty = !M.some(aq => !aqs&layout)
            if (!layouty) {
                # glow label
                # < effect At@101, t@12 etc based on match
                me&modselect,R,{modt:'Pier',t:'At'}
                    .map(t => ts&sha = '3 3 3 999')
            }
            
            each i,aq M {
                $ti = aq.t+"%"+dis(aqs&qua)
                res&title += "\n"+ti
            }
            # < -Bet open, expand elvising trace
            lt(c.ov,3) and c.ov = 0.18
            
            if (layouty) {
                res&bri = 0.7
                res&title += ' (layouty)'
                me&thingodoptible,R,'layout',li
            }
        }
        me&Rthingo,R,c
    }
    # how there is styled
    me.Rlayouto = &acgtRc{
        $c = {t:'layout',sym:"~"}
        c.do18 = &c,li,re{
            delete res&fs
        }
        me&Rthingo,R,c
    }
    # %layout:dim
    me.Rlayouto_dim = &acgtRc{
        c.do18 = &c,li,re{
            grepout(c.N,&n{
                return me&honly,n.sc,{has:{layout:'dim'}}
            })
        }
        me&Rthingo,R,c
        lt(c.ov,3) && !hak(c.N) and c.ov = 0.18
        me&thingodoptible,R,'up',c.li
        return 1
    }
    # unkeen: pagination, being an intended toomuch
    me.Rlayouto_unkeen = &acgtRc{
        ex(c,{sym:"<"})
        c.do18 = &c,li,re{
            # usu !E
            $blockE = c.N.filter(n => me&hal,n,'toomuch,E')
            if (hak(blockE)) {
                $bunch = joint(blockE.map(n => ns&E),',')
                res&title += " !E["+bunch+"]"
                # are sublated, unless we open
                lt(c.ov,3) and grepout(c.N,blockE)
            }
            lt(c.ov,3) and c.ov = hak(c.N) ? 0.2 : 0.12
            # %%layout,toomuch,E
            # accumulates to R%layout but not R%toomuch
            #  it is not quite %%toomuch,
            #   since %impl are compressions,
            #    eg don't visit C.t+.y.cv since %Ctitle says it
            #    < -isR may impl .y.R, and -isJ .y.1
            #   and ope<0 are purposeful exclusions
            #    < dim could make small limit:many
            #      become a less important unkeen
        }
        me&Rthingo,R,c
        me&thingodoptible,R,'up',c.li
        
        return 1
    }
  
  // %%toomuch, %%mirage
    # @67 assigns signage about being R%toomuch**
    me.Rtoomucho = &acgtRc{
        $c = {t:'toomuch',sym:"⦄",cv:76}
        
        c.do1 = &c{
            $sugov = 0
            
            # the %limit magic may reduce %toomuch-ness to sym
            $known = &n{
                # only limit caused toomuch
                return me&hal,n,'limit,toomuch'
                    # toomuch caused only Eing stoppage
                    || me&hal,n,'toomuch:limit,E'
            }
            $simple = me&hall,c.N,known
            simple and sugov = 0.1
            
            # toomuch caused Eing stoppage
            $blockE = c.N.filter(n => ns&E)
            if (!hak(blockE)) {
                # didnt cause any Eing stoppage
                simple and sugov = 0.01
                c.do18 = &c,li,re{
                    res&fs = 9
                }
            }
            else {
                $bunch = joint(blockE.map(n => ns&E),',')
                if (Rs&Cish) {
                    simple && bunch == 't,y,c,sc' and sugov = 0.01
                }
                else {
                    c.do18 = &c,li,re{
                        $cou = me&tc,'!E-count','b'
                        couc&s = hak(blockE)
                        cous&fs = 8
                        cous&ml = -0.2
                        res&title += " !E["+bunch+"]"
                        if (Rs&toomuch_shouldcount && c.ov <= 0.2) {
                            #rec&not = 1
                            delete res&fs
                            cous&title = cou.t+' '+res&title
                        }
                    }
                }
            }
            
            sugov and c.ov ||= sugov
        }
        me&Rthingo,R,c
    }
    # note geometry
    #  similar to toomuch !E-count
    #   the mirage_shouldcount
    #  wants to eat %%length, %%lines, %%paragraphs...
    # make geometry
    #  scoop everything else into something
    me.Rmirageo = &acgtRc{
        $c = {t:'mirage',sym:"⦆",cv:78}
        c.do18 = &c,li,re{
            delete res&fs
        }
        me&Rthingo,R,c
    }
    
  // %%limit (ref)
    # cultivate R %%limit:(ref|dl|nl|...)
    #  adding %toomuch stops E**
    #   an acute case of dimming light, ending thing
   // incur
    # @12
    me.Rlimiti = &acgtR{
        $C = Rs&C

        $s = Rc&s
        if (s && typeof s == 'object' && !Rs&noref) {
            # soft dup limit, sets Rc&nofurther=1
            me&Rlimiti_ref,R,s
        }
        # sprawl limits
        # < find bunch of these at a thing, to %TX anti-dl
        if (Rc&dl && Rc&dl < Rc&d) {
            me&Ri,{limit:'dl',toomuch:1}
            #return
        }
        if (Rc&nl && Rc&N && Rc&nl < Rc&N.length) {
            me&Ri,{limit:'nl',toomuch:1}
        }
        return 1
    }
    # realises where $s was before
    me.Rlimiti_ref = &acgtRs{
        # on Ec&top %X
        $tE = Rc&top.sc.E
        # previous mentions of it, nearest first
        $c = me&Ereflookup,{E:tE,s,R}
        # without being %toomuch or != $pi
        me&Rlimiti_ref_lookfor,R,c
        
        # any previousness causes some R%limit...
        if (c.any) {
            # the case for
            $lim = {limit:'ref',Erefc:c}
            # linkably close self, no more E/e
            c.near and lim.toomuch = 1
            me&Ri,lim
        }
        
        # note this time
        #  effectively a &pio to many places
        $x = fi&EXsim,tE,{ref:s},{n:R}
    }
    me.Rlimiti_ref_lookfor = &acgtRc{
        # find:
        #  other with any expression, even tiny|limited|other-$pi
        #  self with full writeup, same $pi
        #   which we can use to diff against
        #    using leftover slepparatus from its typing up
        #   or %limit.same as it
        $E = Rs&E
        each ig c.got {
            $r = g.n
            $e = rs&E
            # find the last
            # < many %%limit,Erefg,qua until satisfied
            #   iterating Ereflookup
            if (ec&pi != Ec&pi) {
                c.other ||= g
            }
            # note we only r%$magicword the first
            # so %%layout,toomuch,E can not count
            elsif ( rs&toomuch || Rs&tiny ) {
                c.almost ||= g
                # find a fuller further rendition
            }
            else {
                # this is the previous this
                c.self ||= g
                break
            }
        }
        # almost always -> self
        if (c.almost) {
            # even a partial do-over is self here
            # < Self, where lines are traced back
            # ! while we &PiRet 12, pre-Ringing
            #   this modulat goes into the above R
            !c.self and me&Ri,'limit:ref,oddity:no-full'
            c.other = c.almost
            #throw "no finding full thing"
        }
        # care
        if (c.self) {
            $g = c.self
            # can only gain c.near
            # assume $s** still per eg -log, %Top
            $sameTop = me&ifsuchsame,'Top',g.ups,g.downs
            sameTop and c.near = 1
            else {
                # out of time from here, climb data again
                # < know light cones provided by &Rsci
                # < slep or c.redraw
                #   which regen X, patchey D** with previous
                #c.redraw = 1
            }
        }
        c.any = c.self || c.other
    }
   // outsummation
    # @67 assigns signage about R%limit**
    me.Rlimito = &acgtR{
        $l = me&Rthingo,R,{t:'limit',cv:13}
    }
    #  ♲ ref
    me.Rlimito_ref = &acgtRc{
        me&Rthingo,R,ex(c,{sym:"♲",ov:0.12})
        Rs&tiny and c.ov = 0.11
        $li = T.Mw
        $re = liy&sym
        # limit:l/ref:n
        # &Ereflookup c via selection
        grepout(c.N,n => ns&oddity).map(&n{
            res&title += "("+ns&oddity+")"
            me&tc,"oddities","!",'6g'
        })
        $n = theone(c.N)
        $Erefc = ns&Erefc
        
        $types = ['self','other']
        $any = 0
        types.map(&k{
            $g = Erefc[k]
            !g and return
            any and return
            any = 1
            
            $r = g.n
            # < ups~downs over an area
            $location = me&Eref_got_pointer,g
            # fuller description as tooltip
            res&title += " "+k+":"+location
            
            # compress contiguations
            #  when as above, plus the same t
            # < exceptions want exclaiming -hat
            #   when we replace n.*.* to get attention
            $pc = me&jaa,Ry&up,{Erefc:1,limit:'ref'},1 [0]
            $pg = pc && pc[k]
            if (pg) {
                $wasdowns = g.downs.slice()
                $newdown = wasdowns.pop()
                if (heq(wasdowns,pg.downs) && newdown.t == r.t) {
                    # we C%limit/y%limit, just symbol
                    c.ov = 0.11
                }
            }
            sz(c.ov,0.12) and return
            
            $te = me&tc,location
            
            tes&deco = 1
            tes&hs = k == 'self' ? '999' : '888'
            tes&fs = 7
        })
        !any and me&tc,'!any'
        
        # change to c.ov < 3, 3 if auto 0.3
        sz(c.ov,0.12) and return 1
        
        $total = hak(c.got) + 1
        if (total > 2) {
            $says = total
            $talk = 'x'+says+', ...'
            me&tc,talk,says,'7y'
        }
        return 1
    }
  
  // %%other
   // < R%strange/** @2 # schema goes
    me.strange = &acgts{
        $R = me&R
        me&tc,s,'b'
        ac(R,'strange',s)
    }
    # r and r/*
    me.anystrange = &acgtR{
        R ||= me&R
        $ness = r => rs&strange
        ness(R) || me&ioR .some(ness) and return 1
    }
    
   // < R%c/** @3 # machine talk
    me.attendios = &acgttc{
        $R = me&R
        $E = Rs&E
        c.E ||= E
        c.path = me.cby(c.E,E => Ec&top)
        ac(Rc&top,t,c)
    }
  
  // misc f
   // &Rsci
    # c.t may say $t-$pi%qua
    me.t_tpi = &acgtc{
        $tpi = c.t.match(/^(.*)-(\w+)(.*?)$/)
        if (tpi) {
            c.t = tpi[1]+tpi[3]
            c.pi = tpi[2]
            if (c.t == '') {
                # may s.y.$pi
                # or $s/$pi
            }
        }
        $tgk = c.t.match(/^(.*)%(\w+)(.*?)$/)
        if (tgk) {
            c.t = tgk[1]+tgk[3]
            c.gk = tgk[2]
            if (c.t == '') {
                # may $s/*%qua
                # or $s%qua=C:qua
            }
        }
        
        return c
    }
    me.Rsci = &acgtscq{
        c ||= {}
        $R = c.R || me&R
        isst(s) and s = {path:s.split('/')}
        !s and s = {path:[]}
        c.gk and s.path.unshift('%'+c.gk)
        $putsz = hak(c,'s') || hak(c,'n')
        
        $z = c.v || R
        $last = hak(s.path)-1
        each it s.path {
            !isst(t) and debugger
            $tc = me&t_tpi,{t}
            t = tc.t
            $gk = tc.gk
            $pi = tc.pi
            
            $v
            pi and t ||= pi
            gk and v = z.sc[gk]
            # < bal Rc&s/$v, for c.R%ball
            #   or schedule|other nearby y&R
            else v = me&fiu,z,t,c.el
            
            # i %limit/%toomuch=1 or &Rli,'toomuch',{s:1}
            $puts = putsz && i == hak(s.path)-1 && hak(c,'s')
            $putz = putsz && i == hak(s.path)-1 && hak(c,'n')
            if (putz && v) {
                if (gk) {
                    !isar(v) and throw "putz!ar"
                    if (c.el == 8) {
                        # o $l%somegk/$n tests for $n in %somegk
                        #  ie &Rti,'limit/%somegk',{n:e}
                        # returns the /$n as array
                        return me&Rscin,s,c,q,v && v
                        # if !v it may also fail @el==8:
                    }
                }
            }
            if (!v || (puts || putz) && gk) {
                c.el == 8 and return
                !gk and throw "never happens: &fiu creates el<8"
                
                if (puts) {
                    puts = 0
                    v = c.s
                }
                elsif (putz) {
                    v ||= []
                }
                else {
                    v = Cye([gk,2])
                }
                z.sc[gk] = v
            }
            if (isC(v)) {
                # care
                if (R == z) {
                    gk and vy&R = R
                    else {
                        # < bal Rc&s/$v
                    }
                }
                if (pi) {
                    !vc&pi and vc&pi = pi
                    vc&pi != pi and return
                }
                if (puts) {
                    puts = 0
                    vc&s = c.s
                }
                elsif (putz) {
                    putz = 0
                    $vz = vs&z ||= []
                    # returns the last C the /$n is in
                    #   $z:thing/%bunch:v/$n=stuff
                    return me&Rscin,s,c,q,vz && v
                    # < conserve/score?
                }
            }
            if (putz) {
                !gk and throw "never happens: isC putz"
                putz = 0
                # returns the /$n as array
                return me&Rscin,s,c,q,v && v
            }
            !v and return
            z = v
        }
        return v
    }
    # v=[] for /$n-ism, adding|finding c.n
    me.Rscin = &acgtscqv{
        if (c.el == 8) {
            if (isar(c.n)) {
                # has a list
                $all = 1
                $any = 0
                each in c.n {
                    v.includes(n) and any = 1
                    else all = 0
                }
                c.all && !all and return
                !any and return
                return 1
            }
            else {
                v.includes(c.n) and return 1
            }
        }
        else {
            if (isar(c.n)) {
                # < distribute in between includes
                each in c.n {
                    !v.includes(n) and v.push(n)
                }
            }
            else {
                !v.includes(c.n) and v.push(c.n)
            }
            return 1
        }
    }
   // slope
    # proper R/*
    me.ioR = &acgtr{
        $args = [...arguments].slice(4)
        isR(r) and args.shift()
        else r = 0
        R = r || me&R
        return me&ioty,R,...args
            .filter(r => me&Risreal,r )
    }
    me.Risreal = &acgtr{
        # < tends not to happen nowadays
        return rc&N.includes(r) && !rc&not
    }
    me.Rnodepath = &acgtR{
        # < rowing for...
        $N = me.cby(R,R => Rs&ball && Rc&s.y.path)
        $p = N.shift()
        # &inode puts a:
        $path = p && pc&s.y.path
        
        return joint(path,'/')+'//'+joint(N,'/')
    }
    me.ifsuchsame = &acgtkNM{
        $first = N.filter(r => r.sc[k])[0]
        return !first || M.includes(first)
    }
   // data
    # 0.33 = scv(33), with floating points (gets floaty at precision=17)
    # < collect cv type functions, eg is opposite of numf(0.33)
    self.scv = &ov,{
        return dec(sca(ov),15)
    }
    self.gteqcv = &vc{
        v ||= 0
        return (c.gte == null || v >= scv(c.gte))
             && (c.lte == null || v <= scv(c.lte))
             && (c.gt == null || v > scv(c.gt))
             && (c.lt == null || v < scv(c.lt))
             && (c.cv == null || v == scv(c.cv))
    }
    # (qua||0) < 2 and leave
    # sizes something, usu ope|interest for snoozing
    self.lt = &lt{
        t > 1 and t = '0.'+t
        return sz(l,t)
    }
    self.sz = &ns{
        isob(n) and throw "pass value||null"
        return (n || 0) < s
    }
   // data situations
    # match s=sc strictly against c={has:{limit:t},may:{toomuch:1}}
    me.honly = &acgtsc{
        each kv s {
            c.has && (c.has[k] == 1 || c.has[k] == v) and continue
            c.may && (c.may[k] == 1 || c.may[k] == v) and continue
            return 0
        }
        each kv c.has {
            !hak(s,k) and return 0
        }
        return 1
        
    }
    me.hall = &acgtNy{
        each in N {
            !y (n) and return 0
        }
        return 1
    }
    me.hany = &acgtNy{
        each in N {
            y (n) and return 1
        }
        return 0
    }
    # match brack row with order
    me.hal = &acgtnc{
        c = peel(c)
        # check it has them
        each tv c {
            !hak(n.sc,t) and return 0
            v != 1 && n.sc[t] != v and return 0
        }
        # check order
        $ks = haks(c)
        each kv n.sc {
            !hak(c,k) and continue
            $be = ks.shift()
            be != k and return 0
        }
        return 1
    }
    # compose (concat l) name for and call me function
    me.mecy = &acgtl{
        $y = me[l.join('')]
        !y and return
        return y && y (A,C,G,T,...[...arguments].slice(5))
    }
   
   // partN()
    # hash partition array by return value of y(n)
    # returns {ks:[keys],vs:[values]}
    #  because of how javascript (v8) stores properties & elements
    #  things that look like indices of elements will come first
    #   eg assigning -2,-1,0 iterates 0,-2,-1
    #  ! anywhere we rely on hash key order might be affected
    # see also &sortulat
    self.vpartN = &Nyc{
        return partN(N,y,ex({vsort:1},c||{}))
    }
    self.partN = &Nyc{
        c ||= {}
        $h = {}
        $ref = []
        $refs = []
        # bunch of naming and N
        #  of -Eel Xc - point naming particles...
        $bund = []
        each in N {
            $k = y (n)
            if (isob(k)) {
                $v = k
                # lifted from Fish &Xsim c.array
                # index objects in an array
                $vi = refs.indexOf(v)
                if (vi < 0) {
                    vi = refs.push(v)-1
                    bund.push({i:vi})
                    ref[vi] = []
                }
                # < could pile up next $i
                #   for seq looking
                ref[vi].push(n)
            }
            else {
                if (!h[k]) {
                    bund.push({t:k})
                    h[k] ||= []
                }
                h[k].push(n)
            }
        }
        # structure for definitely ordered keys
        # < inc order of the above asignment, with no sort
        $a = {ks:[],vs:[]}
        # we would only sort by non-objects
        #  add 0 onto defor args for partitioning by null
        c.vsort and vsortz(bund,Xc => defor(Xc.t,0))
        each i,Xc bund {
            if (Xc.t == null) {
                # keyed by object
                $k = refs[Xc.i]
                $N = ref[Xc.i]
            }
            else {
                $k = Xc.t
                $N = h[Xc.t]
            }
            a.ks.push(k)
            a.vs.push(N)
        }
        a.vs.length == 1 and a.one = 1
        # curve, etc
        return a
    }
    
   // C stackups
    # dedupe same t
    # < accept t=c with .t, strat for The $n++
    me.dupfiu = &acgtEt{
        t = t+''
        !t.length and debugger
        $du = me&fiu,E,t,8
        if (du) {
            duc&dupfiu ||= 1
            t = t+' '+(++duc&dupfiu)
            $du = me&fiu,E,t,8
            du and throw "dupdup"
        }
        $d = me&fiu,E,t
        return d
    }
    # limitor: maintains an infinite list
    me.Nserial = &acgtNc{
        # assign serial numbers, continuing from last
        c.nk ||= 'sc'
        c.back = reverse(N)
        c.serial ||= 0
        c.neu = []
        each ie c.back {
            $Bati = e[c.nk][c.gk]
            Bati != null and c.serial = Bati; break
            c.neu.unshift(e)
        }
        each ie c.neu {
            e[c.nk][c.gk] = ++c.serial
        }
        # length limit
        while (c.ll && hak(N) > c.ll) {
            N.shift()
            c.back.pop()
        }
        return c
    }
    
   // modulat!
    # select ground 102-14 for name (6), 11 for sym (1)
    me.modselect = &acgtRc{
        c ||= {}
        # < mix down modulat into Rs&M anytime?
        me&modulatM,R
        $N = Rs&M
        1 and 1
        else {
            $N = []
            Rs&M and N.push(...Rs&M)
            # < code: havs(Rs&Mw)->havs->N
            #    auto havs($_)
            # < io: i N o R/%Mw/*/*/$v
            # < io: i havs(Rs&Mw)->havs->N
            each kin Rs&Mw {
                N.push(n)
            }}
        }
        # select what
        $M = N.filter(&n{
            return gteqcv(ny&cv,c)
                && (c.modt == null || c.modt == ns&modt)
                && (c.t == null || c.t == n.t)
                && (c.y == null || c.y (n))
        })
        if (c.el == 9) {
            # wont become R:Display
            M.map(n => nc&not = 1)
        }
        vsortz(M)
        return M
    }
    me.moddelete = &acgtRc{
        c.el = 9
        return me&modselect,R,c
    }
    # mix down R%Mw.$dome.* -> R%M.*
    # see '// f modulat' of mirage
    # periodically R%M <- R%Mw/T.act.t|$dome/$modulat**
    me.modulatM = &acgtRc{
        !Rs&Mw and return []
        $M = (Rs&M||[]).slice()
        $since = hak(M)
        each win Rs&Mw {
            # usu T.act.t, or T.Mw='such'
            ns&modt = w
            M.push(n)
        }}
        if (c) {
            # spatialises, on tv
            # < not til Mirage-ish time
            me&cvdeal,M
        }
        delete Rs&Mw
        Rs&M = M
        # new since
        return Rs&M.slice(since)
    }
    # s='['
    # < %bracket?
    me.modbracket = &acgtsv{
        $abracket = &tsv{
            $be = me&tsc,t,s,''
            v and bey&cv = scv(v)
            bes&label = 'bracket'

        }
        abracket('begin',s,v||23)
        $end = s == '[' ? ']'
            : s == '{' ? '}'
            : '</'+s+'>'
        return &{
            abracket('end',end,77)
        }
    }
    me.modelta = &acgt{
        $R = me&R
        $start = Gtime()
        return &{
            $delta = Gtime(start)
            me&tc,"~"+delta,'b'
            start = Gtime()
        }
    }
  
  
 // R'The'
 
    me.Pi_The = &acgt{ return [
   ... me&Pi_Lab ,
   ... me&Pi_Pier ,

   // site office
    ['Fez',0.66,&acgtRs{
        $E = Rs&E
        $ups = me.cby(R).slice(-4)
        $hert = joint(ups,'/')
        R.t != "awoke" and return
        # < &hu could increase dl if nl is very low
        # < should be getting %indim here and lowering
        if (hert == '0/r/c/X') {
            #me&tc,"HERE"
            #me&hu,"Thinkab",{p:Ry&up,R},{dl:6}
        }
        #debugger
        me&tc,"U:"+hert,'6y'
                #T.oncily ||= 1
                #$found = a.ref == 'tothings' && T.oncily++ < 2
                #found and me&nu,"ref-find!",{Y,ref,Sarg:T.Sarg,a}
    },'ift,D'],
    # looking at their thingoes
    ['hat+Top',0.68,&acgtRs{
        $E = Rs&E
        #E.t != 'Bowler' and return
        $N = Rc&N.filter(r => rs&interux).slice(0,5)
            .map(&r{ return {r,th:rs&interux} })
        # < why too late to do any of this:
        #me&hu,"thingoes",N
        #me&tc,"hereth" .sc.fs = 39
        #me&modulatM,R
        #Rs&lookat = N
    },'ift,D'],

   // -Bat events
    # many e
    ['Bat+V',0.3,&acgtRs{

        # outsphere (s of R%TheTt)
        $V = Rs&V
        $D = Rs&D
        $E = Rs&E
        $pathwithstep = me&climbaboveTheing,R
        $There = pathwithstep[1]
        $top2 = There.t.match(/^The( 2)?$/)
        !top2 and Rc&nl = 500
        me&Battarget,R

        # enables popping events in, waking R%TheTt
        $N = Vy&Todo ||= []
        # < hold any with Ting
        $c = me&Nserial,N,{gk:'Bati',ll:25}
        $latest
        each ie c.back {
            $eB = me&Ei,{t:es&Bati,pi:'Bet',s:e,i,noencode:1}
            latest ||= eB
            c.neu.includes(e) and eBc&el = 2
            # < togs all come from somewhere
            #   this be a click path baked to [0]
            #i == 0 and eBs&ope = 2
        }
        me&Eing,6
        # < select one as above.
        if (0 && top2) {
            me&Ei,{t:'sel',pi:'Spheres',s:latest}
            me&Eing,6
        }

        $N = me&ioR,'Bet'
        $n = me&Ei,{t:'Eel',pi:'Eel',s:N,dl:19}
        me&Eing,6
        # emits what-for
        !ns&aq and me&strange,"E!%aq"
        Vy&TXing = ns&aq
        # what now
        if (Rs&letswake) {
            # < -Ness defference
            $ta = Rs&target
            !ta and me&tc,'!target','G'
            else {
                $node = me.cbu(R,'TheingE')
                me&wants,node,'autoBat',ta
            }
        }
    },'ift,D'],

   //   -Bet event, -Belt slope
    # the e itself
    ['Bet',0.21,&acgtRs{
        $D = Rs&D
        me&walls,C,'bd:3.1'
        # < mutey picture of the C
        $en = me&tc,"e:"+s.t,'g'
        me&walls,en,'b:3.2'

        # qua to deliver, meaning of this event
        Ds&Xsc = {ope:1}
        ahsk(s.c,'mode','C') and Ds&Xsc.ope = -1
        # see -Belt/-Bit%D%Xc

        #   pulling up the sc&tower.N
        $c = sc&tower
        c and me&Ei,{t:'tow',pi:'Belt',s:c.N}
        else me&Ei,{t:'inst',pi:'hat',s,dl:3,noref:1}
    },'ift,D'],
    ['Bet+ope',0.6,&acgtRs{
        $E = Rs&E
        sz(Rs&ope,1) and return
        me&Ei,{t:'sel',pi:'Spheres',s:E}
        me&Eing,6
    },'ift,D'],
    # a slope: $n/$n/$n...
    ['Belt',0.21,&acgtRs{
        $N = s
        !isar(N) and return me&strange,"!array"
        each in N {
            $e = me&Ei,{t:i,pi:'Bit',s:n,noref:1}
            if (ns&miragia) {
                # quiet the miragey, layout containers
                # < undoably
                ec&pi = 'igBit'
            }
        }
    },'ift,D'],
    ['igBit',0.21,&acgtRs{
        Rs&tiny = 1
        Rs&inline = 1
        me&tc,"ignored-Bit:"+s.t,'●','g'
    },'ift,D'],
   //     -Bit of slope, -isX
    ['Bit',0.21,&acgtRs{
        $D = Rs&D
        $E = Rs&E
        $Be = me.cbu(R,'Bet')
        # < /E/X, ark=X being strongly typed -X
        #   R/E/X then are arks, wideness
        #    at one point along the -Belt
        $e = me&Ei,{t:'s',pi:'isC',s:s}
        !me&Eing,4 and return
        if (isR(s)) {
            Rs&isR = 1
            # < whittle down, pushing presentation,
            #   to be turned into an entirety if willed...
            #   or just R+E+X in the first -isC minimality
            # once that -isC is ok, spawn further:
            $tE = ss&E
            if (!isC(tE)) {
                $e = me&Ei,{t:'E',pi:'isC',s:tE}
                !me&Eing,4 and return
            }
            $X = tEc&X
            $e = me&Ei,{t:'X',pi:'isX',s:X}
            !me&Eing,4 and return me&strange,"Xnolike"
            # < Ro,e
            $r = ey&R
            $nec = rs&nec
            !nec and me&strange,"!nec"
            if (rs&nec_simple) {
                me&tc,"t-will-do",'t','8y'
                rs&noDisplay = 1
                Rs&inline = 1
                Rs&tiny = 1
            }
            Rs&nec = nec
            $Xc = Ds&Xc = {}
            each ic nec {
                Xc[c.k] = c.v
            }
            if (!rs&nec_simple) {
                me&tc,"gotta:"+dis(Xc),'1q'
            }
        }
        else {
            # modulat, might something?
            Rs&tiny = 1
            Rs&inline = 1
            if (isC(s)) {
                # click titley bits to auto re-The
                ss&label and Bes&clickat = 'title'
            }
        }
    },'ift,D'],
    # R/E/X
    &{
        me.E_neighbours = &acgtE{
            $Ep = Ey&up
            Ep and return me&ioty,Ep
            # out the top of E space:
            $R = Ey&R
            $p = Ry&up
            $N = []
            each in ps&z {
                ns&E and N.push(ns&E)
            }
            return N
        }
        # find the X/* most identifying X amongst N[X]
        me.X_necessary = &acgtXN{
            $M = []
            each kv X {
                k == 'ref' and continue
                k == 'v' and continue
                $sk = k+'s'
                $refs = X [sk]
                !refs and continue
                each iv refs {
                    $found = hak(N.filter(
                        V => V[sk] && V[sk].includes(v)
                    ))
                    M.push({k,v,found})
                }
            }
            $most_iding = vsortz(M,a => a.found)
            $necessary = []
            each ic most_iding {
                necessary.push(c)
                c.found == 1 and break
            }
            return necessary
        }
    },
    ['isX',0.21,&acgtRs{
        if (Rs&refR) {
            # < reimplement as -Bet compiling
            # duplicate, reuse results
            $r = Rs&refR[0]
            !rs&nec and return me&strange,'!nec'
            sex(R.sc,r.sc,'nec,nec_simple')
            return
        }
        # look for the most identifying classifications
        $iE = s.A
        $Bet = me.cbu(R,'Bet')
        $Bit = me.cbu(R,'Bit')
        # amongst its neighbours, even at the outsphere
        $N = me&E_neighbours,iE
        if (!N.includes(iE)) {
            if (iEc&top && iEy&up
                && me&fiu,iEy&up,iE.t,8 ) {
                # where Ey&up becomes persistent (many R per E)
                # we are looking at a past version of E
                # < rowing perspectives for any part of X
                #    inside a past? transaction
            }
            else {
                me&strange,"!N/iE"; me&tc,'iEN:'+joint(N)
            }
        } 

        $NX = N.map(E => Ec&X).filter(X=>X)
        $nec = Rs&nec = me&X_necessary,s,NX
        if (hak(nec) == 1) {
            $ne = nec[0]
            if (ne.k == 't' && ne.v == iE.t) {
                Rs&nec_simple = 1
            }
        }
        else {
            # < boost or !simple:
            me&Ei,{t:'Es',pi:'hat',s:nec,dl:2}
        }
    },'ift,D'],

   //   -Spheres events look
    ['maybrack',0.22,&acgtRs{
        if (ss&X && ss&z) {
            $ve = me&brackology,R,s,{sc:{ope:2}}
            ac(R,'M',ve)
        }
    },'ift,D'],
    # < wants to generalise to CED|RsE walker
    #   the main thing of s=E-Bet becomes the target
    ['Spheres',0.22,&acgtRs{

        $E = Rs&E
        # s is an E-Bet to look at
        $r = sy&R
        !isR(r) || !rs&Bet and debugger
        s != rs&E and debugger

        # look at the e
        if (isC(sc&s)) {
            me&Ei,{t:'e',pi:'hat',s:sc&s,dl:1,rsc_mix:'maybrack'}
        }
        # look at tow-Belt
        $Belt = me&ioty,r,'Belt','tow' [0]
        $Bits = me&ioty,Belt,'Bit'
        $Bit = Bits.filter(r => rs&isR).slice(-1)[0]
        $Y = Bitc&s
        $n = me&Ei,{t:'R',pi:'hat',s:Y,dl:1}
        each kv Y.sc {
            !isC(v) and continue
            $n = me&Ei,{t:k,pi:'hat',s:v,dl:1,rsc_mix:'maybrack'}
        }








        # default D open
        fi&TXi,E,"Dope",{t:'D'},1
    },'ift,D'],

   //   -Eel
    ['Eel',0.21,&acgtRs{

        #me&walls,C,'bd:3.7'
        $D = Rs&D
        $E = Rs&E
        if (Ec&Xc) {
            Rs&rowy = 1
            # non-first -Eels have an Xc to match
            me&Ei,{t:'Xc',pi:'hat',s:Ec&Xc,dl:2,inline:1,noencode:1}

            $EN = me.cby(E,E => !Ec&Xc && -2)
            $p = Ry&up
            $pE = ps&E
            $name = joint(EN)
            # into D%TX...aq
            $aq = fi&TXi,D,"aq:"+name,Ec&Xc
            # onto E%aq
            Es&aq = aq
            # into E^%aq %TX..aq
            pEs&aq and fi&TXi,pEs&aq,aq,Ec&Xc
        }
        else {
            Es&aq = Cye(["Topeel",8])
        }

       // regrouping Bet
        $BitDXc = B => B && Bs&D && Bs&D.sc.Xc
        # next meaningful Belt Bit
        each ir s {
            !rs&Bet and debugger
            $Belt = me&ioty,r,'Belt','tow' [0]
            $Bits = me&ioty,Belt,'Bit'
            # find last position on Belt
            $Belti = (me&ja,Ry&up,{Belti:1,Bet:r},1 || -1)*1 + 1
            while (1) {
                # seek next position with a D%Xc
                $Bit = Bits[Belti]
                !Bit and break
                !BitDXc(Bit) and Belti++; continue
                break
            }
            !Bit and me&ha,R,{done:1,Bet:r}
            else {
                me&ha,R,{Belti,Bet:r,Bit}
            }
        }

        # group by same D%Xc
        me&jaa,R,'Belti,Bet,Bit' .map(&n{
            $Bet = ns&Bet
            $Bit = ns&Bit
            $Xc = BitDXc(Bit)
            $N = me&jaa,R,'Betgroup,Xc'
            each in N {
                $Betgroup = ns&Betgroup
                if (heq(ns&Xc,Xc)) {
                    me&ha,R,{Betgroup,Bet}
                    return
                }
            }
            # create new
            # an empty hash as id because ja k=1 returns all k
            $Betgroup = {}
            me&ha,R,{Betgroup,Xc}
            me&ha,R,{Betgroup,Bet}
        })

        $groups = me&jaa,R,'Betgroup,Xc'
        each in groups {
            $Xc = ns&Xc
            $Betgroup = ns&Betgroup
            $Bets = me&jaa,R,{Betgroup,Bet:1},'Bet'
            me&Ei,{t:'E'+i,pi:'Eel',s:Bets,Xc,cv:8}
        }

       // having Bets
        $BitDXsc = B => B && Bs&D && Bs&D.sc.Xsc
        $N = me&jaa,R,'done,Bet'
        $done = N.map(n => ns&Bet)
        !hak(done) and return
        !aq and return me&tc,"!ac"
        !aq and debugger
        $qua = {}
        each iB done {
            $Xsc = BitDXsc(B)
            Xsc.ope and Xsc.ope += qua.ope||0
            ex(qua,Xsc)
        }
        hak(qua) and aqs&qua = qua
        me&Ei,{t:'aq%qua',pi:'hat',s:qua,dl:2,inline:1,noencode:1}

        $letswake = 0
        done.map(&r{
            !rs&Bet and throw "done!Bet"
            $re = rs&E
            rec&el == 2 && rs&clickat == 'title' and letswake = 1
        })
        if (letswake) {
            me&tc,"letswake!",'G'
            $Bat = me.cbu(R,'Bat')
            ac(Bat,'letswake',E)
        }
        me&tc,"done:"+joint(done)

        #me&Ei,{t:'aq',pi:'hat',s:aq,dl:2}
    },'ift,D'],
   
   // -Fez > -hat
    # copy modulat straight to D**
    ['Womb',0.21,&acgtRs{
        Rs&top and Rc&dl = 26; Rc&nl = 166
        !isC(s) and return me&strange,"!C"
        $E = Rs&E
        $D = Rs&D
        D.t = s.t
        Dy&cv = sy&cv
        ex(D.c,s.c)
        !Rs&top and ah(E,'D_hides','c','pi')
        ex(D.sc,s.sc)
        # its many
        each iz ss&z {
            zc&not and continue
            me&Ei,{t:i,s:z}
        }
        # < measure modulat? chunks? showable?
        Rs&nofurtherDisplay = 1
    },'ift,D'],
    
    # fairly sprawly, for X**
    ['Fez',0.21,&acgtRs{
        Rs&top and Rc&dl = 26; Rc&nl = 166
        # < no restating refs per ^^-seven
        me&typeup,R,'hat'
    },'ift,D'],
    # stops at C
    ['Fez+Cish',0.262,&acgtRs{
        me&Ri,'limit:Fez,toomuch'
    },'ift,D'],
    ['Fez+Hash',0.262,&acgtRs{
    },'ift,D'],
    
    # sprawly, C**
    ['Bow',0.21,&acgtRs{
        Rc&dl = 12
        Rc&nl = 122
        # < no restating refs per ^^-seven
        me&typeup,R,'hat'
    },'ift,D'],
    # -hat allows qua.dim to sprawl open anyway
    #  it means we don't want to sprawl C
    ['Bow+indim',0.265,&acgtRs{
        #Rc&dl = Rc&d
        me&Ri,'limit:Bow,toomuch'
    },'ift,D'],
    ['Bow+Cish',0.2631,&acgtRs{
        Rs&sym == 'R' && me&Ri,'limit:Bow-R,toomuch'
        me&TXin,'BowC',{layout:'C**'} ({
            # usu t,ycv are impl by %Ctitle drawing them
            #  and y,c are dim
            #   < which should stop .c.X{} from being > 5,
            y: {dim:1,z:{up: {impl:1}}},
            c: {dim:1,z:{
                s: {biggish:1}
            }},
            sc: {dim:1,z:{
                # <wants to be qua.usurped, knowing who
                z: {impl:1},
                title: {ope:1},
            }},
        })
        # < to E/y,c,sc,sc.z
        $z = ss&z
        # its many
        hak(z) and me&Ei,{t:'🚶',s:z,rsc_mix:'nobrackets'}
    },'ift,D'],
    
    ['nobrackets',0.88,&acgtRs{
        $E = Rs&E
        s&bol = '1em solid black'
        
        $y = n => ns&label == 'bracket'
        me&moddelete,R,{y}
    },'ift,D'],
    
   // -hat > -Hash etc
    # expects it to be C
    ['isC',0.21,&acgtRs{
        me&walls,C,'bd:1.5'
        Rs&hat = 1
        isC(s) and return Rs&tiny = 1
        # was supposed to be C but isn't
        # < central fault aggregator
        me&strange,"!C"
    },'ift,D'],
    # diverges into types
    ['hat',0.21,&acgtRs{
        $sym = isR(s) ? "R" :
            isC(s) && isst(s.t) ? "C" : 0
        $Cish = sym
        if (Cish) {
            # isA, isJ
            isA(s) and sym = 'A'
            isJ(s) and sym = 'J'
        }
        elsif (isob(s)) {
            if (isar(s)) {
                # becomes a -Hash below
            }
            else {
                # also X, x
                $asym = me&diverge_ob,R,s
                sym = asym || sym
            }
        }
        if (sym) {
            Rs&sym = sym
            n sym 11 $s:sym fs:13,lh:0.8,hs:757
        }
        if (Rs&tiny) {
            # minimal typing up for labels
            #  in diagrams (-Bat) rather than datadumps (-hat)
            if (isC(s)) {
                # also stops recursion
                # < usu muted %%limit:tiny
                Rs&Ctitle = 1
                return
            }
            else {
                # stops recursion
                # < be %%layout:dim
                me&Ri,'limit:tiny,toomuch'
            }
        }
        Cish and me&typeup,R,'Cish'
        else
        isob(s) and me&typeup,R,'Hash'
        else
        1 and me&typeup,R,'String'
        
        asym and me&typeup,R,'an'+asym
    },'ift,D'],
    ['Cish',0.263,&acgtRs{
        Rs&Hash = 1
        Rs&inlineable = 1
        Rs&Ctitle = 1
    },'ift,D'],
    ['Ctitle',0.2632,&acgtRs{
        # C display whittles down to symbol + name
        # < unless a cold light,
        #    trying to look like JSON
        # < by adopting ranges of sub-R types
        !isst(s.t) and me&strange,'!t'
        n t 12 $s:s.t label,deco
        !hak(s.y,'cv') and cv = '!cv'; me&strange,'!cv'
        else {
            $cv = s.y.cv
            cv == '' and cv = "''"
            else
            !num(cv) and cv = dis(cv); me&strange,'cv?'
            else
            cv <= 0 || cv >= 1 and me&strange,'cv?'
            else {
                cv = (cv+'').substr(2)
            }
            cv != 1 &&
            n y.cv 122 $s:cv label,deco,hs:999
        }
        if (!Rs&strange) {
            me&TXin,'Cishade',{layout:'C'} ({
                t: {impl:1},
                y: {dim:1,z:{
                    cv: {impl:1}
                }},
                c: {dim:1,z:{
                    s: {ope:1}
                }},
            })
        }
    },'ift,D'],
   // -Hash etc
        ['Hash',0.263,&acgtRs{
            $D = Rs&D
            $E = Rs&E
            # Object has border
            #  inc At, key of it somewhere
            me&walls,C,'b:2.2'
            
            # its brackets, 23-77
            # %shym = a %sym that can be mirrored
            Rs&shym ||= isar(s) ? '[' : '{'
            # < G&n should Mw by T.Mw||T.act.t
            #   as &tsc does
            T.Mw = 'shym'
            $bracket = me&modbracket,Rs&shym
            # its many
            each kv s {
                me&Ei,{t:k,s:v}
            }
            bracket()
        },'ift,D'],
        ['String',0.263,&acgtRs{
            $D = Rs&D
            $E = Rs&E
            $di = dis(s)
            n string 13 $s:di %fs:8,hs:584
        },'ift,D'],
   //      etc
        &{
            # -Hash may be -anX|x
            me.diverge_ob = &acgtRs{
                $sym
                isC(s.A) and sym = 'X'
                elsif (s.up) {
                    # X...x.up=X
                    $ux = me&hat_x_upwards,R
                    ux == s.up and sym = 'x'
                }
                return sym
            }
            # -hat^^ with X|x
            me.hat_x_upwards = &acgtR{
                $r = me.cbu(R,r => r != R && (rs&anX || rs&anx))
                return r && rc&s
            }
        },
        ['anX',0.263,&acgtRs{
        },'ift,D'],
        # < -hat -anx .z.* may be X|x from elsewhere (no s.up to R^^anx)
        #   x may be lodged in a variety of weird places,
        #   note such features of program memory lateralisings
        ['anx',0.263,&acgtRs{
            Rs&nobrackets = 1
            # must .up to an X|x we know?
            # < X|x if present
            #R.t == 'awoke' and debugger
            $ux =  me&hat_x_upwards,R
            s.up != me&hat_x_upwards,R and return me&tc,"noxup",'y'
            $style = {}
            style.up = {impl:1}
            !hak(s.z) and style.z = {impl:1}
            me&TXin,'anx',{layout:'anx'} (style)
        },'ift,D'],
        
    
 // R'The' compress -> $D ->
   // %thingo -> $D @68
    ['thingo',0.68,&acgtRs{
        me&Rthingo_toD,R
    },'ift,D'],
   // -String|-Cish -> $D @2637
    ['String',0.2637,&acgtRs{
        $D = Rs&D
        Dc&s = s
    },'ift,D'],
    # < i Dc&s = "(@sym )?@t( @cv)" o &modulat 11-131 .t:*
    #   < knowing sym must be \w, cv \d,
    #   < putting other @* after,
    #    < in a form including the .t, stuff about it,
    #      even the entire modulat, or this part of it
    ['Cish',0.2637,&acgtRs{
        $D = Rs&D
        # ground usually labels itself around here
        $N = me&modselect,R,{gte:11,lte:13}
        # should be simple labels, with .s?
        $cont = N.filter(n => hak(ns&z))
        hak(cont) and debugger
        # make a title
        Dc&s = N.map(n => nc&s) .join(" ")
        # usu "C $t"->"$t" but not if then $t="R blah"
        #return; #
        $comp = Dc&s.startsWith('C ') && !Dc&s.match(/^C \w /)
        comp and Dc&s = Dc&s.replace(/^C /,'')
        # < totally corresponding D-decompression
    },'ift,D'],
    # < when Nine/$t brings D** to resolve to nearby same
    #    having trained on common %Cish modulata,
    #     they can be reconstructed,
    #      even to the %%limit-level,
    #       so your remote data-dumper is cued for The++
    ['thaw+Cish',0.312,&acgtRs{
        $sym = Dc&s.match(/^(\w) /)
        sym && sym[1] &&
            n sym 11 $s:sym[1] fs:13,lh:0.8,hs:757
    },'ift,D'],
    &{
        # see if we can make some compression
        # < eg `a acs` in G as of now
        me.acsume = &acgtsc{
            c.starts && !s.startsWith(c.starts) and return

        }
    },
   
   
   // Describe how eg -Eight hoists
    &{
        # notices Ey&thing to use (+link) or update
        me.compLines_Eything = &acgtEd{
            $t = Ey&thing
            !t and return
            # on the node Somewhence-seven,
            #   E:-seven** encodes itself by %encodeD
            #    and then also R%E**, by %hoisten
            #   R%E:Somewhence**
            #    up on the outEsphere, finds its way into:
            #     R%E/Bowler etc
            #    ignoring R%E**//R%hoisten, ie E:-seven
            # Etop...E is E...e, a y&thing join
            $Etop = d.Etop
            !Etop and debugger
            if (d.d > 1 && ty&cv >= 0.2) {
                # this part of the climbing encode is isolatable
                #~>5 Eything: d.d, t.t, ty&cv
                me&Fame_Ething_add,Etop,E
                if (ts&string) {
                    # stops, %string trusted
                    d.nofurther = 1
                    return me&unfixstring,ts&string
                }
            }
                # everyone sets a thing at the top
                #~>5 Eythingset: d.d, t.t, ty&cv
                # E-seven always wants E:now (its out-E)
                # deal nodewake if Etop is already an out-E
                if (!ts&dige && Etopy&ers) {
                    # 
                    $R = Etopy&R
                    $oR = me.cbu(R,'Piing')
                    R != oR and debugger
                    $i = 3
                    while (i--) {
                        !oR || !oRs&E and break
                        $pE = oRs&E
                        pEy&thing and break
                        oR = oRy&up
                    }
                    !pEy&thing and debugger
                    #~>5 INIT to: pE.t, '<-', E.t
                    $z = oRc&s
                    !isnode(z) and debugger
                    me&wants,R,'pre_Fame_Ething',z
                }
                # < thing awake to see %string change?
                #d.d != 1 and ~>5 Yondfirst: Etop.t, E.t
                # %string made here
                d.for_string = &sdN{
                    ts&string = N.join("\n")+"\n"
                    ts&dige = dig(ts&string)
                    # and percolated to the out-C
                    $CC = Cy&C
                    !CC and return
                    #debugger
                    # supposing C=node%E Ey&C = outsphere
                    CCs&outC = 1
                    sex(CC.sc,t.sc,'string,dige')
                }
        }
        # after you encode t, check dependers to wake
        me.Fame_Ething_add = &acgtEe{
            $Et = Ey&thing
            $R = Ey&R
            if (!Rs&Piing) {
                # -Lab/Lab(i|o)
                Rs&Pier == 'Lab' and return
                debugger
            }
            $s = Rc&s
            !isnode(s) and debugger
            $t = ey&thing
            ac(t,'use',s,'dige',ts&dige||'...')
            #~>5 Eything: Et.t, t.t
        }
        # after you encode t, check dependers to wake!
        me.Fame_Ething = &acgtE{
            $t = Ey&thing
            $R = me.cbu(Ey&R,'Piing')
            each iz ts&use {
                $vers = ts&use_dige[i]
                #~>3 ^^^^Eything: z.t, E.t
                vers == ts&dige and continue
                ~>3 Eythingup: z.t, '>5 lovely', E.t
                me&wants,R,'Fame_Ething',z
            }
        }
    },
    ['Top',0.44,&acgtRs{
        $E = Rs&E
        Cy&cv = 0.22222
        # draw this E-etc
        Rs&encodeD = 1
        # draw together outsphere Ep/*
        #  merging outsphere: Ep//s**//E, &Piing inners: Ep/-etc 
        # < could do everything with pi?
        $Ep = Ey&up
        $Rp = Epy&R
        Rps&Ethinging and Rs&hoisten = 1
    },'ift,D'],
    # &ind to innermost eg E-Fez first, making string
    ['encodeD',0.7,&acgtRs{
        $E = Rs&E
        $D = Rs&D
        # storable encoding
        $t = Ey&thing = Dy&thing ||= Cye([D.t,2])
        # the R//E should have a thing,
        #  since /E**y&thing may not persist,
        #  whole node tends to happen
        $outR = me.cbu(R,'Piing')
        $outE = outRs&E
        outEy&thing ||= Cye([outE.t,2])

        $d = {what: &sd{
            # E**yD
            return sy&D
        }, compLines: &DdC{
            # D is now C, D is a copy to encode
            $E = Cy&E
            Ec&noencode and return d.not = 1
            # found another encoded thing
            $re = me&compLines_Eything,E,d
            re and return re
            # eg %Lab(i|o) (middle|end) of @Lab
            Ec&encode_thing_here and me&reusable_thing_string,d,E

            #delete Cc&top
            #Cy&D = D
            #Cc&pi == 'row' && fi&bug,'Firstlog' and debugger
            #me&dopi,D,d,C,c
            Dc&pi ||= Ec&pi
            # < &Ring a sliver of @7 time for everyone now
            each nk,gk Es&D_hides {
                delete D[nk][gk]
            }
            delete Dc&cv
            delete Dc&TX
            #comp_log(D,d,C)
        } }
        d.Etop = E
        me&Linets,t,E,d
        me&Fame_Ething,E
        d.not and me&strange,"&Linets:not"

        #me&hu,'encod',"Stevewas"
    },'ift,D'],
    ['This',0.44,&acgtRs{
        $E = Rs&E
        $D = Rs&D
    },'ift,D'],
    ['Eight',0.44,&acgtRs{
        $E = Rs&E
        $D = Rs&D
        Rs&hoisten = 2
    },'ift,D'],
    ['seven',0.44,&acgtRs{
        $E = Rs&E
        $D = Rs&D
        $t = Ey&thing ||= Cye([E.t,2])
        Ds&Seeving = 3
        Rs&hoisten = 2
    },'ift,D'],
    ['hoisten',0.7,&acgtRs{
        $E = Rs&E
        $D = Rs&D
        # climb from the node's %E (out-E)
        $p = Ry&up
        $Ep = ps&E
        # supposing we (eg -seven) are the only encoder
        $t = Epy&thing ||= Cye([Ep.t,2])
            # compress the E, start!
            # < linking to sevens? T outspheres
            $d = {what: &sd{
                # can change s (C) for d.compLines, but not d.for_string
                # can also not:
                # E**yD
                $r = sy&R
                # doesn't see other E//R%hoisten=2 (-Eight|-seven)
                rs&hoisten == 2 and return
                $main = ahsk(d,'up','s','y','main')
                #main && main != s and return

                $E = r && rs&E
                E != s and throw "E!=s"
                #Ec&b and debugger
                $rp = r && ry&up
                $z = rp && rps&ball && rpc&s

                # < o p&pi == r%Pier o :p/$s//r
                if (E && !rs&Piing) {
                    # should we go into such &Piering
                    if (rp && rps&ball) {
                        $sp = rpc&s
                        if (spc&pi == rs&Pier) {
                            # being the main r%Pier
                        }
                        else {
                            ~>5 hoistavoid: rp.t, r.t
                            return
                        }
                    }
                    !rs&Pier and debugger
                }
                return E
            }, compLines: &DdC{
                $re = me&compLines_Eything,C,d
                re and return re
                # upper Ec&cv vanishes
                delete Dc&cv
                delete Dc&top
                delete Dc&b
                # < should use D...
                delete Dc&X
                delete Dc&TX
                delete Dc&RX
                $tar = delete Ds&target
                tar and debugger
                #Ds&target = "C:"+tar.t

                # climb E** after s**/-seven
                #Cc&pi == 'seven' and d.s = C
            }}
        d.Etop = Ep
            me&Linets,t,Ep,d
        me&Fame_Ething,Ep
    },'ift,D'],
        
        
   
   // etc
    
    ] }
    # datadump, once inside R%Pier
    me.hu = &acgttsc{
        c = ex({t,pi:'hat',s,dl:3,noencode:1},c||{})
        c.nl = 400
        $e = me&Ei,c
        me&Eing,3
        $r = ey&R
        $C = rs&C
        s&hue = 30
        s&bgh = '731'
    }
},
 
 
 // GOING
    &{
   // slope io: &Rsci dialects
    // dialects
        # not readable?
        me.Rli = &acgtscq{
            c = ex(c||{},{gk:'limit'})
            return me&Rsci,s,c,q
        }
        me.Rlo = &acgtscq{
            c = ex(c||{},{el:8})
            return me&Rli,s,c,q
        }
        me.Rti = &acgtscq{
            c = ex(c||{},{gk:'toomuch'})
            return me&Rsci,s,c,q
        }
        me.Rto = &acgtscq{
            c = ex(c||{},{el:8})
            return me&Rli,s,c,q
        }
   # GOING Sopi
   // -hat - top thing
    me.pihat = &acgtscq{
        $R = me&R
        $go = Rs&goThy
        return me&Sopi,s,'hat',c,q ({
            1: &Ecq{
                Ec&top = 1
                c.nopiinto = 1
                fi&piinto,E,c
                # < for a Cy&thing here
                $t = Ey&thing ||= Cye([E.t,1])
            },
            7: &Ecq{
                sy&data = hash
                
                # the redo:
                $sd = me&disp_suit,s
                Ec&N = []
                me&fiu,E,'topval',9
                
                # do:
                $f = fi&pii,E,{t:"topval",pi:'val',s:hash}
                me&windup_tape,E,6,q
                me&disp_tape,E
                
                go and me&nu,"Slu",E
                $R = me&R
                ac(R,'M',sd)
            },
        })
    }
   // misc
    # chase <ov on tape
    me.windup_tape = &acgtEcq{
        num(c) and c = {ov:c}
        c.ov = scaf(c.ov || 9)
        $seen = 0
        while (Ec&N.length > seen) {
            seen = Ec&N.length
            each ie Ec&N {
                ec&cv == c.ov and continue
                fi&piing,e,c.ov,q
                # sets cv=ov even if no mindbit is there
                ec&cv = c.ov
            }
        }
    }
    me.disp_tape = &acgtEcq{
        # uplink del modulata
        each in Ec&N {
            # n:s - outsphere
            $d = me&disp_suit,n
            each iz ns&z {
                dy&here(z)
            }
            # ny$pi = E - insphere, has others
            $nE = me&mustpis,n
            # n up to some E
            $pE = ny&up
            $pn = me&mustpiE,pE
            # here inside higher middle
            $pd = pny&disp
            !pd and debugger
            pdy&yond(d)
        }
    }
    # housing for stuff around stuff inside
    me.disp_suit = &acgts{
        $d = sy&disp = Cye([s.t,8])
        dy&up = s
        
        $be = me&fiu,d,'beginning'
        me&tc,be,s.t,'q'
        $mi = me&fiu,d,'middle'
        mis&ma = 0.2
        $en = me&fiu,d,'end'
        
        # heres on either side of yond
        dy&here = &z{
            $to = zy&cv < 0.67 ? be : en
            ac(to,'z',z)
        }
        dy&yond = &z{
            ac(mi,'z',z)
        }
        return d
    }
    me.mustpis = &acgts{
        $E = fi&getpi,s
        E == s and debugger
        Ey&up != s and debugger
        return E
    }
    me.mustpiE = &acgtE{
        $s = Ey&up
        $e = fi&getpi,s
        E != e and debugger
        return s
    }
   // -hash etc
    me.pival = &acgtscq{
        return me&Sopi,s,'val',c,q ({
            2: &Ecq{
                if (isob(sc&s)) {
                    fi&piing,s,{E,pi:'hash',ov:2},q
                }
                else {
                    ss&insideEnd = 3
                    Es&Leafit = 3
                    $M = ss&z
                    $di = dis(sc&s)
                    m thinking  $s:di %fs:8,hs:584
                }
            },
        })
    }
    me.pihash = &acgtscq{
        return me&Sopi,s,'hash',c,q ({
            2: &Ecq{
                $M = ss&z
                m thinking  s:{ %deco,fs:8
                each kv sc&s {
                    $row = fi&pii,E,{t:k,pi:'valend',s:v}
                    rows&seenity = 3
                }
                m thinking 7 s:} %deco,fs:8
            },
        })
    }
    me.pivalend = &acgtscq{
        return me&Sopi,s,'valend',c,q ({
            2: &Ecq{
                ss&insideEnd = 3
                Es&Leafit = 3
                $M = ss&z
                $di = dis(sc&s)
                m thinking  $s:di %fs:8,hs:584
            },
        })
    }
    
    },
  // %TheeThy, landscape
    # some events, to|from the book
    ['TheeThy',0.296,&acgtRs{
        #me&Thee,'TheeThy'
        me&reaw,R,'TheeThy'
        me&bin,'Theing'
        me&tc,"TheeThy"
        # < i $s/-This/Something-Eight/Somewhence-seven
        $This = me&fiu,s,'This'
        Thisc&pi = 'This'
        $eight = me&fiu,This,'Something'
        eightc&pi = 'Eight'
        $seven = me&fiu,eight,'Somewhence'
        sevenc&pi = 'seven'
        
       // some data
        # init
        # the -eight remotely
        # i This/Bowler/\E-hat
        #$This = me&fiu,s,'This'
        $Bow = me&fiu,seven,'Bowler'
        $dat = Bowc&s = me&PiRet_data
        dat.moreso = dat.asee
        Bowc&pi = 'hat'
        
        $Bow = me&fiu,seven,'Lol'
        $da = Bowc&s = {more:'some',figaro:dat.asee}
        da.furhtin = {llatin:4}
        Bowc&pi = 'hat'
        
        $Bow = me&fiu,seven,'Room'
        $da = Bowc&s = {fer:dat.asee,even:'more',figaro:dat.asee}
        da.furhtin = {llabin:4}
        $i = 0
        while (i < 60) {
            da = da.th = {}
            i++
        }
        da.is = 'all'
        # < &Eing preferring this to more level$n
        #   diversity seeking
        $ej = Bowc&s.neesd = Cye(['Nees',3
            ,{mo:3,tor:68,functions:"of an elabourate sort",s:"Thsideratea"}])
        ejy&fig = dat.asee
        ejy&vig = 2
        Bowc&s['leveridge'] = Cye(['Nose',7,{s:'li'}])
        $i = 0
        while (i < 55) {
            Bowc&s['lever'+i] = 'thing'
            i++
        }
        Bowc&pi = 'hat'
       //
        # the -nines
        #  autoviv etivity for relatives in This (Bowler)
        #   to be packed into some Nine/$t**
        $The = me&fiu,s,'The'
        Thes&tow = 1
        me&ha,R,'some,doing,ness'
        me&ha,R,'some,doing'
    },'ift,D'],
   // testing
    &{
    me.PiRet_data = &acgt{
        $hash = {
            fig: {vig: 'vort'},
            lw: {vig: 'vurt'},
        }
        $N = [1]
        N.map(&i{
            each kv hash {
                1 < i && isob(v) and v = ex({},v)
                v = hash[k+i] = {le:v}
                k == 'fig' && i == 1 and v.ol = {de:3,do:4}
                k == 'fig' && i == 1 and v.owel = {de:3,do:4,da:5}
            }
            hash['water'+i] = 'par importo'
        })
        $as = hash.asee = Cye(['Think',4,{dia:'dem'},{luc:'cho'}])
        ass&t = {le:3}
        return hash
    }
    # art busier
    me.tivity = &acgt{
        $R = me&R
        $x = me&Jx,R
        me&rollbs,"Fishtivity"
        x.ro("tivit") and Rs&Fishtivity = 5
        if (Rs&Fishtivity) {
            Rs&Fishtivity--
            me&waits,"ForItivity"+Rs&Fishtivity
        }
    }
    },
  //   /This|The%Theing /%TheEight/%TheSeven
    # Nine-ish container of /Eight-ish namespace
    ['Theing',0.291,&acgtRs{
        $x = me&Theing
        # This has 8,7,6 scheme, The may amorph while %tow
        $then = ss&tow ? 'TheThe' : 'TheEight'
        me&bin,then
        
        Rs&onlyish = 1
        me&tc,"Gool","G"
        Rs&TheingE = 1
        #me&piThis,s,2
    },'ift,D'],
    # in The%tow, anyone with sy&Todo may become -Bat
    ['TheThe',0.291,&acgtRs{
        me&bin,'TheThe'
        sy&Todo and Rs&TheTh = 1
    },'ift,D'],
    
    
    ['TheEight',0.292,&acgtRs{
        $x = me&Theing,{in:'TheSeven'}
        # inspheres on sy&$pi=E/**
        sc&nopiinto = 1
        me&hideyfix,R
        #s&nofurtherDisplay = 1
        me&piEight,s,{nopiinto:1},2
    },'ift,D'],
    ['TheEight',0.321,&acgtRs{
        
        # complete -eight
        #!Rs&wakeful and Rs&Fin = 1
        #me&piEight,s
        if (1) {
                # compress the entirety
                # < linking to sevens? T outspheres
                $d = {what: &sd{
                    # changes s (C) for d.compLines, but not d.for_string
                    # E**yD
                    $E = sy&R && sy&R.sc.E
                    return E
                }, compLines: &DdC{
                    $t = Cy&thing
                    if (t) {
                        if (ty&cv >= 0.2) {
                            # stops, %string trusted
                            !ts&string and throw "!string"
                            d.nofurther = 1
                            return me&unfixstring,ts&string
                        }
                        else {
                            # %string made here
                            d.for_string = &sdN{
                                ts&string = N.join("\n")+"\n"
                                ts&dige = dig(ts&string)
                                # and percolated to the out-C
                                Cy&C and sex(Cy&C.sc,t.sc,'string,dige')
                            }
                        }
                    }
                    # upper Ec&cv vanishes
                    delete Dc&cv
                    delete Dc&top
                    # < should use D...
                    delete Dc&X
                    delete Dc&TX
                    delete Dc&RX
                    # climb E** after s**/-seven
                    Cc&pi == 'seven' and d.s = C
                }}
                me&Linets,s,s,d
        }
    },'ift,D'],
    ['TheSeven',0.292,&acgtRs{
        $x = me&Theing,{in:'TheTh'}
        me&hideyfix,R
        $E = Rs&E
        # for a storable thing here, as EsyncThis hoists -sevens
        $t = Ey&thing ||= Cye([E.t,1])
        #me&piSeven,s,{nopiinto:1},2
    },'ift,D'],
    ['TheSeven',0.32,&acgtRs{
        sy&R = R
        
        $go = me&acting,R,'FSev'
        Rs&elvis = 'FishElvis'
        
        #s&hue = 138
        # -seven...-ologise also colours it
        
        #me&piSeven,s,{},7
    },'ift,D'],
  //     /%TheTh has R'The'
    # each thing
    ['TheTh',0.296,&acgtRs{
        sy&R = R
        sc&pi ||= 'Bat'
        $x = me&Theing,{in:'TheTh'}
        $E = Rs&E
        
        $tc = me&Thetower,R
        $es = tc.es
        delete sy&RXing
        es && esy&TXing and sy&RXing = esy&TXing
        
        #$c = me&Thetower,R
        #me&proto_Bat,c
        
        if (sc&pi) {
            $c = {}
            ~>6 pi: R.t, sc&pi
            $r = me&Piering,c
            rs&sleeping and return
            $e = rs&E
            me&fiu,E,e,2
            #Ey&thing = ey&thing
        }       
        me&fiu,Ey&up,E,2
    },'ift,D'],
    ['TheTh',0.6,&acgtRs{
        ~>6 The: R.t, joint(Rs&z)
    },'ift,D,sleeping'],
] }
