# will to Travel!
me.Sch_Go = &acgt{ return [
    =Gnome
     Gnome/
      Fories/ is storage for any:
      TheF/$t/$t%TheFine/$ti%TheFe tick over
       $ti goes OK
        has $exp=$ti-Ness/-eight/-seven/etc
        and $got=-Ness/... that &EsyncThis from This/*/*/etc
        the $exp%dige lets you avoid opening W:$ti until fail
      Thy/
       < %TX staged $ti <-> The...$exp
     
        phil
         Ya/$story
          /Shelf... deps load
          ...Fine W:$story instance
          /Thy... backstage %Piing
         hires:
          ...@Run
           /This... to -hat type views
            will Ring instantly (per -log) when @Run
           /The... control for This

         < The..#$D
           your clicks being configured
           selected one shows CED columns over slope rows
         < %%next_Ness_title_clue for S=1
         see 'switched off Fe->Lab'
    =cut
  // @Gnomp/@Gnome # < separate from w:Travel
    &{
        # Gnome:$t from url, $s:Gnomp
        me.twas_location_hash = &acgtsN{
            $them = haks(peel(N))
            # from|to url
            $t = location.hash.substr(1)
            me&tt,"which" (1) and t = ksaf(them,{aft:t})[0]
            t ||= them[0]
            location.hash = '#'+t
            
            # must reset to change Gnome:$t
            if (sy&twas && sy&twas != t) {
                ~>5 resetYing::::: t
                me&resetYing,sy&R
            }
            sy&twas = t
            return t
        }
        me.resetYing = &acgts{
            $JRom = me&yfuture,me.cbu(R,'JRom')
            JRoms&reset = 1
        }
    },
    ['Gnomp',0.296,&acgtRs{
        
        me&acting,R,'Gnomp'
        Rs&wakeperc = 1
        
        # < hang state in %Te, to survive reset?
        # < have a list of recent Stories
        # < generalise. check after e:focus
        $t = me&twas_location_hash,s,['Fus','TryPiWarmer']
        me&baleg,t,'Gnome'
        
        # %%active:Gnome here
        # < parallel tests? shouldn't interfere? (unpredictably)
        $c = {quietready:1}
        (Rs&boost||0) < 0 and delete c.quietready
        me&activator,c and return
    },'ift,D'],
    # and any SC,Run in between
    ['Gnome',0.296,&acgtRs{
        me&acting,R,'Gnome'
        Rs&client = 1
        me&Names_set,R,'Gnome',s
        # %%active:Lab|Nine here
        #  early so **Nine can activate this time
        me&activator
    },'ift,D'],
    ['Gnome',0.5,&acgtRs{
        # invent Go (Gome gets permit)
        # < ++ for a new @Cat
        #   known replacements, reset strategy
        me&ha,R,{Go:s.t,tid:1}
        me&tc,"\n"
        
        !me&SuperGnome,R,s,{} and return
        # < de-activate? or put &activate in a
        #    sute perm,til=testcomplete
        delete Rs&wakeful
    },'ift,D'],
    # random &bal eph dumpber
    ['Zuist',0.296,&acgtRs{
        me&acting,R,'Zuist'
        me&nu,"Zuist",Rs&Zuist
    },'ift,D'],
  // @Gnome 8 other time
        &{ 
        # Gnomp &quietready ambiently checks any @active
        me.Gnomp_any_quiet_wake = &acgtR{
            $any = me&zaa,R,'active',1 .filter(&z{
                $r = zy&R
                !rs&Gnome and debugger
                zy&want_quiet_wake and debugger
                # they also must bs&wakeful to get there
                $want = me&Gnome_want_quiet_wake,r,z
                want and ~>2 anyquiet: z.t, want
                return want
            })
            !any.length and return 0
            return 1
        }
        # Gnome's &activate allows wanting to quiet wake
        #  sympathise parts of &SuperGnome!
        # < why these must be &saa?
        me.Gnome_want_quiet_wake = &acgtRs{
            # from the last &SuperGnome
            
            # really wants a quiet
            #  even if the want was generated while quiet
            # < how rare
            # < a real quiet, not artificial?
            #   comparative quiet momenting of here, there
            #   gives a workflow
            me&sa,R,'Superquiets,Pending' and return 'drew'
            
            # take any quiet opportunities when %%pur
            # < or just when %%pur,pre?
            $pur = me&sa,R,'pur',1
            if (pur) {
                # < allows so much loop of quiet wake for eg %%active
                me&rollbs,R,'purloop'
                pur = joint(pur)
                if (Rs&purloop != pur) {
                    # < generalise, for Superquiets,Pending etc
                    #    add a &brackstill?
                    #   and an infinite noise source would use a clock
                    Rs&purloop = pur
                    return 'pur:'+pur
                }
                ~>2 purloop: pur
            }
            
            # any tractorbeams
            # < -pipe between -thing
            $N = me&saa,R,'supe,sute,sensitivity,otherable'
            $is = N.some(&n{
                $args = ns&otherable.split(',')
                args = args.map(&k{
                    $arg = theone(me&saa,R,k+',supe,sute,arg' )
                    # < expected args
                    !arg and return 0
                    !arg.sc[k] and return 0
                    return arg.sc[k]
                })
                # has given args
                args.some(v => !v) and return 0
                return me&mearg,ns&sensitivity,[R,...args]
            })
            is and is = 'sens:'+is
            return is
        }
    # %Superpost then &wants %pre 
  // &Superdef & %%active
       =doc
        time barrel:
         you may find yourself Ying@8, able to quiet_wake
          esp. if that wasnt the last thing you did
          
         you may find yourself -hat matching some %TX
          or just streaming &Superdef of This
          
         you may find yourself pushing &Superdef
          because &Superdef led you to activate Lab++ time
         
         you look around at the flock:
         
        Gnomp vator, the top level
        Gnome vator + vate
        -Lab|-Nine vate
         
         any vate can be found out of time
          eg when vator decides to Go it
          eg potential quiet_wake look for a reason to be
           ie &Super* usu want to when %%pur
           # < types of neediness, a fugue of %%pur
           #   that should resolve before vator time++
         and its %%Superdef may allow async etc (WAFFLE)
          may allow async etc, but now:
           -Lab to -nodei
            when +-%%got_active,
             wants a wake for &SuperLab
              because &nodei
              and just to make things tick
           -Lab to -not
            # < -not, the annotation
            may just be watching for something
             in any &Superdef available ^^
             doing pictures into bales of Eight
              immediately|by whatever is %RXing this hook
             trusting til <4s later, we shall have:
          artificial %%quiet,
           can be imposed every 4s or so
            by latering the sooners
           causing a wave of &Super
            that can trust to thus batch redraw
             for a fast stream of 'ok' 
          # < -not(es) are to acquire coords, might be encoded
          #   win prizes for rambling poetry
        
        vator:
         state machine
          for things moving around
          satisfy conditions to various time++
           eg E**//R!%strange
           eg ThyThe clean (push may caution merge)
         step 1 -> step 2 in five easy light cones
         all %%Superdef... anywhere clue operation
          -Labi push ThyThe
          -Labo push ThyNine (if saving)
          -The recv
           # < rolling wake This
           extra e put to likely -Lab (may ++)
          %Gnome time:Such,how
           the way to advance time
           # currently all -Lab Go
          %Gnome proc:Thy-around
           when time, do Thy/** stuff first
         so
          each
           makes an o, about eg -Lab for time
          when ~o
           i time, put that is
            appears on copies of y&thing+
            interacting with time
          
          have a time rowing
           for art withit
          near &Superdef:
           making hoist Eight/Seven/~fig
            before ThisNine
           shall be a Ec&top thing,
            %Piing reusing &Superdef bits
             to transmit y&thing to each other
              in such a way that time++ whenever ~o
              
         
         &SuperGome See
           decide when to This time++
            by Thy time++ (-Lab Go)
            so push etc and all is well
            we then Run time++,
             ie visits the bloop
            expecting This time++
           makes This time++,
            when expected, or it tinkerfugues (auto pause)
            when quiet,
             or whenever tighter grabs of time occur,
              eg next whole -Ness/*/* is got
            -Ness++ new phenomena to get
           eventually
           deciding Nine is complete
            when no more Thy++ is possible
           
           other types of time,
            eg The++ after This++, before Ness++
             showing what arrived (%RX per -Lab...)
              ie basic assertions
               could be into This/not/time on arrive
             push The...y&thing to Thy...-Lab//The
              ie -Lab may know how the entire The should look
               push y&thing there makes it a storable with Outs,
                Outs could be empty, hoping %dige ok
                anything could be lv, incrementaling
                 Nine @2 takes init The|This time and ignores it?
                  to degrees - makes Nine/-Lab/This/such/situation
                   findable for situ->Story guidance mechanism
                   # < feedback
              
              or supplying a flock of figurines
               to dialectical furnishing drawing up
                Such-Lab reports its findings
                 which may actually show up in This/'Such-Lab'/time
                   since they are -Ness-y
                  & hoist turnaround, still under that The++ time,
                   so as to not wake Such-Lab when This++ for report
                   then:
           lead
            neatly
             back
              to: This ->
           receivers:    
            -Lab++ if any
             see The++ after This++, before Ness++
             might have things to light up in:
            -Ness++ pulls, up-to-date
             spills guts if trouble,
              wait to continue? @Gnome settings
               ideal time to fork(), point to start showing dev
                further Nine++ once -Ness wobble could bignoise
            -Nine++ stages
              -Ness complete
              -Lab reveal|pull
          
          and Thy..Lab putting into @Inc|@Pro|@Run
           which will mostly model settings
           to be pasted up via &Superpath
            at times when &Superdefs are allowed to change:
             by going into -Lab to send -nodei from it
              ticking &SuperLab over for it
             by delivering all &Superdefs
              making landel
              which causes a bunch of activity,
               we might Thy** before but when we -Ness
               eg  $initial_The|Lab|This
                which we might have stored
               eg $postNess_The might be called for
                 
              sending us around to:
          &Superdef feeds streams
           eg -Nine reads -Eight**
            < additional -hat perceptions, at times
           eg -Lab reads -The, also writing
            based on -Lab revealed after done -Ness
          is a rowing of stuff
           various dimensions of it affect differently
           following -Nine/-Lab
            should == if we pushed it
        etc
       =cut
     // for &Super* times
        # vate:r%Piing <- %%Superdef for a vate
        me.Superdef = &acgtc{
            $R = me&R
            if (Rs&Piing || Rs&TheFine) {
                # outsphere
                # < organise &Super* via &Superpath
                $r = R
                c.wakenode ||= 1
            }
            else {
                # or in &Piing
                # eg -Lab/-Labi defining what it would push
                # via the ^^%Piing, it vate, may have %%got_active
                $r = me.cbu(R,'Piing')
            }
            $q = {}
            # < make canonical name (resolving $n)
            q.Superdef = 1
            Rs&E and q.E = Rs&E
            # c eg:
            #  f=nodei,to:@Run,wakenode
            #   wakenode means r must experience +-%%got_active
            #    which checks its <32 working one more time
            #     < something for vator to ttl before act
            #  f=Flight,of=inst,to:@Thys,wakenode
            #   as above, more clearly wishes it was &Superpath...
            # async,
            # < y&thing or wishes of a land|time
            #   may introduced in c (no callback)
            #   < it may be used to define &Sarg+
            #     about what|how, hooks etc
            me&ha,r,q,{},c
            
            # ...round trip to @Gome &Supervator to see us
            #  and make sense of situ, de-%strange, etc
            # < ability to act active|not immediately
            #   thinking on behalf of Supervator,
            #    othering sutes?
            #    what if %strange returns?
            #    or the this r%%Superdef could be new|gone|diff
            #     via resolving $n, brackstill for this r%%Superdef
            #     dome=$Superdef each one? traction them in &SuperLab?
            
            # then, %%got_active
            #  stays active
            #   < forces acting on us may like to:
            #      suddenly freeze outgoings
            #      try to avoid waking $to
            #     as in a compile error
            #   < to sleep -Lab? see &Eref_begin etc
            #     we could maybe dome=$Superdef+'o'
            #     if all it is doing is &nodei
            #     or it can be outsourced to @Gome...
            #      would clean up zombie &nodei from deleted Thy**
            if (me&ja,r,'got_active' ) {
                c.got_active = 1
            }
            return &y{
                # < notice whether they call this? see (no callback)
                # < capture y for later via %active/..., see async to -Lab
                c.got_active and y (r,R)
            }
        }
        # @4 draws vate %%Superdef
        me.Supervate = &acgtc{
            $R = me&R
            !me&ja,R,'got_active' and return
            s&bgh = '311'
        }
        # @5 draws|decides who is active
        me.Supervator = &acgtc{
            $h = T.sute
            $R = me&R
            $act_z = []
            # that seem ready, by @5
            me&boxcap,"vator:",'1p' (&m{
                me&walls,m,'bd:1.4,hu:3'
                # vator has a proper list of %active=C...
                $act = Rs&active
                actc&vators ||= 0
                actc&vators ++
                me&tsc,"act.c",dis(act.c),'26'
                # o contrib via %%active
                $N = me&jaa,R,{active:1,eto:Rc&s}
                # i @Gnome/%active/$z
                
                # &rowcap doesn't start anything until called back
                #  only shows 'seems ready' if non-empty (besides my&label)
                # < drawing tables left->right
                # < row.i|o(), row.N...
                $row = me&rowcap,N,'active'
                row('okay',&sma{
                    me&Sup_Eokay,s
                    # < no danger making $act/z if !Eokay?
                    # < a follow? see &EsyncThis etc functionalia
                    $z = a.z = me&copi,act,s
                    act_z.push(z)
                    
                    # policy on what to do when new, -suchpi
                    me&copipol,z,c
                    
                    zc&vators ||= 0
                    zc&vators ++
                    me&tsc,"z.c",dis(z.c),'6'
                })
                me&Superready and return
                # < persist modulat while fuguing !ready...
                #   tables penting change rows|columns
                
                row('@',&sma{
                    $z = a.z
                    # gather opinions on there
                    $defs = me&jaa,sy&R,'Superdef'
                    each in defs {
                        ns&wakenode and zc&wakenode = 1
                    }
                    me&tc,"x"+hak(defs),'y'
                    # &Sargfunc_wants also demands some
                    !hak(defs) and return; zc&wakenode = 1
                    
                    
                    # < make it active when time
                    $ov = 0.2
                    if (zc&ov != ov) {
                        me&tc,numf(zc&ov||0)+'->','y'
                        zc&ov = ov
                    }
                    me&tc,'@'+numf(zc&ov||0),'q'
                    me&tc,'.'+zc&vators,'y'

                    if (zc&ov != zc&cv) {
                        me&tc,'/'+numf(zc&ov||0),'q'
                        
                        !zc&wakenode and me&tc,"(#<otherable)",6
                        # < bring back &diagno
                        me&wants,R,"ovpush",s
                    }
                })
            })
            return act_z
        }
       // vator f
        # do policy when new, -suchpi
        # after &copi, the mirrored state has some hooks
        me.copipol = &acgtzc{
            $s = zy&C
            !s and debugger
            $some = 0
            each ky c.pi_any {
                sc&pi != k and continue
                some = 1
                y (s,z)
            }
            each ky c.pi_new {
                sc&pi != k and continue
                !(zc&el <3) and continue
                some = 1
                y (s,z)
            }
            c.should && !some and debugger
        }
        # check some s//E/* for %strange
        # < and E^^^c&uber
        # < how ready?
        me.Sup_Eokay = &acgts{
            # &Sharg&wants may ha %%pur, direct wake
            $g = me&Sharg,<<'',[s]
                o &wants //R** if %strange o $s//E/?*

            # ends up with none that are strange
            hak(g.N) and me&tc,"%strange",'B'
        }
        
     // f
     // &activator: Gnomp, Gnome hoist bunches
        # R%active, the list is had
        #  eventually and through several ports
        
        me.activator = &acgtc{
            $R = me&R
            # for the %%active opining it
            me&reaw,R,'active'
            me&rollbs,R,'active'
            $act = me&Rsci,'%active'
            # vator spec
            c ||= {}
            ex(act.c,c)
            if (c.quietready) {
                # Gnomp routes ambient attention seeking hooks
                #  with a side project:
                #   does some proto &Superquiet initially,
                #   to quiet wake once &Resides etc concludes
                # sees opportunities to wake at certain times
                # < beyond forcing a possibly repetitious quiet_wake
                me&quietready,R and return 1
            }
            else {
                # follow above vator
                me&active_to,R,c
            }
            # to inherit quiet-awareness,
            #  following the real &quietready on Gnomp
            #  or follow Gnomp on Gnome, etc
            me&howdidIgethere,c
            
            # < compute state, to draw it in &Supe*
            #   with what has changed per self time
            #    as things would be logged
        }
        # if quiet
        me.howdidIgethere = &acgtc{
            $R = me&R
            # determine %is_quiet from ...
            if (Rs&quiet_waker) {
                # Gnomp has or has-not
                Rs&is_quiet and c.quiet = 1
            }
            else {
                # our activator
                !c.to and debugger
                $r = me&yfuture,c.to
                # < this will be on our tunnel
                if (rs&is_quiet) {
                    Rs&is_quiet = c.quiet = 2
                }
            }
            # < we could wake=[exactly-who-needs]
            #   we currently pull attention into Gnome,
            #   then hope that will want other things...
            # < Gnome quiet may want to then wake Lab as if quiet
            #    this could be synth quiet or synthart quiet
            if (Rs&is_quiet) {
                # display how we were activated
                $t = me&Mwty,R,'Peace','R%icount'
                ts&opa = 0.5
            }
        }
        # for vator or vate
        me.active_to = &acgtRc{
            $to = c.to = me.cbu(Ry&up,'active').c.s
            to && !isnode(to) and debugger
            return to
        }
     // &activate: Gnome, Lab are clients
        =pod
         < type of &acquire connects above:
           Gnomp/Gnome%client
            using &(Gnomp|Gnome)_(any|want)_quiet_wake
           Gnome%client...Lab|Nine
            similarly.
            we have a c
             it says how|when Lab is to realise %%active
             it might be now,
              we might have to synth a %%got_active
            and any Lab%%Superdef,fortime...
             clues us to feed eg oute y&thing to The
              an otherable task (sender doesnt wake)
             or ++%%wakenode, if &SuperLab must perceive,
              Lab itself recv|become %%got_active
               and eg &nodei, which sender must wake for
            after the %%got_active,
             which may not be delivered from your $to
              if the act of it was otherable
            you continue once The settles,
             having Thy 1, The 1
             about to This 1
           so &Superdef
            can take eg oute y&thing to The
             so we have Thy 1
             living The to recv it
            without living Lab to send it
            so if you randomly live Lab,
             %%got_active is synthesised in
            but when &activate while so,
             we shall make one up for it
             
         Gnome, Lab get on the list
         and realise their activation
         
        =cut
        
        #     then posit things activation entails, etc
        #  prepare to join quiet wake of Ya%Gnomp
        # importantly Gnomp has &quietready
        #  hooking into the above outside-times
        #   from a &Ying_8 having no next move
        # also, form an orderly todo list
        #  which can decide things any time
        #  bringing light cones into the world
        me.activate = &acgtc{
            $R = me&R
            $s = Rc&s
            # tend to wake from above, 
            #  helps if ^:Gnomp%wakeperc
            #  no effect on Thy..Lab...
            
            # to%%active=us
            $q = {active:s}
            c = ex(c||{},q)
            # make a reading
            $z = me&o_activate,c
            # many calls to &activate per R
            $oc = Rs&first_activate ||= c
            oc && oc != c and c.oc = oc
            else c.init = 1
            
            # anyone interested in being active can:
                if (c.init) {
                    # 0 send %%active
                    me&nodei,R,c.to,q
                    # how we are waking
                    me&howdidIgethere,c
                }
                
            # 0 extra-not-active, rarely
            #   < proper paused-ness, Yingwake|elvis avoiding them
            #   similar to SC%Con meaning %%Control co is needed
            #   halting &Supe*, 
            #    which may cause eg &Resides to stop
            #     < in a way it continues? see reaw.*bal_*
            c.ov < 0.1 and return 1
            
                # 1 may be wakeful, when onlyish
                #   plumbing quiet moments into Gnomp/Gnome
                #   because we dispatch to Gnomp when quiet,
                #   < could ideally write up wakers ourselves
                # tend to wake from above, 
                #  helps if ^:Gnomp%wakeperc
                #  no effect on Thy..Lab...
                Rs&wakeful = 1
                # < only when our want_quiet_wake went off
            
            c.ov < 0.2 and return 0
            # must have an $act/$z
            # < %commit this... when &Superdef are sent
            zc&cv = zc&ov
            me&ha,R,'got_active'
            
            
            return 0
        }
        # vate reads level of one %%active
        me.o_activate = &acgtc{
            $s = c.active
            $R = sy&R
            !R and debugger
            $to = me&active_to,R,c
            !to and debugger
            $r = me&yfuture,to
            $act = c.act = me&Rsci,'%active',{el:8,v:r}
            !act and debugger
            actc&times ||= 0
            actc&times ++
            
            actc&stop_all and c.ov = 0; return
            c.ov = 0.1
            # cones
            $z = me&fiu,act,s.t,8
            !z and return
            
            zc&ov ||= c.ov
            c.ov = zc&ov
            
            return z
        }
        
  // &Superarg, -> &Gnome_Jx # < separate from w:Travel
        # < ceremoniously knowing
        me.Superarg = &acgtsc{
            $h = T.sute
            # c must be so between Superarg-arg are params
            $c = ex({Superarg:1},peel(c||{}))
            # %%rec... are permanent, remain while going faulty
            #  per %%supe,sute,rec, like a %%dome
            !c.flighty and c.rec = c.flighty||'Superarg'
            # can be found:
            $k = haks(s)[0]
            !k and debugger
            c.Superarg = k
            if (c.viatw) {
                # < from other $sutes?
                $z = me&Superarg_find,c.viatw
                if (z) {
                    $v = me&fiu,z,k,8
                    !v && hak(z.y.tv) and debugger
                    !v and c.fail = "viatw!t:"+k
                    else
                    # if climbing from a node, only return lit nodes
                    isnode(z) && !isnode(v) and c.fail = "viatw!node:"+k
                    else s [k] = v
                }
                else c.fail = "viatw!arg:"+c.viatw
            }
            c.arg = 1
            # c must be so the k:v after arg
            #  so s mixes onto the end:
            h.ha(c,s)
            c.fail and return
            $v = s [k]
            # becomes usable to &Sarg
            h.ar [k] = v
            # < make presentable
            $spc = " @"+k
            me&tc,spc,'6g'
            return v
        }
        # find names from surrounds
        #  for any Cat** or Gnome**
        #   via Cat%client=Gnome
        # we have a more non-fatal &Gome_Jx
        # not waiting on much to get ready
        
        # &Gome_Jx is used:
        #  w:Travel: only in &SuperGome
        #  w:Story: for %*Fine, we use
        #  w:The:
        #   &SuperGnome Reside (can not?)
        #   Pi%Lab -n
        #    < conceptually brackstract for one-line rurl (relative url)
        #   &Theing, for all %Piing
        #    < halts %Yingulog, can't find ^^%client
        #       should look down %active
        
        me.Gnome_Jx = &acgtR,cl{
            $arg = {}
            if (cl) {
                # GOING, wrapped in &Gome_Jx
                $GOING = 1
                arg.Gnome = cl
            }
            else {
                # o R^^?%client
                $cl = me.cbu(R,'client')
                if (!cl) {
                    # we may Ying/*(/*)?%active%client
                    # < do we need to be before Peace makes %Ace(.4=Ying)?
                    # < some locales may not grant %active automatically?
                    $Ying = me.cbu(R,'Ying')
                    each ir Yings&z {
                        !rs&active and continue
                        rs&client and cl = r; break
                        each ij rs&z {
                            !rs&active and continue
                            js&client and cl = j; break
                        }
                    }
                }
                # if %client is someone else
                #  eg @Cat)%client = @Gnome)%client=1
                $hi = cl && isC(cls&client) && cls&client
                if (hi) {
                    # @Gnome:hi hired @Cat:cl
                    arg.Hire = cl
                    arg.Hired = hi
                    arg.Gnome = hi
                }
                else {
                    arg.Gnome = cl
                }
            }
            rap(r => ry&R, arg)
            
            $cl = arg.Gnome
            !cl and throw "!client"
            !isR(cl) and debugger
            !(cls&Gnome || cls&Piing) and debugger
            # < xs&Gome going
            arg.Gome = arg.Gnome
            
            # < your use case may be sensitive to rough landings
            # < Superarg that arent nodes
            ex(arg,me&Superarg_arrive,cl )
            rap(r => ry&R, arg)
            
            # arg.Gome gives Gome/*, eg xs&Fories
            $x = me&Jx,R,{c:arg}
            
            # the Run/This > Thy/This, etc
            xs&Run && xs&This && xs&This.y.up != xs&Run and debugger
            
            if (GOING) {
                # what &Gome_Jx does
                Rs&Gomex = x
            }
            return x
        }
        
        
      // f
        # find one such %%Superarg=$k (exclusive gk)
        me.Superarg_find = &acgtkc{
            $jaa = me&hajasute .jaa
            $is = theone(jaa({Superarg:k}))
            c and c.n = is
            is && !iss&fail and return is.sc[k]
        }
        # bind and check all
        # reading but sometimes other to R%Gome
        me.Superarg_arrive = &acgtj{
            $ar = {}
            me&zaa,j,{Superarg:1} .map(&n{
                $kv = ksaf(n.sc,{aft:'arg'})
                !hak(kv) || hak(kv) > 1 and debugger
                $k = kv[0]
                $v = n.sc[k]
                # failing names should !v
                ns&fail && v and debugger
                ns&fail and return
                sex(ar, n.sc, kv)
                # and check it
                if (ns&viatw) {
                    # parent is still attached
                    $z = me&Superarg_find,ns&viatw
                    if (z) {
                        $vv = me&fiu,z,k,8
                        # < catch new Run/This etc
                        vv != v and debugger
                    }
                }
            })
            return ar
        }
        # chase parent of a %%Superarg,fail
        #  -> %%pur,pre=$Parent to &want
        me.Superarg_purfor = &acgtnc{
            if (ns&viatw) {
                # wake parent
                $v = me&Superarg_find,ns&viatw
                v and c.pre = v
            }
        }
    
  // Supe@Gnome
   // 1 @Gome
        me.SuperGnome = &acgtRsce{
            $x = me&Jx,R
            c.t ||= 'Gnome'
            $su = me&supetime,R,c.t
        # non-%%arg, esp as Go is a row
        #  brack only allows other rows as %%n
        $Go
        $x
        su('Reside',{perm:&zaa,jaa,ha,ar{
            
            x = me&Gome_Jx,R
            !x and debugger
            s != xs&Gome and me&tc,"~Gome"
            
        # i @Go <- %%Go ?
          # the entire @Gome 
            Go = theone(me&jaa,R,'Go' )
            !Go and return ha('pur:!Go')
            # acquire %%active
            #  mostly so we keep coming back if jaa(pur)
            #   ie busily attends to !ok &Super* 
            # < later that will be for any wanting-%%active,
            #   %%active-proper once &Superdef allows
            # < we may be pushing Nine some other agenda
            me&activate and debugger; return ha('pur:!active')
            
          # begin @Nine + @Thy
            # < s/ies/y/
            me&bal,'Fories','Fories,eph'
            # event grabulator
            me&bal,'Thy','TheThy,eph'
            # < TheF defaults to $t.t
            $r = me&bal,'TheF','TheF,eph'
            $TF = rc&s
            TFs&about ||= [R.t]
            me&Ring,R,{inside:R,ov:0.4}
            
            # til quiet (once)
            me&Superquiets,R
        me&Superready and return
          # < meaning Gome/* are ready
            x = me&Gome_Jx,R
            # storage pile
            !xs&Fories and ha('pur:!Fories')
            # the bunch of Nines we have open
            $F = xs&TheF
            !F and ha('pur:!F')
            ha('arg',{F})
            # < have Thy first clue from F
            !xs&Thy and ha('pur:!Thy')
        me&Superready and return
      // 
   // 2 write -> Travel...
        # < these... chaining Go, mixing things in
        =pod
         Gump... %%Go,tid,Goting... -> Ya
         Gnome %%Go,tid,Gome,Goting... -> Travel
         Travel...
        =cut
        # i @Gome:s # declares a Name
            me&Superarg,{Gome:s}
        # i @Travel <-+{@Gome,Catfunc:PiiCat} $Go
          # get @Cat to control
            if (x.ro('++')) {
                me&wants,R,'Gnome-tid++',xs&Travel
                ss&tid = (ss&tid||0) + 1
            }
            Go = Cye(Go)
            if (ss&tid) {
                !Gos&tid and debugger
                Gos&tid += "."+ss&tid
            }
            # < mutate $tid, gather the right @Cat
            me&nodei,R,xs&Travel,Go,{},{Gome:s,Catfunc:'PiiCat'}
        # i @Travelable @Cat o &wanta %%Travelable,Cat,n
        #  declares Names, also sanity for a single row
        #  will %%pur if Named things not ready looking
            # fires back with Travel/$Travelable/$Cat
            # < show this to Josh
            $n = theone(me&jaa,R,'Travelable,Cat,n'
            # must be inherited from this Go
            #  ~Go (tid++) becomes a fresh @Cat
            #   Gump or so might have motivation to reuse Gome
            #    TheFine can be shook loose in a similar fashion
            #     it has reself|Leave buttons around to do so
            #     essentially copying itself from W again,
            #      to erase (branch from) any Accepting
            #       we were thinking of committing
                .filter(n => me&etoward,ns&n,Go ))
            !n and return ha('pur:!Cat')
            # @Thy** -> @Cat** would resync if <7,
            #  usu auto resync, come back when quet,
            # < as supervisor, @Gnome grabs moment of @Thy needing resync
            
            # along with @Gome, we now know:
            $t = me&Superarg,{t:ns&Travelable}
            $Cat = me&Superarg,{Cat:ns&Cat}
        me&Superready and return
            # %%Control -> $Cat/* may now
            me&nodei,R,Cat,{Control:1,n}

            # < Cat/* checkable anywhere via &Gome_Jx
            $Inc = me&Superarg,{Inc:0},{viatw:'Cat'}
            $Pro = me&Superarg,{Pro:0},{viatw:'Cat'}
            $Run = me&Superarg,{Run:0},{viatw:'Cat'}
        me&Superready and return
            !x.ro('maynotRun',{}) and me&nodei,R,Run,'mayRun'

            $This = me&Superarg,{This:0},{viatw:'Run'}
            $The = me&Superarg,{The:0},{viatw:'Run'}
        me&Superready and return
            x = me&Gome_Jx,R
            $Run = xs&Run
            !Run and return ha('pur:!Run')
            # &Superarg puts in ar
            Run != ar.Run and return ha('pur:~Run')

        }})&&
   // 3 'See'
        # watch progress!
        # < %%Releasor the n made, u used
        #   < should only have to pause until pushed:
        #    to store J osc via Duolish** &SuperGansp
        su('See',{until:&zaa,jaa,ha,ar{
            # Reside guaratees:
            $Cat = ar.Cat
            # < Name @Cat/*
            $Inc = ar.Inc
            $Pro = ar.Pro
            $Run = ar.Run
            !Inc and return ha('pur:!Inc')
            # e:G seeks here
            4s&sheys_gotoplace = T.ab.y.up
            $F = ar.F
          // %%active are, This -> Fine, nine
            # stuff @Gnome notices about who is active
            # < look like %TX? stream -> {pi:nine,el<3} -> @Fine++ plan
            # < sort these into cv 2-6, voice by %Names
            # < lv play: el:5 - any time, el:6 - when it happens?
            # o %active/:z//C:s
            $vat = {should:1}
            # @Fine = active -nine
            vat.pi_any = {nine: &sz{ me&Superarg,{Fine:s} } }
            # +@Lab then quiet -> wake @Fine
            #  @Fine wants to OK their init
            vat.pi_new = {Lab: &sz{ me&SG_quiet_visitable,R,'+@Lab','Fine',{cos:z} } }
            $N = me&Supervator,vat
            me&SG_do_quiet_visitables,R
            
            # This -> Fine
            #  old ~ otherer
            # changes xs&This=Run/Thisy&This...
            $This = me&Gome_This,R
            !This and return ha('pur:!This')
            ha({sensitivity:'Gome_Thischa_other',otherable:'F'})
            me&Gome_Thischa_self,R,F,ha
            
            $Fine = me&Superarg_find,'Fine'
            !Fine and return ha('pur:...Fine')
            $nine = Finey&nine
            !nine and debugger
            # < Names The|This via @Cat > names from @Thy
            me&Names_set,R,'Fine',Fine
            me&Names_set,R,'nine',nine
            
            # e:S seeks TheF(/Nine)
            $nR = Fine.y.R
            4s&sheys_selfplace = sof(nRy&up)
            
          // stat
            # here at random moments, arrive plot
            $okc = me&SG_tally_oks,nine
            me&SG_draw_oks,okc
            # < including Run things of late
            me&SG_draw_comrades,[This,Run,Fine]
            
            # usu the motion of This>Nine, we wait for
            $unsure = me&Superready
            # usu first time here
            $starting = !okc.done
            
            # < proto for async state through to a @Story here
            #   see Doming & Beeping will separate
            $c = {unsure,starting}
            ex(c,{Fine,nine,This})
            
            # i RunStep o ~P > @Cat
            #  must be rolled out while P%dige same
            $Intro = me&Names_get,R,'Intro'
            $Intro = xs&Intro
            me&nodei,R,xs&Intro,{Introtiv:1,node:Cat}
            me&SG_elIntro
            
            # mode!
            Finec&w and me&SG_RunStep,c
            else {
                me&tc,"SummerCatting?"
            }
            
            # <<<
            # Thy holds what you type|open, cursors for what you're up to
            #  6s of:mem commit (auto-save)
            #  my EQ does save|save-auto|load
            # Be gen certs for code mentioned on good sites, giving trust
            # w change emerges
            #  code branch index
            #   prioritises steps and speeds up slowmo test farm
            #  to use the users
            # observe Proto !now not over finishline
            2


   // 4 the end
            # Rs&goGome and me&nu,"Fins",{Run,This,F,Fine,nine}
            x.ro('end') and return
            return ha('pur:.....')
        }})&&
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        su('Done',{until:&zaa,jaa,ha,ar{
            # n|u all done
            me&tc,"all-done"
        }})
        return su('done')
        }
  
  // @Gnome <-> @Run
      
      // RunStep
        # < an ult
        # < @Ta for hs&Ta rowing ark, h.ar the @Gnome Names
        # %%RunStep flock
        #  heading, @Run-ing as Nine-that-could-be[Run%step]
        
        # make sus:RunStep:$S
        me.iRunStep = &acgtSc{
            # the q.k means rec += ":$S"
            c = pex({RunStep:S},c)
            fatal.isnum(c.RunStep)
            return me&sustain,{},c,'k'
        }
        # flock of sus:RunStep
        me.SG_RunStep = &acgtc{
           // time is
            $R = me&R
            $h = me&hajasute
            $Fine = c.Fine
            $nine = c.nine
            $Run = c.Run = h.ar.Run
            
            me&tt,'spaz' () and me&wants,R,"FLopja",Rc&s
            # merges new -seven with its previum,
            #  as opposed to putting them in a new -Ness on hand, Ec&Into
            # < with this off, the previum should not pull the new version
            ninec&ReStep = 1
            # merges new -Eight also, as above
            #  to add new -Eight to existing Ness/-Eight*
            #  opposite of speedrunning:
            #   Story/Nine syncs This periodically
            #   dividing many Ness from long wandering with expected structure
            #    < time is of course going to be linear
            #       mid-time should not be end-posted
            ninec&ReNessy = 1
            
            # io Run%time
            $time = c.time = (Runs&time || 0)*1
            
            # < io @Fe+1|-1 $Fe1|_1? etc
            $time1 = time + 1
            c.starting && time1 != 1 and me&tc,'undone!?','B'
            # < ha('rec,RunStep:1') -> %%rec:'RunStep:1',RunStep:1
            # < &rowcap de-group-by
            
            # user
            me&tt,'again' (1) and me&sustain,{},{RunStep:time},'k'
            
            # various, clobberatively, to progress
            $susc = {}
            $N = me&suss,'RunStep',susc
            # we R%Loc=C:R.t %RunStep=$mem = C**
            $mem = me&Locio,'RunStep'
            # auto resume or start over
            if (!hak(N) && c.starting) {
                N = memy&init('RunStep:1,thru')
                    # decoy $S=0, they will c.RunStep
                    .map(c => me&iRunStep,0,c .n)
            }
            
           // RunStep/$S+ todolist + attention
            # < which expe()-ish makes 'th' -> {k:th}?
            $th = me&rowcap,[1],{},{k:'th'}
            # N[n-row] will Na[a] mixed with the n%sustain=a
            #  since we are not always iterating sustain-compatible stuff,
            #   we shall a.done ||= such for a -row (nc&drop=1)
            $row = me&rowcap,N,'RunStep',{k:'S',agk:'sustain'}
            
            # < &rowcap could make dupfiu rows per k
            me&RunStep_dedup,N
            c.Sn = {}
            each in N {
                c.Sn[ns&RunStep] = n
            }
            
            # Steps usu known
            row('Fe',&Smola{
                # < a.table etc could contain above slope...
                me&walls,my&up.y.up,'bd:2.4,hu:8'
                $n = a.n
                # the Fe that are -Ness correspond to steps
                $Fe = a.Fe = me&SG_SteptoNess,Fine,S
                Fe and me&tc,Fe.t,'6'
                else me&tc,"!Fe",'b'
                # dome this sc...
                # < replace %rec later. happens naturally?
                a.sc1 = ex({},n.sc)
                a.ov ||= 0.5
            })
            
           // peripherals
            if (0) {
                # the -nine says the next one to fill
                # < nine%Into follows Fe1 or vice versa
                $Fe1 = Cof(ninec&Into)
                !Fe1 and me&tc,"offtrail",'6g'
                # < wait for -Lab...? does %Into point to them til @3
                #   this must be part of that...
                #   
                # < of(Fe1,'-Ness') returns Fe1 if such
                $forNess = Fe1 && Fe1c&pi == 'Ness'
            }
            
            # waiting on quiet++
            # < Aip as canopy lighting timeclock
            #   it's hard to tell when a particular Run has propagated to OK
            $quiettime = theone(h.zaa('quiettime').map(q => qs&quiettime)) || 0
            Rs&is_quiet and quiettime += 1
            c.quiettime = quiettime
            h.ha({quiettime,rec:'quiettimeclock'})
            
            # say our ability to attend time
            th('atti',&vma{
                me&walls,my&up.y.up,'bd:2.4,hu:8'
                # avoids 0.5+
                me&tt,'pause' () and c.pause = 'paused'
                
                !c.quiettime and c.unsure = 'neverquiet'
                # < &tkc: for a k if in c, v may be :something
                c.unsure and me&tc,"unsure"; me&tc,c.unsure,'6'
                else me&tc,"calm"
            })
            
           // => RunningStep
            # < decide to advance, then see that we do...
            #   is ++time ... time++, becauses, political
            #  < time wanders along the sync: Run ... Fe%%ok
            # < allow vaguely accepted without //Outs
            #   @Thy** manages wanderings of many @Gnome
            # < &sustain one (bunch), til they nine%Is
            #   usu carry on if some !ok, with less Plying later,
            #    or maybe do all the Plying on the final thing,
            #     as in brackstract, the complete picture is best
            #   depending on a multi-Step intention object (Plot)
            # a bunch of RunningSteps
            # < -Effect that delivers once...
            #   such that we may keep sending last Go-er
            c.any = h.zaa('RunningStep')
            # press r to Run++
            4s&sheys_runtime = R
                # < export this closer to @Gnome itself,
                #    above this $sute which isnt always happening
                #     see wrinkle, @Gnome 8 other time
                #   getting e:r to @Gnome itself is reliable?
                $eisa_R = me&eisa,'R'
                $last_n = N.slice(-1)[0]
                # what are we working on
                # < &activate as an asky remote &sustain?
                $active_n = me&jaa,R,'RunStep,obsessed' [0]
            
            # &rowcap has its own basic a-per-row, this $o
            #  they kind join on &sustain a, this $a
            $tw = {}
            row('c',&Smola{
                $n = a.n
                
                tw[S] = n
                a.ov < 0.8 and active_n ||= n
                if (eisa_R) {
                    # R runs latest, usu... next|last when OK|ov=8
                    # < is this one
                    last_n == n and a.ov = 0.5
                    else
                    active_n == n and a.ov = 0.5; eisa_R = 0
                }
                
                # can always a.will for when !c.unsure
                if (me&tt,"will",'y' (1)) {
                    # eg added by tt:+gap start @4, make @5
                    a.ov < 0.5 and a.ov = 0.5
                    # negate the need to be at @5-6 to run
                    # < bind the glow-style of tt:will to a.will
                    #   may take a while, then leap off (like a shadow)
                    else a.will = 1
                }
                # < keep display stable while !c.unsure (while This>Fine)
                #  < style it stale if someone is watching
                if (!c.unsure && a.ov >= 0.5) {
                    # getting 0.5->0.8, looking at Fe, etc
                    me&RunStep_stabilised,R,c,h,a,n
                }
                        
                $looks = ns&looks || 0
                ns&looks = looks + 1
                me&tc,'@','6y'
                me&tc,cvf(a.ov),'6y'
                
                # manually select a step for targeted ...
                if (me&tt,'obs' (1)) {
                    active_n and delete active_ns&obsessed
                    active_n = n
                    ns&obsessed = 1
                }
                
                
                
                me&boxcap,'c|a',1 (&{
                    $late = ksaf(n.sc,{aft:'rec',inc:0})
                    $odd = nex({},sex({},n.sc,late),'RunStep')
                    me&tc,dis(odd),'6G'
                    
                    $as = tex({},a)
                    as = nex({},as,odd)
                    me&tc,dis(as),'6y'
                })
            })
            
            $seeseq = me&GapFinder
            row('keep',&Sma{
                $n = a.n
                seeseq.have(S)
                # async once with visit
                me&tt,"drop" (a.done)
            })
            
            th('tude',&vma{
                # < c.* should be brack, for an in-sute per row?
                $odd = grep(nex({},c,'Fine,nine,This'))
                hak(odd) and me&tc,dis(odd),'6G'
                if (hak(seeseq.gaps)) {
                    me&tt,"+gap" (1) && seeseq.gaps.map(&S{
                        me&sustain,{},{RunStep:S},'k' .ov = 0.4
                    })
                }
            })
           
           // => state
            # export Do clues to Fine
            me&RunStep_tw_nine_igStep,tw,nine
            # remember what we were doing
            # no step in an interesting state
            $doings = active_n
            $dont_remember = me&tt,'--mem' ()
            !doings || dont_remember and memy&iN([])
            else {
                $n = active_n
                $a = ns&sustain
                # < slicing freezable c.* out of a %%sustain
                $sc = sex({},n.sc,'RunStep,thru,obsessed')
                #me&fu,"glab",{a,sc,mem,C}
                memy&iN([sc])
            }
        }
        
        me.RunStep_stabilised = &acgtRchan{
            $Fine = c.Fine
            $Run = c.Run
            
            # notice completing this step
            # < &iot1 any/%RunningStep==$n%RunStep
            #   or sep|def them with io, so n iterates with its z
            $ofS = c.any.filter(z => zs&RunningStep == ns&RunStep)
            $z = ofS.shift()
            ofS.map(n => nc&drop = 1)
            if (z) {
                # requests quietwake
                #  purloop per pur
                h.ha('pur:RunningStep:'+zs&RunningStep)
                if (a.Runafter == Runy&R) {
                    # remain wilful, initial &wants Run sporadically doesnt
                    # < Go, time, etc
                    !c.starting and ~>0 !starting: R.t, ns&RunStep
                    a.ov != 0.6 and h.ha('pur:Runkick',{pre:Run})
                    a.ov = 0.5
                }
                elsif (zs&quiettime_now < c.quiettime) {
                    me&tc,"..7",'6G'
                    zc&drop = 1
                    a.ov = 0.7
                }
            }

            # have a moment to run this step
            if (!hak(c.any)) {
                me&tsc,"could-Run-this","?",'y'
                !num(a.ov) and debugger
                # note that elIntro originates a:RunStep.*, resetting ov low
                $ovkeen = a.ov < 0.6
                if (a.will || ovkeen && !c.pause) {
                    delete a.will
                    delete a.ers
                    # < &rowcap might have an A to use with relevant these things:
                    me&dotheRunStep,R,c,h,a,n
                }
            }

            # checkable .> ok
            if (a.ov >= 0.7 && !c.starting) {
                me&RunStep_checkup,R,c,h,a,n
            }
        }
        
        me.RunStep_checkup = &acgtRchan{
            $Fine = c.Fine
            $Run = c.Run
            # not-ok if errors
            $ok = 1
            if (a.ov < 0.8) {
                if (a.ov < 0.72) {
                    # while @Run still has:
                    $ers = me&ja,Runy&R,'er,Bang',1
                    # each step remembers errors
                    ers and a.ers = ers
                    a.ov = 0.72
                    # < could we do this too early?
                    #   it is a quiet_wake away
                }
                if (a.ers) {
                    ok = 0
                    me&erscap,a.ers
                }
            }
            # time to look for an OK
            # see &SG_tally_oks
            if (ok && a.Fe && me&isFe_ok,a.Fe ) {
                me&tc,"OK"
                a.ov < 0.8 and a.ov = 0.8
            }
            else {
                # Fine will have your attention
                # < keep going, with|after fugue
                if (c.time < 1) {
                    # Run%time isnt yet anywhere
                    # < sending a Go with particulars
                    #    situation there must match description
                    #   that complete and return to us when done
                    #    but not before the activity ->@Fine
                    #     perhaps knowing to sort wants by hire like Aip?
                    a.ov = 0.5
                    a.pur("early...")
                }
                else {
                    ns&dodge = 1
                }
            }
            if (a.ov == 0.8) {
                # shall we do the next one
                ns&obsessed and delete ns&thru
                # while we are the latest to Run
                $title_clued = ns&RunStep == c.time
                #  &Sunpit seeing another title leads on (if no next Fe)
                    && me&ja,Runy&R,'next_Ness_title_clue',1
                if (!ns&thru && title_clued) {
                    # could become thru-ey (only latest to Run)
                    me&tt,'thru?' (1) and ns&thru = 1
                }
                # usu, next is known
                $Snext = c.time+1
                $next_known = me&SG_SteptoNess,Fine,Snext
                if (ns&thru) {
                    c.tude = 'through'
                    $next = title_clued
                    # we must wait for -Lab to OK through to it
                    next_known and next = me&SG_throughNess,Fine,a.Fe
                    
                    if (next) {
                        # move on from this step
                        a.ov = 0.9
                        # to here
                        $thru = ns&thru + 1
                        me&iRunStep,Snext,{thru}
                        # < having that row ^ join this iteration
                        #    is the dome stream
                        # come around to will it into &dotheRunStep
                        h.ha('pur:next:'+Snext)
                    }
                    else {
                        c.allis = 'done'
                    }
                }
                else {
                }
            }
        }
        
        
      // RunStep f
        # given have(6), gaps=[1-5]
        me.GapFinder = &acgt{
            $i = 1
            $gaps = []
            
            
            return {
                gaps,
                have: &S{
                    !num(S) and throw "!num", S
                    # dup?
                    S == i-1 and return
                    S < i and debugger
                    while (i != S) {
                        gaps.push(i)
                        i++ > 64 and throw "manysteps"
                    }
                    # the S+1
                    i++
                },
            }
        }
        # < need a sequence generator, number ranges in [...new Array(i)]
        me.RunStep_tw_nine_igStep = &acgt,tw,nine{
            $i = 1
            $ig = {}
            
            
            
            
            
            
            haks(tw).sort().map(&ii,{
                ii == i and i++
                else {
                    while (i < ii) {
                        ig[i] = 1
                        i++
                    }
                }
            })
            !hak(ig) and delete nines&igStep
            else nines&igStep = ig
        }
        # prefer more recent
        me.RunStep_dedup = &acgtN{
            $SK = vpartN(N,n => ns&RunStep)
            each ik SK.ks {
                $N = SK.vs[i]
                # %%further adopted by more recent
                # < io expr for:
                $going = grepout(N,n=>ns&thru)
                if (hak(going) == 1 && hak(N) == 1) {
                    going = going[0]
                    $quest = N[0]
                    # quest comes in with specifics in mind
                    goings&looks < quests&looks and debugger
                    goingc&drop = 'out-quested'
                    # < does it last?
                    quests&thru = 1
                }
            }
        }
        # < simply wanting a RunningStep from a RunStep
        me.dotheRunStep = &acgtRchan{
            $Run = c.Run
            me&tc,"Run++"
            h.ha('pur:Run++')
            # < many steps
            # < -Effect it there
            # Run increments itself
            Runs&time = ns&RunStep - 1
            
            # drop -Eight/$S-seven
            me&forgetRunStep,Run,ns&RunStep

            # if ro Run oncer on
            # < pass singleton through %%Go
            $r = Runy&R
            a.Runafter = r
            rs&Run = 1
            # go there
            me&wants,R,'Run++',Run

            # we are now:
            a.ov = 0.6
            $RingS = {
                RunningStep: ns&RunStep,
                quiettime_now: c.quiettime,
            }
            $gs = me&sustain,{},RingS
            c.any.push(gs.n)
        }
        # drop -Eight/$S-seven
        me.forgetRunStep = &acgt,Run,S{
            fatal.isnum(S)
            $This = me&fiu,Run,'This',7
            $goners = me&Sharg,'$s/*/*',[This] .N
                .filter(&s{
                    sc&pi != 'seven' and debugger
                    return s.t == S
                })
            
            # reorder hack, else bottom-posting, see resolve $n
            $empties = s => me&ioty,s .map(z => me&fiu,s,z,9 )
            goners.map(&s{
                empties(s)
                $E = me&REof,s
                empties(E)
                
                # drop Erefs
                me&Ereftakedown,E
            })
            
            # < drop also Effects, &nodei to it, &nodeo from it?
            #   or do they sometimes fall back into place?
        }
      
      // &Locio proto mem:
        # proto mem:, json (t,y,sc)** <-> brack-ish N[sc+]
        # avoids work, you should checkout = Dy&oN|init() perhaps once,
        #  then iN() to 7 every time
        me.Locio = &acgtt{
            $R = me&R
            # to sample attention from
            $Loc = me&rollbsc,R,'Loc'
            # this is a global address, in remember/$W/$t
            Locc&W = R.t
            $D = Loc.sc[t]
            D ||= me&remember,Loc,t
            # when we should save
            #  eg Plot ticks
            Dy&save ||= &{ me&remember,Loc,t }
            # brack-ish N[sc+]
            Dy&iN ||= &N{
                # drain mem/*
                $were = (Ds&z||[]) .map(n => n.sc)
                # N = [0] means []
                N = grep(N)
                if (!hak(N)) {
                    # add nothing
                    !hak(were) and return
                    Ds&z = []
                    Dy&save()
                }
                else {
                    $eq = hak(were) == hak(N)
                    each ic N {
                        !eq and break
                        !heq(c,were[i]) and eq = 0
                    }
                    eq and return
                    Ds&z = N.map(c => Cye(['stuss',1,{},c]))
                    Ds&z.map(n => !hak(ns&z) && delete ns&z );
                    Dy&save()
                }
            }
            Dy&oN = &{
                $N = me&ioty,D .map(n => n.sc)
                # < wherefrom is this? Cye()?
                N.map(c => c.z && delete c.z)
                return N
            }
            
            # auto begin from memory, or your cdefault
            Dy&init = &cdefault,{
                $N = Dy&oN()
                if (hak(N)) {
                    N.map(c => c.remembered = 1)
                    return N
                }
                
                $N = fuN(cdefault) .map(c => pex(c))
                # may be [] if !cdefault
                return N
            }
            
            return D
        }
      
      // misc %%quiet_visitable
        # check @Gnome is async to Fine, etc
        me.SG_draw_comrades = &acgtN{
            $R = me&R
            N.map(s => sy&ers || s)
                .filter(s => Rc&N.includes(me&yfuture,s ))
                .map(&r{
                    debugger
                })
            return
            me&rowcap,N ('Name',&sm{
                # < Names may be The//E, or from it?
                # go Out
                sy&ers and s = sy&ers
                $t = me&Name_of,s
                me&tc,"@"+t,'G'
                # we async
                $heretoo = Rc&N.includes(me&yfuture,s )
                heretoo and debugger
            })
        }
        # < generalise to two parts
        # remember somewhere to wake after the next quiet
        me.SG_quiet_visitable = &acgtRt,to,c{
            $h = T.sute
            # < to will find %Names if string
            c = ex({rec:t,quiet_visitable:to},c||{})
            # spur from the Gnome@8 throat as %%pur
            c.pur = t+'...'
            h.ha(c)
        }
        # progress the above state
        # < provided by &supetime?
        # < see < there is a way to want a node to wake
        me.SG_do_quiet_visitables = &acgtR{
            $h = T.sute
            !Rs&is_quiet and return
            h.zaa('quiet_visitable') .map(&n{
                $to = ns&quiet_visitable
                isst(to) and to = me&Superarg_find,to
                !to and return h.ha({pur:"!arg:"+dis(to.sc)})
                me&wants,R,'visitable:'+ns&rec,to
                # < does an == %%rec per dome drop others?
                nc&drop = 1
            })
        }
      
      // @Fine Ness
        # Nesswork
        # Steps start from 1, may return nothing
        me.SG_SteptoNess = &acgt,Fine,S{
            fatal.ispi(Fine,'nine')
            fatal.isnum(S)
            return me&iot,Fine,'-Ness' [S-1]
        }
        me.SG_NesstoStep = &acgt,Fine,Ness{
            fatal.ispi(Fine,'nine')
            fatal.ispi(Ness,'Ness')
            $N = me&iot,Fine,'-Ness'
            $i = N.indexOf(Ness)
            0>i and throw "!Ness",Ness,N,Fine
            return i+1
        }
        # from this Fe-Ness til the next one
        me.SG_throughNess = &acgt,Fine,Fe{
            fatal.ispi(Fine,'nine')
            fatal.ispi(Fe,'Ness')
            $N = ksaf(me&ioty,Fine ,{aft:Fe,inc:0})
            each in N {
                ispi(n,'Ness') and return n
                # eg -Lab must ok first
                !me&isFe_ok,n and break
            }
        }
      
      // @Fine Fe ok
        me.isFe_ok = &acgt,Fe{
            $j = Fe && Fey&R
            !j and return 0
            !js&TheFe and debugger
            # < &zam,['ready','ok']
            $ok = me&za,j,'ready' && me&za,j,'ok'
            return ok
        }
        # check nine%Is
        me.SG_tally_oks = &acgt,nine{
            $h = T.sute
            # o @nine/Ness/@n//Outs == @Fine/@Fe
            $more_ok = 0
            $oks = 0
            each in nines&Is {
                $Fe = ny&Outs
                # new steps must be accepted and @Fine reselfed
                #  before they appear, non-%eph
                # o Ness %%ready %%ok
                $ok = me&isFe_ok,Fe
                !ok and break
                ok and oks += 1
                # < we should D the ok steps, may be avoided if reself
                $be = {became_ok:Fe,rec:'becomesing'}
                !h.zaa(be) and h.ha(be); more_ok = 1
            }
            # the outsphere|accepted bunch of @Fine/@Ness
            # < rename from The (as part of a rebuild)
            $bunch = me&fiu,nine,'The',7
            $total = hak( me&ioty,bunch )
            return {more_ok,oks,done:hak(nines&Is),total}
        }
        # draw the above
        me.SG_draw_oks = &acgtc{
            # see also &Acceptings
            # < ts?
            $t = (t,s) => me&tc,t .c.s = s
            
            me&boxcap,'prog','g' (&m{
                me&walls,m,'bd:9'
                ms&ma = 0.2
                me&ts,"OKs",c.oks
                if (c.done != c.total) {
                    me&tc,'/','6y'
                    me&ts,"done",c.done
                }
                if (c.oks != c.total) {
                    me&tc,'/','6y'
                    me&ts,"total",c.total
                }
                c.oks == c.done and me&tc,"OK",'g'
                c.oks != c.total and me&tc,"...",'g'
                # < completes? additions?
            })
        }
      
      // elIntro <- @Intro
        =pod
          < have a tiny pile of what might effect what
             might know which time was edited easy
          < finish stylehouse: style -> X -> A
            style, the folk name for sc
        =cut
        me.SG_elIntro = &acgt{
            $h = me&hajasute
            # < here is a good time, may be sure
            # auto!
            # < sprout another Fine to mock elIntro here and oft supply at @Inc
            me&boxcap,'elIntro','1s' (&m{
                me&walls,m,'bd:3.3'

                # @Gnome receives notifies for @Inc
                me&SG_ei_elIntro
                # @Inc must happen while gs is stable
                # < join the subjobbies into &sustrain
                #   eg IncBefore i(gs,0) when it sees it is el==2
                #    < which should be a want for an after-initial Inc
                #      and periodic ambition to go get it
                me&sustaining,'elIntro' .map(
                    gs => me&SG_sustain_elIntro,gs
                )
            })
        }
        # takes %%elIntro when diff comes up
        # produce %%RunStep when @Inc ready, per $gs
        me.SG_sustain_elIntro = &acgt,gs{
            $h = me&hajasute
            $R = me&R
            
            # dropped from origin? since nc&drop, none &sustaining
            # < poison mode, waits for clients to pack up
            gs.el > 8 and debugger; return
            !gs.Q and debugger
            
            # &sustain {} {elIntro:gs} # to sample $gs
            # &sustain gs {untility:v} # to inherit gs id
            #  and then $a=v if ish()
            #  el=2 if v changes (amongst something true)

            # < there is a way to want a node to wake
            #    see &wokesince
            # classic leave this time
            $be = me&sustain,gs,{IncBefore:1}
            if (be.el == 2) {
                ~>2 elIntro->Inc: gs.Q.t
                $to = h.ar.Inc
                !to and debugger
                me&wants,R,'elIntro->Inc',to
                # < pur({wants})
                be.pur("->Inc")
                return
            }
            
            # arrive after
            $IncAfter = Rs&is_quiet && 1
            $af = me&sustain,gs,{IncAfter},2
            af.el > 8 and return af.pur("Thingoe")
            # managed to @Inc,quiet without ~gs
            # < double check from a be{el2} stashed Incy&R
            
            # < not necessary to draw steps only now
            
            # < any steps disturbed should sustain more
            af.el == 2 and ~>2 elIntro->Run: joint(gs.steps,', ')
            # < should never happen?
            #   the above always takes time
            #    since be would el:2?
            #   supposing the original $gs stays the same,
            #    or changes completely in a way we select for
            #     see &sustain / if hak(s) / tex()
            gs.el == 2 and me&tc,"elIntro!"
            #; debugger
            if (!gs.steps) {
                $Q = gs.Q
                $P = Qs&P
                return me&tc,'!steps','B'
            }
            # < flavours of done().. and their ui
            #    how far up the stem you drag it
            #    something about the angle it snaps off
            #    adding a comment to each one
            #     scaling up comspheres from there til sustain:tagasastes
            # < perhaps this needs a gardening Story
            me&tt,"drops" (gs.done)
            me&tt,"DROPs" (gs.a.done)
            me&tt,'aband' (&{ gs.done(); gs.a.done() })
            gs.steps.map(&i{
                $S = me&sustain,gs,{RunStep:i},'k'
                $n = S.n
                me&boxcap,"step:"+i (&m{
                    me&walls,m,'b:2.2h5'
                    S.ov >= 0.8 and me&tc,"done"
                    else me&tc,".."
                    me&tt,"drop" (gs.done)
                    me&tt,'o' () and me&tc,dis(nex({},n.sc,'dome,supe,sute,rec,sustain')),'6G'
                })
            })
            ~>6 elIntro: dis(tex({},gs))
            
        }
        # hold latest Q per Q.t, finding what steps it changes
        # get $gs, diff from ec&e=Q
        me.SG_ei_elIntro = &acgt{
            $R = me&R
            $h = T.sute
            # each sustain is a grouping and keeping in time!
            
            # starting with change events to start unpacking
            # < better elvis routing: e**:locating/e:meaning
            me&sustrain ({
                i: me&eis,'elIntro' ,
                # extra step, ^ persists
                #  usu ignore the first one if i empty, laters still &osus it
                graspQ: &yea{
                    $Q = ec&e
                    # less index|many-ing than later
                    y ({Qt:Q.t},Q)
                    #~>5 graspQ: e.t
                },
                elIntro: &yea{
                    #~>5 ElIntro: e.t
            # < have certain P%dige changes for steps
            #   is where we want to have a /$node, inc @Fe that come up
            me&boxQ,e (&QPm{
                
                me&walls,m,'bd:3.3'
                ms&ope and me&fu,'diffPs',{di,e,gs}
                Qc&of != 'wjs' and me&tc,"!wjs",'B'; return
                # async once, with visit
                me&tt,"drop" (a.done)
                
                # does two things:
                #  sequentials Q|P strings
                #   and resets Qy&diffPs.doing = {}
                #  creates a diff 
                #   by way of the above, starts diffing Q-P, then laP-P
                # Q stays the first version, see 'Q seems to never update'
                # < might just be for the warmup &t from Pro
                $di = me&diffPs,R,Q,P,Q
                !di and return h.ha('pur:!diffP?')
                # gs.of|t|etc = &Qidc
                # < Babz $gs = di.gs or return { &fu,nogs:Q\n &tc,"Nogs",'B' }
                #    rows of lines of code diverges in the return BLOCK
                #     and etc ways to scrunch stuff together
                #   would unpack to the:
                $gs = di.gs
                !gs and me&fu,{nogs:Q}; return me&tc,"Nogs",'B'
                if (di.Comp) {
                    # might be an el:2
                    gs.steps ||= me&diffPs_knowsteps,di
                }
                else {
                    a.done('==')
                    return me&tc,'=='
                }
                gs.Q = Q
                # make this %sustain,elIntro
                y (gs)
                #~>6 ei_elIntro: dis(tex({},gs))
            })
            
                },
            })
        }
        
        
 },
  
  // Supe@Lab
   // 3 'Lab' @Lab
    &{
        me.SuperLab = &acgtRsce{
            $x = me&Jx,R
            c.t ||= 'Lab'
            $su = me&supetime,R,c.t
            su('One',{until:&zaa,jaa,ha,ar{
                # < &activate would know about %%inst leaving
                c.el == 9 and return me&tc,"cancel"
                me&activate and return ha('pur:noteven')
                me&Supervate,{}
                ha('pur:')
            }})&&
            su('Done',{until:&zaa,jaa,ha,ar{
                # n|u all done
                me&tc,"all-done"
            }})
            
            return su('done')
        }
    },
  // @Gnome/(@Thy...@Lab)%Piing
    # where non -Ness Fine/$t are staged for Piing/The...
    ['TheThy',0.2901,&acgtRs{
        me&reaw,R,'TheThy'
        me&acting,R
        # < for %Gome
        !me.cbu(R,'Gnome') and return me&tc,"!Piing",'b'
        Rs&wakeful = 1
        Rs&Piing = 1
    },'ift,D'],
    ['TheThy+Piing',0.292,&acgtRs{
        # @Thy, which always runs with @Gnome,
        # < posits a new @Lab time
        Rs&Sarndat = me&Sarn,<<'',[R]
            i @Thy/-This/#@Fine-Labine/@-Lab#@n%ThyLab/c&s=@n
        
    },'ift,D'],
    # receives %%inst as an Ec&uber
    ['ThyLab',0.295,&acgtRs{
        me&activate
    },'ift,D'],
    ['ThyLab',0.5,&acgtRs{
        $c = {}
        Rs&ThyLab_going and c.el = 9; me&tc,"--shutdown"
        !me&SuperLab,R,s,c and return
        # < drain process
        c.el == 9 and Rs&ThyLab_gone = 1; me&tc,"Deletables"
    },'ift,D'],
  // Pi%Lab
    &{
    me.Pi_Lab = &acgt{ return [
       // -Lab
        # loads Nine/-Lab, into -Bat preparator!
        #  or, posit Nine/-Lab from -Bat
        #   will need to select all etivity about time...
        #   
        ['Lab',0.22,&acgtRs{
            
            $V = Rs&V
            $E = Rs&E
            $D = Rs&D
            me&tc,'Lab','g'
            # outsphere: loads Nine/s-Lab
            $e = me&Ei,{t:'Outs',pi:'Labe',s:s}
            Ey&OutsE = e
            me&Eing,9
            
            # insphere: -Bat preparator
            $e = me&Ei,{t:'Ins',pi:'Labi',s:ey&D}
            Ey&InsE = e
            me&Eing,9
            
            # outsphere: -Bat compressor
            $e = me&Ei,{t:'Ino',pi:'Labo',s:ey&D}
            Ey&InoE = e
            me&Eing,9
            
            if (V) {
                # let TheFine sense this state, like -Eight%dige
                #  its &piLab will use instead:
                $details = [Ey&InsE,Ey&InoE]
                Vs&dige = dig(details.map(e => ey&thing)
                    .map(t => ts&dige).join("")
                )
            }
        },'ift,D'],
        ['Lab',0.55,&acgtRs{
            $E = Rs&E
            $D = Rs&D
            
            #me&hu,"Lavee",E,{dl:1}
        },'ift,D'],
       
       // %bell etc
        # < -hat with separate lum + layout tricks for %z
        ['bell',0.23,&acgtRs{
            $E = Rs&E
            $D = Rs&D
            if (!isC(s)) {
                $b = Ec&b
                $z = Rc&s = Ec&s = b && bc&s || Cye([E.t,1])
                me&tc,'eph','6y'
                zc&s = s
            }
        },'ift,D'],
        ['bell',0.265,&acgtRs{
            $E = Rs&E
            $D = Rs&D
            # for D impersonating s
            me&Dapes,R
            # < Rsci backed me&Eo,'^E%bell'
            !Ry&up.sc.bell and Rs&top_bell = 1
            if (Rs&top_bell) {
                Rs&encodeD = 1
                $be = me&tsc,"show-C",'','g'
                # < make this about doing -hat for them
                #   -Bet finds specifics, default s**-ness
                # < the -hat wants to be minimal,
                #   no same .t, simple $c%$sc
                # < find that function for doing this:
                (Rs&ope||0) >= 1 and Rs&show_s = 1
            }
            
            # s
            # < o %show_s o R^^%top_bell
            $tob = me.cbu(R,'top_bell')
            tobs&show_s and Rs&show_s = 1
            if (Rs&show_s) {
                if (!Rs&strange) {
                    me&TXin,'Csubtle',{layout:'C'} ({
                        s: {z:{
                            y: {ope:-1},
                            sc: {z:{
                                z: {impl:1},
                            }},
                        }},
                    })
                }
                me&hu,"s",s,{dl:1}
            }
            
            # s**
            if (Rs&climbD) {
                $N = me&climbD,s
            }
            else {
                $N = me&ioty,s
            }
            N.map(&n{
                me&Ei,{t:n.t,s:n,noref:1}
            })
            Rs&rowish = 1
        },'ift,D'],
        &{
            # for D impersonating s
            me.Dapes = &acgtR{
                $D = Rs&D
                $s = Rc&s
                D.t = s.t
                each kv s.c {
                    D.c[k] = v
                }
                each kv s.sc {
                    k == 'z' and continue
                    D.sc[k] = v
                }
                !Dc&pi and delete Dc&pi
            }
            # D** is only via E**
            # < warn when D**... they should compress
            me.climbD = &acgtD{
                $E = Dy&E
                !E and throw "D!E"
                # also, same pi, for E** strewn with not-things
                return me&ioty,E
                    .filter(e => Ec&pi == ec&pi && ey&D)
                    .map(e => ey&D)
            }
        },
        # after Top@44 fills in E**y&thing
        ['bell+show_s',0.45,&acgtRs{
            $E = Rs&E
            # for Ey&thing encoding here
            Ey&thing and Rs&show_thing = 1
        },'ift,D'],
        ['show_thing',0.45,&acgtRs{
            $E = Rs&E
            me&hu,"Eything",Ey&thing.sc.string
        },'ift,D'],
       
       // -n 
        ['n',0.321,&acgtRs{
            $E = Rs&E
            $D = Rs&D
            $x = me&Gome_Jx,R
            me&Pi_n,R,s,E,x
            me&tc,"Hasann"
            Rs&strange and Ds&strange = joint(Rs&strange,', ')
        },'ift,D'],
        &{
        me.Pi_n = &acgtRsEx{
            # name|path in nodelist
            # < nodelist <- &Gome_Jx aliases, eg client
            # < pick something from xs&*
            $name = isC(s) ? sc&s : s
            !isst(name) and return me&strange,"!name:"+name
            # Node/with/tpath
            $nodepath = name.split('/')
            if (hak(nodepath) > 1) {
                name = nodepath.shift()
                $twpath = nodepath
            }
            # @Node
            $n = x.sc[name]
            !n and return me&strange,"!find:"+name
            # /with/tpath
            each it twpath {
                $z = me&fiu,n,t,8
                if (!z && ny&R) {
                    $r = ny&R
                    # < %eph-lenient o s/z connections
                    z = me&ioty,r .filter(r => r.t == t)
                        .map(r => rc&s) [0]
                }
                !z and return me&strange,"!climb:"+n.t+"/"+t+"("+i+")"
                n = z
            }
            Es&target = n
        }
        },
       
       // %Labe decompress
        ['Labe',0.22,&acgtRs{
            $E = Rs&E
            $D = Rs&D
            Rs&bell = 1
        },'ift,D'],
        &{
            # decompress strategies
            # apply to E/e
            me.defaultDpi = &acgtEc{
                isst(c) and c = {pi:c}
                c.Epi ||= T.act.t
                $N = me&pity,E,'-'+c.Epi
                N.map(&e{
                    $D = ey&D
                    $s = ec&s
                    # &Ei'd this act
                    !D and return
                    $api = Dc&pi || sc&pi
                    api and return
                    # may be implied from above
                    ec&Dpi = c.pi
                })
            }
            # sc&pi -> Dc&pi and R%$pi=1 for a while
            me.typeup_Dpi = &acgtRs{
                $E = Rs&E
                $D = Rs&D
                # may be implied from above
                Ec&Dpi and Dc&pi = Ec&Dpi
                $api = Dc&pi || sc&pi
                # sc&pi -> Dc&pi and R%$pi=1
                api and me&typeup,R,api
                api == 'Lab' and delete Rs&Lab
                !api and me&strange,"Labe!pi"
                Rs&pretendpi = api
            }
        },
        ['Labe',0.31,&acgtRs{
            $E = Rs&E
            $D = Rs&D
            me&typeup_Dpi,R,s
            # < do all @260* before R/* do
            if (Rs&nodei) {
                # ways to spec $to:
                #  /eto, /-n, c&s, .t
                $to = me&fiu,s,'eto',8
                if (to) {
                    # C:eto implies -n
                    $toE = me&pity,E,'-Labe'
                        .filter(e => ec&s == s)[0]
                    toEc&Dpi = 'n'
                }
                to ||= me&pity,s,'-n' [0]
                if (!to) {
                    to = sc&s || s.t
                    me&Ei,{t:"eto",Dpi:'n',s:to,implied:1}
                }
                # -nodei/-row implied
                me&defaultDpi,E,'row'
                me&tc,'nodei','y'
            }
            if (Rs&row) {
                # < no E/* implies D%* is the row.sc
                # < it might have -row/-n, eto or not
                me&tc,'row','y'
            }
            if (Rs&n) {
                me&tc,'n','y'
            }
            me&Eing,6
        },'ift,D'],
        ['Labe+pretendpi',0.319,&acgtRs{
            delete R.sc[Rs&pretendpi]
        },'ift,D'],
       // %Labi make to|from -Bat
        ['Labi',0.22,&acgtRs{
            $E = Rs&E
            Rs&bell = 1
            Rs&climbD = 1
            $p = Ry&up
            if (ps&top_bell) {
                # due to Nine/-Lab (top of the outsphere)
                # wanting to include %tige,dige
                Ec&encode_thing_here = 1
            }
        },'ift,D'],
        ['Labi',0.32,&acgtRs{
            $E = Rs&E
            $D = Rs&D
            me&typeup_Dpi,R,s
            # < %bell generic adjustments to D**
            #    %Labo then pushes, it appears in %Labe
            #     so Ting finish when effect is incorporated
            #     y&thing may have commit log for such
            
            me&Eing,6
        },'ift,D'],
        ['Labi+nodei',0.326,&acgtRs{
            $E = Rs&E
            $D = Rs&D
            # destination
            $eto = me&fiu,E,'eto'
            !eto and me&strange,"!eto"
            $t = eto && etos&target
            !t and me&strange,"eto!target"
            !isnode(t) and me&strange,"eto%target!node"
            # stuff to send
            $rows = me&climbD,D .filter(d => dc&pi == 'row')
            !hak(rows) and me&strange,"!-row"
            
            # externalisings defined, undertaken
            me&Superdef,{f:'nodei',to:t,wakenode:1} (&rR{
                # r%Piing//..R%Pier%Labi
                each in rows {
                    me&nodei,r,t,n.sc
                }
            })
            me&anystrange and return Ds&fail = 1
        },'ift,D'],
        ['Labi+pretendpi',0.329,&acgtRs{
            delete R.sc[Rs&pretendpi]
        },'ift,D'],
       // %Labo compress again
        ['Labo',0.22,&acgtRs{
            $E = Rs&E
            Rs&bell = 1
            Rs&climbD = 1
            $p = Ry&up
            if (ps&top_bell) {
                # due to Nine/-Lab (top of the outsphere)
                # wanting to include %tige,dige
                Ec&encode_thing_here = 1
            }
        },'ift,D'],
        
        
        
        ['Labo',0.37,&acgtRs{
            $E = Rs&E
            $D = Rs&D
            Ec&noencode and return me&tc,'eph','6y'
            me&typeup_Dpi,R,s
            if (Rs&nodei) {
                $eto = me&fiu,E,'eto',8
                !eto and return me&strange,"!eto"
                $z = etoy&D
                # < trying to follow|update how %Labe did it
                zc&s == s.t and etoc&noencode = 1
            }
        },'ift,D'],
        ['Labo+pretendpi',0.379,&acgtRs{
            delete R.sc[Rs&pretendpi]
        },'ift,D'],
    ] }
    },
  
  # < io deal
  // @Nine <-> @Thy
    &{
    # Gnome/Thy/This/#@Fine/Lab
    # see &EsyncThis c.ThyF, puts @Lab -> E/Ness/* -> Nine/*
    me.Fine_pre_nine = &acgtREsx,Ninec{
        $Thy = xs&Thy
        # stuff we're projecting to The
        $Thys = me&fiu,Thy,'This',8
        $ThyF = Thys && me&fiu,Thys,s.t,8
        #return me&tc,"Avoiding-ThyF-return"
        # < create that per Fine so we can capture The for it
        if (ThyF) {
            Ninec.ThyF = ThyF
            sy&ThyF = ThyF
        }
        me&Names_set,R,'Fine',s
        
        # ++Fine drops the -nine after %Fest is Pushed!
        # < -pipe should tell us when to pull?
        # track the decoded object
        me&ha,R,{TheLive:sy&Live}
        if (me&da,R,{TheLive:1}) {
            delete sy&nine
            me&ha,R,"nexttimeDIY"
            me&wants,R,"PUSHpull",s
        }
        me&za,R,"nexttimeDIY" and me&tc,"pushPULL"; Ninec.DIY = 1
    }
    # Nine%TheFine has E-nine'd
    me.Fine_aft_nine = &acgtREsx{
        # e Thy/This for $Nine/
        $Thy = xs&Thy
        $Thys = Thy && me&fiu,Thy,'This'
        !Thys and debugger; return me&tc,'!Thys','b'
        
        me&SuperNine,R,s,{}
        
        me&seeknewIs,R,E,s,Thy
        me&FespringLabs,R,E,s,Thy
    }
    # < this until Fe Ply narrows to a bunch of -six
    # which set of This** should we look at on e:f
    me.seeknewIs = &acgtREs,Thy{
        !Es&Is and return
        $la = Es&Is .slice(-1)[0]
        $sevens = la && me&ioty,la,['','']
        $as = sevens && sevens .slice(-1)[0]
        as and as = Cof(as).y.ers
        !as and return
        # this also gets set from Fe Ply, first ~ -six it finds
        #  ie into the time-seven, past passing tests
        $was = 4s&sheys_furtherplace
        $inside = was && was != as && me&fiu,as,was,8
        inside and 'leaving -seven/* got'
        else {
            was != as and ~>6 taking -seven: la.t, asy&up.t, as.t
            4s&sheys_furtherplace = as
        }
    }
    # start next -Lab++ after ok Fe
    # i Thy...$s-Lab o %Is/>%ok/[0]
    # < one by one
    me.FespringLabs = &acgtREs,Thy{
        $N = me&ioty,R,'TheFe'
        $sN = me&ioty,s
        each ir N {
            $n = rs&exp
            !n and break
            
            $was = grepout(sN,n)
            hak(was) != 1 and debugger
            if (nc&pi == 'Ness') {
                $or = r
                $r = ny&R
                r != or and debugger
                $ok = r && me&ja,r,'Dige' && me&ja,r,'ready' && me&ja,r,'ok' 
                !ok and me&tc,"waitsfor:"+r.t,6
                !ok and break
                continue
            }
            #return 'switched off Fe->Lab'
            # externalisings defined, undertaken
            me&Superdef,{f:'Flight',of:'inst',to:Thy,wakenode:1} (&{
                # %%n%tige brackstills
                me&nodei,R,Thy,{inst:1,n}
            })
        }
    }
  // @Nine <-> @Fe < -Ply
    # Nine/Fe Accepting ~
    #  handles here (as well as by w:Paving...)
    me.Fe_Accepting = &acgtREstz{
        # < or Name:Do
        $Gnome = sof(me.cbu(R,'client'))
        
        # map the diff into got**
        me&Bangrasp,'Fe_mergent' (&{
            me&Fe_mergent,R,E,s,t,z
        })
        
        # once it is Accepting=$dige,s,t
        !me&Fe_isAccepting,R and return
        # ... see ABORTED push automation
    }
    # < real as the E|exp**:n walk
    me.Fe_mergent = &acgtREstz{
        $x = me&Jx
        # < o E, /Ness:/#@t
        $EN = me&fiu,E,'Ness',7
        # < to tv
        $Ness = me&fiu,EN,z.t,7
        # Ness/** y&C to This/**
        $This = me&fiu,E,'This',7
        
        $Diff = theone( me&ioty,R,'Diff' )
        me&rollbs,R,'Ply,DiffDigs'
        if (!Diff) {
            # wait for it? if we have t:exp and a z:got
            t and return me&tc,"!Diff",'y'
            # no t:exp, make an all-new diff
            delete Rs&Ply
            # mock output of diff()
            $N = [Cye(['new',1,{s:zs&string}])]
            Comp = me&textdiffN,N,{fold:1}
        }
        else {
            # hang Ply caching on Diff caching
            
            # < GOING?
            # z is just the outsphere exp
            # get a Q for the insphere exp
            #  shortly after its outsphere mis-diges
            #   due to including the insphere dige
            $exp = Diffs&exp
            expc&of != 'W' and debugger
            # then the C** insphere (with y&deLines)
            $w = expc&s
            !isC(w) and debugger
        
            # <<<<
            # slep follow Diff, following Ness + $got
            $Comp = Diffs&Comp
            # < follow Comp itself? ref changes when Diff%boost
            (Diffs&boost||0) > 0 and delete Rs&Ply
            Rs&DiffDigs != Diffs&Digs and delete Rs&Ply
            Rs&DiffDigs = Diffs&Digs
        }
    // &Plymergent
        # to show or no
        me&boxcap,'Ply-mergent' (&ml{
            me&walls,m,'b:3.4'
            lc&s = 'Ply'
            $hideguts = !me&tt,'guts' ()
            # < interaction is low. what does The++ need computing etc.
            !hideguts and delete Rs&Ply
            $Ply = Rs&Ply ||= me&Plymergent,R,E,s,Ness,Comp
            hideguts and Plyc&not = 1
            # if not &boxcap this time, put in m
            Plyy&origin ||= R
            Plyy&origin != R and ac(m,'z',Ply)
            
            $Th = Cof( Cof( me&fiu,E,'This' ))
            
     //     Plyy&offendEd
            # sustain its Effect - pointing to p!
            me&boxcap,'offend',1 (&ml{
            me&walls,m,'b:3.3'
            ls&ml = 2
            lc&s = ''
            me&scroll,m
            
            !me&tt,"offend?" () and $dont = 1
            
            $N = ahsk(Ply,'y','offendEd') || []
            !hak(N) and me&tc,"none!?",'B'
            me&tc,"~x"+hak(N)
            # < should be an iterator, seeking @Ply/offend <-> This**
            $maxsend = 11
            if (hak(N) > maxsend) {
                if (me&tt,'sendall?' ()) {
                    maxsend = 100
                }
            }
            
            $firstsix = 1
            each ic N {
                # < link this to the &tt,'sendall?'
                maxsend == i and me&tc,"<offend-send-cursor>",'16G'
                me&boxcap,"off"+i,1 (&m{
                    $E = c.E
                    $d = c.d

                    $tpa = slant(me&ttpath,E .slope)
                    #me&tc,tpa+"\n",'6y'

                    # < slope vis, brackstract pile
                    #  < point to gupile, glowing bits
                    $see = {}
                    me&uptonode,E,see
                    # < chop at @This easier
                    $path = see.path
                    path.includes(Th) and path = ksaf(path,{aft:Th,inc:1})
                    #me&fu,"Thi"+i,{ye,path,Th}
                    
                    me&tc,slant(path),'6y'
                    if (hak(see.beyond)) {
                        me&tc,'/','G'
                        me&tc,slant(see.beyond),'6y'
                    }
                    if (ds&pi == 'six') {
                        me&tc,'-six','G'
                        if (firstsix) {
                            firstsix = 0
                            # e:f takes you there
                            #  instead of just latestNess/*/*-seven [0]
                            # < shaping everything so you see This...E
                            4s&sheys_furtherplace = me&uptonode,E
                            ms&bgh = 873
                        }
                    }
                    
                    if (i >= maxsend) {
                        ms&opa = 0.7
                    }
                    elsif (!dont) {
                        # sending to $node:-six/E-Fez
                        # < any This** that changes when we do this is sus
                        me&Effect,s,E,'showy-'+ds&pi,{show:1,ope:1,arrowy:1}
                    }
                })
            }
            })
        
        })
        # < is parsing the diff (from and) into two trees,
        #     to $z|$exp
        #      < &deL giving y&toLines
        #     and $t|$got, which we Lineso'd from things in This/**
        #      applying lv kind of mind
        #     so eg $got...seveny&thing is joined on
        #      as a pool of sense to help finding stringsat the -Ness/#@Eight
        # < -Effect to /This/
        $out = 34
        Comp = Comp.slice(out,out+8)
        #me&bal,'mergent',{eph:1,Zuist:{Ness,Comp}}
        #{Ness,t,z,exp,Diff,This}
        3
    }
    # returns [$n+] or null, permiting 'Accepting'
    # < move to w:Pavings
    me.Fe_isAccepting = &acgtR{
        # < we dont know both s+t when the Fe el2
        #    I forget which is exp|got, or if they are actually Ins|Outs
        $have = me&jaa,R,'Accepting,s,t',1
        have = theone(have)
        $pushing = have && me&ja,R,{Accepting:have,go:1},1
        return theone(pushing)
    }
    # watching from @Gnome
    # < GOING except for study into test case
    #   hardwired it a couple of days later
    =pod ABORTED push automation
        in @Gnome:See:
            # we automate Accepting:
            # < the above @Intro sense might help tick:
            try {
            $N = me&Effected,s,{iSeeFe:1,mode:'uniq'}
            N && N.map(Fe => me&SuperGnome_iSeeFe,R,s,Fe,c)
            }
            catch(er) {
                # < errors in there are window-fatal to Superquiets?
                ha({pur:'error',er})
            }
        in &Fe_Accepting
        
            # tell @Gnome:See to automate this push
            #me&Effect,s,Gnome,'Fe-Accepting',{iSeeFe:s}
            # leads back to &SuperGnome_iSeeFe
         
     me.SuperGnome_iSeeFe = &acgtRszc{
        $h = me&hajasute
        $Fe = zy&R
        # sanity checks
        !Fes&TheFe and debugger
        # is it still the one...
        # < cull zombie -Effects
        $Fine = c.Fine
        $now = theone( me&ioty,Fine,'',z.t )
        hak(h.jaa({autopushed:z})) and return
        now != z and return
            #me&fu,"ZombieEffect",{now,z}
        
        # they should be Accepting what they already were
        #  ~Fe invalidates the Accepting we granted
        $dige = me&Fe_isAccepting,Fe
        !dige and return me&fu,"ZombieAccept",z
        
        
        # now, get pipe leading to Fories**
        $pipen = theone(me&jaa,Fe,'eto,pipe' )
        # pipen%eto = Fories/...  # where it comes from
        # pipen%pipe = TheF/@Fest # selfer of it
        #     /$t)%TheFine        # self
        #     /Re:$t)%ReNine...   # staged
        $selfer = pipens&pipe
        $TheF = selfery&up
        !TheF.t == 'TheF' and debugger
        $Fest = Aof(selfer)
        !Fests&TheFest and return me&fu,"selfer^!Fest",{selfer,Fest,Re} 
        $Re = theone(me&ioty,Fest,'ReNine','Re:'+selfer.t )
        # < Babz "~ selfer,Fest,'/',Re": sense into msgs for sute
        !Res&ReNine and return me&fu,"pipeis",{selfer,Fest,Re}
        # in Ins:
        $N = me&ioty,Re,'ball'
        N.some(r => !rs&ReNine) and return me&fu,"!ReNine**",{Re,N}
        N = [Re,...N].map(r => sof(r))
        $depthy = s => s != N[0]
        
        # < &sustrain in a sub-&supetime?
        $reset = me&tt,"reset" (1)
        $rows = me&rowcap,N,"Fe-Accepting",'O'
        $ready = 1
        rows ('ready',&nmal{
            a.r = Aof(n)
            $ja = a.ja = s => me&ja,a.r,s
            !ja('ready') and ready = 0; me&tc,"!ready...";
        })
        !ready and h.ha('pur:toPave!ready')
        # < h.za (or just sute/&sustrain-ings)
        $pushing = theone( h.zaa("AllPushy,rec:toPave") )
        reset and pushing = 0
        !pushing and h.ha("AllPushy,rec:toPave")
        $allok = 1
        # < neverfails?
        !pushing and me&elvis,R,'Push',{wake:Re}
        
        rows ('push',&nmal{
            if (!pushing) {
                me&tc,"push!"
                h.ha("pur:push!")
                return allok = 0
            }
            a.ja('ok') and return me&tc,'ok'
            allok and h.ha({pur:"pushed",pre:n})
            allok = 0
        })
        !allok and return me&tc,"okwait..."
        
        $res = me&sustain,{dige:dige},{ReSelf:1}
        if (res.el == 2) {
            # fire once and hope
            $Fest = me&yfuture,selfer
            Fests&Leave = 1
            h.ha({pur:"reself",pre:selfer})
            return
        }
        elsif (!res.conclusion) {
            res.conclusion = 1
            me&tc,"we-are-done"
            # block iSeeFe until next -Effect
            h.ha({autopushed:z,dige,rec:'autopushed'})
            # < it just comes back via %%dome?
            h.jaa('rec:toPave') .map(n => nc&drop = 'are-done')
            h.jaa('rec:ReSelf') .map(n => nc&drop = 'are-done')
        }
        #me&fu,"iSeeFe:",{Fe,pipen,selfer,Fest,Re,N}
     }
    =cut
    },
  
  # see w:Story for %TheFine
  # < sub the doer and &Gome_Resides
  // Super@Nine (empty)
    &{
        me.SuperNine = &acgtRsce{
            $x = me&Jx,R
            c.t ||= 'Nine'
            $su = me&supetime,R,c.t
            su('One',{until:&zaa,jaa,ha,ar{
                # < &activate would know about %%inst leaving
                c.el == 9 and return me&tc,"cancel"
                me&activate and return ha('pur:noteven')
                me&Supervate,{}
                ha('pur:')
            }})&&
            su('Done',{until:&zaa,jaa,ha,ar{
                # n|u all done
                me&tc,"all-done"
            }})
            
            return su('done')
        }
    },
    # just enough %Piing-ness to be able to activate
    ['TheFine',0.291,&acgtRs{
        !me.cbu(R,'Gnome') and return
        
        me&rollbs,R,'E'
        $E = Rs&E ||= Cye([R.t,1])
        Ey&R = R
        Es&z ||= []
        # < be %Piing
        # Rs&Piing = 1
    },'ift,D'],
  
  # namespace bridge:
  // %Names:C
    =Names
      %Names%*:
       all are the shape of or refer to:
         /$tw=n.t = $n
        not /$n, one absolute $n
       /$tw = $n
        a name here, for $n
        then some qualities to its being a Name are:
       /$local = 1
        supplied to set
        alludes to their scope on the slope.
       # not reliant on a corresponding /$tw:
       /$tup
        pulled from above, only return from &Names_get
       /$task|$tasked
        what we are ask(ing|ed) for /$tup
       /$tdown
        names announced to $s from $s/**
      
      push up /$tdown, pull down /$tup
       up = more fame
      
      get can source $n from /$tw|$tup|$tdown
      
      < perhaps @Cat and /@Run/* are name-perc-stopping.
        the slope folds names
      < perc one big /$tw
         currently only for names defined here,
          /$tup|$tdown the not-here
        if it climbs & puts /$tw:
         we are %%oust-ing, Fame negotiates where we can what
          and coordinates with other users of a name we want to change
           this would usually be pushing This++ -> &EsyncThis
        or if it climbs & advertises having that name
         then on _get, you must climb down to the source of the name
          might be more A
           nice soft layer of advertising a feature over spacetime (the breaker)
            which brings in awareness to decide the exact relativity,
             if and when it even matters
           A^^crux...C
            A asked all the way to crux, who led ...somewhere
             who you can believe into there is up to formulas
              ie needing something on screen now to hang out with
               that is like it in some way
        leading back to
         osc push j > J, Aip, relativity
          whos truth gets where|when
           and should certain things be prioritised
        /media/s/Elvis/Music/Stevetop/1Gosh/Spartacus R/08 The curse.mp3
         is a good constricted space soundtrack
         our threads of perception build a picture, eg:
          A == A, Ay, !AyA, Aytime, Atime
        
      see &node_get_Names into N[a+]
       < converting wou%X/$k/$v back into rows
      see &brackstract for a front to this data
       
    =cut
    # fame distribution
    ['Names',0.87,&acgtRs{
        me&reaw,R,'Names'
        $Na = Rs&Names
        me&acting,R and me&nu,"Names",Na.sc,'forement'
    },'ift,D'],
    &{
    # &Saturn -> %Names
    me.Names_collector = &acgtR{
        $g = {}
        $nameN = []
        g.from_ax = &a{
            $na = sex({},a,'Name,name')
            !hak(na) and return
            !isC(a.s) and throw "what is it"
            na.s = a.s
            nameN.push(na)
        }
        g.done = &{
            !hak(nameN) and return
            $la
            each i,na nameN {
                $c = {}
                hak(na,'Name') and $t = na.Name
                else {
                    $t = na.name
                    # not known to aboves & beyonds,
                    #  may give up name inwardly to an above Name
                    # < except when led into, eg @Thy/@This, @Thy...@seven
                    #   which is more about using @Thy's Sarndat to climb ...
                    #    we are really looking for phrasing,
                    c.local = 1
                }
                !isst(t) and throw "!name"
                la != null && la != t and throw "~name"
                me&Names_set,R,t,na.s,c
            }
        }
        return g
    }
    # < &sc_collector, agreement diag
    
    # name a node, climb the name into place
    # < whoever might like to know, esp if ~s
    me.Names_set = &acgtRtsc{
        !isst(t) and throw "t!string"
        !isnode(s) and throw "s!node"
        c ||= {}
        # < &yio? activate R%Names from R%Piing noticing it?
        $Na = me&rollbsc,R,'Names'
        # <<<
        # i %Names:Na (knowing somewhere it should C:Names)
        # i R/%Names/$t/$s/$n-naming
        #  and the usu reverse: i $s/$t
        #  and the usu noticing etc
        # the -naming defines scope (c&local or not)
        # < seems like a /believe/ join to &Saturn
        #   they would all end up with z-indexes
        #    last io to do highest,
        #    .Name includers having the .pathi they occurred
        #     (for the use case in the scope of many &Saturn)
        $was = ahsk(Na,'sc','tw',t)
        ah(Na,'tw',t,s)
        if (c.local) {
            ah(Na,'tlocal',t,1)
            return
        }
        # < keep putting above?
        #  < be told when our Names are outshon? notice where til?
        s == was and return
        
        # climbs & puts.
        #  < when %%active, puts @Lab|@Nine for @Gnome,
        #    which makes it a %%Superarg,
        #     which all share to @Gnome%Names
        #     where we can find them
        $climbput = &j{
            $Na = js&Names || me&rollbs,j,'Names'
            !Na and return
            # < outshine what is there?
            ah(Na,'tdown',t,s)
            climbput(jy&up)
        }
        climbput(Ry&up)
    }
    # for a given node, return its name
    me.Name_of = &acgts{
        $R = sy&R
        !R and return
        $Na = me&rollbsc,R,'Names'
        each tn Nas&tw {
            # the %Piing put forward their E
            sy&ers == n || s == n and return t
        }
    }
    # does j have a client, return its s
    me.clientmight = &acgtj{
        j = jy&R
        $cl = js&client
        !cl || !isC(cl) and return
        $z = fatal.sof( me&yfuture,cl )
        return z
    }
    # create outcrop of names looked up in here
    me.Names_get = &acgtRtc{
        c == 1 and c = {fatal:1}
        c = peel(c)
        R = Ry&R
        $Na = me&rollbsc,R,'Names'
        # here
        $s = ahsk(Na,'sc','tw',t)
        if (s == null) {
            # put here
            s = ahsk(Na,'sc','tdown',t)
        }
        if (s == null) {
            $j = me.cbu(R,j => js&Ying || j != R && (js&Names || js&client))
            js&Ying and j = null
            if (j) {
                if (js&Names) {
                    s = me&Names_get,j,t,{c,outer:1}
                }
                # also goes across this link, eg to @Gnome
                # < becomes %%hire
                $cl = me&clientmight,j
                if (cl && s == null) {
                    s = me&Names_get,cl,t,{c,outer:2}
                }
            }
        }
        
        # < climb for /** for /$tasked until /$task
        # note asking this
        !c.outer and ah(Na,'task',t,1)
        # being asked
        else ah(Na,'tasked',t,1)
        
        # remember what it was, all the way down
        if (s) {
            $was = ahsk(Na,'sc','tup',t)
            ah(Na,'tup',t,s)
        }
        else
        # < fix throw ..., tinystring display
        c.fatal and throw "!Names:"+t
        
        return s
    }
    },
  
  // sy&Fames:C
    # reverse of Names, for being y&thing-consequent
    
    #  or is it %%oust?
    # see &Fame_Ething for so far
    
  
  # nine wants to join reality:
  # < Travel..@Run by %%hire, %Piing** by %%inst
  // Travel..@Cat/@Run %Piing**
   
   // Travel..@Cat
    # space depot, needs Run%%mayRun
    # see %Travelables, which is R^2 of here
    # @Cat ~ %SummerCat, has %client=Gnome
    ['sleeping+PiiCat',0.2971,&acgtRs{
        # < test tests, GONER?
        # < redo the way @Intro classifies who to wake on ~t
        # @Inc gives us %Inn=R:Inc (providing oft %ting(Q) server)
        me&rollbs,R,'Inn,client'
    },'ift,D'],
    ['PiiCat',0.2901,&acgtRs{
        me&reaw,R,'PiiCat,Inn,client'
        me&acting,R
        
        $n = sy&Gorow
        !n and debugger
        
        # < switch off Ec&uber)%client
        $cl = Rs&client = ns&Gome
        
        $tr = Ry&up
        # Travel/$t/$s
        $t = trc&s
        t != sy&up and debugger
        # < &Sarn here about our Go-eyness
        #    /@Run has a &Sarn too
        me&haveGorowgetControl,R,s,t and return
        
        # rebuild %SummerCat?
        # each has a This|The?
        me&Names_set,R,'Cat',s
        me&bin,'PiiOther'
        me&fiu,s,'Inc'
        me&fiu,s,'Pro'
        me&fiu,s,'Run'
    },'ift,D'],
    
   // /@Inc|@Pro
    ['PiiOther',0.2901,&acgtRs{
        me&reaw,R,'PiiOther'
        me&acting,R
        me&supsphere,s
        R.sc['Pii'+s.t] = 1
        me&Names_set,R,s.t,s
    },'ift,D'],
    # a Paving for this way. see %SummerCat/Inc%Aearch
    ['PiiInc',0.2901,&acgtRs{
        # < @Intro routes news
        # < each resource may be directed
        #return
        Rs&Aearch = 1;
        me&ha,R,'loaded'
    },'ift,D'],
    # have steps, todos
    #  e heading for A:n rather than Run/The...
    ['PiiPro',0.2901,&acgtRs{
        # < Go comes with specific mechanism for running the tests
        #    usu w:$t (as Travelable|Gnome is named)
        #  < might also be W:$t, containing a Gnomp-like efforter
        $Cat = me.cbu(R,'client')
        $t = Caty&up.t
        me&ha,R,{clientWay:t}
        T.asyncQs = []
        me&way,R,t,{},'noop'
        $was = delete T.asyncQs
        hak(was) and return me&waits,"preload-w"
        me&settle_prev,R and return
        me&ha,R,'loaded'
    },'ift,D'],
    
   // /@Run %Piing**
    # @Run ~ %Jrunto
    #  exp by random clicks and %%initdata
    # see TheThy 2901
    ['PiiRun',0.2901,&acgtRs{
        $x = me&Jx,R
        me&ja,xc&Pro,'loaded'
        !me&ja,R,'mayRun' and return me&tc,"!mayRun..."
        Rs&Piing = 1
        # < &Gnome_Jx: its def @Run should match up
        #   it basically discovers its way to @Gnome, @Cat, etc
        #   from anywhere in @Thy, @Cat, etc
        #   it wants to read %%hire
    },'ift,D'],
    ['PiiRun',0.299,&acgtRs{
        $x = me&Jx,R
        me&bin,'PiiRunThis'
        $t = me&jaa,xc&Pro,'clientWay',1 [0]
        !t.match(/\w+/) and return me&tc,"!way",'g'
        $x = me&Jx,R
        if (x.ro("Run") || 0 && !Rc&b) {
            # synth a thing
            ss&time ||= 0
            $time = (ss&time*1) + 1
            !time and debugger
            me&Runpin,R,t,time
            # may not make it back
            ss&time = time
        }
        me&Runpin_amb,R,t
    },'ift,D'],
    ['PiiRun+Piing',0.293,&acgtRs{
        Rs&Sarndat = me&Sarn,<<'',[R]
            i @Run/@-This/-Eight/-seven/**%Ethinging
        
    },'ift,D'],
    ['PiiRunThis',0.298,&acgtRs{
        s.t != "This" and return
        me&tc,"Thising",'y'
        # < what does &Gome_This do
    },'ift,D'],
   
 // /@Run style
  // &tidyball &minimod
    # outside &Piing
    &{
    # quiets -Log, -seven, -Eight
    #  returns con, a hash of /$tt=$ope for the first &Piing E
    #  < should be Ey&main as such, might be -Bat if Ey&Todo
    me.tidyball = &acgtR{
        $s = Rc&s
        $N = me&modselect,R
        
        # < keep warnings as such
        $keeps = grep(&n{
            return ns&fs >= 12 && n.t != 'Peace'
                || ns&controls
            }, N)
        
        # < use there
        sc&pi == 'seven' || sc&pi == 'Eight'
            && keeps.push(... me&modselect,R,{t:'t',cv:11})
        
        if (hak(keeps)) {
            # dont not them
            grop(keeps,N)
            if (0) {
                # they capsulate, to move around?
                grop(keeps,Rs&M)
                me&boxcap,'savedmod' (&ml{
                    lc&not = 1
                    keeps.map(&n{
                        # mute -Log
                        ny&label and ny&label.c.not = 1
                        #me&modclone,m,n
                        ac(m,'z',n)
                    })
                })
            }
        }
        N.map(n => nc&not = 1)
        
        # also the R%ball/R%fix for s%attr
        me&ioty,R,'fix' .map(r => rs&noDisplay = 1)
        
        $controls = theone(grep(n => ns&controls, keeps))
        $con = controlss&controls
        con.n = controls
        return con
    }
    
    # draw mod cv@11-12 tiny picture
    me.minimod = &acgtE{
        me&boxcap,'minimod' (&ml{
            lc&s = '~'
            ls&fs = 8
            me&minimod_build,E,{dl:4}
        })
    }
  // &minimod f
    # sketch modulat from -Log**
    # spaces out the &com c.* at d.d=3
    me.minimod_build = &acgtEd{
        d = peel(d)
        if (d.dl) {
            d.may_boost_d = d.dl
            # start capsulating at eg -Log/-row/*
            d.many_d = d.dl-1
        }
        me&indo,E,d (&sd{
            d.sc = {}
            # E must be real
            $r = sy&R
            !r and return d.not = 1
            # no capsule for -Log/-row
            d.many_d && d.d < d.many_d and return
            
            $m = me&minimod_capsuling,s,d
            me&minimod_styling,m,s,d

            # gather labelly stuff
            #  Cish@2637 also does this, to Dc&s = spant()
            me&modselect,r,{gte:1,lt:13} .map(&n{
                me&modclone,m,n
            })

            d.gotmod()
        })
    }
    # process of having boxcaps
    me.minimod_capsuling = &acgtsd{
        $capsuling = me&boxcap,'mobit:'+s.t
        $m = d.m = T.ab
        ms&mobit = 1
        
        $modcmp = &{}
        
        # d%boost: dl++ if little turned up yet
        d.gotmod = &{
            $cusp = d.d == d.may_boost_d
            $more = hak(ss&z)
            if (cusp && more && me&measure_modulat,ms&z < 5) {
                # eg just number at N-vat/$i
                # press on until the many
                d.dl += 1
                ds&boost = 1
            }
            delete d.gotmod
        }
        
        d.unind = &{
            # sync Tap:ab with &ind
            capsuling()
            
            if (ds&boost && me&measure_modulat,ms&z,'nomem' > 13) {
                me&ioty,m,['mobit','']
                    .filter(n => !me&nfilt,n,{gt:1,lte:11} )
                    .map(n => nc&not = 1)
                me&ioty,m,'mobit'
                    .map(n => ns&bor = 0)
            }
        }
        return m
    }
    me.minimod_styling = &acgtmsd{
        $r = sy&R
        $l = my&label
        lc&s = s.t
        lc&not = 1
        
        ms&dis = 2
        # extend &ind d.* to know d/d
        if (d.up) {
            $uz = d.up.z ||= []
            $nonfirst = uz.push(d) - 1
        }
        if (d.d >= d.many_d && nonfirst) {
            # space between the main items
            ms&ml = d.d == d.many_d ? 0.3 : 0.1
        }
        
        me&walls,m,'b:3.4'
        delete ms&pa
        
        if (rs&Cish) {
            d.nofurther = 1
            ms&bgh = rs&anA ? '111' : '222'
            
        }
    }
  // %Foldabline
    # for a tidy E-Log
    me.RE_singline = &acgt{
        $R = me&R
        !Rs&Top and debugger
        # override &Piing's Efd:ope
        #delete Rs&noDisplay
        $r = me&uptoR,Rs&E
        rs&Foldabline = 1
    }
    },
    # quiet s** R modulat for /-Log
    ['Foldabline',0.94,&acgtRs{
        s&bg = '#201'
        # reverse indent
        s&ml = -2
        delete s&pl
        
        # boost>=1 unfolds
        me&til_boost_reDisplay and return
        
        # mute most stuff, end up with &Piing's m%controls
        $con = me&tidyball,R
        if (con) {
            $n = con.n
            ny&label.sc.fs = 6
            if (!con.D && sc&pi == 'Log') {
                # < turn REy&main into E, soon as Ey&R?
                # s//E
                $E = me&Eof,s
                me&minimod,E
            }
        }
        
        # other style
        # futile, usu much too big
        map(C => s&dis = 2, r => rs&C, me&ioR,R,'Pier')
        
        # may beadding modulat very late:
        Rs&Mw and me&modulatM,R
        
        return
        # < get -ology for putting these things back together
        #   must be the standard table
        $tz = vpartN(N,n => ny&cv)
        me&fu,"Futz",tz
        me&fu,"FutR",R
    },'ift,D'],
    &{
    # drops y&Display/** history, recreating dom inside here
    # < Display bug in the element list rearranger
    #    drip feeds them in at the start, 1 at a time
    me.til_boost_reDisplay = &acgtk{
        $R = me&R
        k ||= T.act.t + 'd'
        
        $Fold = cvlt(Rs&boost,1) && 1
        $was = me&ollbs,R,k
        Fold != was and Rs&igVDisplayin = 1
        !Fold and return 1
        R.sc[k] = 1
    }
    },
  
 // A:Run <-> A:Fish
   
   &{
   // @Run -> &Sunpit
     // &Runpin
        me.Runpin = &acgtRtv{
            $time = v
            # keep the latest facts, title clues, %%Bang,er... etc per &Runpin
            $dome = 'ranRun'
            $conc = {Runpin:1,time,dome}
            
            $A = me&RunA,{time}
            A.Run = R
            # < these go somewhere, copy %SummerCat some more
            #   to allow -nine to glean a title @Run's latest bunch
            # only do S 1 if time
            # ! dont use R%Ace because of missing 4c&Srupto
            #   strange fact of R-life, so far very little A
            $plan = "Run "+t+"@"+time
            $clog = ~>7 Atry: plan, '>0:fail'
            me&Bangrasp,plan (&{
                me&way,R,t
            },&er,c{
                # er taints the %%Runpin,...
                conc.er = er
                #  and the #msgs logline
                clog && clog.set('fail','ERR: '+erc&s)
                # keep the latest %%Bang,er... per &Runpin
                me&ha,R,c,{},{dome}
                #  which we draw up in &Runpin_amb
            })
            
            $now = A&doords[time]
            conc.title = now.t
            $nums = haks(A&doords)
            $ti = nums.indexOf(time+'')
            # < &strange?
            ti < 0 and return me&tc,"no-time:"+time,'B'
            $ni = nums.slice(ti)[1]
            $next = A&doords[ni]
            next and me&ha,R,{next_Ness_title_clue:next.t,dome}
            
            # < notice %%er up there
            me&ha,R,conc
            me&dome_traction,R,dome
        }
        me.Runpin_amb = &acgtRt{
            $ers = me&ja,R,'er,Bang',1
            ers and me&erscap,ers
        }
        me.RunA = &acgtc{
            $name = ''
            c.time and name += '@'+c.time
            $V = G&Aye,'Run'+name
            c.time and V.time = V
            ex(V.c,c)
            Vc&Srupto = me.Sunpit
            me&RunA_testo,V
            
            return V
        }
     
     // &Sunpit
        # S for an osc pin, bump through segments of the work
        me.Sunpit = &acgtit,talk,params{
            !i && !t and throw "no io"
            $m =
            ~>3 Sunpit: dis(cint(i,t)), 'thought was'
            !num(i) and debugger
            
            
            A&doings ||= {};
            A&doords ||= {};
            $l = A&doings[t] ||= {}
            $ld = A&doords[i] ||= l
            ld != l and debugger
            l.num = i
            l.t = t

            if (A&time && num(i)) {
                A&time != i and return 0
            }
            
            # or until done
            l.done and return
            
            l.done = 1
            #~sttalk: ki([s,t,talk,params]);
            return 1
        }
     
     // &Bangrasp
        # @Run's try...catch
        #  lifted from %Jproto
        #   you can date this code by its use of ;
        # < generalise, with &Supe, %%Go recoils in shock (unless ...)
        me.Bangrasp = &acgtt{
            return &yf{
                
                $er = null;
                # < generalise, with &Supe
                $destac = me&Gstac_reset
                try {
                    y()
                }
                catch (e) {
                    destac()
                    # < something about ignoring all of its This** 
                    er = me&Yingerr,R,e,t;
                    
                    # write that down
                    $msg = erc&s;
                    $conc = {Bang:t,er,msg}
                    # < keep trying-er? @Pro would know
                    ers&async and conc.async = 1
                    
                    # er handler, probably does the below
                    f and f(er,conc)
                    else {
                        # this once
                        ~>0 ERROR: t+':', ''+er
                        me&ha,R,conc
                        n error  $s:er,R %Error
                    }
                }
                destac()
                
                !er and return
                
            }
        }
        me.erscap = &acgtN{
            me&boxcap,'Errors!' (&m{
                # prevents &boxcap from disappearing when empty
                #  way before zuct will put stuff in it
                me&tc,''
                
                N.map(&er,{
                    n error  $s:er,R:1,Rzucto:m %Error
                })
            })
        }
     
   
   // @Run <-> @This** test harness
   
     // @Run &openEight, This** inflation
        # -Eight opens for a V:process that will add -six
        me.openEight = &acgttY{
            fatal.iske(t)
            # eventually, further
            Y.time != Y and debugger
            $V = Y.time
            A = V
            $time = A&time
            A = G&Aye,'-Eight...'
            $R = me&R
            $s = Rc&s
            $Eight = me&legramp,s,'-This',t+'-Eight'
            $Ya = A
            return &{
                # < receive their ACGT from &n, etc
                # < handlers etc may keep logging after Run time ends
                #    anything othering makes a tinkling noise
                #     via async Yingpile
                #    and does the Eight** on the now-8 A:Run@3
                #    every 2s or so they EsyncThis
                #    
                $args = [...arguments]
                A = Ya
                A = G&Aye,'-Eight...-six'
                $six = me&legramp,Eight,time+'-seven',...args
                ac(A,'six',six)
                return six
            }
        }
        # for This/such-Eight/so-seven/[thing-Fez,{sc&s,...sc}]
        me.legramp = &acgtS{
            $N = [...arguments].slice(5)
            each il N {
                !isar(l) and l = [l]
                # < l[1] (s+)
                $next = me&inramp,S,...l
                !next and debugger
                S = next
            }
            return S
        }
        # builds a @Run/**r
        # < returning r** with E@36?
        # < expets() it. {s,pi,t}
        me.inramp = &acgtzscq{
            # z must be above s
            $ins = me&Pii,z,s,q
            !ins and debugger
            s = ins
            !zy&R and debugger
            zy&R != z and z = zy&R
            C = zs&C
            !C and debugger
            # s may be string
            $spec = isst(s) ? [s] : [s.t,s]
            while (1) {
                $r = me&bal,...spec
                if (!rs&sleeping) {
                    if (wasat != null) {
                        grepout(zs&z,r)
                        zs&z.splice(wasat,0,r)
                    }
                    break
                }
                # drop the recycling
                $wasat = zs&z.indexOf(r)
                grepout(zs&z,r)
            }
            s = rc&s
            # c -> s.c -> main E &Piing/&PiRet c
            #  certain (nl,dl) may end up in Rc&*, else R%*
            c and ex(s.c,c)
            
            # they get sy&R @293, &Piing @296
            #  the //E/* will be @333 after:
            me&Ring,r,{und:r,ov:0.333}
            
            return s
        }
     // unrecycle
        # unrelatedly, a double arrive is needed
        # this is Rbitx, as opposed to RbitX
        # R:This encounters itself as a sleeping stub!
        #  an %onlyish/%ball might exist before @3
        me.unrecycleRbitx = &acgtRX{
            
            $p = Ry&up
            0 && R.t != 'This' and debugger
            else
            hak(X.z) != 1 and debugger
            else {
                $n = X.z[0]
                # for %onlyish/* only
                !ps&onlyish and debugger
                else
                # < &bal %balz already replaced the sleeping one?
                ns&sleeping == 'aleeping' && (!Rc&N.includes(n) || ps&z.includes(n)) and debugger
                else
                !ns&sleeping and debugger
                else
                !ps&z.includes(R) and debugger
                else {
                    $ni = Rc&N.indexOf(n)
                    if (ns&sleeping != 'aleeping') {
                        #ni >= 0 and debugger
                    }
                    else {
                        ni < 0 and debugger
                    }
                    nc&b && nc&b != ahsk(R,'c','V','x',R.t,'z',0) and debugger
                    if (ni >= 0) {
                        # Rc&refR will have picked it up (for|if Rc&s)
                        !Rs&refR.includes(n) and debugger
                        # < these two should act same, yet &applyRbitX (by R0 for Rc&N)
                        #    should inherit some not-c&not-ness from a throaty generique
                        Rc&N.splice(ni,1)
                        nc&not = 'stop it'
                    }
                    X.z = []
                    # and everything it may have somehow made while sleeping?
                    #  otherwise eg p:This/R:-This%Pier ends up Rc&X == Rc&V
                    #   < debug when easy to see everything
                    delete X.x
                    delete X.recycled
                    X.unrecycx = 1
                    # back to &arriveRbitX, we become the only /$r there
                }
            }
        }
     
     # &Thisplanet talks to:
     // A.h io This**
        # A.h .o(Eight.t) replaces A.h
        # @Run suits up A:Run (V), has an Eight** opener|cursor
        me.RunA_testo = &acgtV{
          // who it is
            # -Eight++
            # get $id-Eight/$time-seven handle, for i-ing thence
            $Ah = V.h = {}
            # taken over by latest opened V.h = {o,tys,...}
            #  o always opens a new Eight
            #  V.h starts an opener, then cursor and opener
            V.h.o = &tc{
                c ||= {}
                $h = {o:V.h.o}
                # knows -Eight name
                h.t = t
                # onto A:Runtime.h
                #  for access by assertions eg &AhWombmod
                !c.local and V.h = h
                # -seven/-six++
                # interfaces, not sharing A
                h.sixer = me&openEight,t,V
                # cursory list of all -six, any h
                #  for access by assertions eg &AhWombmod
                Vs&six ||= []
                $A = V
                
          // what it does
                # most pi
                # like n $t -pi $s=suchacall()
                h.tys = &tysc{
                    !iske(t) || t == '' and throw "non t", t
                    # < c -> Ec?
                    $testway = pex(Ah.sixc,h.sixc)
                    c = pex({pi:y,s}, pex(testway,c) )
                    $q = {dupi:1}
                    $six = h.sixer([t+'',c,q])
                    # supposedly this is still @Run...A
                    #  as opposed to A...stuff-we-will-dump
                    #   which has no links up
                    Vs&six.push(six)
                    h.lasix = six
                    return six
                }
                # hat data, unsprawly
                # Fez sprawly until C (eg X**), esp avoiding A
                # Bow sprawly while C (eg s**)
                # for default Fez etc Rc&nl: see &Piing / c.soft_rcbits
                haks(peel('hat,Fez,Bow,Womb,brackio')).map(&pi,{
                    # < mep h { (t,s,c) => h.tys(t,$k,s,c) } 'hat,Fez,Bow'
                    #    coalesce via peel(). or perl's qw{}
                    h[pi] = (t,s,c) => h.tys(t,pi,s,c)
                })
                # < Babz for breaking out of one-line me&calls
                h.brack = (t,s,c) => h.tys(t,'brackios',s,c)
                # < Babz for "big quotations" in me&calls
                h.diff = &{ me&Ahdiff,...arguments }
                # random data dump, not a This**. can't &fu if !A.5
                h.fu = &ts{
                    !isst(t) and s = t; t = 'h.fu'
                    me&fu,t,s
                }
                
                return h
            }
        }
        # guesses some A&six, eg &Ahdiff_what it should diff
        #  which is unlikely to want other diffs (which -Womb)
        me.testo_pi_unassumable = {Womb:1,Difmo:1}
        me.testo_pi_recent = &acgt{
            !As&six and debugger
            # < grep(y,y,N), and sub y=fu|ar|C arg interpretation
            return grep(&n{
                # primary source, eg -hat not -Womb
                return !me.testo_pi_unassumable[nc&pi]
                # six.t unindented, eg Fus@7 / Ploy sidetrack
                    && !n.t.startsWith(' ')
                # in the same Eight as now
                    && n.y.up.y.up.t == A.h.t
            }, As&six)
        }
     
     // mock objects
       // &mockR
        # minimal R b%C,wou Doming
        me.mockR = &acgtt{
            $spawner = &b{
                return &y{
                    $r = me&mockR_make,t,b
                    me&mockR_begin,r
                    y (rs&C,r)
                    me&mockR_commit,r
                    return spawner(r)
                }

            }
            return spawner()
        }
        me.mockR_make = &acgttb{
            $r = Cye([t,333])
            ry&R = r
            # have the previous r
            b and rc&b = b
            rs&ver = b && bs&ver+1 || 1
            # have %C that leads back to r
            $C = rs&C = Cye([t,1])
            Cy&R = r

            return r
        }
        me.mockR_begin = &acgtr{
            $C = rs&C
            # have %wou (see &Domes_o3)
            me&sahazaja,r
            me&dome_o3,r
        }
        me.mockR_commit = &acgtr{
            # may be done early
            !lt(ry&cv,9) and return
            # these args weird
            #  &Domes_7 passes R,p,r,s to all its "plugins"
            me&dome_7,r,r,r;
            me&node_accept,r,r
        }
       // &mockbrackR
        # $be = &mockbrackR,'unit',{no_hajasute:1}
        # be.Again('title'?,&Chir{ ... })
        # or be.main = &Chir{ ... }; be.do('title'?)+
        me.mockbrackR = &acgttc{
            c = peel(c)
            c.t = t
            # times: fork counter, by r%ver
            # c and sc: r and its This...-brack, by Aip
            ex(c,{times:{},c:{},sc:{}})
            # overalls for this r.t
            c.idc ||= {dome:defor(c.dome,'it')}
            
            # for the test A.h
            c.A = A
            A.h.be = c
            c.diff = A.h.diff
            
            # feed y=&Chir{ ... }
            # and perhaps b and or g||'title'
            c.Again = &{
                # < safe to iterate?
                $g = {}
                each iv arguments {
                    ish(v) and g = v
                    # b is the previous r
                    isR(v) and g.b = v
                    isfu(v) and ahk(g,['y'],v)
                    isst(v) and g.t = v
                }
                c.g = g
                !g.y and throw "huh"
                
                me&mockbrackR_An,c,g
                
                return c.Further = &{
                    return c.Again(g.r,...arguments)
                }
            }
            # less chainy, eg just be.do(title?,b?,y?)
            c.do = &{
                $args = [...arguments]
                !grap(isfu,args) and fatal.isfu(c.main); args.push(c.main)
                return !c.Further || grap(isR,args)
                    ? c.Again(...args)
                    : c.Further(...args)
            }
            return c
        }
        # looks like A:n
        me.mockbrackR_An = &acgtcg{
            $r = g.r = me&mockR_make,c.t,g.b
            $C = rs&C
            fatal.isR(r)
            fatal.isC(C)
            me&mockR_begin,r
            me&mockAipR_begin,c,g

            fatal.isnum(rs&ver)
            # starts returning null, then 1 forked
            $subver = ahk(c,['times'],rs&ver,1)-1 || null
            # so $r = cc&_1, then cc&_1_1 forked
            # < Babz cc&1.1
            g.Aip = spant(rs&ver,subver)
            g._Aip = joint(['',rs&ver,subver],'_')
            c.c[g._Aip] = r

            # hope for
            me&mockbrackR_middle,c,g

            # and finish, as Ying would sort out all the pieces of the sun
            me&mockR_commit,r

            # extra data to see goes here
            me&mockbrackR_osc,c,g
        }
        me.mockAipR_begin = &acgtcg{
            $r = g.r
            # < commit this, but have it available already
            $b = rc&b
            b and by&future = r
            # < make Aips
        }
        me.mockbrackR_middle = &acgtcg{
            $r = g.r
            fatal.isR(r)
            # mix eg %%dome=bf into every sute.ha(...)
            $idc = g.idc || c.idc || {dome:'it'}
            $sute = me&hajadome,r,idc
            # and with %%rec &zaaj knowing, T.sute
            $Tap = me&Tap,{sute}
            $h = c.no_hajasute ? sute : me&hajasute
            
            # extra data to see goes here
            $i = g.i ||= {}
            # the ways
            map(y => y (C,h,i,r), g.y)

            # %%rec computing
            sute.traction()
            # < via sute.packdown[]()?
            delete T.hajasute
            Tap()
        }
        # test the data after
        me.mockbrackR_osc = &acgtcg{
            $i = g.i
            # might not take the whole picture
            i.whole == 0 and $see = i; delete i.whole
            else
            # you may set i.whole=1 to position it before more i.*
            hak(i) and $see = ex(i,{whole:C})
            else {
                # < reverse expe(): zooms into whole if no others.
                $see = C
            }
            
            # extends to sixc&* and then sixy&main//R%*
            #  over any h.sixc later, see &RunA_testenv / h.tys()
            $sixc = peel(g.c)
            
            if (see == i) {
                # other keys are there
                # sidetrack into $pi per i.$t
                if (c.i_pi) {
                    ~>5 haveanipi: dis(c.i_pi)
                    # < might be a grep c interfacable like this
                    #   and where to put the derivative
                    #    eg %TX anything to six/*//r%*
                    $pis = peel(c.i_pi)
                    $pifor = {}
                    each kv pis {
                        if (v == 1) {
                            # everything
                            ex(pifor,map(v => k,
                                nex({},i,'whole')
                            ))
                        }
                        else {
                            # < specifics
                            v.split('-').map(K => pifor[K] = k)
                        }
                    }
                    hak(pifor) and ex(sixc,{pifor})
                }
            }
            
            $say = spant(c.t,g.Aip,g.t)
            $six = c.A.h.brack(say,see,sixc)
            # This...-brack 
            c.sc[g._Aip] = six
        }
       
     // assertions, breakdowns, etc
      // assertions
       // modulat
        # -Womb a s-six modulat, styles and all
        # < not E**, only E (//R%M) ?
        me.AhWombmod = &acgts{
            s == -1 and s = a&six.slice(-1)[0]
            $E = me&Eof,s
            me&finishPiing,s
            # now everything eg ss&string is there
            #$imm = ss&string && "Yep" || ""
            #me&fu,"FOund"+imm,{s,E}
            $r = Ey&R
            $modcon = Cye(['modcon',1])
            $N = rs&M
            !hak(N) and debugger
            grap(n => !isC(n), N)
            modcons&z = flatten(rs&M)
            #A.h.hat('modcon', modcon, 'dl:5')
            return A.h.Womb('modulat of: '+s.t, modcon)
        }
        
       // diff
        # patches of modulat
        me.AhDifmo = &acgt{
            $g = me&Ahdiff_what,[...arguments].slice(4)
            $n = me&Ahdiffany,g.t,g.c,...g.what
            return A.h.tys(g.t,'Difmo',n)
        }
        # be.diff("them",bes&_21*,'see'?)
        me.Ahdiff = &acgt{
            $g = me&Ahdiff_what,[...arguments].slice(4)
            me&AhdiffWomb,g.t,g.c,...g.what
        }
        
       // Ahdiff*
        # diff argulator, &finishPiing
        me.Ahdiff_what = &acgt,args{
            !A.h and debugger
            # and want to see its whatevers
            $g = {what:[]}
            each iv args {
                if (isst(v)) {
                    !hak(g,'t') and g.t = v
                    # second 'string' -> &diffany c
                    else  g.option = v
                }
                isC(v) and g.what.push(v)
            }

            # we drift onto new A.h recreated by A.h.o
            #  or beyond onto &mockbrackR c, gaining sight of its cs&_Aips
            # < As&six
            if (hak(g.what) < 2) {
                # may be somethings here:
                $c = A.h.be || A.h
                # named versions:
                $N = c.sc && havs(c.sc)
                N ||= me&testo_pi_recent
                !hak(N) and throw "Ah.diff without Ah>>.sc or A%six"
                
                # or one given to latest what
                hak(g.what) == 1 and g.what[1] = N.slice(-1) [0]
                else
                # default latest whats
                !hak(g.what) and g.what = N.slice(-2)
            }
            g.what.some(n => !isC(n)) and debugger
            
            # auto title
            # < R%Diff gets named after $exp. rebuild it!
            !hak(g,'t') and g.t = '..'+g.what.slice(-1)[0].t

            # < being visible in @Run as modulat is weird
            #   do a proper A:Run** situation? some -Eight take Run%M?
            g.c = peel(g.option)

            # < not just sixes?
            g.what.map(six => me&finishPiing,six)
            hak(g.what) != 2 and debugger
            
            return g
        }
        # -Womb <- diff $t $old $new c
        #  ~~ &Ahdiff with concrete args
        # < &enL implanting C|N Lines via BQ (for eg %moren, if not deleted)
        me.AhdiffWomb = &acgttcsz{
            # < marking the first \n in|for a while
            # < Cye([t,y,c,sc]) can not drop %z
            c = peel(c)
            $n = me&Ahdiffany,t,c,s,z
            return A.h.Womb(t,n,'ignore_sc')
        }
        # s:old, z:now
        me.Ahdiffany = &acgttcsz{
            $R = me&R
            Rs&Pier and R = me.cbu(R,'Piing')
            c = peel(c)
            # no caching
            c.el ||= 2
            # no seeing (puts modulat on se)
            !c.se && !c.see and c.se = Cye(['invis',1])
            # may be strings
            $N = isst(s) && isst(z) ? me&twoCstrings,t,z,s
                : [z,s]
            
            $di = me&diffany,R,...N,c
            
            $N = dis&Comp
            !N and throw "!diff. are s|z %string?"
            $n = Cye(['vis',1])
            # ! Cye() deletes y&*, %z
            ex(n.y,{di,s,z})
            ns&z = N.map(n => Cye(n))
            return n
        }
      
      // breakdowns, etc
        # avail This/$pointer lookups
        # < through A.h.o (move h.o->h.i)
        me.oThis = &acgtR{
            $Run = me.cbu(R,"PiiRun")
            # the pattern given in a callback, to allow many lines
            return &sc{
                if (c) {
                    # thing on an E** we could look at
                    #  like -Spheres, know of the one %%Erefc
                    c == 'Eref' and s += '%%Erefc 11'
                    else {
                        throw "unknown E-part", c
                    }
                }
                return me&Risc,Run,'This/'+s
            }
        }
        # study the R**c&dl of the last -six
        me.dumpadepthmap = &acgt{
            $ide = a&six.slice(-1)[0]
            $r = Aof(ide)
            $ides = rc&s
            $ya = me&indo,r (&sd{
                !isC(s) and debugger
                return [sc&d,sc&dl,s.t].join("\t")
            })
            # is only visible as a %*_string)%ball
            idess&depth_map_string = ya
        }
        # < style-reminders...
        me.whatarethosemsgscolours = &acgt{
            # there is this #msgs type of log
            # < &c within A:Fish
            #  < Babz name params, also on throw
            #     spacing to degrees of relevance
            #      compare with slope
            $all = map(v => '>'+v+' '+v,
                [0,1,2,3,4,5,6,7,8,9])
            # < Babz keeping this indented
            #    breaks &diffPs_knowsteps if in w:Fus
            #~>1 colours: ...all
        }
       // &watchfor*
        me.watchforthe = &acgt,tpath{
            $R = me&R
            $Ying = me.cbu(R,'Ying') .c.s
            $watchmem = Yingy&watchmem ||= {}
            $l = tpath.split('/')
            $s = Ying
            each it l {
                0 < i and me&tc,"/",'6y'
                s = me&node_downwards,s
                    .filter(n => n.t == t)[0]
                !s and me&tc,"!"+t,'g'; return
                me&tc,t,'G'
            }
            $was = watchmem[tpath]
            watchmem[tpath] = s
            was && was != s and debugger
        }
        me.watchfora = &acgtts{
            $R = me&R
            $Ying = me.cbu(R,'Ying') .c.s
            $watchmem = Yingy&watchmem ||= {}
            $was = watchmem[t]
            watchmem[t] = s
            t
            was && was != s and debugger
        }
    
   // @Run <-> Fish
        # adapt @Run .. A:least
        #  a disconnected A maker, &com powers
        #  a mock fi&live, a main() for w:Fish as J pin
        #   C is a Run/$W, from @Pro, being A:n
        #   couched in &Yingbal while @Run is running
        # you have a permanent C to hang Cy&Fish on
        
        # &Fishliver (t,y+)+
        # $W, the permanent
        # < you have a permanent C to hang Cy&Fish on
        me.Fishliver = &acgtt{
            $h = A.h
            !h.tys and throw "give open -Eight"
            # < per(manent C) is Rc&s? is now Run,
            #    or Run/$W when %Cat is thinking
            $W = Cye([defor(t,A.h && A.h.t,'Run:n'),1])
            # pass it the logger
            #  does not matter that this for Eight:Log at this point
            #  .o() will open another Eight:etc
            #    and put that cursor on hA.h...
            Wy&testo = h
            return &ty{
                # args like &mockbrackR c.Again
                $g = {t:"Ascape"}
                each iv arguments {
                    isfu(v) and ahk(g,['y'],v)
                    isst(v) and g.t = v
                }
                !g.y and throw "huh"
                
                $V = A
                $A = me&Fishlive,W (&AV{
                    # main(), sunpit, the ways
                    map(y => y (A,V), g.y)
                })
                    # < -Aipscape
                    $Atw = hashkv([A,...(As&z||[])].map(n => [nc&sip,n]))
                    # < -Ascape
                    h.hat(g.t,Atw)
            }
        }
        # each attendance
        me.Fishlive = &acgtW{
            # < %nlist from V^^. a type of Erefc
            $V = A
            # live on this 4/$C
            # a type of A** lifetiming is going on, see Fish&A / &At
            # A:least has no .up
            $A = Wy&Fish ||= fi&Atopleast
            $testo = Wy&testo

            if (!A&step) {
                # init A:least

                # pass it the logger
                fi&Thisplanet,{testo}

                # <<< close circuit, singularise... we have A.Run
                #  perhaps &Eing / Hash avoids opening A&Airlock=V?
                #     something else may find it though...
                #      while dumping all of everything?
                #   V may change over time
                #    to visit a sunpit multiple times per RunA (...V)
                #   V.Run slightly less often?
                # help &poolfour &comeback
                #A&otherer = R
                #A&otherA = V

                # boundary
                # mock to avoid fi&elvis (see close circuit)
                #  usu &isAthinger makes &oftserve that makes &elvis to %Jrunto
                # < if 4c&live=1 all the time, we could use 4s&todo += e
                #   which this is pretending to be doing:
                A&oftserve = &scqd{
                    #(a&oftquest||=[]).push({s,c,q,d})
                }
            }

            # < -seven time = 1.2 if step=2
            A&step ||= 0
            A&step++

            A&live = 1
            $mores = {}
            A&step > 1 and mores.step = A&step
            $done = fi&complace,'yarrr',{W,A},mores

            # main(), sunpit
            return &y{
                y (A,V)

                done()
                # callbacks happen outside:
                delete A&live

                return A
            }
        }
    },
   
   
]}
