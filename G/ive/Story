# Yap
me.Sch_Story = &acgt{ return [
   =Story
    Story/** mark runtime difference along Plot/Point
     on %%quiet,wake: This &pageturn,
      marks where Plot%Page++ > Point
     < on %%wake or sync occurances of arbitrary etc
    we mark Point//-eight
     < locked into Story/** while marking,
        since testing and tested share Ying,
         should have some %%wake lock?
     usu spend a Page marking a Point
     if ok
       +Point:$next (on &pageturn) to continue
     else
       < Point%trouble = +Point:trouble
          no Pointc&Page_out until &accept
          locked into Story/**, consuming -eights
         then restart or resume after Point:trouble as if ok
          ignoring Point%trouble and Point:trouble,
         making this a messy testrun, semi-valid
          < Story/** and not may be separate enough?
     
    %TheNine can create|resume|update tests
     < subtests per Travel/$t
       or anything with a state to reset|repeat
       startStory,Adventure+
       eg:
     < shall go looking for %%may,
       ends up engaging a Gumpframe,
        which ... Travel/$t,
         Story letting the workflow,
         locking on %Pave, with bunch to push?
     
    -eight/-seven/**/-vat emerge
     gaining simpname from nodepile relations
      -vat -> -n|-C for sy&up does|not lead to a node
     < %Slope about sy&up, c.ip, etc.
     when ready:
      < to Dome slep the othering of R%Yingates
         if R%tunneling, wants update|change
          can we deliver e.c to specific wakers?
        from:
        %Yingates[-2..] (!%Fin) awake for streaming, then finish
         < %onlylish sometimes flaky until R:Ying itself happens
            knowing more &Yingwhen may find why,
            %Yingates/* also want selective waking
            yet it depends on *%ball%Peace and ^%Ying
    
    in bursts of activity:
     < hide most of the nodepile and nodes
     < regroupable, to Plot points
    
    once computed a bit,
      < know if weird, eg C not node or e
      < know if unexpected if $Storie
      and the whole bunch,
      < merge into similar previous %Yingates,
         waking [-3] to incorporate [-2]/*
          with %Yingates%onlyish + slep
           to keep most -gate|-seven (%Yingate),
           tallying into -eight again (%Yingates)
        by overall same-ness, looking for e:clicking
         < generated by Zif<->Lines<->C
      < ignore %Story/**, leaving only %%quiet,wake?
         could be implied by the ending of an -eight
        if e:click
          if %Story/**
           capture any adjusted ology for replay
            configuring magnifying glasses to produce test data
            not as e:clicks but as parameters on the %Yingate
             a Te proposed to be permanent,
              apply to others after it with Index?
            slep it to re-Y:pi accodingly,
           < Jx new modulat must ...
          else
           capture pointer|meanings for replay
            previously went quiet? (awaiting click) or:
             < e:click while thinking loses a &Yinge?
             < while at it, later[] may have R-d since
              
    storability:
      < the %Yingates/%Yingate -> -seven/-rows/-row/-vat becomes:
        %Storie/%Stori/-thing**
         %Storie+ are tapes to sync to $Story
         %Stori moment
          happens ||= s&when || next %Yingate
          s&rows breakdown pointing to **:
         -thing** as mentioned in s&rows, default -n
          see 'pile of nodes':
           say $step..$node, even if $step asleep
            maybe more if $node needs unique name
             in the -thing** and in the node pile,
              ie a %twmt across either,
               so Ghost..$z-node can point to the %dige%Q
                coming from a Duolish..$t-node...,
                 coming from a Travel..$t-node
       < or:
        -nine/-eight/-seven/-six/-five/-four/-three/-two/-one
          -nine a whole book
          -eight a chapter, lump of pages|trips
         %Yingate expanded about the aparatus of the plot:
          -seven a page, a trip to A.4|$Ying
            possibly more than one trip,
             ie %Jrunto many times between %Jproto
          -six the overall notion of change, plot pointering
          -five why doing (e|%Jproto plans)
          -four what doing (%Jrunto dome state)
          -three who (dome thing)
          -two part (A pointers)
          -one detail
         all may + Elsewheel, appears with developer
      
      # then Lines it
      < as diff against previous Lines (el:6?)
        web landscaping
      < which might turn into tiny Lines for $Storie:
          implying -nine/-eight/-seven/-n**, etc
          Lines[5] implies z + low light (ki d=4.23)
      < stable $Storie Lines indent -> type means:
         wide ack for similar tests|output
          subtracting normal: what most tests sound like
      
    < %The names %Plot for a new %Storie,
       Stu->toPave without %MayGansp

    < rebuild &waits_8, test against $Stories
    
    < @Story groups time, turns observe/respond corner
      pretending to be Fingo S-ing, providing:
        < log interesting acts
         eg CBing|Travel|Duolish starts|ends
        < log should be mergible with Yingu, Evelse, etc logs.
        shuntographer
        runs the game seq:
        < %Paving nice, found%Pave
        < @Story: %Paving+twinned ready
        < %Paving CB also from Ghost..$z
         diff Know..$s/found%Pave with:
          Know..$s%Paving itself
            eg %cha:Thing-has:dige,src:s,from:Q
          Ghost..$z%twin, as used by Travel..$t
            eg %%cha:Thing-has:dige,src:s,from:Q,to:z,t:t
        < %Gump gets Know..$s (+ Ghost/$t..$z)? out of date
        < @Story: %Paving+twinned+%Gump ready
        < %Story:
         any Ghost/$t..$z -> Travel/$t
         notices them vanish, knows why
        < @Story:
          start Travel/* wanted,
           pre-@Search the %Gump versions (%Jhost)
            inc anything in a $W.5, with wjs %args
          start Travel/$t
          end Travel/$t
          end Travel/*
          start Duolish/*
           $u should be as input to %Gump, or restart?
          end Duolish/*, when all is commit
   =cut
   =todo
     -seven..-vat are Yingate's rows' properties
     
     < er diag, jam the Y:-seven until sorted,
        adjust ology|pointing or encoding after,
         usu define schema|depth-limit|reducer for random data
     
     -seven/-rows/-row/-vat
      -vat draws the something on the rows of -seven
     
     < -vat -> -row: brack in brack
       it would become a -row as well
     < -row:$b (anywhere) may include interesting by&up
       bc&shade, or the R/node/C via by&brack for it
       < leading back to a non-waker Yingate row,
         and then the r row that %%waits, etc
     < -row ref-itivity,
       maybe point to another -row (anywhere)
       esp as a later -seven/-rows/-row
       esp the one described in The**/Misc**
        collection of oddities (non-node items)
       or pool some misc upwards, on Misc accept:
        repile -row to point to it
        knowing that it was looking for it, eg &nodeo
     
     // less urgey
       < -R with sip|tip (serial or Te ip):
       < also know the R above R:Ying
         eg it starts with an %%e,to=Lingo-R c.o:^2
         see 'say $step..$node'
         -R names climb Rc&X beyond the last $node etc?
       < Ac&ip, like Y:Acec&ip or what Rc&ip could be,
          are per Run, per time finding names
         Cc&ip, like Jc&ip, Tec&ip or Xc&ip
          are per finding of the name, many times
         wave and particle, frames and movie
      
         # compression or re|de|piling:
         < stop at some -rows or -row if so simple,
           c&s = diagram pointering -thing** beyond
            or pointering nodepile if -n. gets complicated:
           changes (eg assigning c.ip) would need rolling out
            as some kind of change to auto-accept (%Zif)
             rename wants this
           novelty depiles back to -row/-vat
            to find &brackology to lay into
             and in general... diff long form, diag short form
   =todo

// Story - intents <-> extents
 // %Story itself
    ['Story',0.299,&acgtRs{
      // as non-%play
        me&reaw,R,'Story,Cu'
        me&inode,R
        $x = me&Jx,R
        
        # %play avoids running tests
        #  ie we are playing with the W
        $store = xs&Ying.t+"/Story%play"
        !Rc&b and Rs&play = (localStorage[store]||0) *1
        else {
            # sync %play once init
            localStorage[store] = Rs&play || 0
        }
        $play = Rs&play || 0
        me&introqua,R,{play}
        
        if (!Rs&play) {
            Rs&Shouldbeempty = 1
            me&tsc,"off",'','g'
            return
        }
        
      // as playing
        # quiet,wake:Story then Story/This
        #  ie settle non-Story**, then start Story
        sy&running = 1
        if (!sy&ever_quiet) {
            me&quiet_waker,R and sy&ever_quiet = 1
            !sy&ever_quiet and return
        }
        
        # changing Stories/Around
        me&ja,R,'Arounder' &&
            me&bal,'Arounder','Zaroum,eph'
        # sources of and tests
        me&bal,'Stories','Stories,eph'
        
        # expectation - where it begins
        
        # < Babz: o &bal,...
        #   io knowing i.bal likes to var $$t = C
        $r = me&bal,'The','The,eph'
        $The = rc&s
        #Thes&about ||= ['Fingoup','whatGumps']
        #Thes&about ||= ['Fingo-init']
        # 
        Thes&about ||= ['Dealap']
        # max 400 Yings?
        #  left failing because Dealap toodiff as firstNine
        #Thes&about ||= ['vovol','Dealap']
        # max 490 Yings
        #  left failing while Jrunto learns logging
        Thes&about ||= ['vv','Easiness']
        
        # pile of nodes
        me&bal,'Nodar','Nodar,eph'

        # navigator
        me&bal,'Plot','Plot,eph'
        
        # experience
        $r = me&bal,'This','theThis,eph'
        # is visited to draw them into %Yingates/%Yingate
        # < lighter drawing into -eight/-seven
    },'ift,D'],
  // misc Story
    # negate %onlyish sleeping innards,
    #  lose history and make untunnelable
    ['Shouldbeempty',0.33,&acgtRs{
        # < stash history until?
        $N = grepout(Rs&z,r => rs&ball && rs&sleeping)
        me&losehistory,R,N
    },'ift,D'],
    &{
        me.losehistory = &acgtRN{
            N.map(&r{
                delete Rc&X.x[r.t]
                # ^ transacted, v not
                rs&ball and rc&s.y.invalide = 1
            })
        }
    },
    ['Storiz',0.33,&acgtRs{
        me&reaw,R,'Storiz'
        me&inode,R
        $p = Ry&up
        $pb = pc&b
        $b = Rc&b
        #pb && pbs&Shouldbeempty and debugger
        Rs&icount == 1 and G&yl:6000,&{ me&elvis,R,'leeks' }
        #Rs&icount == 2 and debugger
        me&nu,'wer',R
        #me&waits,"Formore"
    },'ift,D'],
 
 // %Stories/Stori/Eighi Live
  // %Stories%Pavings
    ['Stories',0.297,&acgtRs{
        
        me&reaw,R,'Stories'
        me&inode,R;
        $x = me&Jx,R;
        Rs&Pavings = 1
        Rs&directory = "Stories"
        ah(R,'inheritscif','ball','Stori',1)
        # < give nodeo pathia, %%inside=Stori,tw=Eighi
        ah(R,'adhere','twmt',s)
        # make W**%Paving mean W/J**,
        #  J directoried inside J^
        #  %Compiling used to W**
        #  suits compiling mountains of code,
        #  to give %Paving** that hierarchy
        #   eg remotes listen to the peak
        #  as views all named in the same space
        ah(R,'adhere','director',1)
        # species=1 only
        ah(R,'adhere','fully',1)
        # less Paving brains
        # < may %onlyish settle up etc
        ah(R,'adhere','noGump',1)
        
        $r = me&bal,"Around","Around"
        $The = xs&The
        if (!Rc&b) {
            $p = me.cbu(R,r => rs&Peace == 9).y.up
            p = ps&Te
            !py&Stories_init and Thes&very_first = 1
            py&Stories_init = 1
            each it Thes&about {
                # is 1: "0" && 1
                i > 0 && !Thes&very_first and break
                # the first time Story resets, warm cache
                # this will mess up L:startStory,
                #  which never sees async &t
                me&fiu,s,t
            }
            0 == i and delete Thes&very_first
        }
        s&hue = 66
    },'ift,D'],
    ['Stories+Pavings',0.2999,&acgtRs{
        me&bewind,R and return
        me&tsc,"SP"
    },'ift,D'],
    
  // Stori/Eighi?%Paving
    # loads if The/Stori wants
    # many Stori/Eighi%dige toc for directory=$Stori
    #  usu enough to pass tests where -eight%dige matches
    ['Stori',0.291,&acgtRs{
        #me&inode,R
        #!me&za,R,'waits' && me&sleepic,R and return ~>5 Sleeps: s.t
    },'ift,D'],
    ['Stori',0.298,&acgtRs{
        me&reaw,R,'Stori'
        #me&tsc,"Stori"
        # has Eighi inside
        ah(R,'inheritscif','ball','Eighi',1)
        # Stori%twmt=Stories, Stori/**%twmt=Stori
        #  does its own %eto,tw for its Eighi
        ah(R,'adhere','twmt',s)
    },'ift,D'],
    
    # loads if Stori wants
    # download details to difference an -eight
    ['Eighi',0.33,&acgtRs{
        #me&sleepic,R and return
        me&reaw,R,'Eighi'
        
        #me&tsc,"Eighi:"+ki(Rs&twmt,2)
    },'ift,D'],
   
  // Around** < until -pipe good
    # loads, small list of potential Stori
    #  could be in each A.4 (W:Lingo) Stories,
    #   outsphere of Story/Stories
    #  since Stories%eph we must store our list
    ['Stori+Around',0.294,&acgtRs{
        me&reaw,R,'Around,onitself'
        me&inode,R
        # does its own %eto,tw
        ah(R,'adhere','twmt',s)
        #me&scroll,10
        # has ourself inside:
        #me&bal,"Around","Zaroum,eph"
    },'ift,D'],
    ['Stori+Around',0.7,&acgtRs{
        $x = me&Jx,R
        $Q = me&PaveQ,R,s
        Qc&el == 9 || x.ro("Arou",{}) and me&nodei,R,xs&Story,"Arounder"
    },'ift,D'],
    
    # like TheTest (stages Around)
    ['Zaroum',0.291,&acgtRs{
        me&reaw,R,'Zaroum,onitself'
        #debugger
        me&inode,R
        Rs&acceptables = 1
        me&tsc,"Zaroum"
        
        me&bal,"Around","Zaround,eph"
    },'ift,D'],
    ['Zaroum',0.294,&acgtRs{
        $h = {
            ytag: 'origin',
            self: &acgtnt{
                $r = me&bal,"Re:"+t.t,'ReArou,unity,eph'
                $z = rc&s
                return z
            },
            other: &acgtntzlm{
                return me&fiu,z,l.t
            },
        }
        me&acceptables_reother,R,h
    },'ift,D'],
   // ReArou
    ['ReArou',0.295,&acgtRs{
        me&reaw,R,'ReArou,unity'
        ah(R,'inheritscif','ball','ReArou',1)
    },'ift,D'],
    ['ReArou+unity',0.35,&acgtRs{
        $N = me&ioty,R,'ReArou'
        s&bg = '#180213'
        # Accepting:Push
        me&toPaves,R,[R,...N]
    },'ift,D'],
    # ReArou** difference and flock apply again
    ['ReArou',0.33,&acgtRs{
        $go = me&acting,R,'Re'
        $x = me&Jx,R;
        # the got, being pushed, is 
        $The = sy&origin
        $t = me&twineThat,R,The,{origin:xs&Stories}
        t and me&toPave,R,R,t,The

        go and me&nu,"The",The
        !t and return
        $r = ty&R
        $Q = rs&Q;
        if (go) {
            me&nu,"Q",Q
            me&nu,"P",Qs&P
        }
    },'ift,D'],
    
    
   // Zaround
    # like TheNine (for Around)
    ['Zaround',0.33,&acgtRs{
        me&reaw,R,'Zaround,onitself'
        #debugger
        me&inode,R
        me&tsc,"Zaro"
        $x = me&Jx,R
        $that = me&getThat,R,xs&Stories,"Around"
        !that and return
        #me&nu,'that',that
        $self = me&selfThat,R,that
        #me&nu,'self',self
        
        $r = me&bal,s.t,self,'ZaTen,eph'
    },'ift,D'],
    ['ZaTen',0.294,&acgtRs{
        me&tsc,"ZaTen"
        me&reaw,R,'ZaTen,bal_tw_s'
        Rs&acceptables = 1
        ah(R,'inheritscif','ball','ZaNine',1)
        $go = me&acting,R,'Nine'
        $x = me&Jx,R;
        $Plot = xs&Plot
        sc&pi = 'Arou'
        # roll the invention of Eigh s
        me&sleepic,R and me&rollbs,R,'bal_tw_s'; return
        
        if (!me&ioty,s .length) {
            me&fiu,s,"Roundness"
        }
    },'ift,D'],
    ['ZaTen',0.67,&acgtRs{
        $N = me&ioty,R,'ZaNine'
        # -nine settles the -eights, see &sleepic
        # < create new &settles and go to sleep
        #me&settle,R,N && me&sleepic,R,2 and return
        me&acceptables,R,N
        $c = {
            
            # Eigh have inside:
            #  t may be accepted in-change
            # outside:
            #  merely reincludes Nine/$z (Eigh%exp)
            #  z%* or z/* may have been changed
            #   are meta or recipe for the running of it
            # z separates to allow y&up=O, keeps s&z, y&*
            # < align diff chunks outside Nine/($z**)
            #    per Nine/($t** inside)
            
            # an Eigh accepted again
            accept: &acgtsOrznt{
                me&accept,R,t
                $dige = me&storable,t
                # Nine/$z links /$eight
                $Z = G&Cye,z
                me&fiu,O,Z,2
                Zc&pi = 'eight'
                Zs&dige = dige
            },
            # an Eigh still
            sleep: &acgtsOrz{
                $Z = G&Cye,z
                me&fiu,O,Z,2
            },
            # the Nine itself
            self: &acgtsO{
                me&Linets,s,O
                me&accept,R,s
            },
        }
        me&acceptables_reself,R,N,c
    },'ift,D'],
    ['ZaNine',0.291,&acgtRs{
        me&inode,R
        me&tsc,"ZaNine"
    },'ift,D'],
 
 // %The/Test/Nine/Eigh pos
  // 1 %TheTest o Stori
    ['The',0.292,&acgtR,The{
        me&reaw,R,'The'
        me&inode,R
        $x = me&Jx,R
        ah(R,'inheritscif','ball','TheTest',1)
        # init The/$t/$t
        #  which %%Nine -> Plot, then <-> eight
        $Story = xs&Story
        $about = uniq([
            # < load all %about from the start
            #   needs to make a Nine current
            Thes&about[0],
            ... me&jaa,R,'Nine',1 ,
        ])
        each it about {
            $n = me&fiu,The,t
            i == 0 and ns&firstNine = 1
        }
    },'ift,D'],
    # -nine being Zavable
    ['TheTest',0.294,&acgtRs{
        
        me&reaw,R,'TheTest,shelf'
        me&rollbs,R,'shelf'
        Rs&acceptables = 1
        $go = me&acting,R,'Test'
        $x = me&Jx,R;
        # wants to get Stories/$t(/$bits)
        #  and commit them all at once, with history
        #  and commit $t -> Stories/Around
        $that = me&getThat,R,xs&Stories,s.t
        !that and return
        
        $The = xs&The
        if (Thes&very_first) {
            # reset after warming cache
            $p = me.cbu(R,r => rs&Peace == 9).y.up
            !ps&JRom and throw "where"
            ps&reset = 1
        }
        
        # then harness %Live into TheNine
        # < harness self (TheNine<->...) <-> other (Paving)
        $self = me&selfThat,R,that
        
        # doesn't reload Nine/Eigh
        # < unless it looks pulley
        #   without losing all the L-mapping etc: lv in?
        !Rs&shelf and Rs&shelf = self
        else
        self != Rs&shelf and me&tsc,'re-self',0,'g'
        self = Rs&shelf
        
        # < a Stori could compose many Stori,
        #    a Stori = plot - subplots
        #     subplots pointed to, recipised to solo:
        #      being vague about -nodes,
        #      templating the test data for inputs from Stori,
        #      from Zif noticing only $t, $begin|end_dige change
        $r = me&bal,s.t,self,'TheNine,eph'
        rc&s != self and me&nu,"Craze",rc&s
        sy&Nine = self
    },'ift,D'],
       
  // 3  %TheNine -> $eight
    # Nine/$exp + Story/-eight%Yingates
    #  = Nine/Eigh%exp+%got
    ['TheNine',0.295,&acgtRs{
        
        me&reaw,R,'TheNine,bal_tw_s'
        Rs&noRsync = 1
        Rs&acceptables = 1
        $go = me&acting,R,'Nine'
        $x = me&Jx,R;
        $Plot = xs&Plot
        sc&pi = 'nine'
        # roll the invention of Eigh s
        me&sleepic,R and me&rollbs,R,'bal_tw_s'; return
        
        if (sy&autoviv && !me&ioty,s .length) {
            ac(Plot,'autovivNine',s.t)
            if (ss&firstNine) {
                # init something for &Plot_Default to begin on
                #  usu tests grow off the end of others and never:
                # need to ignore startup (2 Pages, by the time Plot&init)
                me&fiu,s,['beginning',1,{},{L:'startup',ignore:'start'}]
                # and then this will turn into something
                me&fiu,s,['le-3',1,{},{L:'further'}]
            }
            else {
                # the next Test, Pages probably renumbered like so:
                me&fiu,s,[s.t+'-1',1,{},{L:'intoit'}]
            }
        }
        # $Nine cloned from a Stories/Stori
        # $Nine/* become Eigh%exp (have %dige, instructions)
        # these eight -> Eigh%got (have %dige%string, y&Point=$L)
        # < %%Having,eight come in order?
        $gotN = me&jaa,R,"eight,Having,L",1
        me&twlic,gotN,s (&lzct{
            $r = c.surprise ? me&bal,t,'eph'
                : me&bal,t,l
            
            ex(r.sc,c)
            #me&tsc,"Ergo:"+t+(ki(c)) .sc.dis = 1
            
            rs&TheEigh = 1
            l and rs&exp = l
            z and rs&got = z
        })
    },'ift,D'],
    # next to TheEigh
    ['EighExp',0.32,&acgtRs{
        me&reaw,R,'EighExp,title'
        s&bgh = '000'
    },'ift,D'],
    
  // 4  %TheNine <- $eight
    # many acceptables
    ['acceptables',0.295,&acgtRs{
        me&reaw,R,'acceptables,reself'
        me&rollbs,R,'reself'
    },'ift,D'],
    ['TheNine',0.67,&acgtRs{
        
        $N = me&ioty,R,'TheEigh'
        # -nine settles the -eights, see &sleepic
        # < create new &settles and go to sleep
        #me&settle,R,N && me&sleepic,R,2 and return
        me&acceptables,R,N
        $c = {
            
            # Eigh have inside:
            #  t may be accepted in-change
            # outside:
            #  merely reincludes Nine/$z (Eigh%exp)
            #  z%* or z/* may have been changed
            #   are meta or recipe for the running of it
            # z separates to allow y&up=O, keeps s&z, y&*
            # < align diff chunks outside Nine/($z**)
            #    per Nine/($t** inside)
            
            # an Eigh accepted again
            accept: &acgtsOrznt{
                me&accept,R,t
                $dige = me&storable,t
                # Nine/$z links /$eight
                $Z = G&Cye,z
                me&fiu,O,Z,2
                Zc&pi = 'eight'
                Zs&dige = dige
            },
            # an Eigh still
            sleep: &acgtsOrz{
                !rs&exp and return
                rs&exp != z and debugger
                $Z = G&Cye,z
                me&fiu,O,Z,2
            },
            # the Nine itself
            self: &acgtsO{
                me&Linets,s,O
                me&accept,R,s
            }
        }
        me&acceptables_reself,R,N,c
    },'ift,D'],
  
  // 6  %TheEigh 
    ['TheEigh',0.33,&acgtRs{
        me&reaw,R,'TheEigh,exp,got,now_missing'
        $x = me&Jx,R
        $go = me&acting,R,'Eigh'
        
        $t = Rs&exp
        $z = Rs&got
        $L = z && zy&Point
        
        # z-eight is already Lineso:
        $Dige = z && zs&dige
        $cha = !Dige || !me&za,R,{Dige}
        Dige and me&ha,R,{Dige}
        !cha && me&sleepic,R and return
        if (go) {
            me&zu,"TheEigh",s
            me&zu,"Exp",t
            me&zu,"Got",z
            me&zu,"Point",L
        }
    },'ift,D'],
    ['TheEigh',0.36,&acgtRs{
        
        $t = Rs&exp
        $z = Rs&got
        me&Pointness
        
        # has -eight happened (got got)
        !z || !zs&dige || !zs&string and return me&ha,R,'unready'
        # < exp ||= surprise?
        
        # from here, it's a &toPave that doesn't pushPave at the end,
        #  instead sending the flock of storables onward
        me&acceptable,R,z,t
        
        # < probably want Qdiff,z,t=null
        #    or know t is a link, do &moreThat
        #    or t could be this step's part of another &Linets
        #     and need to other it there and then commit that,
        #      staging chunk regroup for commit essential
        #     lots of slightly different %%$word...,
        #      iterating commissions on 
        if (me&ja,R,'ok' ) {
            s&bgh = '041'
            # &Effect needs to be permanent (or %%dome)
            me&Effect,s,zy&eight,'isok',{ok:1,ope:0}
            if (!me&za,R,'ok' ) {
                me&yyt,z,'on_ok',R,s
            }
            return
        }
        # when Story is recording itself,
        # these all cause that -eight to show the failing, etc
        if (!t) {
            me&log,R,"Unexpected",{got:z}
            return
        }
        if (me&za,R,'unready' ) {
            me&log,R,"Failing",{got:z}
            if (Rs&trailing) {
                # beyond last expected thing
                me&log,R,"Trailing"
            }
        }
        # receive the got into a diff against the full self
        !(tc&pi && ts&dige) and return me&tsc,"Nine/!-eight"
        
        $self = me&moreThat,R,t,t
        !self and return me&waits,"Nine/.."
        
        $Q = me&PaveQ,R,selfy&That
        
        me&Qdiff,R,z,Q
        # < to &brackology
        # < mergible
    },'ift,D'],
  
  // 7 %ReNine reselfs <- %TheNine
    # < i $t... ytia o %%acceptia:t
    ['TheTest',0.294,&acgtRs{
        $x = me&Jx,R
        $h = {
            ytag: 'origin',
            self: &acgtnt{
                $r = me&bal,"Re:"+t.t,'ReNine,unity,eph'
                $z = rc&s
                zy&store = xs&Stories
                return z
            },
            other: &acgtntzlm{
                return me&fiu,z,l.t
            },
        }
        me&acceptables_reother,R,h
    },'ift,D'],
    ['ReNine',0.295,&acgtRs{
        me&reaw,R,'ReNine,unity'
        ah(R,'inheritscif','ball','ReNine',1)
    },'ift,D'],
    ['ReNine+unity',0.35,&acgtRs{
        $N = me&ioty,R,'ReNine'
        s&bg = '#180213'
        
        # Accepting:Push
        me&toPaves,R,[R,...N]
        # engages
        # < subscribe to Q-1 for this
        me&da,R,'Pushable,go'
            && me&log,R,'Pushabilityofthethingthatisnow'
        
        # completes: L%resumed for any fixed up
        me&da,R,'allok:Push'
            && uniq(me&ioty,R,'ReNine' .map(&r{
                    $z = rc&s
                    $ze = zy&origin
                    return zey&Point
            })).map(L => L && me&ReNine_pushed_Point,R,L )
    },'ift,D'],
    # ReNine** difference and flock apply again
    ['ReNine',0.33,&acgtRs{
        $go = me&acting,R,'Re'
        $x = me&Jx,R;
        # the got, being pushed, is 
        $The = sy&origin
        # < de-dupe meaning of 'origin'
        # into the enclosing Stories or /Stori**
        $store
        me.cby(R,&r{
            !rs&ReNine and return 1
            !rs&unity and return 0
            $z = rc&s
            z && zy&store and store = zy&store
        })
        #!store and throw "^^^ReNine!y&store"
        # < because pipe can go back through Nine &reother,
        #    and Test/Nine &reself
        $t = me&twineThat,R,The,{store}
        # < ReNine species
        t and me&toPave,R,R,t,The

        go and me&nu,"The",The
        !t and return
        $r = ty&R
        $Q = rs&Q;
        if (go) {
            me&nu,"Q",Q
            me&nu,"P",Qs&P
        }
    },'ift,D'],
 
 // This%Storystream
  
  // Outlog/* group into Pages -> /$eight
    ['theThis',0.293,&acgtRs{
        me&reaw,R,'theThis,wakeful,onlyish'
        me&inode,R
        # wake R when p%onlyish/R%wakeful
        Rs&wakeful = 1
        # sleep r when R%onlyish/r!%wakeful
        Rs&onlyish = 1
        
        $c = {s: me&theOutlog,R }
        me&Storystream,R,s,c
    },'ift,D'],
    ['theThis',0.296,&acgtRs{
        $D = Rs&Storystream
        $x = me&Jx,R
        # draw the story, probably chunked by a %%quiet
        each im Ds&z {
            mc&pi ||= 'eight'
            # %onlyish 294 has made these if sleeping them
            $r = me&bal,m.t,m,'Yingates,eph'
            rc&s != m and throw 'crae'
        }
        # leaves current -gate streaming
        r and rs&wakeful = 1
    },'ift,D'],
        
    # when e,on:m%Yingates, it keeps filling up
    ['sleeping+Storystream',0.53,&acgtRs{
        $D = Rs&Storystream
        # < want to have a sleeping This just for this
        #    more often than waiting til quiet
        #   moment to picture things before they ~ again
        Dy&stream()
    },'ift,D'],
    &{
    me.Storystream = &acgtRsc{
        
        $x = me&Jx,R
        me&reaw,R,'Storystream,pause'
        me&rollbs,R,'Storystream'
        $D =
        # < it having a Y to consider, slepvia
        sy&Storystream =
        Rs&Storystream ||= me&logdome,R,s
        !c.s and throw "thing to follow"
        Dc&thing = c.s
        Dc&ignoring = x.ro('pause',{})
        
  // Ploty&Pageturn(ing)
        # page turning
        # may be unturned, see merge similar previous
        # < turn fractions of a page|plot, when|why
        $Plot = xs&Plot
        $This = s
        # just the turney bit
        Thisy&Pageturn = &q{
            # othery before turn: make name
            $t = me&yyt,Plot,'Pageturning',R,D
                || "blank-"+(1+hak(Ds&z))
            # close
            Dy&domed(q)
            # open
            Dy&dome(t,'light')
            return D
        }
        $page_turning = &q{
            # turney bit:
            me&yyt,This,'Pageturn'
            
            # othery &Plot_Pageturn responds to it
            me&yyt,Plot,'Pageturn',R,D
            
            $i = Ds&z.length
            i > 15 and Rs&pause = 1; ss&overturning = 1
            # < Plot leaves tightenable hooks
            #   for Yingate_2 -> Outlog -> next:
        }
        # when it matters, want to self,
        #  even if too close to the last quiet,wake (loop avoidance)
        $Y = me.cbu(R,'Ying').sc.Ying
        Ys&quiet_wakers_too_recently = &R{
            #~>4 pagequiet: Plots&Page
            # can sometimes want to happen:
            #  must self to act first in the next Page
            #   < supposing multiple layers of quiet_wakers
            me&yyt,Plot,'Pageturnable',R,D and return 1
            page_turning()
        }
        
  // usu on a quiet wake
        # takes over from Story
        $q = me&quiet_waker,R
        q ||= !sy&quue
        sy&quue = 1
        if (q) {
            me&tsc,"q";
            #~>4 quiet,wake: s.t
            $Ying = xc&Ying
            !Yings&Det and throw "!Det"
            $q = {}
            if (1) {
                # until the current Outlog:D
                #  so pages|-eights end with %%quiet(_recently,wake)
                q.until = Yings&Det
            }
            else {
                # OR, not. have on the old page:
                #  quiet waking %%node:This..
                #  < log:Pageturn...Point++ etc
                #   takes a few wakes to ready the next Point,
                #  should be on the old page?
                #   since they mention the old Point
                #  which is likely to be %%Ignored
                #   or grepo everything from Story**
                #    see Ying only in or out of some subnet
                #    may take templating the new Point in the old page,
                #     for a beginning with many different middles parametised
                #     watching the new Point set up there too
                #      and stream() just before it really starts
            }
            page_turning(q)
        }
        # then inhaling nothing if the page was just turned ^
        Dy&stream()
    }
    },
 
 // This/$eight/$seven details
   
  // $eight/$seven
    ['Yingates',0.296,&acgtRs{
        
        me&reaw,R,'Yingates,wakeful,who'
        me&inode,R
        $x = me&Jx,R
        Rs&rowish = 1
        # R/* become %Yingate!%ball
        Rs&noRsync = 1
        
        $E = Rs&eight = me&pieight,R,s,1
        $L = sy&Point
        
        if (Rs&wakeful) {
            # no -eight, yes -seven
            # < or -eight without &enL?
            me&tsc,"wakeful",0,'g'
        }
        else {
            # complete -eight
            Rs&Fin = 1
        }
        
        each in ss&z {
            $r = me&Ret,R,{t:"n:"+i,s:n,Yingate:1}
        }
    },'ift,D'],
   
  // -seven -> &brackology
    # < self a -seven
    #   has a &brackology + more
    # < brackology rearranging so node:Gilramp=wake
    # < saying when node:Travel..Gilramp
    ['Yingate',0.32,&acgtRs{
        sy&R = R
        $p = Ry&up
        $z = pc&s
        
        sc&pi ||= 'ugh'
        s&hue = 138
        # -seven...-ologise also colours it
        
        # have serials now interspersed
        # < notice c&i per c&pi?
        sc&i != null &&
            n Dci 01 $s:sc&i %fs:8
        # may be  (Dc&i per Dc&pi?)
        $zi = zs&z.indexOf(s)
        
        me&piseven,R,s,{t:zi,D:s}
    },'ift,D'],
    
    # < othering back into &brackology any novelty
    ['Yingate',0.44,&acgtRs{
        me&reaw,R,'Yingate'
        Rs&rowish = 1
        !sy&seven and return
        $x = me&Jx,R;
        $go = me&acting,R,'-seven',0
        
    },'ift,D'],
   
  // -eight/-seven
    # -eight collects -four,-seven+
    #  -seven selfs &brackology
    #   < slep
    # other it/them to:
    #  c.expect: Nine/$t
    #   < chunk difference
    #  c.nlist: official nodes
    #   -n can tpath relative to their name
    # < see Atiming of R,R/*, adjust cv for less rounds
    ['Yingates+Fin',0.33,&acgtRs{
        
        me&bewind,R and return
        Rs&fixatfour = 1
        $x = me&Jx,R;
        $go = me&acting,R,'-eight',0
        
        $E = Rs&eight
        $L = me&Pointness
        L != sy&Point and debugger
        
        # page of story: -eight a %Yingates
        $c = {ov:0.4}
        $Ch = c.Checkable = me&jaa,R,'Checkable,efrom' [0]
        if (Ch) {
            c.ov = 0.9
            # have name pile
            $No = xs&Nodar
            $X = Noy&X
            c.nlist = X.ss
            # Nine/$t instrunction
            $z = Chs&expect
            z and c.expect = z
            go and me&zu,"exp",z
            # send results
            c.Finto = Chs&efrom
        }
        else {
            if (L && Ls&checking) {
                # unchecked checkingness
                #  esp avoid if %Fuguing
                #   it will be loading more test data to diff
                me&Effect,s,E,'acheck','Ignored,ope:0'
                me&tsc,"acheck",0,'g'
            }
            elsif (me&ja,R,'Ignored' || me&ja,R,'Ignorable') {
                # ^ from This noticing no L for it, or ^ reason:
                # < that it was expected:
                $why = me&ja,R,'Ignorable',0
                $n = me&tsc,"Ignored:"+(why||"?"),"Ignored","g"
                !why and ns&fs = 18
                me&Effect,s,E,'Ignored','Ignored,ope:0'
            }
            elsif (Rs&icount < 5) {
                # start hidden, later Effect:diff reveals
                me&Effect,s,E,'hid',{hid:1,ope:0}
            }
        }
        
        me&pieight,R,s,c
        
        if (Ch) {
            # -> Eigh
            # randomly not part of %%Checkable circuit
            me&nodei,R,Chs&efrom,{Fin:s,dige:ss&dige}
        }
        else {
            !Es&Ignored and me&tsc,"..Checkable"
        }
    },'ift,D'],

// %Fish(This|Eight|Seven) for -seven etc to happen within
  
  # ensures This is The
  
  # see @Gome
  // F(ishSt)ories # storage
    # < &thide if normal, wordpres
    ['Fories',0.297,&acgtRs{
        me&reaw,R,'Fories,bal_tw_s'
        me&inode,R;
        $x = me&Jx,R;
        me&sleepic,R and me&rollbs,R,'bal_tw_s'; return
        Rs&Pavings = 1
        Rs&directory = "Stories"
        ah(R,'inheritscif','ball','Stori',1)
        # < give nodeo pathia, %%inside=Stori,tw=Eighi
        ah(R,'adhere','twmt',s)
        # make W**%Paving mean W/J**,
        #  J directoried inside J^
        #  %Compiling used to W**
        #  suits compiling mountains of code,
        #  to give %Paving** that hierarchy
        #   eg remotes listen to the peak
        #  as views all named in the same space
        ah(R,'adhere','director',1)
        # species=1 immediately, probably about to use it
        ah(R,'adhere','fully',1)
        # less Paving brains
        # < may %onlyish settle up etc
        ah(R,'adhere','noGump',1)
    },'ift,D'],
    ['Fories',0.397,&acgtRs{
        s&dis = 5
        delete Rs&rowish
    },'ift,D'],
  // TheF* # storables self
    ['TheF',0.292,&acgtRs{
        me&reaw,R,'TheF,bal_tw_s'
        me&acting,R,'TheF'
        me&sleepic,R and me&rollbs,R,'bal_tw_s'; return
        $x = me&Jx,R
        ah(R,'inheritscif','ball','TheFest',1)
        # init The/$t/$t
        #  which %%Nine -> Plot, then <-> eight
        $about = uniq([
            # < load all %about from the start
            #   needs to make a Nine current
            ss&about[0],
            ... me&jaa,R,'Nine',1 ,
        ])
        each it about {
            $n = me&fiu,s,t
        }
    },'ift,D'],
    # -nine being Zavable
    ['TheFest',0.294,&acgtRs{
        me&tc,'TheFest','b'
        me&reaw,R,'TheFest,shelf'
        me&rollbs,R,'shelf'
        Rs&acceptables = 1
        $go = me&acting,R,'Fest'
        $x = me&Jx,R;
        # wants to get Stories/$t(/$bits)
        #  and commit them all at once, with history
        #  and commit $t -> Stories/Around
        $that = me&getThat,R,xs&Fories,s.t
        !that and return
        
        $c = {}
        if (Rs&shelf) {
            # the self we have been using
            # anyone can Ef%%curse=this_self
            $Ec = {curse:1,mode:'includes',s:Rs&shelf,go}
            $cursed = me&Effected,s,Ec
            if (cursed) {
                # < refer to this @This in &SuperSC
                me&tc,"cursed:",'b'
                # light up the Leave button
                # < call this tied-e?
                ah(R,'c','b','sc','Leave',1)
            }
        }
        # < a buttoner|Effector that can glow 'Leave' because c.pull
        # then harness %Live into TheNine
        # < harness self (TheNine<->...) <-> other (Paving)
        x.ro('Leave') and c.pull = 1
        cursed && c.pull != 1 and debugger
        $self = me&selfThat,R,that,c
        
        # doesn't reload Nine/Eigh
        # < unless it looks pulley
        #   without losing all the L-mapping etc: lv in?
        c.pull and Rs&shelf = self
        !Rs&shelf and Rs&shelf = self
        else
        # < make warning?
        self != Rs&shelf and me&tsc,'re-self',0,'g'
        self = Rs&shelf
        
        # < a Stori could compose many Stori,
        #    a Stori = plot - subplots
        #     subplots pointed to, recipised to solo:
        #      being vague about -nodes,
        #      templating the test data for inputs from Stori,
        #      from Zif noticing only $t, $begin|end_dige change
        $r = me&bal,s.t,self,'TheFine,eph'
        rc&s != self and me&nu,"Craze",rc&s
        sy&Nine = self
        c.pull and rs&igV = 1
        
        me&ha,R,'selfReady'
    },'ift,D'],
    ['TheFest',0.294,&acgtRs{
        $x = me&Jx,R
        $h = {
            ytag: 'origin',
            self: &acgtnt{
                $r = me&bal,"Re:"+t.t,'ReNine,unity,eph'
                $z = rc&s
                zy&store = xs&Fories
                return z
            },
            other: &acgtntzlm{
                return me&fiu,z,l.t
            },
        }
        me&acceptables_reother,R,h
    },'ift,D'],
  
  // TheFine-nine
    
    =pod
     -nine/* binds The + This
      The=Fine, specifically its s/-Ness** (outsphere)
     E-nine syncs:
      /The/-Ness** from Fine/-Ness
       outsphere knows (vaguely):
      /This/-Eight** from This
     to:
      /Ness/-Ness** how we did
     /The/-Ness downloads to /Ness/-Ness (not %dige)
      to instruct it to do stuff
      ~ in /Ness/-Ness**,
       our place to hang up &togcon|adjustments
      compares to /The/-Ness**,
       patching etc, wants Fine &accept
      as &bal-bits where ~
       display elvising into R:This**
       relative to this test,
        stacking up old Fine to retrieve|replay acts from
        time dilation zone
     anyway
      /Ness/-Ness
       makes %dige per regrouped This** received
    =cut
    &{
    // -nine/-Ness
        # < are here and there, should more like &EsyncThis...
        me.iNess = &acgtsc{
            !c.t and debugger
            # may have already...
            # < almost &clinto: pull the outsphere per -Ness
            $z = me&fiu,s,c.t,8 || me&fiu,s,[c.t,'-Ness']
            return z
        }
        # i outsphere || something
        # s-nine/*-Ness:N -> E/Ness/*
        me.EsyncThe = &acgtEsc{
            $Ness = me&fiu,E,'Ness'
            
            # -nine/* from Fine/*
            $The = me&fiu,E,'The'
            # < sync proper, beyond el:2
            me&clintout,s,The,'-Ness' .map(&g{
                $n = gy&C
                if (1 || gc&el <8) {
                    # < should build tw, separate?
                    #i $Ness/@sum/** yOuts o $n:sum/**
                    $z = me&iNess,Ness,{t:n.t}
                    me&clonover,z,n
                    me&ioty,n .map(&e{
                        ec&pi != 'Eight' and debugger
                        $ze = me&fiu,z,e.t
                        me&clonover,ze,e
                        
                        me&ioty,e .map(&v{
                            vc&pi != 'seven' and debugger
                            $ve = me&fiu,ze,v.t
                            me&clonover,ve,v
                            
                            me&ioty,v .map(&V{
                                # pointers per -seven?
                                debugger
                            })
                        })
                    })
                    # EsyncThis causes -Ness @3
                    #zc&el = 3
                }
            })
            
            # -nine/* autoviv
            $M = me&pity,Ness,'-Ness'
            !hak(M) and me&iNess,Ness,{t:E.t+'-1'}
            
            me&EnextNess,E,s,c
        }
        # sets next Ec&Into=-Ness beyond any in Es&Is
        me.EnextNess = &acgtEsc{
            $Ness = me&fiu,E,'Ness'
            $M = me&pity,Ness,'-Ness'
            $completeNess = &z{
                # the almost Ec&Is
                (Es&Is||[]).includes(z) and return 1
                (c.almostIs||[]).includes(z) and return 1
            }
            each iz M {
                completeNess(z) and z = 0; continue
                Ec&Into = z
                break
            }
            Ec&Into && !M.includes(Ec&Into) and debugger
            if (Ec&Into != z) {
                # new -Ness (to E...)
                $t = E.t+'-'+(M.length+1)
                me&fiu,Ness,t,8 and throw "!Guessnew"
                $z = me&iNess,Ness,{t}
                Ec&Into = z
            }
        }
    // -nine/This
     // io-adapti
        # list filter by M=$pi and N=$scgk
        me.pity = &acgtsMN{
            $N = me&ioty,s,N
            $pi = M && M[0] == '-' && M.substr(1)
            pi and N = N.filter(n => nc&pi == pi)
            else
            M and debugger
            return N
        }
        
        # Ness..z <- The..g
        # < qua scuttle space
        me.clonover = &acgtzg{
            zy&Outs = g
            each kv g.c {
                k == 'el' and continue
                z.c[k] = v
            }
            each kv g.sc {
                k == 'tige' and continue
                k == 'dige' and continue
                k == 'z' and continue
                z.sc[k] = v
            }
        }
        # E/The|This/** have yC=The|This/**
        me.clintout = &acgtszk{
            return me&pity,s,k .map(&n{
                $Eig = me&fiu,z,n.t
                $el = 8
                Eigs&tige != ns&tige and el = 3
                Eigy&C != n and el = 2
                Eigy&C = n
                Eigs&tige = ns&tige
                Eigc&el = el
                return Eig
            })
        }
        
        # This
        # you or your yC having dige
        me.digeward = &acgtn,easy{
            # set up some linearity
            $nt = ns&dige && n || ny&C
            nts&dige and return nt
            else
            !easy and debugger
        }
        # i $z/@n y- o $s/*:n%$k
        me.clinto = &acgtszk{
            return me&pity,s,k .map(&n{
                $Eig = me&fiu,z,n.t
                $el = 8
                $nt = me&digeward,n
                Eigs&dige != nts&dige and el = 3
                Eigy&C != n and el = 2
                Eigy&C = n
                Eigs&dige = nts&dige
                Eigc&el = el
                return Eig
            })
        }
        # o $z/@n y- o $s/*:n%$k
        me.clonto = &acgtszk{
            return me&pity,s,k .map(&n{
                $Eig = me&fiu,z,n.t,8
                $el = 8
                !Eig and return el = 2
                $nt = me&digeward,n
                Eigs&dige != nts&dige and el = 3
                Eigy&C != n and el = 2
                # returns el+
                return el
            })
        }
     // &FasyncThis: @Gome wants Fine
        # from Gome, notices ~This, returns TheFine+ to wake
        me.FasyncThis = &acgtFc{
            $r = me&yfuture,F
            !rs&TheF and debugger
            $This = c.This
            !This and debugger
            # This** -> TheFc&InFine=TheFine(-nine)
            $s = Fc&InFine
            # may be on the wake
            c.wake = []
            c.el = 8
            $el = &vs{
                c.el = v
                s && c.wake.push(s)
                return c
            }
            # too new
            # < could [F] in this case? make too busy? if !b?
            #   wants what is currently happening? since Gome..TheF
            #   so just Ring inside TheF until got?
            #    or shallow comeback here later
            #   the waits_8|Ying_8 do-over...
            #   the A:Gome vs A:Fine
            !s and return el(1)
            sc&pi != 'nine' and debugger
            !sy&nine and return el(1,s)
            c.InFine = s
            # into the -nine's &EsyncThis
            $E = fi&getpi,s
            $Eis = me&fiu,E,'This',7
            # checks curret F%Into=-nine/This
            !Eisy&C and debugger
            if (Eisy&C != This) {
                # for Gome to pull a new Fine
                me&Fineiscursed,s
                return el(2)
            }
            
            # -nine/This/*%dige slep
            !me&Thislooksready,This and return el(1,This)
            
            # stream when acty c&el
            # < never set everything to el:8?
            $N = me&clonto,This,Eis,'-Eight'
                .filter(el => el <8)
            hak(N) and return el(3,s)
            
            return el(8)
        }
        me.Fineiscursed = &acgtzn{
            n ||= 1
            zs&cursed = (zs&cursed||0) + n
        }
        me.Thislooksready = &acgt,This{
            # it must be a complete This
            # < Ying_8 mutex Gome + SC
            $N = me&pity,This,'-Eight'
            each in N {
                !me&digeward,n,'easy' and return 0
            }
            return 1
        }
     // &EsyncThis: Fine-nine <- This
        # does a -Ness..-seven complete its -Eight?
        me.Esevencompletey = &acgtEsc,Es{
            $Ei = Esy&up
            Esc&pi != 'seven' and debugger
            # if -Eight/-seven were from Fine
            #  otherwise they pile into one -Ness per -nine
            !(Eiy&Outs && Esy&Outs) and return
            # < doing a looser what-looks-good
            #   where serial numbering is different etc...
            $lastEs = me&pity,Ei,'-seven' .slice(-1)[0]
            !lastEsy&Outs and debugger
            # completes -Eight
            return Es == lastEs
        }
        # E/Ness/-Ness from /**
        # < merge with &uptopi?
        me.suptoNess = &acgtz{
            $Ness = me.cbu(z,s=>sc&pi=='Ness')
            !Ness and debugger
            return Ness
        }
        # pull This/** into E/Ness/**
        me.EsyncThis = &acgtEsc{
            
            $This = c.This
            $Eis = me&fiu,E,'This'
            
            # Fine follows only one This
            # < with &Xio
            if (Eisy&C && Eisy&C != This) {
                me&Fineiscursed,s,0.001
                # let Gome decide to Leave Fine, via &FsyncThis
                $R = me&R
                $x = me&Gome_Jx,R
                me&Effect,s,xs&Gome,'Finecursed',{curse:s}
                # dont sync a leaving This
                # < syncThis while|post Leave Fine?
                #   cancelled Fine+This may stack up somewhere
                return []
            }
            Eisy&C = This
            
            # -ninec&Into -> E/Ness/-Ness:Into
            #  current -seven receiver
            !Ec&Into and debugger
            # < i $likelyNess/@g:Ei/@e:Es y- o $This/:g/:e
            #   looking for -Ness with traces of Ei/Es
            # find batch of E/This/g/e wanting update
            # < o This/:g/:e{el<8}
            $N = me&clinto,This,Eis,'-Eight' .map(&g{
                $n = gy&C
                return {g,N: me&clinto,n,g,'-seven' }
            })
            $sevens = []
            $assigning = &{
                # -Ness completing (any) bunch of /-Eight/*-seven
                #  assign the rest of This..-seven after -Ness++
                #  which means full of known (to Outs) -sevens
                $fullNess = []
                each i,gh N {
                    $g = gh.g
                    $n = gy&C
                    each ie gh.N {
                        $en = ey&C

                        sevens.includes(e) and continue
                        sevens.push(e)
                        # the current -Ness=Ec&Into
                        # selected and may fill up per -seven
                        # < they could go any -Ness, grudgingly
                        $Ness = Ec&Into

                        if (!es&inNess || ec&el <8) {
                            # make -Ness/-Eight/-seven
                            # < with &Xio
                            $Ei = me&fiu,Ness,g.t
                            # directly to E-Eight, which yC%string
                            Eiy&C = n
                            Eic&pi = 'Eight'
                            $Es = me&fiu,Ei,e.t
                            Esy&C = en
                            Esc&pi = 'seven'
                            es&inNess = Es
                            if (me&Esevencompletey,E,s,c,Es) {
                                fullNess.push(Ness)
                                # other -Eights, then next -Ness
                                break
                            }
                        }
                    }
                }
                if (hak(fullNess)) {
                    # the almost Ec&Is, not to be Ec&Into
                    $almost = c.almostIs ||= []
                    almost.push(...fullNess)
                    me&EnextNess,E,s,c
                    return 1
                }
            }
            $max = 5
            while (assigning()) {
                max-- < 0 and debugger
            }
            
            # things we visit wake downstream
            $Ness = me&fiu,E,'Ness'
            $Nesses = me&pity,Ness,'-Ness'
            uniq(sevens).map(&e{
                $Es = es&inNess
                !Es and debugger
                if (c.DIY || ec&el <8) {
                    $Ness = me&suptoNess,Es
                    if (ec&el <8) {
                        # only latest -Ness should ~
                        $justdid = Ness == Ec&Into
                            || (c.almostIs||[]).includes(Ness)
                        !justdid and debugger
                    }
                    !Nesses.includes(Ness) and debugger
                    # or:
                    Nessc&el = 3
                }
            })
            # also anything &EsyncThe bumps
            return Nesses .filter(z => zc&el <8)
        }
    // -nine
        # < outsphere (W:$t%Fine) wants:
        #    Fine/-Ness/-Eight/-seven
        #   ie toc hoisted from each W:$t/-Ness
        #    a good level of detail
        #     may be lum if you really want
        #      lots of A:Fish per A:Gome
        #    can clue a -Ness waiting for more -seven
        #     %%quiet bringing it around for progress check...
        #    otherwise assume -Ness complete on -nine
        #     and make a new Ec&Into
        me.pinine = &acgtscq{
            return me&Sopi,s,'nine',c,q ({
                2: &Ecq{
                    # < have the E-nine%EFine, button for:
                    # c.DIY - redo every -Ness
                    # Nine/-Ness attract Sevens
                    #  virtual Eight is between, may storable
                    #  the -Ness becomes storable
                    me&EsyncThe,E,s,c
                    
                    # c.This/*%dige slep
                    $NessN = me&EsyncThis,E,s,c
                    
                    # -Ness those with This** to receive
                    # < o E/Ness/-Ness{el<7}
                    #  < el there being a famous c&el
                    $Ness = me&fiu,E,'Ness'
                    $any = 0
                    me&pity,Ness,'-Ness' .map(&z{
                        zc&el = hak(grepout(NessN,z)) ? 3 : 8
                        if (zc&el < 7) {
                            me&piNess,z
                            Ey&Fri = z
                            any = 1
                        }
                    })
                    NessN.length and debugger
                    
                    # Is: -Ness that looks done
                    Es&Is = me&pity,Ness,'-Ness' .filter(z => zy&Ness)
                    #!any and return
                    
                    # seeks Ec&Into beyond any Es&Is
                    me&EsyncThe,E,s,c
                },
                7: &Ecq{
                    # hows it going
                    me&tc,"Hows",'B'
                }
            })
        }
    //  /-Ness%string
        me.piNess = &acgtscq{
            return me&Sopi,s,'Ness',c,q ({
                6: &Ecq{
                    # TheFe $got=Part%dige inspheres
                    #  $got=Party&thing%dige outsphere
                    # < present set of storables to %TheFe
                    #   see 'outsphere for &accepting piggyback'
                    #   inc more special effects like %%inside
                    
                    # Fine/Part%tige = outsphere
                    #  /Part-Ness/-Eight/-seven usually
                    #   for cluing distribution of This** -> -Ness**
                    #  hang up anything amongst, Troom
                    #  preserved, made available again
                    # ~ %tige:
                    #  &accept for Fine/Part** <- Ness/-Ness**
                    #   the Fine self Linets reuse_string from:
                    # storable encoding, -Ness outphere
                    $t = me&reusable_thing,s
                    $d = {compLines: &DdC{
                        d.d == 2 and me&reusable_thing_string,d,C
                        me&usucompD,D
                    }}
                    me&Linets,t,s,d
                    !ts&dige and debugger
                    
                    # Fine/Part%dige = insphere
                    #  reuse -seven encoding already
                    #  may include more|less verbose Troom stuff
                    #   to diff Troom result as groked from The
                    $reuse = {tah:['yC','yC'],if_pi:'seven'}
                    $d = {compLines: &DdC{
                        if (me&reuse_string,d,C,reuse)
                            return d.reuse_string
                        me&usucompD,D
                        # know outsphere for &accepting piggyback
                        d.d == 1 and Ds&tige = ts&dige
                    }}
                    me&Linets,s,s,d
                    
                }
            })
        }
    //  %string
        me.usucompD = &acgtD{
            # < clearer
            delete Ds&string
            delete Ds&dige
            delete Dc&el
        }
        # turn %string back into y&toLines
        # huh
        me.unfixstring = &acgts{
            return s.replace(/\n$/,'')
        }
        # < migrate -Ness o Linets d.reuse climby ifspression
        #   .at.ah=[yC,yC]
        #   .if.pi='Eight'
        self.isnk = &k{
            !(k == 'y' || k == 'c' || k == 's') and return
            k == 's' and k = 'sc'
            return k
        }
        # could go further into subframe if !string?
        self.splitnkgk = &s{
            $k = isnk(s [0])
            return k ? [k,s.substr(1)] : [s]
        }
        # policy for %string reuse|regenerate
        me.reuse_string = &acgtdCc{
            $t = C
            if (c.tah) {
                each ik c.tah {
                    $v = ahsk(t,...splitnkgk(k))
                    !v and return
                    t = v
                }
            }
            !ts&dige and return
            if (c.if_pi) {
                $is = tc&pi == c.if_pi
                c.notif and is = !is
                !is and return
            }
            # expected to
            !c.easy && !ts&string and throw "!string"
            
            # < directly to d, in Linets, clients must return for us
            c.reuse ||= 1
            if (c.reuse) {
                d.nofurther = 1
                d.reuse_string = me&unfixstring,ts&string
                return 1
            }
            return 1
        }
        me.reusable_thing = &acgts{
            return sy&thing ||= Cye([s.t,2])
        }
        # %string made here (on Cy&thing)
        me.reusable_thing_string = &acgtdC{
            $t = me&reusable_thing,C
            d.for_string = &CdN{
                ts&string = N.join("\n")+"\n"
                ts&dige = dig(ts&string)
            }
        }
    },
    
  // TheFine**
  
   // Fine -nine -> /%TheFe got+exp
    # < cultivate
    ['TheFine',0.295,&acgtRs{
        
        me&reaw,R,'TheFine,bal_tw_s'
        Rs&noRsync = 1
        Rs&acceptables = 1
        $go = me&acting,R,'Fine'
        $x = me&Gome_Jx,R;
        !x and return me&wants,R,"Gome_Jx",xs&Gome
        $F = xs&TheF
        !F and debugger
        # acty Fine(-nine) attract This**
        # Gome wakes the inner when ~This
        me&must_newnodesamepath,Fc&Into,s
        Fc&InFine = s
        
        sc&pi = 'nine'
        # -This
        $This = me&Gome_This,R
        !This and return me&wants,R,"Gome_This",xs&Gome
        sy&This = This
        
        # roll the invention of Eigh s
        #me&sleepic,R and me&rollbs,R,'bal_tw_s'; return
        
        $Ninec = {This}
        # redo every -Ness
        x.ro('DIY') and Ninec.DIY = 1
        $E = me&pinine,s,Ninec,-2
        # < tow inside ^, use for interactivity...
        me&bal,"-nine",E,'eph,EFine'
        
        go and me&nu,"SCthis",{This,Fri:Ey&Fri,E,Einto:Ec&Into}
        
        
        # the last -Ness grows by stray sevens
        # tracks all -sevens ever
        # < Leave causes a scope-out
        
        $gotN = Es&Is || []
        me&twlic,gotN,s (&lzct{
            t = t.replace(/[^A-Z\d_-]+/gi,'_')
            $r = c.surprise ? me&bal,t,'eph'
                : me&bal,t,l
            
            ex(r.sc,c)
            #me&tsc,"Ergo:"+t+(ki(c)) .sc.dis = 1
            
            rs&TheFe = 1
            l and rs&exp = l
            z and rs&got = z
        })
    },'ift,D'],
   
   // Fine &acceptables
    # accepting Fe**, a bunch of test data
    ['TheFine',0.67,&acgtRs{
        $N = me&ioty,R,'TheFe'
        # -nine settles the -eights, see &sleepic
        # < create new &settles and go to sleep
        #me&settle,R,N && me&sleepic,R,2 and return
        me&acceptables,R,N
        $c = {
            
            # Eigh have inside:
            #  t may be accepted in-change
            # outside:
            #  merely reincludes Nine/$z (Eigh%exp)
            #  z%* or z/* may have been changed
            #   are meta or recipe for the running of it
            # z separates to allow y&up=O, keeps s&z, y&*
            # < align diff chunks outside Nine/($z**)
            #    per Nine/($t** inside)
            
            # an Eigh accepted again
            accept: &acgtsOrznt{
                me&accept,R,t
                $dige = me&storable,t
                # z got for Fine/-Ness
                # links to W:Fine/-Ness
                $Z = Cye(z)
                me&fiu,O,Z,2
                # already -Ness or so
                !Zc&pi and debugger
                Zs&dige = dige
                me&acceptFinePart,Z,z,t
            },
            # an Eigh still
            sleep: &acgtsOrz{
                !rs&exp and return
                rs&exp != z and debugger
                $Z = G&Cye,z
                me&fiu,O,Z,2
            },
            # the Nine itself
            self: &acgtsO{
                # picking up s/-Ness/*yCything
                $reuse = {tah:['yC','ything']}
                $seenapath = []
                $d = {compLines: &DdC{
                    $path = joint(d.path)
                    seenapath.includes(path) and return d.not = 1
                    seenapath.push(path)
                    if (me&reuse_string,d,C,reuse) {
                        return d.reuse_string
                    }
                    #me&usucompD,D
                }}
                me&Linets,s,O,d
                me&accept,R,s
            }
        }
        me&acceptables_reself,R,N,c
    },'ift,D'],
    &{
        # inside the reself accept{} hook,
        #  ie taking Part:z with $got:t to outsphere Part:Z
        me.acceptFinePart = &acgtZzt{
            $th = ty&thing
            !th and return
            # it might have encodings for the outsphere
            #  must spread string reuse to -Ness/*
            me&ioty,t .map(&n{
                # they also:
                !ny&thing and debugger
                $Zn = me&fiu,Z,n.t,8
                Zn and debugger
                $Zn = me&fiu,Z,n.t
                Zny&C = n
            })
            #  so we can include the Part dige on itself:
            Zs&tige = ths&dige
        }
    },
  
   // %TheFe(ature) differencing
    ['TheFe',0.299,&acgtRs{
        me&bin,'TheFe'
        me&reaw,R,'TheFe,exp,got,now_missing'
        $x = me&Jx,R
        $t = Rs&exp
        $z = Rs&got
        !t && !z and return Rs&FeRel = 1
        $go = me&acting,R,'Fe'
        if (!x.ro('Outs',{})) {
            # < concealments, similar to compressions:
            #    Normal's TheFine/TheFe tends to ...
            # < clearer rowing to the outsphere from -nine from This
            # < &acceptable** for same atoms in different 9s
            Rs&noRsync = 1
            if (sc&pi == 'Ness' && ss&dige && ss&tige) {
                Rs&nofixfor = peel('pi,dige,tige')
            }
        }
        # may %string or just %dige
        go and me&nu,"expgot",{t,z}
        me&FeDigestill_sleeps,R,z and return
        
    },'ift,D'],
    ['TheFe',0.36,&acgtRs{
        $t = Rs&exp
        $z = Rs&got
        # < distribute diff chunks to -Ness**
        !t && !z and return Rs&FeRel = 1
        # init being from $got, then Fine 
        sc&pi = t && tc&pi || z && zc&pi
        # for merge
        me&Feacceptable,R,s,t,z
    },'ift,D'],
    &{
        # %TheFe stills got:z%dige
        me.FeDigestill_sleeps = &acgtRz{
            $Dige = z && zs&dige
            $cha = !Dige || !me&za,R,{Dige}
            Dige and me&ha,R,{Dige}
            !cha && me&sleepic,R and return 1
        }
        # from %%unready to %%ok || &Qdiff
        me.Feacceptable = &acgtRstz{
            # has -eight happened (got:z)
            !z || !zs&dige || !zs&string and return me&ha,R,'unready'
            # < exp ||= surprise?

            # from here, it's a &toPave that doesn't pushPave at the end,
            #  instead sending the flock of storables onward
            me&acceptable,R,z,t

            # < probably want Qdiff,z,t=null
            #    or know t is a link, do &moreThat
            #    or t could be this step's part of another &Linets
            #     and need to other it there and then commit that,
            #      staging chunk regroup for commit essential
            #     lots of slightly different %%$word...,
            #      iterating commissions on 
            if (me&ja,R,'ok' ) {
                s&bgh = '041'
                # &Effect needs to be permanent (or %%dome)
                #me&Effect,s,zy&eight,'isok',{ok:1,ope:0}
                if (!me&za,R,'ok' ) {
                    me&yyt,z,'on_ok',R,s
                }
                return
            }
            # when Story is recording itself,
            # these all cause that -eight to show the failing, etc
            if (!t) {
                me&log,R,"Unexpected",{got:z}
                return
            }
            if (me&za,R,'unready' ) {
                me&log,R,"Failing",{got:z}
                if (Rs&trailing) {
                    # beyond last expected thing
                    me&log,R,"Trailing"
                }
            }
            # receive the got into a diff against the full self
            !(tc&pi && ts&dige) and return me&tsc,"Nine/!-eight"

            $self = me&moreThat,R,t,t
            !self and return me&waits,"Nine/.."

            $Q = me&PaveQ,R,selfy&That

            me&Qdiff,R,z,Q
            # < to &brackology
            # < mergible
        }
    },
   // FeRel, EFine, etc
    # < E-nine/*/* lum from E-nine/OK/*
    # for &bal,E-nine**
    # < is a %Cit-like cloud of self-reference
    ['EFine',0.295,&acgtRs{
        me&reaw,R,'EFine'
        me&bin,'EFine'
        $l = me.cby(R,'^^^EFine')
        if (l.slice(0,3).includes(R)) {
            s&hue = -88
            me&thide
        }
        me&thide,'easy'
        me&acting,R,'EF' and me&nu,'l',l
    },'ift,D'],
    # some otherish thing
    ['FeRel',0.361,&acgtRs{
        me&reaw,R,'FeRel'
        me&bin,'FeRel'
        me&acting,R,'FeRel'
    },'ift,D'],
    &{
    },
  
 // The**
    
    =The
     little %TX -pi circuit
     user generating selections
      could mean any of the coordinates for it
      a multiple select should find language that expresses it
     use R
    =cut
    =neupi
     &dopi: makes $D, maybe more $E/*
     so
     $E
      equivalent to $R
      $E/* become children
      E%TX and E%RX
      almost reusing the object
       would need to dome the $E/* and etc for this time
     $C for display
     $D for recording
      Dc&pi changes as it types up:
      -val
       -hash
        -C
         -n locatable from a namable node
       etc
      a one-line instant of data-point observation
      in the $D-sphere
       is the storable -log/**
     
     < E%RX per spec, so paths in can be made
     
     < $D @6 sleps?
       may be able to 'OK', no modulat default
     
     < $D @7 converts to modulat
       $D sometimes rehydrates
        without needing the data (Rc&s)
         $D-got
          may make local expansion of sc&s it has
           but want a new -log to confirm it in-time
         $D-exp
          cannot expand
     
     < $D @8 is the click-unit
       somethings in the modulat may further instruct:
     
     %TheeThy is a %Story
      /%TheThis does eg -nine
      /%TheThe Troom for /$Tt
     
     This shows stuff, potentially out of time
      -log will be Ring by Eight
     < The..#$D
       your clicks being configured
       selected one shows CED columns over slope rows
    
    =cut
  // %TheeThy, landscape
    # some events, to|from the book
    ['TheeThy',0.296,&acgtRs{
        
        me&reaw,R,'TheeThy'
        me&bin,'Theing'
        
        me&tc,"TheeThy"
        # init
        # the -eight remotely
        # i This/Bowler/\E-hat
        $This = me&fiu,s,'This'
        $Bow = me&fiu,This,'Bowler'
        $dat = Bowc&s = me&PiRet_data
        dat.moreso = dat.asee
        Bowc&pi = 'hat'
        
        $Bow = me&fiu,This,'Lol'
        $da = Bowc&s = {more:'some',figaro:dat.asee}
        da.furhtin = {llabin:4}
        Bowc&pi = 'hat'
        
        $Bow = me&fiu,This,'Room'
        $da = Bowc&s = {fer:dat.asee,even:'more',figaro:dat.asee}
        da.furhtin = {llabin:4}
        $i = 0
        while (i < 60) {
            da = da.th = {}
            i++
        }
        da.is = 'all'
        Bowc&pi = 'hat'
        
        # the -nines
        #  autoviv etivity for relatives in This (Bowler)
        #   to be packed into some Nine/$t**
        $The = me&fiu,s,'The'
        Thes&tow = 1
        me&ha,R,'some,doing,ness'
        me&ha,R,'some,doing'
    },'ift,D'],
  //   /%Theing
    # Nine-ish container of /Eight-ish namespace
    ['Theing',0.291,&acgtRs{
        $x = me&Theing,{in:'TheTh'}
        Rs&onlyish = 1
        me&tc,"Gool","G"
        Rs&TheingE = 1
    },'ift,D'],
    # R%Theing...Ec&top also have E
    ['TheingE',0.291,&acgtRs{
        me&bin,'TheingE'
        $p = Ry&up
        me&rollbs,R,'E'
        $E = Rs&E ||= Cye([R.t,1])
        Ey&R = R
        # E**
        ps&E and Ey&up = ps&E
    },'ift,D'],
    ['TheingE',0.297,&acgtRs{
        $x = me&Theing
        $E = Rs&E
        me&ioR,R .filter(r => rs&Pier)
            .map(r => me&tc,"Acc:"+r.t )
        xy&go and me&nu,"E",E
    },'ift,D'],
  //     /%TheTh has R'The'
    # each thing
    ['TheTh',0.296,&acgtRs{
        sc&pi ||= 'Bat'
        $x = me&Theing,{in:'TheTh'}
        $E = Rs&E
        
        $tc = me&Thetower,R
        $es = tc.es
        delete sy&RXing
        es && esy&TXing and sy&RXing = esy&TXing
        
        #$c = me&Thetower,R
        #me&proto_Bat,c
        s&dis = 1
        
        me&tivity
        sc&pi and me&Piering
    },'ift,D'],
    ['TheTh',0.6,&acgtRs{
        ~>6 The: R.t, joint(Rs&z)
    },'ift,D,sleeping'],
    &{
    # identity spreader
    me.Theing = &acgtc{
        $R = me&R
        $s = Rc&s
        $x = me&Jx,R
        Rs&Thex && c and throw "const"
        Rs&Thex and return Rs&Thex
        Rs&Thex = x
        c ||= {}
        # believing something
        # < R%tow going?
        ss&tow and Rs&tow = 1
        
        # receivable somewhere
        Rs&elvis = 'FishElvis'
        # < want to bal to receive em further in?
        Rs&tow and 'check Ey&Todo?'
        
        c.long ||= T.act.t
        c.long and me&reaw,R,c.long+',elvis,tow'
        c.short ||= c.long
        c.short and xy&go = me&acting,R,c.short
        c.in and me&bin,c.in
        
        return x
    }
    # leap into R'The'
    me.Piering = &acgtc{
        $R = me&R
        $x = me&Theing
        $s = Rc&s
        me&tc,"---"
        # or as R:
        $del = me&modelta
        c ||= {}
        c.Pier ||= sc&pi
        c.t ||= "R-"+c.Pier
        c.Top = 1
        c.s = sc&s
        c.V = s
        $r = me&PiRet,R,c
        ac(R,'z',r)
        x.ro('noD') and rs&noDisplay = 1
        me&Ring,r
        each iy rs&commit {
            y ()
        }
        
        rs&matches && xy&go and me&nu,'matches',rs&matches
        
        del()
        xy&go and me&zu,"r",r
    }
    },
  // &FishElvis + -Bat f
    &{
    me.FishElvis = &acgtRs{
        ~FishElvis
        try {
        !Rs&ball and debugger
        $N = ksaf(c&slope,{aft:R,inc:0})
        
        # expect R%elvis...R:$pi
        $pi = hak(N.filter(z => isR(z)))
        !pi and return me&Gazel,R,s
        
        $p = Ry&up
        $M = ps&z
        #ksaf(ps&z,{aft:R})
        
        $c = {A,C,R,s,N,M,el:2}
        me&Thetower,R,c
        c&tower = c
        $n = c.es
        ~>3 sol: dis(n), c.wake.t
        ny&Todo.push(C)
        
        T.wake = c.wake
        me.Lastev = c
        }
        catch(er){
            ~>3 noFish: ""+er
        }
    }
    # where|how elvising goes
    #  This/Has/A/Thing may home e in:
    #   This/Has/e%tow/A/Thing
    #   This/e%tow/Has/A/Thing
    #   The%tow/Has/A/Thing
    # < always a further step
    # < constituation of climbers, for rowing
    # s finds Trooms for itself
    me.Thetower = &acgtRc{
        c ||= {}
        # find Thyer/%Theing/...s
        c.above = me&climbaboveTheing,R .map(r => rc&s)
        # their next sibling with %tow
        c.tows = c.above.map(&s{
            $p = sy&up
            !p and return
            return ksaf(ps&z,{aft:s})
                .filter(z => zs&tow)[0]
        })
        # The springs The 2, etc
        if (!hak(c.tows.filter(z=>z)) && c.el == 2) {
            c.tows[1] = me&makeextraThe,c
        }
        # each %tow/...s
        c.towing = []
        $nearest = reverse(c.tows).filter(z=>z)[0]
        each iz c.tows {
            !z and continue
            $s = c.above[i]
            $r = sy&R
            $path = c.above.slice(i*1+1)
            # This<->The is implied
            rs&Theeing and path.shift()
            # try to route
            # may create nearest %tow/**
            $el = z == nearest && c.el == 2 ? 0 : 8
            each ii,n path {
                !z and continue
                $e = me&fiu,z,n.t,el
                z = e
            }
            c.towing[i] = z
        }
        c.elvisors = reverse(c.towing).filter(z=>z)
        # first|deepest is where to elvis
        $es = c.elvisors[0]
        !es and return c
        esy&Todo ||= []
        c.es = es
        # nearest R above that, to wake elvisor
        $z = me.cbu(es,z=>zy&R)
        c.wake = zy&R
        # who has TX
        return c
    }
    # find Thyer/%Theing/...R
    me.climbaboveTheing = &acgtR{
        $r = R
        $N = [r]
        while (1) {
            $p = ry&up
            !p and break
            N.unshift(p) > 5 and debugger
            rs&Theing and break
            r = p
        }
        return N
    }
    me.makeextraThe = &acgtc{
        $Thyer = c.above[0]
        $The = c.above[1]
        $zc = The.t.match(/^(.+) (\d+)$/)
        $t = zc ? zc[1] : The.t
        $i = zc ? zc[2]+1 : 2
        t = t+' '+i
        $es = me&fiu,Thyer,t
        ess&tow = 1
        # will be %Theing
        return es
    }
    # GOING receive+see e somewhere
    me.proto_Bat = &acgtc{
        #return
        if (c) {
            $ev = me.Lastev
        }
        else {
            $R = me&R
            $x = me&Theing
            $s = Rc&s
            !sy&Todo and return
            $e = sy&Todo.slice(-1)[0]
            !e and return
            $ev = ec&tower
        }
        if (1 || xy&go) {
            me&nu,"e",e
            $ev = ex({},ev)
            me&nu,"tower",ev
            $int = {N:1,M:1}
            each kv ev {
                !isar(v) and continue
                each in v {
                    ev[k+'_'+i] = n
                }
            }
        }
    }
    },
   
  // &Eref*
    &{
    # search for other R with ref, E^^
    me.Ereflookup = &acgtc{
        $E = c.E
        $e = c.e ||= E
        $s = c.s
        $R = c.R
        c.got ||= []
        # look for the ref
        $x = fi&EXsim,E,{ref:s}
        # from R not being replaced
        $b = ec&b
        $br = b && by&R
        $z = x.z.filter(r => !br || brc&N != rc&N)
        each in z {
            $tp = me&Rnodepath,n
            c.got.push({E,n,tp})
        }
        # further up
        Ey&up and me&Ereflookup,ex(c,{E:Ey&up})
        E != e and return
        
        # sort by R tree
        c.got.map(g => ex(g, me&Rcrux,R,g.n ))
        # < -seven having a time sense greater than -eight
        #   -seven on a different -Nine are too far
        #   see otherable &EsyncThis as -log
        # ignore those after this R^^^
        $poss = c.got.filter(g => g.seek < 0)
        # group by distance up from here
        #  then start climbing down again, sorting...
        $neu = []
        $h = vpartN(poss,g => g.ups.length)
        each iN h.vs {
            neu.unshift( ... me&Erefclimb,N )
        }
        c.got = reverse(neu)
        
        # prefer closer...
        
        if (R.t == 'figaro') {
            $gl = es&glop = []
            poss.map(&g{
                gl.push(g)
                gl.push(g.tp )
            })
            gl.push( me&Rnodepath,R )
        }
        return c
        # create distality
        # satisfy
        #  r%toomuch or %tiny doesnt count
    }
    me.Erefclimb = &acgtNc{
        N.length <= 1 and return N
        c ||= {}
        c.i ||= 0
        c.i *= 1
        # climb nearer|earlier first until satisfied
        #  if a later thing redraws it (differing)
        #   we want to follow on from that instead...
        # just sort it all into:
        $neu = []
        $eg = N[0]
        $h = vpartN(N,g => me&Rcrux_seek,c.i,eg.downs,g.downs )
        each iN h.vs {
            $k = h.ks[i]
            N.length > 1 and N = me&Erefclimb,N,{i:c.i+1}
            N.map(g => g['seek_'+c.i] = k)
            neu.push(...N)
        }
        c.i > 25 and throw "lost"
        return neu
    }
    # find join between **R and **r
    #  resorts to comparing Rc&s or R.t to get it done
    # < into rowing
    #   proof that X-stitching needs to preserve $n-order
    #    by way of Jip, Aip, tip, etc
    # < for [r], with no particular R
    #    finding islands
    #   would be able to sort the whole thing as a tree
    #    currently different joins may compare c.seek
    me.Rcrux = &acgtRr{
        $c = {ups:[R],downs:[r]}
        $loca = &nN{
            $ni = N.indexOf(n)
            if (ni < 0 && ns&ball) {
                # use the eternal C arriving on different R
                ni = N.findIndex(r => rs&ball && rc&s == nc&s)
                ni >= 0 and c.viaball = 1
            }
            ni < 0 and return
            # we might find r^3 is R^1, trim R^3-2
            N.splice(0,ni)
            return 1
        }
        $upsi = &nN{
            $p = ny&up
            !p || ps&Gens and return
            ps&ball && !ns&Pier && !me&fiu,pc&s,n.t,8 and debugger
            N.unshift(p)
            return 1
        }
        while (1) {
            # upmost either
            $L = c.ups[0]
            $l = c.downs[0]
            # found in the other
            loca(L,c.downs) || loca(l,c.ups) and break
            # further y&up
            !(upsi(L,c.ups) || upsi(l,c.downs)) and break
        }
        while (c.viaball) {
            # try to resolve R.t to deepen the join
            # see resolve $n
            $L = c.ups[1]
            $l = c.downs[1]
            !L || !l || L.t != l.t and break
            c.ups.shift()
            c.downs.shift()
        }
        # on the join, is r before R (c.seek<0) or not (>0)
        c.seek = me&Rcrux_seek,0,c.ups,c.downs
        return c
    }
    # for a given 
    me.Rcrux_seek = &acgt,offset,left,right{
        left == right and return 0
        offset *= 1
        $L = left[offset]
        $l = right[offset]
        if (L == l) {
            # simply see where in R%z
            $Li = Ls&z.indexOf(left[offset+1])
            #Li < 0 and debugger
            $li = Ls&z.indexOf(right[offset+1])
            # eg left=[R,y,R] right=[R]
            Li < 0 && li < 0 and debugger
            return li - Li
        }
        elsif (Ls&ball && ls&ball) {
            $s = Lc&s
            s != lc&s and debugger
            !ss&z and debugger
            $Li = ss&z.indexOf(left[offset+1].c.s)
            Li < 0 and debugger
            $li = ss&z.indexOf(right[offset+1].c.s)
            li < 0 and debugger
            return li - Li
        }
        elsif (Ls&ball || ls&ball) {
            debugger
        }
        else {
            # they dont join, even by C
            # < if R/$t ? yfuture the L?
            debugger
        }
    }
   
    # transact Ec&top
    me.Eref_begin = &acgtre{
        $p = ry&up
        $E = ps&E
        !E and throw "!E"
        $oe = me&fiu,E,e.t,8
        # stop seeing refs from the old e in E%X
        oe and ec&b = oe
        oe == e and debugger
        ac(r,'commit',&{
            # copy to E^^^%X
            $c = {E,e}
            ec&b and c.removing = [ec&b]
            me&Erefputup,c
            delete ec&b
            me&fiu,E,e
            es&glop and me&nu,"Glop",es&glop
        })
    }
    # commit Ec&top (top of &Piering) to E^^
    me.Erefputup = &acgtc{
        $E = c.E
        $X = Ec&X || fi&EXsim,E,{}
        # add new
        $e = c.e
        $e_x = e && ec&X || {}
        each is e_x.refs {
            $x = e_x.ref[i]
            each in x.z {
                fi&EXsim,E,{ref:s},{n}
            }
        }
        # remove old
        each i,oe c.removing {
            $oX = oec&X
            $gonei = []
            each is oX.refs {
                $ox = oX.ref[i]
                !X.refs and continue
                $i = X.refs.indexOf(s)
                if (i < 0) {
                    each in ox.z {
                        $r = ny&R || n
                        $name = me&Rnodepath,r
                        ~>3 confuslet: name
                    }
                    continue
                }
                $x = X.ref[i]
                grepout(x.z,n => ox.z.includes(n))
                !hak(x.z) and gonei.push(i)
            }
            reverse(gonei).map(&i{
                X.refs.splice(i,1)
                X.ref.splice(i,1)
            })
        }
        Ey&up and me&Erefputup,ex(c,{E:Ey&up})
    }
   
  // C, %E/**, D
    # R%E/e - like &pii, setup @3
    me.Ei = &acgtc{
        $R = me&R
        $E = Rs&E
        !c.t and throw "!t"
        c.t = ""+c.t
        #me&t_tpi,c
        $t = delete c.t
        $e = me&dupfiu,E,t
        c.cv and ey&cv = scaf(c.cv); delete c.cv
        ex(e.c,c)
        return e
    }
    # three spheres @12
    me.CED = &acgtR{
        $p = Ry&up
        # D display
        $C = Rs&C = Cye([R.t,1])
        Cy&R = R
        # E itself, may be passed in
        $E = Rs&E ||= Cye([R.t,1])
        Ey&R = R
        # D record
        $D = Rs&D = Cye([R.t,1])
        Dy&R = R
        Dy&E = E
        Ey&D = D
        # E**
        ps&E and Ey&up = ps&E
        Rs&Top and Ec&top = E
        # all R have:
        Rc&top ||= R
    }
    # E remains given|base type
    # D shifts into that mind with R%-pi
    #  supposing from-here R-ing
    #  ie descing order of immediacy
    # < mindwind or dome? fail over when X clash?
    #   re-&pio if already
    me.typeup = &acgtR,pi{
        $D = Rs&D
        $E = Rs&E
        Dc&pi = pi
        R.sc[pi] = 1
    }
  // %E/** @3
    # E/** sync, Ringing, in or out of time
    # repeatedly applies E/* to PiRet
    me.Eing = &acgtc{
        $R = me&R
        $s = Rc&s
        $D = Rs&D
        $E = Rs&E
        $C = Rs&C
        
        Es&z and vsortz(Es&z)
        $many = hak(Es&z) > 30 ? 20 : 0
        # @13 a bunch
        each ie Es&z {
            # create R
            ey&R != null and continue
            ey&R = 0
            
            # the R recursion
            # unless %limit %toomuch
            #  note returns the /$n as array
            $stop = me&Ro,'%limit/%toomuch'
            # < specifics
            #   could be %TX.unstop'd out of the shadow
            # < joining  /$n to:
            if (stop) {
                # all %tu/not should be accounted for by eg limits
                # note returns the last C the /$n is in
                $n = me&Ri,'%toomuch/limit',{n:stop}
                ac(n,'explains',e)
            }
            else {
                $c = {t:e.t,s:ec&s,E:e}
                $r = me&PiRet,R,c
                ey&R = r || 0
                ey&R == 0 and debugger
            }
            # not @1
            !r || rc&not and me&Ri,'%toomuch/not',{n:e}
            
            # until
            if (many && i > many) {
                me&Rti,'many',{s:'..'+hak(Es&z)}
                break
            }
        }
        # @2, etc
        if (c) {
            num(c) and c = {ov:c}
            c.ov = scaf(c.ov)
            me&Ring,R,{inside:R,ov:c.ov}
            $allok = !me&Ro,'%toomuch'
                && !hak(me&ioR .filter(r => rs&strange))
            return allok
        }
    }
  // R%toomuch/** @67
    # @67 assigns signage about being R%toomuch**
    me.Rtoomucho = &acgtR{
        me&Ro,'%limit/%toomuch' and me&Ri,'%toomuch/%implied'
        
        me&Rthingo,R,{t:'toomuch',sym:"",cv:25}
    }
    # capsule, filler for %limit|%toomuch|...
            # defer to %limit if the only
    # sizes something, usu ope|interest for snoozing
    self.sz = &nks{
        $v = n.sc[k] || 0
        return v < s
    }
    me.Rthingo = &acgtRc{
        $C = Rs&C
        # the l, whose y&n=li is T.Mw
        $l = c.l
        if (!l) {
            # plant in R
            T.Mw = c.t
            $l = R.sc[c.t]
            $putl = 1
        }
        !l and debugger
        
        # make capsule here
        $li = me&tc,c.t+'-cap'
        liy&cv = c.cv && scaf(c.cv) || 0.13
        delete lic&s
        $hu = (""+liy&cv).substr(-1)
        me&walls,li,'bd:1.4,hu:'+hu
        
        # move into it
        putl and ly&n = li
        T.Mw = li
        if (c.sym) {
            $re = me&tc,c.t+'-sym',c.sym,c.symc||'b'
            rec&s = c.sym || ""
            res&fs = 17
            res&lh = 0.3
            liy&sym = re
        }
        
        c.n and return l
        
        # making a tiny version of it
        # compress
        $explain = &nt{
            # may explain 
            $talk = n.t+" explains "+t.t
            li.t += "  "+talk+"  "
            ac(t,'explained',n)
        }
        me&ioty,l .map(&n{
            $N = ns&explains
            !N and return
            each it N {
                me&ioty,l .map(&g{
                    g == t and explain(n,g)
                    $all = 1
                    $any = 0
                    me&ioty,g .map(&m{
                        m == t and explain(n,m)
                        !ms&explained and all = 0
                        any = 1
                    })
                    if (any && all) {
                        # a whole thing is explained
                        $N = []
                        me&ioty,g .map(m => ms&explained)
                            .map(expl => expl && N.push(...expl))
                        N = uniq(N)
                        N.map(&n{
                            # can be another n
                            explain(n,g)
                        })
                    }
                })
            }
        })
        $N = me&ioty,l
        $allexpl = 1
        $anyexpl = 0
        me&ioty,l .map(&n{
            !(ns&explains || ns&explained) and allexpl = 0
            anyexpl = 1
        })
        
        $all = allexpl && anyexpl
        # all explained, hide what-is
        all and li.t += " (all %explain)"
        else
        anyexpl and li.t += " (some %explain)"
        
        re and re.t += li.t
        all && sz(l,'ope',1) and return l
        
        
        me&ioty,l .map(&n{
            T.Mw = li
            # names are minds, have time
            if (me['R'+c.t+'o_'+n.t]) {
                me['R'+c.t+'o_'+n.t](A,C,G,T,R,l,n)
                # only that unless open
                sz(n,'ope',2) and return
            }
            
            # bit of thing.. almost capsule
            T.Mw = li
            $talk = c.t+": "+n.t
            $t = me&tc,talk,n.t,'b'
            ns&explained and me&tc,"Expl"+dis(ns&explained),'6y'
            
            if  (isst(nc&s)) {
                # < text style, oppo to .t or %string
                me&tc,talk+".s",nc&s,'y'
            }
            elsif (nc&s != null) {
                # might be a /$n
                me&tc,talk+"&s",dis(nc&s),'y'
            }
            me&ioty,n .map(&e{
                # probably an E/e avoided
                $en = me&tc,t,"/$n="+e.t,e.t,'6d'
                ens&ma = 0.1
                ns&explained and me&tc,en,"Expl"+dis(ns&explained),'6y'
                
            })
        })
        
        return l
    }
   
  // &PiRet while &Eing, create R @13
    me.PiRet = &acgtRc{
        # < &Rti,'nofurther' in %toomuch - displayed
        Rc&nofurther and me&tc,"nofurther"; return
        # spreads base type, or Ec&pi @2
        c.Pier ||= Rs&Pier || 'blank'
        
        if (c.Top) {
            c.task ||= 'Pi_The'
        }
        
        $r = me&Ret,R,c
        
        if (c.Top) {
            $h = Rc&N[0]
            #ry&I = 1
            rc&N = []
            rc&d = 0
            rc&dl = 15
            rc&nl = 100
            delete rc&refR
            delete rc&refs
        }
        ry&cv = 0
        $E = c.E
        E and tax(r.sc,E.c,'dupl,noref,inline')
        me&CED,r
        $C = rs&C
        $E = rs&E
        Ec&pi and rs&Pier = Ec&pi
        Ec&pi ||= rs&Pier
        
        if (c.Top) {
            me&Eref_begin,r,E
        }
        
        # puts on tape or not
        me&Rlimiti,r
        
        # is on tape or not
        !c.Top and !Rc&N.includes(r) and rc&not = 1
        
        return r
    }
   
  // R%limit/** @13
    # cultivate R%limit(%toomuch|/ref/...)
    
    # @12
    me.Rlimiti = &acgtR{
        $C = Rs&C
        
        # limits want workarounds
        $limit = &tc{
            # the case for
            $ref = me&Ri,'%limit/'+t,c
            # no more E/e. eg linkably close self
            !c || c.toomuch and me&Ri,'%limit/%toomuch',{n:ref}
            return ref
        };

        $s = Rc&s
        if (s && typeof s == 'object' && !Rs&noref) {
            # soft dup limit, sets Rc&nofurther=1
            me&Rlimiti_ref,R,s,limit
        }
        # sprawl limits
        # < find bunch of these at a thing, to %TX anti-dl
        if (Rc&dl && Rc&dl < Rc&d) {
            limit('dl')
            return
        }
        if (Rc&nl && Rc&N && Rc&nl < Rc&N.length) {
            limit('nl')
        }
        
        Rc&N.push(R)
    }
    # realises where $s was before
    me.Rlimiti_ref = &acgtRs,limit{
        # on Ec&top %X
        $tE = Rc&top.sc.E
        # previous mentions of it, nearest first
        $c = me&Ereflookup,{E:tE,s,R}
        # without being %toomuch or != $pi
        me&Rlimiti_ref_lookfor,R,c
        
        # any previousness causes some R%limit...
        if (c.any) {
            # the case for
            $ref = limit('ref',{s:c})
            # linkably close self, no more E/e
            c.near and me&Ri,'%limit/%toomuch',{n:ref}
        }
        
        # note this time
        #  effectively a &pio to many places
        $x = fi&EXsim,tE,{ref:s},{n:R}
    }
    me.Rlimiti_ref_lookfor = &acgtRc{
        # find:
        #  other with any expression, even tiny|limited|other-$pi
        #  self with full writeup, same $pi
        #   which we can use to diff against
        #    using leftover slepparatus from its typing up
        #   or %limit.same as it
        $E = Rs&E
        each ig c.got {
            $r = g.n
            $e = rs&E
            # find the last
            # < many %%self:g,qua until satisfied
            #   iterating Ereflookup
            if (ec&pi != Ec&pi) {
                c.other ||= g
            }
            elsif ( me&Ro,'%limit/%toomuch',{R:r} || Rs&tiny ) {
                c.almost ||= g
                # find fuller further rendition
            }
            else {
                # this is the previous this
                c.self ||= g
                break
            }
        }
        # almost always -> self
        if (c.almost) {
            # even a partial do-over is self here
            # < Self, where lines are traced back
            !c.self and me&tc,"no-full"
            #throw "no finding full thing"
        }
        # care
        if (c.self) {
            $g = c.self
            # can only gain c.near
            # assume $s** still per eg -log, %Top
            $sameTop = me&ifsuchsame,'Top',g.ups,g.downs
            sameTop and c.near = 1
            else {
                # out of time from here, climb data again
                # < know light cones provided by &Rsci
                # < slep or c.redraw
                #   which regen X, patchey D** with previous
                #c.redraw = 1
            }
        }
        c.any = c.self || c.other
    }
    
    # @67 assigns signage about R%limit**
    me.Rlimito = &acgtR{
        $l = me&Rthingo,R,{t:'limit',cv:13}
        
        if (me&Ro,'%limit/%toomuch' ) {
            # spawns no E**
            me&tc,"limtoo",'g'
            ac(R,'M',Cye(['toom',2,{s:'toom'}]) )
        }
    }
    #   ref
    me.Rlimito_ref = &acgtRln{
        $l = me&Rthingo,R,{t:'ref',sym:"",l,n,cv:13}
        $li = T.Mw
        $re = liy&sym
        # limit:l/ref:n
        # &Ereflookup c via selection
        $c = nc&s
        
        $types = ['self','other']
        types.map(&k{
            $g = c[k]
            !g and return
            $r = g.n
            # the amount of '^'
            $down = g.downs.slice()
            $ups = hak(g.ups.slice(1))
            $location = ups > 1 ? "^"+ups : '^'
            # allow '^/ref' - not inc ups|downs[0]
            ups <= 1 and down.shift()
            # 1
            $downs = ""
            $waspath = 0
            down.map(&r{
                # '//' when leaving node-sphere
                $path = rs&ball && rc&s.y.path
                !path && waspath and downs += '/'
                downs += '/'+r.t
                waspath = path
            })
            # going far makes '^4:This/etc'
            ups > 1 and downs = ':'+downs.substr(1)
            location += downs
            # fuller description as tooltip
            re.t += " "+k+":"+location
            
            # compress contiguations
            #  when as above, plus the same t
            # < exceptions want exclaiming -hat
            #   when we replace n.*.* to get attention
            $p = Ry&up
            $pl = p && ps&limit
            $pn = pl && me&fiu,pl,'ref',8
            $pc = pn && pnc&s
            $pg = pc && pc[k]
            if (pg) {
                $wasdowns = g.downs.slice()
                $newdown = wasdowns.pop()
                if (heq(wasdowns,pg.downs) && newdown.t == r.t) {
                    # we C%limit/y%limit, just symbol
                    return lis&tiny = 1
                }
            }
            
            $te = me&tc,location
            
            tes&deco = 1
            tes&hs = '999'
            tes&fs = 7
        })
        
        lis&tiny and return
        
        $total = hak(c.got) + 1
        if (total > 2) {
            $says = total
            $talk = 'x'+says+', ...'
            me&tc,talk,says,'7y'
        }
    }
  
  // < R%strange/** @2 # schema goes
    me.strange = &acgts{
        $R = me&R
        me&tc,s,'b'
        Rs&strange = 1
    }
  // < R%c/** @3 # machine talk
    me.attendios = &acgttc{
        $R = me&R
        $E = Rs&E
        c.E ||= E
        c.path = me.cby(c.E,E => Ec&top)
        ac(Rc&top,t,c)
    }
  // slope misc
    # proper R/*
    me.ioR = &acgtR{
        R ||= me&R
        return me&ioty,R
            .filter(r => rc&N.includes(r) && !rc&not)
    }
    me.Rnodepath = &acgtR{
        # < rowing for...
        $N = me.cby(R,R => Rs&ball && Rc&s.y.path)
        $p = N.shift()
        # &inode puts a:
        $path = p && pc&s.y.path
        
        return joint(path,'/')+'//'+joint(N,'/')
    }
    me.ifsuchsame = &acgtkNM{
        $first = N.filter(r => r.sc[k])[0]
        return !first || M.includes(first)
    }
  
  // slope io: &Rsci + dialects
   // dialects
    # for &Ri,'%subject/atom',c
    me.Ri = &acgtscq{
        return me&Rsci,s,c,q
    }
    me.Ro = &acgtscq{
        c = ex(c||{},{el:8})
        return me&Ri,s,c,q
    }
    # not readable?
    me.Rli = &acgtscq{
        c = ex(c||{},{gk:'limit'})
        return me&Rsci,s,c,q
    }
    me.Rlo = &acgtscq{
        c = ex(c||{},{el:8})
        return me&Rli,s,c,q
    }
    me.Rti = &acgtscq{
        c = ex(c||{},{gk:'toomuch'})
        return me&Rsci,s,c,q
    }
    me.Rto = &acgtscq{
        c = ex(c||{},{el:8})
        return me&Rli,s,c,q
    }
   // &Rsci
    # v=[] for /$n-ism, adding|finding c.n
    me.Rscin = &acgtscqv{
        if (c.el == 8) {
            if (isar(c.n)) {
                # has a list
                $all = 1
                $any = 0
                each in c.n {
                    v.includes(n) and any = 1
                    else all = 0
                }
                c.all && !all and return
                !any and return
                return 1
            }
            else {
                v.includes(c.n) and return 1
            }
        }
        else {
            if (isar(c.n)) {
                # < distribute in between includes
                each in c.n {
                    !v.includes(n) and v.push(n)
                }
            }
            else {
                !v.includes(c.n) and v.push(c.n)
            }
            return 1
        }
    }
    me.Rsci = &acgtscq{
        c ||= {}
        $R = c.R || me&R
        isst(s) and s = {path:s.split('/')}
        !s and s = {path:[]}
        c.gk and s.path.unshift('%'+c.gk)
        $putsz = hak(c,'s') || hak(c,'n')
        
        $z = R
        $last = hak(s.path)-1
        each it s.path {
            $gk = t.substr(0,1) == '%' && t.substr(1)
            $v
            gk and v = z.sc[gk]
            # < bal Rc&s/$v, for c.R%ball
            #   or schedule|other nearby y&R
            else v = me&fiu,z,t,c.el
            
            # i %limit/%toomuch=1 or &Rli,'toomuch',{s:1}
            $puts = putsz && i == hak(s.path)-1 && hak(c,'s')
            $putz = putsz && i == hak(s.path)-1 && hak(c,'n')
            if (putz && v) {
                if (gk) {
                    !isar(v) and throw "putz!ar"
                    if (c.el == 8) {
                        # o $l%somegk/$n tests for $n in %somegk
                        #  ie &Rti,'limit/%somegk',{n:e}
                        # returns the /$n as array
                        return me&Rscin,s,c,q,v && v
                        # if !v it may also fail @el==8:
                    }
                }
            }
            if (!v || (puts || putz) && gk) {
                c.el == 8 and return
                !gk and throw "never happens: &fiu creates el<8"
                
                if (puts) {
                    puts = 0
                    v = c.s
                }
                elsif (putz) {
                    v ||= []
                }
                else {
                    v = Cye([gk,2])
                }
                z.sc[gk] = v
            }
            if (isC(v)) {
                # care
                if (R == z) {
                    gk and vy&R = R
                    else {
                        # < bal Rc&s/$v
                    }
                }
                if (puts) {
                    puts = 0
                    vc&s = c.s
                }
                elsif (putz) {
                    putz = 0
                    $vz = vs&z ||= []
                    # returns the last C the /$n is in
                    #   $z:thing/%bunch:v/$n=stuff
                    return me&Rscin,s,c,q,vz && v
                    # < conserve/score?
                }
            }
            if (putz) {
                !gk and throw "never happens: isC putz"
                putz = 0
                # returns the /$n as array
                return me&Rscin,s,c,q,v && v
            }
            !v and return
            z = v
        }
        return v
    }
  // misc f
    me.PiRet_data = &acgt{
        $hash = {
            fig: {vig: 'vort'},
            lw: {vig: 'vurt'},
        }
        $N = [1]
        N.map(&i{
            each kv hash {
                1 < i && isob(v) and v = ex({},v)
                v = hash[k+i] = {le:v}
                k == 'fig' && i == 1 and v.ol = {de:3,do:4}
                k == 'fig' && i == 1 and v.owel = {de:3,do:4,da:5}
            }
            hash['water'+i] = 'par importo'
        })
        hash.asee = Cye(['Think',4,{dia:'dem'},{luc:'cho'}])
        return hash
    }
    me.modelta = &acgt{
        $R = me&R
        $start = Gtime()
        return &{
            $delta = Gtime(start)
            me&tc,"~"+delta,'b'
        }
    }
    # art busier
    me.tivity = &acgt{
        $R = me&R
        $x = me&Jx,R
        me&rollbs,"Fishtivity"
        x.ro("tivit") and Rs&Fishtivity = 5
        if (Rs&Fishtivity) {
            Rs&Fishtivity--
            me&waits,"ForItivity"+Rs&Fishtivity
        }
    }
    # hash partition array by return value of y(n)
    # returns {ks:[keys],vs:[values]}
    #  because of how javascript (v8) stores properties & elements
    #  things that look like indices of elements will come first
    #   eg assigning -2,-1,0 iterates 0,-2,-1
    #  ! anywhere we rely on hash key order might be affected
    self.vpartN = &Nyc{
        return partN(N,y,ex({vsort:1},c||{}))
    }
    self.partN = &Nyc{
        c ||= {}
        $h = {}
        each in N {
            $k = y (n)
            h[k] ||= []
            h[k].push(n)
        }
        # structure for definitely ordered keys
        $a = {ks:[],ki:{},vs:[]}
        $keys = haks(h)
        c.vsort and vsortz(keys,k=>k)
        each ik keys {
            $i = a.ki[k]
            null == i and i = a.ki[k] = a.ks.push(k)-1
            a.vs[i] = h[k]
        }
        return a
    }
  // C f
    # c.t may say $t-$pi
    me.t_tpi = &acgtc{
        $tpi = c.t.match(/^(.+)-(\w+)$/)
        tpi and c.t = tpi[1]; c.pi = tpi[2]
    }
    # dedupe same t
    me.dupfiu = &acgtEt{
        $du = me&fiu,E,t,8
        if (du) {
            duc&dupfiu ||= 1
            t = t+' '+(++duc&dupfiu)
            $du = me&fiu,E,t,8
            du and throw "dupdup"
        }
        $d = me&fiu,E,t
        return d
    }
    # limitor: maintains an infinite list
    me.Nserial = &acgtNc{
        # assign serial numbers, continuing from last
        c.nk ||= 'sc'
        c.back = reverse(N)
        c.serial ||= 0
        c.neu = []
        each ie c.back {
            $Bati = e[c.nk][c.gk]
            Bati != null and c.serial = Bati; break
            c.neu.unshift(e)
        }
        each ie c.neu {
            e[c.nk][c.gk] = ++c.serial
        }
        # length limit
        while (c.ll && hak(N) > c.ll) {
            N.shift()
            c.back.pop()
        }
        return c
    }
  // R'The'
    
    me.Pi_The = &acgt{ return [
       
       // %Top back
        &{
        me.Rlimits = &acgtr{
            !rc&ha and return
            $upritN = {};
            each tz rc&ha {
                
                typeof z != 'object' and continue
                t == 'err' and continue
                # write trouble next to each node
                each in z {
                nc&dubquiet || ns&dubquiet and continue
                # R included are from Rc&refs/refR
                # < may not be in our h/R pool, showing...
                #   same Rc&s=objects near but not in this process
                $M = me&Mw,n,'Mlimits';
                $re =
                m $t 1189 s: %deco,fs:17,lh:0.3
                $o = ns&refR[0];
                # say where it originated
                $nam = me&nampup,o,n;
                if (ns&tiny) {
                    res&hs = '499';
                    re.t += '@'+nam
                }
                else {
                    m $t 11892 $s:nam %deco,fs:7,hs:999
                }
                }
            }
        }
        # R%M + R%Mw.* -> R%M, spaced
        me.modulatM = &acgtR{
            $M = []
            each in Rs&M {
                M.push(n)
            }
            each win Rs&Mw {
                ns&modt = w
                M.push(n)
            }}
            me&cvdeal,M
            vsortz(M)
            Rs&M = M
        }
        # shading weight -> dis:1 or not
        me.specialfx = &acgtR{
            Rs&tiny and grepout(Rs&M,n => ns&modt == 'Pier')
            $N = me&ioR,R
            Rs&inline || hak(N) <= 1 and return
            # < properly sizing it for:
            $larger = N.filter(n => !ns&tiny)
            !hak(larger) and return
            each in N {
                ns&inline and continue
                $C = ns&C
                s&dis = 1
                s&ml = 1
            }
        }
        },
        ['Top',0.12,&acgtRs{
            # lets /Display** recycle Elements
            me&arriveRbitX,R,R.t
            # capsule of %TX
            Rc&top = R
        },'ift,D'],
        ['Top',0.67,&acgtRs{
            me&Rlimits,R
            each ir Rc&N {
                rs&limit and me&Rlimito,r
                rs&toomuch and me&Rtoomucho,r
            }
            # < generating weightiness
            each ir Rc&N {
                # R%M + R%Mw.* -> R%M, spaced
                me&modulatM,r
            }
            $N = reverse(Rc&N)
            each ir N {
                # with shading, dis:1 or not
                me&specialfx,r
            }
            
        },'ift,D'],
        ['Top',0.9,&acgtRs{
            
            # disp
            s&dis = 1
            C.y.cv = 0.76
            me&walls,C,"b:2.2"
            me&scroll,28
            if (!Rs&noDisplay) {
                $d = me&Display,R,{prep:1}
                
                # < appears twice unless:
                Rs&noDisplay = 1
            }
            me&applyRbitX,R
        },'ift,D'],
        
       // %Pier,C,E,D types @2, &Eing E/** @3
        ['Pier',0.2,&acgtRs{
            $C = Rs&C
            $E = Rs&E
            # config via Ec&*
            Ec&dl and Rc&dl = Rc&d + Ec&dl
            $p = Ry&up
            $pE = ps&E
            if (!pE || pEc&pi != Ec&pi) {
                $n = me&tc,'new:Ec&pi','-'+Ec&pi,'G'
                ny&cv = 0.105
            }
            
            $name = R.t
            n At 101 $s:name %deco,fs:6
            
            R.sc[Rs&Pier] = 1
            me&haja
        },'ift,D'],
        # E/** expands, if not already
        ['Pier',0.3,&acgtRs{
            me&Eing
        },'ift,D'],
        
       // &pio @254 ground finds trips
        # i %TX/* o Troom
        ['Top',0.21,&acgtRs{
            # set TX
            $E = Rs&E
            $V = Rs&V
            Vy&RXing and fi&RXi,E,Vy&RXing
        },'ift,D'],
        # %TX awarenesses a point
        # dome suspicion
        ['Pier',0.264,&acgtRs{
            $E = Rs&E
            $M = fi&pio,E,{t:E.t,pi:Ec&pi,v:s}
            !hak(M) and return
            $t = me&Mwty,R,'Pier','At';
            ts&sha = '3 3 3 999'
            T.Mw = 'TX'
            # is it the end of a Ting
            $sym = M.some(aq => aqc&TX) ? '' : ''
            # < modify this to click expand elvising trace
            me&tc,"RX:"+joint(M),sym,'T'
            me&attendios,'matches',{M}
            each i,aq M {
                $qua = aqs&qua
                !qua and continue
                qua.ope and Rc&dl += 1
            }
        },'ift,D'],
        
       // -Bat events
        ['blank',0.21,&acgtRs{
            # diverges into types
            Rs&hat = 1
        },'ift,D'],
        # many e
        ['Bat+V',0.3,&acgtRs{
            # outsphere (s of R%TheTt)
            $V = Rs&V
            $D = Rs&D
            $E = Rs&E
            # enables popping events in, waking R%TheTt
            $N = Vy&Todo ||= []
            # < hold any with Ting
            $c = me&Nserial,N,{gk:'Bati',ll:5}
            each ie c.back {
                $n = me&Ei,{t:es&Bati,pi:'Bet',s:e,i}
                c.neu.includes(e) and nc&el = 2
                # < selected one
                0 == i and me&Ei,{t:'sel',pi:'Spheres',s:n,i}
            }
            
            me&Eing,6
            $N = me&ioty,R,'Bet'
            $n = me&Ei,{t:'Eel',pi:'Eel',s:N,dl:9}
            
            me&Eing,6
            $ED = ny&D
            Vy&TXing = EDs&aq
        },'ift,D'],
        
       // -Spheres events look
        ['Spheres',0.22,&acgtRs{
            $E = Rs&E
            $r = sy&R
            !isR(r) || !rs&Bet and debugger
            $Belt = me&ioty,r,'Belt','tow' [0]
            $Bits = me&ioty,Belt,'Bit'
            $Bit = Bits.filter(r => rs&isR).slice(-1)[0]
            $Y = Bitc&s
            $n = me&Ei,{t:'R',pi:'hat',s:Y,dl:1}
            each kv Y.sc {
                !isC(v) and continue
                $n = me&Ei,{t:k,pi:'hat',s:v,dl:1}
            }
            # default D open
            fi&TXi,E,"Dope",{t:'D'},1
        },'ift,D'],
        
       //   -Eel
        ['Eel',0.21,&acgtRs{
            
            #me&walls,C,'bd:3.7'
            $D = Rs&D
            $E = Rs&E
            if (Ec&Xc) {
                s&dis = 1
                s&ml = 1
                # non-first -Eels have an Xc to match
                me&Ei,{t:'Xc',pi:'hat',s:Ec&Xc,dl:2,inline:1}
                
                $EN = me.cby(E,E => !Ec&Xc && -2)
                $p = Ry&up
                $pD = ps&D
                $name = joint(EN)
                # into D%TX...aq
                $aq = fi&TXi,D,"aq:"+name,Ec&Xc
                # onto D%aq
                Ds&aq = aq
                # into D^%aq %TX..aq
                pDs&aq and fi&TXi,pDs&aq,aq,Ec&Xc
            }
            else {
                Ds&aq = Cye(["Topeel",8])
            }
           
           // regrouping Bet
            $BitDXc = B => B && Bs&D && Bs&D.sc.Xc
            # next meaningful Belt Bit
            each ir s {
                !rs&Bet and debugger
                $Belt = me&ioty,r,'Belt','tow' [0]
                $Bits = me&ioty,Belt,'Bit'
                # find last position on Belt
                $Belti = (me&ja,Ry&up,{Belti:1,Bet:r},1 || -1)*1 + 1
                while (1) {
                    # seek next position with a D%Xc
                    $Bit = Bits[Belti]
                    !Bit and break
                    !BitDXc(Bit) and Belti++; continue
                    break
                }
                !Bit and me&ha,R,{done:1,Bet:r}
                else {
                    me&ha,R,{Belti,Bet:r,Bit}
                }
            }
            
            # group by same D%Xc
            me&jaa,R,'Belti,Bet,Bit' .map(&n{
                $Bet = ns&Bet
                $Bit = ns&Bit
                $Xc = BitDXc(Bit)
                $N = me&jaa,R,'Betgroup,Xc'
                each in N {
                    $Betgroup = ns&Betgroup
                    if (heq(ns&Xc,Xc)) {
                        me&ha,R,{Betgroup,Bet}
                        return
                    }
                }
                # create new
                # an empty hash as id because ja k=1 returns all k
                $Betgroup = {}
                me&ha,R,{Betgroup,Xc}
                me&ha,R,{Betgroup,Bet}
            })
            
            $groups = me&jaa,R,'Betgroup,Xc'
            each in groups {
                $Xc = ns&Xc
                $Betgroup = ns&Betgroup
                $Bets = me&jaa,R,{Betgroup,Bet:1},'Bet'
                me&Ei,{t:'E'+i,pi:'Eel',s:Bets,Xc,cv:8}
            }
           
           // having Bets
            $BitDXsc = B => B && Bs&D && Bs&D.sc.Xsc
            $N = me&jaa,R,'done,Bet'
            $done = N.map(n => ns&Bet)
            !hak(done) and return
            !aq and return me&tc,"!ac"
            !aq and debugger
            $qua = {}
            each iB done {
                $Xsc = BitDXsc(B)
                ex(qua,Xsc)
            }
            hak(qua) and aqs&qua = qua
            me&Ei,{t:'aq%qua',pi:'hat',s:qua,dl:2,inline:1}
            me&tc,"done:"+joint(done)
            
            #me&Ei,{t:'aq',pi:'hat',s:aq,dl:2}
        },'ift,D'],
       //   -Bet event, -Belt slope
        # the e itself
        ['Bet',0.21,&acgtRs{
            $D = Rs&D
            me&walls,C,'bd:3.1'
            # < mutey picture of the C
            $en = me&tc,"e:"+s.t,'g'
            
            Ds&Xsc = {ope:1}
            #   pulling up the sc&tower.N
            $c = sc&tower
            me&Ei,{t:'tow',pi:'Belt',s:c.N}
            me&walls,en,'b:5.2'
        },'ift,D'],
        # a slope
        ['Belt',0.21,&acgtRs{
            $p = Ry&up
            $pE = ps&E
            
            $N = s
            !isar(N) and return me&strange,"!array"
            each it N {
                $e = me&Ei,{t:i,pi:'Bit',s:t,noref:1}
                pEc&i > 0 and continue
                
                # < how each thing relates to others
                #$M = me.cby(t)
                #me&tc,tn,"x"+hak(M),6
            }
        },'ift,D'],
       //     -Bit of slope, -isX
        ['Bit',0.21,&acgtRs{
            $D = Rs&D
            $E = Rs&E
            # < /E/X, ark=X being strongly typed -X
            #   R/E/X then are arks, wideness
            #    at one point along the -Belt
            $e = me&Ei,{t:'s',pi:'isC',s:s}
            !me&Eing,4 and return
            if (isR(s)) {
                Rs&isR = 1
                # < whittle down, pushing presentation,
                #   to be turned into an entirety if willed...
                #   or just R+E+X in the first -isC minimality
                # once that -isC is ok, spawn further:
                $tE = ss&E
                if (!isC(tE)) {
                    $e = me&Ei,{t:'E',pi:'isC',s:tE}
                    !me&Eing,4 and return
                }
                $X = tEc&X
                $e = me&Ei,{t:'X',pi:'isX',s:X}
                !me&Eing,4 and return me&strange,"Xnolike"
                $r = ey&R
                $nec = rs&nec
                !nec and me&strange,"!nec"
                if (rs&nec_simple) {
                    me&tc,"t-will-do",'t','8y'
                    rs&noDisplay = 1
                    Rs&inline = 1
                    Rs&tiny = 1
                }
                Rs&nec = nec
                $Xc = Ds&Xc = {}
                each ic nec {
                    Xc[c.k] = c.v
                }
            }
            else {
                # modulat, might something?
                Rs&tiny = 1
            }
        },'ift,D'],
        # R/E/X
        &{
            me.E_neighbours = &acgtE{
                $Ep = Ey&up
                Ep and return me&ioty,Ep
                # out the top of E space:
                $R = Ey&R
                $p = Ry&up
                $N = []
                each in ps&z {
                    ns&E and N.push(ns&E)
                }
                return N
            }
            # find the X/* most identifying X amongst N[X]
            me.X_necessary = &acgtXN{
                $M = []
                each kv X {
                    k == 'ref' and continue
                    k == 'v' and continue
                    $sk = k+'s'
                    $refs = X [sk]
                    !refs and continue
                    each iv refs {
                        $found = hak(N.filter(
                            V => V[sk] && V[sk].includes(v)
                        ))
                        M.push({k,v,found})
                    }
                }
                $most_iding = vsortz(M,a => a.found)
                $necessary = []
                each ic most_iding {
                    necessary.push(c)
                    c.found == 1 and break
                }
                return necessary
            }
        },
        ['isX',0.21,&acgtRs{
            if (Rs&refR) {
                # duplicate, reuse results
                $r = Rs&refR[0]
                !rs&nec and return me&strange,'!nec'
                sex(R.sc,r.sc,'nec,nec_simple')
                return
            }
            # look for the most identifying classifications
            $iE = s.A
            # amongst its neighbours
            $N = me&E_neighbours,iE
            !N.includes(iE) and me&tc,"!N/iE",'b'
            $NX = N.map(E => Ec&X)
            $nec = Rs&nec = me&X_necessary,s,NX
            if (hak(nec) == 1) {
                $ne = nec[0]
                if (ne.k == 't' && ne.v == iE.t) {
                    Rs&nec_simple = 1
                }
            }
            else {
                # < boost or !simple:
                me&Ei,{t:'Es',pi:'hat',s:nec,dl:2}
            }
        },'ift,D'],
        
       // -hat -> -Hash etc
        ['isC',0.21,&acgtRs{
            me&walls,C,'bd:1.5'
            Rs&hat = 1
            isC(s) and return Rs&tiny = 1
            # was supposed to be C but isn't
            # < central fault aggregator
            me&strange,"!C"
        },'ift,D'],
        ['hat',0.21,&acgtRs{
            # diverges into types
            $sym = isR(s) ? "R" :
                isC(s) ? "C" : 0
            sym &&
                n sym 11 $s:sym fs:13,lh:0.8,hs:757
            if (Rs&tiny) {
                if (isC(s)) {
                    # C display whittles down to symbol + name
                    # < by adopting ranges of sub-R types
                    n t 12 $s:s.t label
                    return
                }
                else {
                    # stops recursion
                    $ref = me&Ri,'%limit/tiny'
                    me&Ri,'%limit/%toomuch'
                }
            }
            sym and me&typeup,R,'Cish'
            else
            isob(s) and me&typeup,R,'Hash'
            else me&typeup,R,'String'
        },'ift,D'],
        ['Cish',0.263,&acgtRs{
            Rs&Hash = 1
        },'ift,D'],
        ['Cish',0.7,&acgtRs{
            $N = me&ioR
            N.some(r => hak( me&ioR,r ) > 5) and return
            delete Rs&Mw.Hash
            # y, c, sc
            #R.t == 'R' && Ry&up.t == 'y' and debugger
            N.map(&r{
                rs&toomuch and return
                delete rs&Mw.Hash
                delete rs&Mw.Pier
                rs&inline = 1
                $C = rs&C
                Cs&pr = 0.3
            })
        },'ift,D'],
        ['Hash',0.263,&acgtRs{
            $D = Rs&D
            $E = Rs&E
            me&walls,C,'b:2.2'
            n begin 23 s:{
            each kv s {
                me&Ei,{t:k,s:v}
            }
            n end 77 s:}
        },'ift,D'],
        ['String',0.263,&acgtRs{
            $D = Rs&D
            $E = Rs&E
            $di = dis(s)
            n thinking 12 $s:di %fs:8,hs:584
        },'ift,D'],
        
        
    ] }
    },
   
   # GOING Sopi
   // -hat - top thing
    &{
    me.pihat = &acgtscq{
        $R = me&R
        $go = Rs&goThy
        return me&Sopi,s,'hat',c,q ({
            1: &Ecq{
                Ec&top = 1
                c.nopiinto = 1
                fi&piinto,E,c
                # < for a Cy&thing here
                $t = Ey&thing ||= Cye([E.t,1])
            },
            7: &Ecq{
                sy&data = hash
                
                # the redo:
                $sd = me&disp_suit,s
                Ec&N = []
                me&fiu,E,'topval',9
                
                # do:
                $f = fi&pii,E,{t:"topval",pi:'val',s:hash}
                me&windup_tape,E,6,q
                me&disp_tape,E
                
                go and me&nu,"Slu",E
                $R = me&R
                ac(R,'M',sd)
            },
        })
    }
   // misc
    # chase <ov on tape
    me.windup_tape = &acgtEcq{
        num(c) and c = {ov:c}
        c.ov = scaf(c.ov || 9)
        $seen = 0
        while (Ec&N.length > seen) {
            seen = Ec&N.length
            each ie Ec&N {
                ec&cv == c.ov and continue
                fi&piing,e,c.ov,q
                # sets cv=ov even if no mindbit is there
                ec&cv = c.ov
            }
        }
    }
    me.disp_tape = &acgtEcq{
        # uplink del modulata
        each in Ec&N {
            # n:s - outsphere
            $d = me&disp_suit,n
            each iz ns&z {
                dy&here(z)
            }
            # ny$pi = E - insphere, has others
            $nE = me&mustpis,n
            # n up to some E
            $pE = ny&up
            $pn = me&mustpiE,pE
            # here inside higher middle
            $pd = pny&disp
            !pd and debugger
            pdy&yond(d)
        }
    }
    # housing for stuff around stuff inside
    me.disp_suit = &acgts{
        $d = sy&disp = Cye([s.t,8])
        dy&up = s
        
        $be = me&fiu,d,'beginning'
        me&tc,be,s.t,'q'
        $mi = me&fiu,d,'middle'
        mis&ma = 0.2
        $en = me&fiu,d,'end'
        
        # heres on either side of yond
        dy&here = &z{
            $to = zy&cv < 0.67 ? be : en
            ac(to,'z',z)
        }
        dy&yond = &z{
            ac(mi,'z',z)
        }
        return d
    }
    me.mustpis = &acgts{
        $E = fi&getpi,s
        E == s and debugger
        Ey&up != s and debugger
        return E
    }
    me.mustpiE = &acgtE{
        $s = Ey&up
        $e = fi&getpi,s
        E != e and debugger
        return s
    }
   // -hash etc
    me.pival = &acgtscq{
        return me&Sopi,s,'val',c,q ({
            2: &Ecq{
                if (isob(sc&s)) {
                    fi&piing,s,{E,pi:'hash',ov:2},q
                }
                else {
                    ss&insideEnd = 3
                    Es&Leafit = 3
                    $M = ss&z
                    $di = dis(sc&s)
                    m thinking  $s:di %fs:8,hs:584
                }
            },
        })
    }
    me.pihash = &acgtscq{
        return me&Sopi,s,'hash',c,q ({
            2: &Ecq{
                $M = ss&z
                m thinking  s:{ %deco,fs:8
                each kv sc&s {
                    $row = fi&pii,E,{t:k,pi:'valend',s:v}
                    rows&seenity = 3
                }
                m thinking 7 s:} %deco,fs:8
            },
        })
    }
    me.pivalend = &acgtscq{
        return me&Sopi,s,'valend',c,q ({
            2: &Ecq{
                ss&insideEnd = 3
                Es&Leafit = 3
                $M = ss&z
                $di = dis(sc&s)
                m thinking  $s:di %fs:8,hs:584
            },
        })
    }
    
    },
    
  # SC/
  // This**
   
   // This
    # interface to have R/r that return r@295
    ['doRbales',0.294,&acgtRs{
        sy&balein = &sc{
            return fi&balein,s,c
        }
    },'ift,D'],
    ['doRbales',0.296,&acgtRs{
        fi&Rbales
    },'ift,D'],
    
    ['newsevens',0.7,&acgtRs{
        $N = delete Rs&newsevens
        $noR = N.filter(n => !ny&R)
        each in noR {
            # into E**, to wake nearest R-er
            $sev = fi&getpi,n
            $r
            me.cbu(sev,&s{
                $z = sy&C
                r = z && zy&R
                return r && isnode(rc&s)
            })
            !r and debugger
            me&wants,R,'Rnew',rc&s
        }
        #me&nu,"Newsevens",{N,r}
    },'ift,D'],
    
    ['FishThis',0.293,&acgtRs{
        me&reaw,R,'FishThis,wakeful,onlyish'
        me&inode,R
        $x = me&Jx,R
        # wake R when p%onlyish/R%wakeful
        Rs&wakeful = 1
        # sleep r when R%onlyish/r!%wakeful
        Rs&onlyish = 1
        # resume %FishThis when %ball-created
        ah(R,'nextlifesc','FishThis',1)
        
        me&tsc,"FishThis"
        Rs&doRbales = 1
        sc&nopiinto = 1
        me&piThis,s,2
    },'ift,D'],
    # any This/-eight, tend to sleep
    ['FishThis',0.296,&acgtRs{
        # draw the story, probably chunked per &live
        # leaves current -gate streaming
        #r and rs&wakeful = 1
    },'ift,D'],
    &{
        me.hideyfix = &acgtR{
            !hak(R.sc,'boost') && Rs&icount <= 2 and Rs&nofix = 1
        }
    },
   
   // Eight
    ['FishEight',0.293,&acgtRs{
        me&reaw,R,'FishEight,wakeful,who'
        me&inode,R
        $x = me&Jx,R
        Rs&rowish = 1
        Rs&onlyish = 1
        me&hideyfix,R
        Rs&noRsync = 1
        me&scroll,29
        
        $go = me&acting,R,'FEig'
        
        Rs&doRbales = 1
        # inspheres on sy&$pi=E/**
        sc&nopiinto = 1
        #s&nofurtherDisplay = 1
        $p = Ry&up
        $z = pc&s
        me&piEight,s,{into:[z]},2
    },'ift,D'],
    ['FishEight',0.321,&acgtRs{
        # before|after Rbales?
        #$E = Rs&eight = me&pieight,R,s,1
        
        # complete -eight
        #!Rs&wakeful and Rs&Fin = 1
        me&piEight,s
    },'ift,D'],
   
   // Seven
    # < self a -seven
    #   has a &brackology + more
    # < brackology rearranging so node:Gilramp=wake
    # < saying when node:Travel..Gilramp
    ['FishSeven',0.295,&acgtRs{
        # causes empties:
        #delete Rs&ball
        me&hideyfix,R
        Rs&noRsync = 1
        $p = Ry&up
        $z = pc&s
        me&piSeven,s,{into:[z]},2
    },'ift,D'],
    ['FishSeven',0.32,&acgtRs{
        sy&R = R
        $p = Ry&up
        $z = pc&s
        
        $go = me&acting,R,'FSev'
        Rs&elvis = 'FishElvis'
        
        s&hue = 138
        # -seven...-ologise also colours it
        
        me&piSeven,s,{},7
    },'ift,D'],
    
    # < othering back into &brackology any novelty
    ['FishSeven',0.44,&acgtRs{
        me&reaw,R,'FishSeven'
        Rs&rowish = 1
        #!sy&seven and return
        $x = me&Jx,R;
        $go = me&acting,R,'-seven',0
        
    },'ift,D'],

]}