# Picturity!
   // modulat f
    me.scroll = &acgts{
        s&mh = s;
        s&over = 1
    }
    # in-modulat &nu
    me.mnu = &acgtgts{
        $nu = me&nu,t,s;
        nus&ope = 1;
        me&zN,nu;
        me&zuct,g,nu;
    };
   // misc()
    # selective ex, removing
    #  as in consuming arguments from a c
    window.tax = &s,take,c{
        !c and return s
        !isha(s) || isC(s) || !isha(c) || isC(c) and throw "tax"
        isst(take) and take = G&peel,take
        else
        isar(take) and throw "{map{k:1}take}"
        each k,remove take {
            !hak(c,k) and continue
            remove and s[k] = delete c[k]
            else { s[k] = c[k] }
        }
        return s
    }
    # "$t1-$t2" for [C,C,C{.t==not}]
    window.joint = &N,join,not{
        # ioty may N=C/*
        $M = me&ioty,N .map(n => isC(n) ? n.t : n)
            .filter(t => t != null && (not == null || t != not))
        $s = M.shift()
        join ||= '-'
        each in M {
            # leading joiner-ish thing
            n.startsWith('<'+join) and s += n
            else { s += join+n }
        }
        return s
    }
    window.defor = &sc{
        return s != null ? s : c
    }
    # y(v,k) for s
    window.hav = &sy{
        return haks(s).map(k => y(s[k],k))
    }
    # removing .filter
    window.grepout = &Ny{
        $out = []
        each in N {
            y (n,i) and out.unshift(i)
        }
        return out.map(i => N.splice(i,i+1)[0]).reverse()
    }
    
    # some of the smallest structures
    # reversibly|diffily, create transform theory
    # phenom comes in waves
    # waves have a skin
    # skins relate posture
    window.hashkv = &kv{
        $c = {}
        c[k] = v != null ? v : 1
        return c
    }
    
    # hash from k:v, v=1 if not given
    window.peel = &s,sep{
        s == null and return {}
        if (isst(s)) {
            # shortcut?
            !s.includes(sep||',') and return hashkv(s)
            # < sep?
            # < rebuild for k:that:go:deeply,
            #   or that@link to indentedchunk later
            #    or link object anywhere, if A:L..A:peel
            #    < rebuild a subset of yaml mostly,
            return G&peel,s
        }
        isha(s) and return s
        throw "not peely", s
    }
   // arq()
    # departmentalise c if not already
    #  for s sublating its namespace
    # q.K=1:        c=v -> s.K=v
    # q.K=gk:  c(.K)?=v -> s.K.k=v
    # is basically:
    #  !q.qk and q = {qk:q}
    # q.peely>0: peel(v) if it needs to be housey
    #  not if v is going for c.label.s
    #  
    # smallest totality?
    #  people fall in a ditch that triangle will not fix
    window.arq = &cq{
        
        $origin = c
        # c fated to mix into s.$K, not s
        #  unless it knows any of these $k
        !q.qk and throw "index"
        # < without any q.qk? does to_housey(c.*.*)
        $qk = haks(q.qk)
        # the default department first
        $K = qk[0]
        $gk = q.qk[K]
        # how c and any c.K should end up
        $housey = v => isha(v) && !isC(v)
        # v must be beyond housey (index)
        $itemic = v => !isha(v) || isC(v)
        
        # try to leave c(.*)? housey
        # may not be possible, if v=C and no more qk
        # eg &Cye solving c="La":
        #   expe() peely=1: -> c={La:1}
        #  + qk.s=1:
        #   exts() peely=0: -> c={s:"La"}
        #   expe() peely=1: -> c={s:{La:1}}
        # more eg below
        $to_housey = &vd{
            # not c if peely=0
            # even c.*.* if peely=2
            !(q.peely && q.peely >= (d||0)) and return v
            return v == null ? null : peel(v)
        }
        if (itemic(c)) {
            # 2-house: c.label.s may be itemic
            # c=C -> c.s=C, then -> c.label.s=C
            gk != 1 and c = hashkv(gk,c)
            else {
                # 1-house: c should be housey
                # c=C -> c.label=C
                # c="st" -> c.label=(peely ? {st:1} : "st")
                c = to_housey(c)
                if (itemic(c)) {
                    # was peely=0, or C passed through peel()
                    # put as default department
                    K != null and c = hashkv(K,c)
                }
                else {
                    # now may have deparments:
                }
            }
        }
        if (housey(c)) {
            # for any department, or the default
            $match = qk.filter(K => hak(c,K))
            if (!hak(match)) {
                # nothing we know about
                #  (that we should try to make housey)
                # c.s:C -> c.label.s=C
                c = gk == 1 ? c : hashkv(gk,c)
                c = hashkv(K,c)
            }
            else {
                each iK match {
                    $v = c[K]
                    $gk = q.qk[K]
                    # leave c.label={...}
                    # < or whatever we want there
                    housey(v) and continue
                    # 2-house: v may be itemic
                    # c.label=C -> c.label.s=C
                    gk != 1 and v = hashkv(gk,v)
                    else {
                        # 1-house: c.label should be housey
                        # c.label="st" -> c.label=(peely ? {st:1} : "st")
                        v = to_housey(v)
                        # may still be itemic if !peely, eg:
                        # c.label=C -> c.label.C (unhousable)
                        isC(v) and throw "c."+K+"=C !",c,v
                    }
                    # < when|how v not housey (domesticate it)
                    isC(v) and throw "c."+K+"=C !",c,v
                    !isha(v) and throw "c."+K+"!housey",c,v
                    v == c[K] and continue
                    # preserves the c passed in
                    c == origin and c = ex({},c)
                    c[K] = v
                }
            }
        }
        else {
            throw "type",c
        }
        if (q.peely == 2) {
            # < c.label.s housey or fatal?
            throw "each qkv c"
        }
        return c
    }
   // ex*()
    # s=k:v hash copy after arq()
    #  c can stay string if ^ takes it beyond c.*.*
    # v merges if both hash
    # s|c being C is fatal
    #  < could have something on it?
    # v not being hash is fatal
    #   which is where exts() would give it a key
    #   unless v=1,
    #    logically compatible with v={...}
    window.expe = &scq{
        # ensure c is a hash
        $origin = c
        if (q) {
            # get a list of words
            q = peel(q)
            # arq() is basically:
            !q.qk and q = {qk:q}
            # may departmentalise c, peel c.label
            q.peely = defor(q.peely,1)
            c = arq(c,q)
        }
        return ex2(s,c)
    }
    window.ex2 = &scq{
        c = peel(c)
        isC(s)||isC(c) and throw "expe..C"
        each kv c {
            $V = s [k]
            if (V && isha(V) || v && isha(v)) {
                # allows either $v to:
                #  peel if other is hash
                isst(V) && isha(v) and V = peel(V)
                isst(v) && isha(V) and v = peel(v)
                #  replace 1->{}
                V = exable(V)
                #  and|or premix arrays in v.*
                v = exable(v,V)
                # mixing v into V
                ex(V,v)
            }
            else {
                # replacing
                V = v
            }
            s [k] = V
        }
        return s
    }
    # will it ex()
    # s = one argument to ex() at a time
    # returns s or a coercion to replace it:
    #  s=null|1 -> {} coercion
    #  s.* and c.* array pre-mixing
    window.exable = &s,c,fatal{
        # returns coercions or false
        !s and return {}
        s == 1 and return {}
        isar(s) and throw "what?"
        if (!isha(s)) {
            fatal and throw "!exable",s,c
            return 0
        }
        # < Cy&sortin patch-conforming c, putting el:8 etc
        #   exable(c,s) becomes lv(s,c)
        #   ex(s,c) becomes el(s,c)
        isC(s) and throw "exC"
        if (c) {
            # premix arrays
            # c,s are the s,c from ex(s,c)! upside down.
            #  here, s merges into c
            #  because we can replace s
            #    as returning a coercion
            #   with a copy with pre-mixed arrays
            # < does it uniq, or have:
            #    a sort-in function on s.* or isC(V)?
            #   if k=ref, has to renumber or create subnet
            s = ex({},s)
            each kv s {
                $V = c[k]
                (!v || !isar(v)) && (!V || !isar(V)) and continue
                # < coerce V==0 -> []?
                V && isar(v) && !isar(V) and throw "ex not<-array"
                v && isar(V) && !isar(v) and throw "ex array<-not"
                s[k] = [...(V||[]), ...(v||[])]
            }
        }
        return s
    }
    # s=K.k:v hash copy
    # with q, c may be (already)? departmentalised
    # s.label = "st", c.label = {...} is fatal
    #  in reverse however, s will .label:{...,s:"st"}
    #   given q.label:"s"
    # c="st" or c=K/"st" may -> s=K/"s":"st"
    #  if q.es[K] (not peeled?)
    # eg la:{ya:2} + la:three -> la:{ya:2,s:three} (K="la")
    window.exts = &scqk{
        if (k) {
            # specifying a pair
            !isst(q) and throw "q+k"
            q = {qk:hashkv(q,k)}
        }
        else {
            # get a list of words
            q = peel(q)
            !q.qk and q = {qk:q}
            # with a default gk='s'
            $qk = haks(q.qk)
            hak(qk) == 1 && q.qk[qk[0]] == 1 and q.qk[qk[0]] = 's'
            # dont peel c(.label)?="string"
            q.peely = 0
        }
        return expe(s,c,q)
    }
   
   // Api() etc
    # create a -pi on a node
    me.Api = &acgtstc{
        !isst(t) and throw "which -pi"
        # takes c.t (< etc) into a new c
        c = tax({},'t',c)
        c.el = 2
        $b = s.y [t]
        $E = s.y [t] = Cye([defor(c.t,s.t),1,{pi:t}])
        Es&z ||= []
        Ey&up = s
        return E
    }
    # for s if sc&pi=$k, or sy&$k
    # < used
    window.phisy = &sk{
        $z = sc&pi == k ? s : s.y [k]
        !z || !zc&pi and throw "shocks",z
        return z
    }
   
 // -** - takes a look
   // -eight**
    me.Dispup = &acgtn{
        $R = me.cbu(n,n=>isR(n))
        
    }
    # < drop -seven c.t=i, se.t can be set
    me.pieight = &acgtRsc{
        $E = me&Api,s,'eight',c
        $D = Cye(["Eighting"])
        $Eac = &e{
            ac(E,'z',e)
            me&bracki,R,D,hashkv(ec&pi,e)
        }
        
        $fo = me&pifour,R,s
        Eac(fo)
        
        if (c.ov >= 0.6) {
        each ie ss&z {
            # paragraph of story: -seven a %Yingate
            !ey&R and debugger
            $se = me&piseven,R,e,{}
            # < could almost rename that after returning it
            #   would require A:n@1 until the S domed
            Eac(se)
        }
        }
        
        # -eight display
        $br = me&pibrackology,R,s,{D}
        $ol = bry&ology
        # sorts before four
        # < start early to take place, load D when ...
        oly&cv = 0.117
        
        me&onaneight,R,s,E
        # through -tll (thing looks like) to -act
        
        #ss&z.length > 5 and me&scroll,27
        
        # only -four yet, to help -eight sublate
        !c.ov < 0.6 and return
        # 6
        $d = {
            compLines:&DdC{
                me&dopi,D,d,C,c
            },
        }
        # < the Lineso top D on ss&string.D
        #   showing the string with chunks inteligised
        me&Linets,s,E,d
        
        # &acceptables_reself
        c.Finto &&
            me&nodei,R,c.Finto,{Fin:s,dige:ss&dige}
    }
    me.onaneight = &acgtRsE{
        $thisR = R
        $n = me&tsc,"TESTSHADE"
        me.nto(R,n,&sTe{
            me&blankeight,thisR,E
            T.wake = 'not'
        })
        sy&on_ok = &acgtjz{
            ~>5 IsOK: s.t
            G&yl:3,&{ me&blankeight,thisR,E }
            ss&ISOK = 1
        }
    }
    me.uptoR = &acgts{
        $z = me.cbu(s,z => zy&R)
        !z and debugger
        return zy&R
    }
    me.blankeight = &acgtRE{
        $apply = &Onc{
            $modon = me&Dispon,n;
            # can remain on Rs&eCsc.-eight
            !modon and ~>4 Non: O.t
            me&eCsc,O,'-eight',c (modon);
        }
        # < grepo (returning the climbed v)
        $N = me&ioty,E .map(z => zy&brackology) .filter(z=>z)
        ~>5 cept: joint(N)
        $eightR = me&uptoR,E
        # each -eight/*//-brackology
        N.map(&z{
            $r = me&uptoR,z
            $st = {dis:0}
            #{bo:'3px dotted white'}
            if (r == eightR) {
                # -four/*%groupthing, so the label remains
                zy&M(&m{
                    # has been visited by R:Display
                    !my&Display and debugger
                    apply(m,m,st)
                })
            }
            else {
                # hide entire $eight/r
                $ce = rs&C
                !cey&Display and ce = me&ollbs,r,'C'

                apply(r,r,st)
            }
        })
    }
    # < may merge -eight with similar -four
    #   eg a sequence of e:clicks each return to Story
    #    whereas a bunch all happen, then return to Story
    me.pifour = &acgtRsc{
        $fo = me&Api,s,'four',c
        $gof = me&acting,R,'-four',0
        # merge eight:s/seven:z/row into D/row+%%gate=z
        $D = me&pigate,R,fo,{N:s}
        # start an interactive viewability on it
        $br = me&pibrackology,R,fo,{D}
        bry&M(&Km,{
            # -legs tallies Km/Kn,
            # and unrelatedly mutes Km:gate:
            # < -gate is the source of that, contrib %togcon:
            #    so ope:-1 show Km.t+sizo, no Kn, nothing in -legs
            #   before br renders Km, then finish after
            # < Km, without label, not pointtoable?
            $leg = me&pilegs,R,s,{Km}
            # fatal create each -leg in -four
            me&fiu,fo,leg,2
        })
        
        # out of timer
        $po = me&piling,R,fo
        gof and me&nu,"tugboat",po
        
        return fo
    }
    
   // -seven, who sc&pi=other
    # split a pi into self or other,
    # ie R:seven (self) does -seven cv < 6,
    #   (Displaying it through R:seven)
    #  R:eight (other) carrying on with non-R:seven aspects
    me.sopi = &acgtRstcq{
        !sy&R and throw "beself"
        q = peel(q)
        $self = sy&R == R
        return &SO{
            $se = self ? me&Api,s,t,c : s.y [t]
            $args = []
            if (q && q.thing) {
                if (self) {
                    # keep instruction for later
                    $D = sey&thing = c.D || sey&thing || s
                    # most probably s/row+
                    D == s and Dc&brackin ||= 1
                }
                else {
                    $D = sey&thing
                }
                !D and throw "unthingD"
                args.push(D)
            }
            !se and throw "unself"
            (self ? S : O)(se, ...args)
            return se
        }
    }
    # < self in %Yingate, continues with -eight
    me.piseven = &acgtRsc{
        $se = me&sopi,R,s,'seven',c,'thing' (&se,D{
            # $D = sey&thing
            # < maybe how to -gate..-vat,
            #   see 'capture any adjusted ology for replay'
            #   specifics for the process its going into,
            #    want tuning in the brackology
            # it should be -gate, -log, etc by now
            $br = me&pibrackology,R,se,{D}
            br != sey&brackology and throw "you"
            #me&nu,"See",{s,br}
        },&se,D{
            $br = sey&brackology
            bry&M(&Km,{
                # -seven/-rows: of similarity
                #  allowed one oddness, see -groupbrack_similark
                $tee = joint(me&ioty,Km )
                # < &fiu,s,z,2 - fatal create?
                me&fiu,se,tee,8 and throw "already a "+tee
                $mg = Kmy&gate = me&fiu,se,tee

                # < hardwired or $Storie-got configuring
                #    &togcon
                # < track approx time of each -seven
                #   species a trail of samples
                tee == 'time' and mgc&ms = 'z'; return

                !Kmc&rows and throw "norows"
                each in Kmc&rows {
                    $gr = me&fiu,mg,i
                    gry&row = n
                    each kv n.sc {
                        $gv = me&fiu,gr,k
                        gvc&s = v
                        gvc&pi = 'vat'
                    }
                }
            })
        })
        return se
    }
  
  // -piling Yc&M[$pi+] to complete
    # draws drawings together as plans to complete them
    # find all -pi for s, generating a poc&M to be Yc&M
    me.piling = &acgtRsc{
        $po = me&Api,s,'ling',c
        # searches s for sy&somethingc&pi,
        #  eg s=$fo=-four, finds $D, $br
        $M = []
        $api = v => v && v.c && v.c.pi && M.push(v)
        hav(s.y, v => api(v))
        # and eg $fo/$leg+
        sc&pi && me&ioty,s .map(v => api(v))
        
        poc&M = arou(uniq(M),v=>v!=po)
        return po
    }
    me.dopi = &acgtDdCc{
        $s = c&s
        if (c&pi == 'vat') {

            # starts s=object|data|value, becomes stringified
            !isC(s) and Dc&s = ki(s); return
            Dc&s = s.t
            # avoid talking of R
            isR(s) and return Ds&R = 1
            Dc&pi = 'n'
            # usually -n: a C we can find
            # as a flower amongst|beyond the body of nodes
            $stem = []
            $beyond
            $Xss = c.nlist || []
            $la
            $foundnode = me.cby(s,&zd{
                $t = z.t
                # tell if la^z != z/la
                if (la && !(zs&z && zs&z.includes(la))) {
                    $r = lay&R
                    $rem = ''
                    # < see vv/beginning/3 "Story/Story!%eph/beginning"
                    #   s^^ different to sy&R^^
                    r && !(rs&eph || me&ollbs,r,'eph' ) and rem = '!'
                    !r and rem = '?'
                    #stem[0][0] == 'le-2' and debugger
                    stem[0].push(rem+'%eph')
                }
                la = z
                stem.unshift([t])
                if (Xss.includes(z)) {
                    !zy&path and throw "node!zy&path"
                    # finish?!
                    return 1
                }
                beyond = 1
                return 0
            })
            !stem.length and throw "nostem C"
            Dc&s = stem.map(l => l.join('')).join('/')
            !foundnode and Dc&pi = 'C'
            else
            beyond and Ds&beyond = 1
        }
        # normal -vat -> -n, talk of ground things
        Dc&pi == 'n' and delete Dc&pi
    }
  
  // stylemap - make outsidable
    
 // -brackology** - makes a look
    # situating crammed meanings
    #  wildest edge of things, where wheres where
    # < fill with hooks, combine with KnowC?
    #   see CB, which also wants:
    # < brackology with styles
    # < may have already been, shade difference?
    # < Citology, has nk/gk etc scrambling in one pool?
    # < gear in br/* (params|c) sitting near g/** (sc)
    # < K should be %grouping, with no label
    #  < because the Kn labels look enough like it
    # < they could hoist elsewhere, eg the Abodis minimaps
    # < and pipe into projections, gaining extra layout layers
    #   gy&M shall iterate Km for its current group+ology
    # < X.ref for inter-group object link
    # < only changes pop up, shrink in
    # < separate sizology
    #    the brackgroup causes -brack on D?
    
    # start an interactive viewability of brack
    me.pibrackology = &acgtRsc{
        $br = me&Api,s,'brackology',c
        $D = c.D
        !D and throw "!D"
        # g-ology provides bry&M() which iterates g/Km,
        #  which we create after -group**
        $g = me&piology,R,br,{D}
        # Ds&X should be up to date, eg &bracki
        #  or not yet created, eg -gate el:2 D (has )
        #   < it could allkv slep before reindexing it
        Dc&brackin ||= 1
        $X = me&brackXD,D
        !hak(X.k) and return br
        #-1 - only amounts (rows + uniq t)
        # 0 - t-only
        # 1 - with amounts
        # 2 - t:v, for 1 v only (as now)
        # < t-only, of at the toplevel
        if (gs&pow < 0) {
            $op = me&sizo,g,{t:'rows',len:Ds&z.length,opelen:1};
            # < each type of X.*, will be Km mot
            me&sizo,g,{len:hak(X.k)};
            !(op && ops&ope) and return br
        }
        # pre-K** structure pooling
        # < pass D around explicitly
        $gr = me&pigroup,R,br,c
        # i D/K/n o D%X
        $Z = me&pigroupbrack_similark,R,gr,c
        
        # piping into: i K/Km/Kn o D...%X  
        # < D iterates rows of %%K:z,n,Km?,...
        # < K knows which d+z it came from, to repipe...
        #   having slep sensors along the pipe,
        #   solo just the changed stuff
        # in this case we want rows grouped away
        me&Kmish,Z,{for:'K'} (&dz{
            # < might be no regroup, direct from %wou
            d == z and debugger
            # < t? i?
            # piped into modulat from the structuring D/K, now z
            # K: are the gy&M iterables
            #  see 'K should be %grouping'
            $K = me&opeKn,g,z.t,{walls:'bd:1.4'}
            # < originate
            Kc&rows = zs&z
           
            Ks&pow = gs&pow
            Ks&ope = gs&ope
            
            Ks&bgh = 581;
            Ks&dis = 2;
            
            # readies zs&X
            me&Kmish,z
            # K/Km:ark-sim/Kn:C-vat
            # has an X-specific iteration,
            # < D/t/-x
            c.tx = zs&X.k
            c.Kms = me&pitxology,R,K,c
            
            me&pitsograph,R,K,c
        })
        # beyond -brackology: i Km-mod o Km,
        #  knowing how to translate interest in those later expressions,
        #  into focusing this -brackology on certain rows/columns/values
        return br
    }
   
 // -group # i -ology/Km {reasoning} o $info**
  
  // pooling -> Km+
    =spec
     < -group makes K for mix of -group*
       mostly we want to:
     
     -groupbrack_similark
      group similar rows: D(/group)/row
     
     < -grouprefs
       
       stepx5: x3CTravel(wakex2), gatex3
        or (wakex2,gate:le-2) if not ^ K/Km/Kn mergible:
         would inject Km with Cn not from that K?
          or inject Kn:gate with Cn&v:
           Cn&v are really multiple, coming from Cn&x.ref
           < iterate &Knish
         yet have them undo if the wake is open
        Cn sizo (explicit x1) if different to Kn sizo
         or (wakex1) if wakex1
       
       puts K=step,node,wake as columns
        because they share a lot of refs
     
     < -groupspace
       puts K=step,node as columns, with an order
        because that is efficient Cn&v^ = Kn&v
         and we can z-order (or something else?) the v**
       or
        because that is Ying/*/** + attention
         and we have a Nodar to order them
      
      should be a pipe, ^ i D o D%X
     
     < D indentifying its structure
       when D = a -group*,
        D provides an iterator for %%Km,D:z
         and more, magical overlaying D:others

      < further D may be another layer of info, relative to origin
         how to traverse the origin to get the grouping
        not the origin in that grouping

      < ideally producing only X (not new D+rows)
        having ways to the original node and indexing qualities against them
        they might have an index of which indexes are important,
         and how to compute metrics for possible layouts
        can &bracko handle that? with joins?
       
       so many X, each perspecting D**
    =spec
    me.pigroup = &acgtRsc{
        $D = me&Api,s,'group'
        c.D and Dy&origin = D
        # Km = agreeable Km,D
        return D
    }
    # D%X
    me.brackXD = &acgtD{
        return Ds&X ||= me&brackX,Ds&z
    }
    me.Kmish = &acgtDc{
        !D and throw "!D"
        c ||= {}
        c.for ||= 'Km'
        me&brackXD,D
        # depth of C before rows
        $d = Dc&brackin
        # < etc, if we are on a K
        #!d && me.cby(&sd{ try while hak(d)<3 })
        $Dp = Dy&up
        !d && Dp && Dpc&brackin and d = Dpc&brackin-1
        !d and throw "noindex"
        # any D-group* y&M interates Cn, before Km
        return &y{
            d == 1 and $N = [D]
            else {
                $index = [...Array(d-1)].map(t=>'*')
                $N = me&ioty,D,index
            }
            N.map(&C{
                c.for == 'K' and y (D,C)
                else {
                    each in Cs&z {
                        nc&drop and continue
                        y (D,C,n)
                    }
                }
            })
        }
    }
    # < Kmish returning what y (D,C,n) returns ^
    me.resultily = &{
        
    }
  
  // structures
   // addition
    # group similar rows
    # allowing a and a+b to fit together,
    #  sizo per column|value communicates the oddness
    # splitting by %%dome:$v
    # < show clearer when Km%ope (tabular?)
    me.pigroupbrack_similark = &acgtRsc{
        $D = me&Api,s,'groupbrack_similark',c
        # i D/K-joint/n o D/n
        # layers of C structure before /n-row
        Dc&brackin = 2
        # the last of which (D/z) informs K.t (no label)
        # < doing this between K already there? is multiply|divide
        me&Kmish,c.D (&dzn{
            d != c.D and throw "c.D==d"
            $ks = haks(n.sc);
            $matchness = 0;
            $match = null;
            # < D/K indexed already, for K with k
            #   the X.k/$k might union X.grouptype/K
            #    for different types talks about X.k stuff
            each iK Ds&z {
                # < K having indexes already
                $no = haks(K.c).filter(k => !hak(n.sc,k)).length
                # allowing a and a+b to fit together
                no > 1 and continue
                # splitting by %%dome:$v
                ns&dome != Kc&dome and continue
                $yes = ks.filter(k => hak(K.c,k)).length
                $matched = yes - no
                matched <= matchness and continue
                match = K
                matchness = matched
                #j.t == 'Travel' and me&nu,"matched"+i,[ks.join(','),matched+'('+yes+'/'+no+')'+matchness,c.t]
            }
            if (match && matchness >= ks.length-1) {
                # groups members with <= 1 odd key
                $K = match
                ac(K,'z',n)
            }
            else {
                $K = Cye([ks.join(','),1]);
                # Kc&* are the match
                # < &if
                each kv n.sc {
                    K.c[k] = 1
                }
                Ks&z = [n]
                Ds&z.push(K)
                Ky&up = D
            }
        })
        #N.length == 1 and N = [z]
        return D
    };
   
   // subtraction
    # D-gate/@row+%gate=oD = N/oD/row
    me.pigate = &acgtRsc{
        
        $D = me&Api,s,'gate'
        $N = c.N
        !N and throw "!N"
        Dc&brackin = 1
        # < i $D/@row%gate=@gate y:row o $s/:gate/:row
        # < separation happening. it's not our $row to eat.
        #   separation coming before the row:{} here
        #   better getting at the row in &ind, grouped by arkfor?
        #   and tw mode, or even t mode (dup keep z)
        #   otherwise works:    this v is io's d.row, not brack row
        # i $D/@row row:{ s&gate = s.row[1] } y o $s/:gate/:row
        # instead:
        Ds&z ||= []
        me&ioty,N .map(&z{
            me&ioty,z .map(&t{
                t = Cye(t)
                ts&gate = z
                ac(D,'z',t)
            })
        })
        return D
    }
   
 // -ology # i $metrics o -ology/K**
   // 1 - br+g
    # viewable end of a -process
    # eg -brackology is -brack... -> -ology
    #  at R:eight/-four/-brackology/-ology,
    #   Rs&M += -ology
    me.piology = &acgtRsc{
        $br = s
        $fo = bry&up
        
        me&labelt,R,br,c,{thispi:'ology'}
        $g = me&Api,br,'ology',c
        
        gy&cv = 0.12
        # is appearable thing
        c.appears and ac(R,'M',g)
        # $g is a $pt
        me&togcon,R,g
        # and has a label, etc
        me&ologise,R,g,c
        # br has things from g,
        #  once other inputs them to $g/*
        bry&M = &y{
            me&ioty,g,'groupthing' .map(Km => y(Km))
        }
        # interfaces to its representation
        bry&gog = &y{
            y (g)
        }
        return g
    }
    # generate names over the slope
    # < these types in %Slope hypothetica
    me.labelt = &acgtRscq{
        # must be a pi under Rc&s already:
        $br = s
        $fo = bry&up
        
        # one highly unique:
        # < conveniently named after Rc&s.t,(^^^brc&pi) and c.*,
        #   a compressey mingle of what's around (to it|it to)
        # < once $g created, before its name matters: Y:pi @015
        # with c.* fact:
        $D = c.D
        c.t = c.t || joint([
            # stretches up to Rc&s.t:
            s.t,
            # up two:
            fo && foc&pi,
                brc&pi,
            # pi we're about to make ($g):
            q && q.thispi,
            # and some thing coming at it
            D && Dc&pi && '<-'+Dc&pi
        ])
        
        # one small and concise:
        # all .t are likely to be the same...
        # display title for the c&pi having -brackology above
        #  -four being the last real work,
        #    before the holograms showing it
        c.label = fo && foc&pi || c.t
        
        # all R/**{,2}/-ology appear
        if (br == Rc&s || fo == Rc&s || foy&up == Rc&s)
            c.appears = 1
    }
    # label clickable, energised, etc
    me.ologise = &acgtRgc{
        $q = {
            walls:'b:2.2',
            label:{walls:'bg'},
        }
        # ex(q,c) with q.label.s = c.label
        c = exts(q,c,'label')
        # < move out
        c.sc and ex(g.sc,c.sc)
        gs&hue = 30
        gs&ws = 0
        me&applystylec,g,c,{};
        me&opelabel,g,c.label;
        me&opewires,g;
        # energised
        gs&ope and gs&pow = gs&ope
        gs&pow ||= 0
        if (gs&pow > 1) {
            #gs&float = 'right';
            #gs&dis = 2;
        }
    }
    
   // 3 i K/Km/Kn
    # i Km:t c.tx=X.k /t/x
    me.pitxology = &acgtRgc{
        !c.tx and throw "!tx"
        $Kms = [];
        each tx c.tx {
            $Km = me&opeKm,g,t
            Kmc&k = t
            Kmc&x = x
            Kms.push(Km)
        }
        # energise it
        # < sizography of the K+
        gs&pow < 2 and gs&ma = 0.2
        each i,Km Kms {
            Kms&pow = 1
            $con = c.kc && c.kc[k]
            con and ex(Km.sc,con)
            gs&ope > 0 && Kms&ope == null and Kms&ope = 1
            Kms&ope and Kms&pow = gs&pow = 2
            gs&pow ||= 0
            
            if (Kms&pow < 1) {
                Kms&ma = 0.1
                Kmc&left_blank = 1
                continue
            }
            # open
        }
        return Kms
    }
    # draw openable /ref/z
    me.pitsograph = &acgtRgc{
        $Kms = c.Kms
        !Kms and throw "!Kms"
        each i,Km Kms {
            $k = Kmc&k
            $x = Kmc&x
            # total values for key, Km%ope if 1
            me&opesizup,Km,{len:hak(x.ref)}
            Kms&ope <= 0 and continue
            
            fio(Km,['ope',1,{s:":"},'hs:888']);
            $vii = 0;
            each vi,fx x.ref {
                $v = x.refs[vi];
                $lc = me&slabeline,v
                $Kn = me&opeKn,Km,lc.t,{label:{tsc:'y'}};
                Kny&v = v
                ac(Kn,'vis',vi)
                
                $lab = Kny&label;
                $bsize = Knc&size || Knc&sortcv && 1 || 0
                Knc&sortcv = 1;
                lc.C &&
                    fio(Kn,['sym'+vi,112,{s:lc.sym},
                    'label,fs:13,lh:0.8,hs:757']);

                # total rows for this value with this key
                # < light up other k/v/rows this k/v/row has
                Knc&size = 0
                me&sizo,Kn,{len:fx.z.length};
                # many same lc.t pile up many sym, add sizo
                # < fix in -ology
                Knc&size ||= 1
                Knc&size *= 1
                bsize and Knc&size = (Knc&size||1)*1 + bsize*1
                Knc&size == 1 and delete Knc&size
                Knc&size > 1000 and debugger
                Kns&ma = 0.2;
                if (Kns&ope > 0) {
                    each in fx.z {
                        $val = n.sc[k];
                        $na = [g.t,k,vi,i].join("'");
                        $wa = me&opeKn,Kn,na;
                        way&cv = 0.2;
                        was&dis = 1;
                        # sprout icon, some non-nu to click
                        $wan = me&opeKn,wa,'Ü¤',{label:{tsc:'y'}};
                        if (wans&ope) {
                            # whole row
                            me&mnu,wa,'row',n
                        }
                        else {
                            # for the value
                            me&mnu,wa,k,val;
                        }
                        wany&cv = 0.8;
                    }
                }
            }
        }
        return g
    }
    # a title for $s, data if weird
    # < -vat compat, fliop
    me.slabeline = &acgts{
        $c = {}
        if (isC(s)) {
            c.C = 1
            c.sym = isR(s) ? 'R' : 'C'
        }
        c.t = c.C ? s.t :
            s == null ? '*null' :
            isst(s) ? s :
            isob(s) ? ki(s,2) : ""+s;
        return c
    }
   
   // 6 o K**, other
    # storable -four/Km/ref
    me.pilegs = &acgtRsc{
        $Km = c.Km
        !Km and throw "!Km"
        c.t ||= joint(Km,'-','gate')
        $mg = me&Api,s,'legs',c
        me&ioty,Km .map(&Kn,{
            $N = me&ioty,Kn
            #me&nu,"Kn:"+Kn.t,N
            $gr = me&fiu,mg,Kn.t
            grc&pi = 'leg'
            Knc&size and grs&size = Knc&size
            gry&leg = Kn
            if (Kn.t != 'gate') {
                $x = Knc&x
                $ii = 0
                # ology modulat compresses same v.t along N
                #  to simplify order of every ref
                each in N {
                    !ns&vis and continue
                each i,vi ns&vis {
                    $fx = x.ref[vi]
                    $v = x.refs[vi];
                    # how many times it was used
                    $gv = me&fiu,gr,''+(ii++)
                    gvc&pi = 'vat'
                    gvc&s = v
                    gvs&size = fx.z.length
                    gvs&size == 1 and delete gvs&size

                    $nN = me&ioty,n
                    each iz nN {
                        #zs&groupthing and debugger
                        # size,sym,label
                    }
                }
                }
            }
            else {
                # mute %%gate after size
                # < in such a way that Te|diff can inflate it
                $aft_size = 0
                each in N {
                    aft_size and ns&dis = 0
                    n.t == 'size' and aft_size = 1
                }
            }
        })
        return mg
    }
   
    
   
   