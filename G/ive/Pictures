# Picturity!!
 // modulat f, &tc*, &*cap
   // your modulat
    # select ground 102-14 for name (6), 11 for sym (1)
    me.modselect = &acgtRc{
        R = Aof(R)
        c ||= {}
        # c.el=9,n=undef shall not delete everything (at the time)
        grep(k => hak(c,k) && c[k] == null, ['t','y','n']) .map(&k{
            throw "undef c."+k, c
        })
        # < mix down modulat into Rs&M anytime?
        me&modulatM,R
        $N = Rs&M
        1 and 1
        else {
            $N = []
            Rs&M and N.push(...Rs&M)
            # < code: havs(Rs&Mw)->havs->N
            #    auto havs($_)
            # < io: i N o R/%Mw/*/*/$v
            # < io: i havs(Rs&Mw)->havs->N
            each kin Rs&Mw {
                N.push(n)
            }}
        }
            
        # select what
        $M = N.filter(&n{
            return gteqcv(ny&cv,c)
                && (c.modt == null || c.modt == ns&modt)
                && (c.t == null || c.t == n.t)
                && (c.y == null || c.y (n))
                && (c.n == null || c.n == n)
        })
        if (c.el == 9) {
            # wont become R:Display
            M.map(n => nc&not = 1)
        }
        vsortz(M)
        return M
    }
    me.moddelete = &acgtRc{
        c.el = 9
        return me&modselect,R,c
    }
    # mix down R%Mw.$dome.* -> R%M.*
    # see '// f modulat' of mirage
    # periodically R%M <- R%Mw/T.act.t|$dome/$modulat**
    me.modulatM = &acgtRc{
        !Rs&Mw and return []
        $M = (Rs&M||[]).slice()
        $since = hak(M)
        each win Rs&Mw {
            # usu T.act.t, or T.Mw='such'
            ns&modt = w
            M.push(n)
        }}
        if (c) {
            # spatialises, on tv
            # < not til Mirage-ish time
            me&cvdeal,M
        }
        delete Rs&Mw
        Rs&M = M
        # new since
        return Rs&M.slice(since)
    }
    # C += C**, independent of the above &mod*
    # i $m/@sum/** y o $s:sum/**
    #  is how we used to (but it unsorts the s** !?)
    me.modclone = &acgtms{
        fatal.isC(s)
        $sleeve = &sd{
            # drop %z and y/!cv
            s = Cye(s)
            ac(d.m,'z',s)
            # follow me down
            d.m = s
        }
        me&indo,s,{m} (&sd{
            sc&not and return d.not = 1
            sleeve(s,d)
            if (sc&zuct) {
                $r = sc&zuct
                # goes through its r%C
                !rs&C and debugger
                sleeve(rs&C,d)
                # then all flatten(r%M)
                d.inz = flatten(rs&M)
                # s(c&zuct=r) always s/r
                $any = grap(n => n != r,ss&z||[])
                any and debugger
            }
        })
    }
   
   // misc make modulat
    # s='['
    # < %bracket?
    me.modbracket = &acgtsv{
        $abracket = &tsv{
            $be = me&tsc,t,s,''
            v and bey&cv = scv(v)
            bes&label = 'bracket'

        }
        abracket('begin',s,v||23)
        $end = s == '[' ? ']'
            : s == '{' ? '}'
            : '</'+s+'>'
        return &{
            abracket('end',end,77)
        }
    }
    me.modelta = &acgt{
        $R = me&R
        $start = Gtime()
        return &{
            $delta = Gtime(start)
            me&tc,"~"+delta,'b'
            start = Gtime()
        }
    }
    me.scroll = &acgtns{
        num(n) and s = n; n = C
        C = n
        s ||= 9
        s&mh = s
        s&over = 1
        s&po = 2
    }
    # in-modulat &nu
    me.mnu = &acgtgts{
        $nu = me&nu,t,s;
        nus&ope = 1;
        me&zN,nu;
        me&zuct,g,nu;
    };
   
   // &ts, &tc, &tcl(abel) usu modulat bits
        # explicitly s-having, will s=0 (&tsc s||=t)
        me.ts = &acgttsc{
            $n = me&tc,t,c
            nc&s = s
            return n
        }
        # s = t, like &tsc,'becomes',0,'6y'
        me.tc = &acgtmtcb{
            !isC(m) and b = c; c = t; t = m; m = 0
            $args = [t]
            # t+s can be split if b is c-ish (inc '')
            b and args.push((c && isst(c.s) ? c : {s:c}),b)
            else args.push(0,c)
            
            !m and return me&tsc,...args
            return me&mtsc,m,...args
        }
        # make both $n/$label%styled
        #  so &mtsc,n,... are outside of %styled
        me.tcl = &acgtmtc{
            !isC(m) and c = t; t = m; m = 0
            # t may be n already, moving c&s to the label
            $n = m ? m : me&tc,t
            $ot = delete nc&s
            t ||= ot
            # < split c by ',', apply latter to n
            $l = ny&label = me&mtsc,n,t+'-label',0,c
            lc&s = t
            tax(n.sc,l.sc,'dis')
            ls&pa = 0.2
            return n
        }
   // &ty, &tt usu interactive bits
        # &tc + clickable callback: &ty,... (&sTe{ ... })
        me.ty = &acgtmt{
            !isC(m) and t = m; m = 0
            t = [t,0,'g']
            $n = m ? me&mtsc,m,...t
                : me&tsc,...t
            $R = Cy&R
            return &y{
                me.nto(R,n,y)
                return n
            }
        }
        # &tt ({onto|once}) toggling, oncing.
        #  self: &tt,t () and 'while on'
        #  self: &tt,t (&{}) a
        # a &ty with state shared between self|other moments
        me.tt = &acgttc{
            $R = me&R
            $s = Rc&s
            $q = {}
            # from node (or named above) y&tt...
            #  through the ^^boxcaps
            $mem = me&Tabstate,'tt',q
            # then mem.i|o(t+,v?)
            
            return &y,async{
                
                # may visit to handle events there
                # < they might give a light level to start it at
                #   topics it magnetises to, etc
                #  &tt,'la' () and "sync"
                !y and y = {rebool:1,onto:&{}}
                else
                #  &tt,'lap' (1) and "sync once"
                y == 1 and y = {rebool:1,once:&{}}
                else
                # usu with a visit (other callback happens immediately)
                isfu(y) and y = {once:y}; y [async ? 'async' : 'other'] = 1
                
                # check state, hang on all ^^^&boxcap
                $qua = mem.o(t) || {}
                # < why not C?
                #   what shape are %TX**?
                fatal.ish(qua)
                # v = qua.on | e
                $handler = &v{
                    $args = [...arguments]
                    # v varies, and what the handler does
                    # only called where it can:
                    # < X log on things it changes, eg l%bri, io ideally
                    #    the txn out of time is obvious next time
                    #    and our v|e|qua eyes its theoretical reality
                    #     eg observe where exp on it,
                    #      wake for yay much ~
                    #   Effect being a nearby proto of that
                    # or simply:
                    #  be visiting, like x.ro
                    
                    # < rename is?
                    y.always and y.always (...args)
                    # < style flash in y.async
                    if (qua.on) {
                        y.on = qua.on
                        ls&bri = 1.6

                        y.onto and y.onto (...args)
                        # < having qua.el for moment cha of qua
                        #   depending on hoisty commit qua.ok=1 on res-merge
                        #    see emerge or submerge from Thying
                        # do thing once per click
                        if (y.once) {
                            y.once (...args)
                            qua.on = 0
                        }
                    }
                }
                $l = me&ty,t,c (&zTe{
                    z != l and debugger
                    # invoked asap when toggled
                    qua = mem.i(t,qua)
                    qua.on = !qua.on ? 1 : 0
                    if (y.other || y.async) {
                        # < know we are to Effect somewhere, and
                        #  < apply an async Effected handler
                            # < async if Effect... completely async
                            #  < as Be by Y:Easy
                        # < for overriding an R%noDisplay=1 default,
                        #   we must sync R without it first
                        #    subsequent togglings may just &Csse dis:0
                        #   < Babz: tie io expr this?
                        #      with X flock of impulse, joinables...
                        
                        # ignoring the above,
                        # handler would expect e at this point
                        # while other|async
                        handler (e)
                        
                        if (y.async) {
                            T.wake = 'not'
                        }
                        else 'visit R'
                    }
                    else 'visit R'
                    ~>7 tt 8: t, qua.on
                })
                
                if (y.other || y.async) {
                    # < may happen both occasions if Effect
                    #    would notice X txn done
                    #   
                    #    it might choose to leave
                    # see 'only called where it can'
                }
                else {
                    # handle while visiting
                    #   sync, self, awake, etc etc
                    handler (qua.on,T)
                    qua.on and ~>7 tt 4: t, qua.on
                }
                
                # y.rebool is for a mesh of logic functions that return true
                # < another school (&Superready) return true for abort
                
                # &tt,'lap' (1) and "sync once"
                y.rebool and return y.on
                
                return l
            }
        }
   // &ttpath, &Tabstate
        # climb a path from modulat rowcap|bowcap**
        #  very temporary
        # < could assume s is in T.ab, since no sy&up
        #    most modulat doesnt sy&up, except &boxcap/&boxcap**
        me.ttpath = &acgts{
            $g = {slope:[]}
            me.cbu(s,&n{
                # < a.table etc could contain above slope...
                ns&dis and ahk(g,'bydis',ns&dis,n)
                # path
                g.slope.unshift(n)
            })
            return g
        }
        # memory controller
        # < X|io interesting
        me.Tabstate = &acgttq{
            $R = me&R
            $s = Rc&s
            q ||= {}
            # < $q = {$t}, which put into &Xio might ...
            #   for &yio's ahk() however, mem.i(qua) doesnt work
            #    relies on having at least one key (to listend)
            hak(q,'t') and q.path = [q.t]
            
            
            # any T.ab^^^ (environmental)
            q.index ||= []
            # what may be supplied
            #  or leave it up to the mem.i('lastkey','such')
            q.path ||= []
            
            # may index by all ^^^&boxcap
            $m = T.ab
            if (m) {
                !m and throw "tt!Tab"

                # storage tricks eg mc&state_upon=@seven
                me&state_upons,q,m

                # < it may want a group by instead of some slope
                #   eg cycling style of all nodes
                ahk(q,['index'], slant(me&ttpath,m .slope))
            }
            
            # each string keying where mem ios onto the end of
            $lovely = [...q.index,...q.path]
            
            
            q.state_upon ||= s
            
            $mem = me&yio,q.state_upon,'tt',...lovely
            # < io upony&/$tt{$upon***/T.ab}
            #   io returns an io@1 ready to simply .i|o(...)
            return mem
        }
        # $m=T.ab has hosting contract with eg @seven
        me.state_upons = &acgtqm{
            $R = me&R
            $s = Rc&s
            
            $k = mc&state_upon
            !k and return
            
            if (k[0] == '@') {
                $z = me&Names_get,R,k.slice(1)
                !z and throw "upon!",k,m
                # put s** namespace we climbed
                $N = me.cby(R,r => rc&s && rc&s == z) .slice(1)
                !hak(N) and throw "none between",k,m
                # nodal index lumps /start/like/this,
                #  to never conflict with q.index[1] (in this case)
                #   being defined somewhere else.
                #   we are in y&tt 
                ahk(q,['index'], '/'+slant(...N))
            }
            else {
                throw "upon?",k,m
            }
            
            q.state_upon = z
        }
   
   // &rowcap, &boxcap modulat zones
        # build out modulat with whatever turns up
        #  so we can &dupfiu for t=iofail/suchexpr
        #  revoking the thing if nothing turns up (suchexpr)
        me.boxcap = &acgttc,el{
            $R = me&R
            el ||= 1
            # traction what is already, so m comes after it in a/*
            T.Mwcap and T.Mwcap()
            # before our capturing, set up in the above
            $a = T.ab
            if (a) {
                # eg C:iofail is reused, many C:suchexpr
                #  has my&up=a
                $m = el == 2 ? me&fiu,a,t
                    : me&dupfiu,a,t
            }
            else {
                # above is raw &Mwcap or nothing
                $m = me&tc,t
                # &tcl moves c&s to the label
            }
            !m and debugger
            isst(c) && c[0] == '0' and $slim = 1; c = c.substr(1)
            # &tcl C makes C/label of t+c style,
            #   returning C, for writing in next to the label
            #  confusingly, &tc,C,t,c will return C/thing
            me&tcl,m,t,c
            
            $capture = me&abTap,'box:'+t,m
            
            return &y{
                # for &boxcap,t,c (&m{...})
                y and y (m,my&label)
                
                capture()
                
                # consider thing done
                $N = me&ioty,m .filter(n => n != my&label)
                if (!hak(N)) {
                    # < who?
                    my&up and me&fiu,my&up,m,9
                    else mc&not = 1
                }
                each in ms&z {
                    !slim and ms&pa ||= 0.1
                }
                # < &dupfiu seq may have gaps ^
                return m
            }
        }
        # horizontal N>table iterator in boxcaps
        # &rowcap,N,'key' ('astep',&vmal{ ... })
        #  a persists per &rowcap (table)
        # < row nesting, splitting via mirage
        me.rowcap = &acgtNcq{
            c = peel(c)
            q = peel(q)
            # < q.t
            $name = q.k || joint(haks(c),',') || ''
            $table
            $head
            me&boxcap,"rowcap:"+name,(c.tsc||'5') (&ml{
                table = m
                lc&not = 1
                head = me&tc,'rowcap-tablehead','3y'
                $space = me&tc,head,'space','4y'
                delete headc&s
                delete spacec&s
                # the first column's title
                # < from args for first callback?
                hak(name) and spacec&s = name
                
                q.O and me&walls,table,'bd:2.4'
                # closes until putting a column:
            })
            $Na = []
            return &ty{
                # rejoing rowcap table closed above!
                $Tap = me&Tap,{ab:table}
                fatal.isst(t)
                fatal.isfu(y)
                !hak(N) and me&tc,t+"!rows",'6p'
                each in N {
                    isC(n) && nc&drop and continue
                    $a = Na[i]
                    if (!a) {
                        # start a row
                        a = {}
                        $agka = q.agk && n.sc[q.agk]
                        if (agka) {
                            # branch ish eg %%sustain
                            ex(a,agka)
                            a.a = agka
                        }
                        ex(a,{n})
                        if (!a.done) {
                            # < must have: sense of how to be done() with it
                            #  removes N/$n
                            !isC(n) and a.done = grepout(N,{is:n})
                            else
                            #  dropping the row
                            #   is how &sustain works underneath
                            #    < with hooks
                            # < stretch from sustain source downstream to refractions
                            #    it may read self|other args
                            #     for whatever out-there is doing with its ...
                            #   ||= here allows later processes to cancel earlier
                            #    up until a %%sustain redoes a.done() for its $n
                            # non-R can use yfuture
                            #  these may have got it by being %%rec-copied to a future
                            # < other wires. this is a short wire, anyway.!
                            ny&brack and a.done = () => ahk(me&yfuture,n ,'c','drop',1)
                            #else throw "how to el9",n,c,q
                        }
                        Na[i] = a
                    }
                    # a.* = n%* in &rowcap c.*
                    $args = grep(map(k => a[k] = n.sc[k], haks(c)))
                    !hak(args) and args = [n]
                    $s = args[0]
                    !s and throw "row!such", c, n
                    # piling into each %%active id
                    #  the $el=2 repeating $m per ty
                    me&boxcap,dis(s,2),'3y',2 (&ml{
                        # should be one row l
                        ls&dis = 4
                        # < checking for multiple-same-named s.t
                        # for a phase of its activation-think
                        me&boxcap,t,'4b' (&ml{
                            # column l, moves to head/l
                            me&fiu,m,l,9
                            me&fiu,head,l
                            ls&dis = 4
                            # ensure something, so &boxcap doesnt c&not
                            $space = me&tc,'space'
                            delete spacec&s
                            y(...args,m,a,l,a.a)
                        })
                    })
                }
                Tap()
            }
        }
  
 // capsulating, &Mwcap
    # captures modulat around y(m...)
    me.abTap = &acgttm{
        $R = me&R

        $Tap = me&Tap,{ab:m}
        # listen for &tc
        $capture = me&Mwcap,R,t
        # allow m/m (sees a/m) to stream before inner &boxcap
        $Mwcap = me&Tap,{Mwcap:&{capture(m,'partial')}}

        return &y{
            y and y(m)
            Tap()
            # without 'partial' sets T.Mw=was
            capture(m)
            Mwcap()
            return m
        }
    }
    # transact ~T.*
    me.Tap = &acgtc{
        $was = sex({},T,c)
        ex(T,c)
        return &{
            ex(T,was)
            haks(c).map(&k{
                !hak(was,k) and delete T[k]
            })
        }
    }
    # capture modulat (of &tc, x.ro, etc) into $m
    me.Mwcap = &acgtRkm{
        $was = T.Mw
        T.Mw = k
        return &y,partial{
            !partial and T.Mw = was
            !Rs&Mw and return
            $N = delete Rs&Mw[k]
            !hak(N) and return
            y and m = isfu(y) ? y () : y
            !m && !y and debugger
            !m and return
            each in N {
                # the old &n->modulat->R trick: 'n error  $s:er,R %Error'
                nc&R and debugger
                nc&R and ac(R,'M',z)
                else ac(m,'z',n)
            }
        }
    }
  
 // main
   
   # < oos: grammar, compiletypes
   # < drink NutGravy. see `a '(dow|self)\.is'`
   // types
    # C in R%ball|bell
    #  normal for R'Peace'|'The'
    #   Peace time is most of 2020, W:Thingo:
    #    getting Travel|Gnome, Fish late, then halting for:
    #   2021 beginning with &X_necessary, 'spec The'
    self.isba = j => isR(j) && (js&ball || js&bell)
    self.isbo = s => typeof s == 'boolean'
    # string
    self.iskeyish =
    self.iske = k => typeof k == 'string' || typeof k == 'number'
    # stringy nothing
    $spacechars = {" ":1,"\n":1,"\t":1}
    self.isspace = s => hak(s) && !havs(s).some(s => !spacechars[s])
    # numbery, mostly as s*1 == s (not ' '*1 == ' ')
    self.isnum =
    self.num = s => (isnu(s) || s && s.length && !isspace(s)) && s*1 == s
    
    # housey, indexey {}|[], eg a random c (see %%sustain)
    self.ish =
    self.isho = v => isha(v) && !isC(v)
    # itemic
    self.isitemic =
    self.isit = v => !isha(v) || isC(v)
    # -suchpi
    self.ispi = (v,pi) => isC(v) && (!pi ? vc&pi : vc&pi == pi)
    
    # make lots of fatal versions of isba(), etc
    # < put it through me.Yingminds?
    self.fatal = {}
    fatal.refresh = &{
        # < o self/ ~~^is # left on an upswing, s=/$k
        #   where via group by $k ~~ /^is/
        #    and then not grouping anyway
        #    as no thing is tgere
        haks(self)
            .filter(k => k.startsWith('is'))
        # < i fatal/$k = &{ !self[k] && die }
        #    Babz it into die(capturing etc)
        #     has to be die for "try not to die", "it's trad to die"
            .map(k => fatal[k] = &s{
                $v = self[k](...arguments)
                !v and throw "!"+k, s
                return s
            })
    }
    fatal.refresh()
    G&yl:0.04,&{ fatal.refresh() }
   # < iot(s,c,q) with callbacks, see 'where via group by'
   // access types
    # see also Index / common nodal
    # see also Jay / &withR, &withA, etc
    
    # C|R|E|D -> Ec&s
    #  ie looser sof(), still must isC()
    self.csof = &j{
        # out of D?
        j = jy&E || j
        # to R
        j = Aof(j)
        fatal.isC(jc&s)
        return jc&s
    }
    # climb into a R//s, the usu sphere change
    self.sof = &j{
        # < any Cish? have to not disappear inside
        !isR(j) and return j
        # things that have
        fatal.isba(j)
        fatal.isC(jc&s)
        return jc&s
    }
    fatal.sof = &j{
        $s = sof(j)
        s == j and throw "j==sof(j)",j
        return s
    }
    # < slope y&up and...?
    self.Aof = &sk{
        $r = sy&R
        fatal.isR(r)
        # for s//R//$k=C
        # < deprecate this. breaks map(Aof,...)
        k and return r.sc[k]
        return r
    }
    # climb over a usu separation (&clonover, &copi, etc)
    #  where multiple C over dimensions, most grabable.
    self.Cof = s => s && (sy&C || sy&Outs) || s
    # o s//R//E
    me.REof = &acgts{
        $r = me&yfuture,s
        $e = rs&E
        !e and throw "!RE",s
        return e
    }
    # s// means the main E inside the RE on s
    me.Eof = &acgts{
        !isnode(s) and debugger
        # s-Log// (sy&R%E)
        $RE = me&REof,s
        !REc&pi || REc&pi != sc&pi and debugger
        # /-Log
        # < REy&main isnt there til later
        $E = me&Risc,RE,'-'+REc&pi
        return E
    }
    
   // access many
    # &ioty with easier s//R for any %scgk, tends to R//s
    # < leg the s//R, see &Sharg sound.
    me.iot = &acgtscg{
        # Such c is forming
        g ||= {}
        c.startsWith('%') and s = sy&R || s; c = c.substr(1)
        else
        c.startsWith('-') and g.suchpi = c.substr(1); c = ''
        else {
            $t = c; c = ''
        }
        # g$N - g buys N

        $N = me&ioty,s,c,t
        # < gs.* can identify, clue how it should be elsewhere
        g.suchpi and grepout(N,n => nc&pi != g.suchpi)
        $fromr = isR(s)
        each in N {
            if (fromr) {
                !isR(n) and ~>4 n-in-r: s.t, '/', n.t
                n = N[i] = sof(n)
            }
        }
        return N
    }
    # storage on sy&$t via h.i|o(k+,v?)
    me.yio = &acgtst{
        # y&tt/...:lovely/...:expr
        $lovely = [...arguments].slice(6)
        $auf = &{
            $expr = [...arguments]
            $io = expr.shift()
            # transpose instruction to accum|count
            isar(expr[0]) and $y = ['y']; expr[0] = expr[0][0]
            # just h.i('such') -> such:1
            io == 'i' && hak(expr) == 1 and expr.push(1)
            return [s,y||'y',t,...lovely,...expr]
        }
        return {
            i: &{ return ahk(...auf('i',...arguments)) },
            o: &{ return ahsk(...auf('o',...arguments)) },
        }
    }
    
   // access ^^
    # &complace -> &Thisplanet...
    # involves this climby visitor in &com:
    me.Ay = &acgtvsc{
        return &y{
        # v = $A
        # s = ^^..1^^
        # c = matches, eg c&complace. no callback if not.
        c = peel(c)
        c.c and c.c = peel(c.c)
        
        # state
        $g = {d:0,visit:[],climb:[]}
        # and parsed expr:s
        # climbing particles once A.1 is reached (^^..1)
        s == '^^..1^^' and g.partat = 1
        else '^^'
        # visit $v first, ie $v^^ not $v/^^
        g.fromhere = 1
        
        $z = v
        while (1) {
            g.d++ > 10 and throw "oup"
            $skip = 0
            fatal.isC(z)
            $visit_first = g.d == 1 && g.fromhere
            if (!visit_first) {
                $up = zy&up
                # < extra ways up via y&R, etc
                !up and break
                up == z and g.loopy = 1; break
                if (g.party) {
                    !up.1 and debugger
                    # after climbing A.up, visiting all until A==A.1
                    # skip til next A with .1=A
                    #  this is the A.1=A hack, see J
                    # < g.partat = 3, for A^^..3, then all 3s, 4
                    #    might need g.party=z...
                    # < same for Cy&1-4?
                    up.1 != up and skip = 1

                    # nothing here about .2, which has this same sense
                    # .2 to the .1 above our .1
                    # .3 to itself, less often than .1
                    # .4 to itself, avoid beyond
                    up.4 == up and g.not = '>4'
                }
                g.la = z
                z = up
                # < g.N all inclusive
                ahk(g,['climb'],z)
            }
            
            # start climbing particles
            g.partat && z[g.partat] == z and g.party = 1
            # matching any
            c.c && !hak(sex({},z.c,c.c)) and skip = 1
            skip and continue
            ahk(g,['visit'],z)
            # visit
            $ret = y (z,g)
            ret and ahk(g,['yes'],z)
            g.not and break
        }
        return g
        }
    }
    me.Ayu = &acgtvsc{
        s ||= '^^'
        $p
        me&Ay,v,s,c (&sd{
            p = s
            d.not = 'Ayu'
        })
        return p
    }
        
  // misc() array
    # slices hash-keys|array by key|value|matcher:
    #  c = {aft: 'akey'|v|v=>1 } | 'akey'
    #  returns
    #   slices of arrays
    #   arrays of keys of hashes
    # note num()-able hash keys all come in order first,
    #  otherwise in order of appearance
    self.ksaf = &sc{
        $keys = haks(s)
        # < default to !inc the match?
        # < variations for
        !isob(c) and c = {aft:c,inc:1}
        $it = c.aft||c.bow
        if (iskeyish(it)){
            $ki = (isar(s) ? s : keys).indexOf(it)
        }
        else {
            # slice by value
            $ki = -1
            each ik keys {
                $v = s [k]
                !(isfu(it) ? it(v,k,i) : v == it) and continue
                ki = i*1
                break
            }
        }
        if (ki < 0) {
            # not found
            !c.may and throw "no ksaf",c
            $N = keys.slice()
        }
        else {
            # slice arg2 is first one not to include
            # splice arg2 is length of selection
            $N = keys.slice(... c.aft ? [ki+1] : [0,ki])
        }
        # may include the point, usu just what's behind it
        c.inc and c.aft ? N.unshift(keys[ki]) : N.push(keys[ki])
        # c.near for closest to ki first (reverse the bow)
        c.aft ? c.rev : c.near && !c.rev and N.reverse()
        isar(s) and N = N.map(k => s [k])
        return N
    }
    # ! (s)ubject is passed in from the right, as perl does
    # < Babz in as perl does
    #   expr like 'grep {...} grep {...} N' need a lot of magic?
    #   and /such/, and ../such/ like ksaf() til
    #    not requiring Babz?
    #   and to prefix '_ =>' onto c expr: !_c&recycled
    #    as in perl $_ (not as bare expr, in c=BLOCK)
    # < for c='string' s=[C+], find C%string
    #  < and more... io Babz makes c={ifs,climb,select,etc}
    self.grep = &cs{
        # no function greps for true
        #  see also nex(), for not-null
        arguments.length == 1 and s = c; c = {y:v => v}
        else
        # function
        isfu(c) and c = {y:c}
        else
        # item: usu C to look for in /$n
        isit(c) and c = {is:c}
        else
        isar(c) and c = {in:c}
        hak(c,'is') and c.y = v => v == c.is
        hak(c,'in') and c.y = v => c.in.includes(v)
        isfu(s) and throw "iterating? it's grep(y,N)"
        
        $array = isar(s)
        $o = array ? [] : {}
        each kv s {
            !c.y (v,k,o,s) and continue
            array and o.push(v)
            else o[k] = v
        }
        return o
    }
    # false if empty, like &za
    self.grap = &cs{
        $N = grep(c,s)
        return hak(N) && N
    }
    self.grop = (c,s) => grepout(s,c)
    # removing .filter, y=[n+]|&n{1}|$n
    window.grepout = &Ny{
        $out = []
        # < expets is|includes
        isar(y)     and $Z = y;    y = n => Z.includes(n)
        hak(y,'is') and $v = y.is; y = n => n == y.is
        !isfu(y)    and $v = y;    y = n => n == v
        each in N {
            i *= 1
            y (n,i) and out.unshift(i)
        }
        return out.map(i => N.splice(i,1)[0]).reverse()
    }
    # [1,1,2] = flatten([1,[1,2]])
    window.flatten = &M{
        !isar(M) and throw "flatten!ar"
        $N = []
        each il M {
            l == null and continue
            isar(l) and N.push(...l)
            else N.push(l)
        }
        return N
    }
    
    # revisit &fabioty
    
    # map, [] or {}, waves of y(v,k)
    self.map = &N{
        $args = [...arguments]
        $N = args.pop()
        $array = isar(N)
        $waves = [N]
        args.reverse().map(&y{
            $N = waves.slice(-1)[0]
            $neu = array ? [] : {}
            waves.push(neu)
            each in N {
                array and i *= 1
                neu[i] = y (n,i)
            }
        })
        return waves.slice(-1)[0]
    }
    # returning [v+]
    self.armap = &{
        $s = map(...arguments)
        return isar(s) ? s : havs(s)
    }
    # replacing map()
    #  N changes in place (and returns)
    # < undef == y() deletes it?
    self.rap = &N{
        $args = [...arguments]
        $N = args.pop()
        $array = isar(N)
        args.reverse().map(&y{
            $M = []
            each in N {
                array and i *= 1
                M.push(y (n,i))
            }
            each in N {
                N[i] = M.shift()
            }
        })
        return N
    }
    # randomize array
    # < pick many, randomly
    self.shuffle = &a{
        var j, x, i;
        for (i = a.length - 1; i > 0; i--) {
            j = Math.floor(Math.random() * (i + 1));
            x = a[i];
            a[i] = a[j];
            a[j] = x;
        }
        return a;
    }
  // misc() array many
    # array from iterable: [s] = y.i=s|[s+]|&{}|[]
    #  for &sustrain y.i
    #   where you want one-or-list, possibly from callback
    self.fuN = &s{
        # < args?
        isfu(s) and s = s (...[...arguments].slice(1))
        !s and s = []
        !isar(s) and s = [s]
        return s
    }
    # figures if N = N or N[0] is the intended array to use
    #  for eg N=[...arguments] for aroint()
    # < there are a bunch of arguments parsing things
    #   eg C|A:n, C t can be given C,
    #    which is should clone if no further args
    #    other args become t?,y,c,sc of an elvis upon given C
    # < can '() => ...' functions access the callers arguments?
    #   for aroint() to take less code
    #  < multiplex a bunch to parse things out. eg sum(y?,N|...N)
    #   < arguments are silly though, modern life is params
    self.flatorray = &N{
        return hak(N) == 1 && isar(N[0]) ? N[0] : N
    }
    # add numbers sum(f?,N)
    # < compile out the optional leading arg uglies
    self.sum = &{
        $args = [...arguments]
        $whatfor = isfu(args[0]) && args.shift()
        # sum(a,b,c...) or sum([a,b,c])
        $N = flatorray(args)
        $total = 0
        each in N {
            whatfor and n = whatfor(n)
            num(n) and total += n*1
        }
        return total
    }
    # perl split()
    #  except it's how many $times to match (from 1)
    self.split = &s,by,times{
        $N = s.split(defor(by,' '))
        if (times && hak(N) > times) {
            N = [
                ... N.slice(0,times),
                N.slice(times).join(by)
            ]
        }
        return N
    }
  // misc() array string
    # ghostily, the way to w:Text from w:Pictures
    # < types for weird sorts of compression!!
    #   for eg W.t storable (filename sanity)
    
    # "$k:v(.t)" separated by " ", only C|string from c, eg a
    # < no numbers? not c.el? see &sustain etc
    # used for Eight.t by &complace
    self.idint = &c{
        $idc = grep(v => iske(v) || isC(v), c)
        !hak(idc) and throw "no idint"
        return spant( armap((v,k) => cint([k,v]), idc) )
    }
    
   # simply joining by something, possibly with C.t
    self.cint = &{ return aroint([...arguments],':') }
    self.daint = &{ return aroint([...arguments],'-') }
    # < dis() that goes peel:1 if big
    #    or value types could be separators, as in R%Cit
    self.coint = &{ return aroint([...arguments],',') }
    self.slant = &{ return aroint([...arguments],'/') }
    self.spant = &{ return aroint([...arguments],' ') }
    # allows the above to be eg cint(i,t) or cint([i,t])
    self.aroint  = (N,k) => joint((hak(N) == 1 && isar(N[0]) ? N[0] : N),k)
    # "$t1-$t2" for [C,C,C{.t==not}]
    # < not used once in a year in weird times (&pilegs)
    #   path making (from climbing) shall where itself by now
    window.joint = &N,join,not{
        # ioty may N=C/*
        $M = (isC(N) ? me&ioty,N : N||[]) .map(n => isC(n) ? n.t : n)
            .filter(t => t != null && (not == null || t != not))
        $s = M.shift()
        join ||= '-'
        each in M {
            # leading joiner-ish thing
            (n+'').startsWith('<'+join) and s += n
            else { s += join+n }
        }
        return s
    }
  // misc() access
    # defor wanting true, != 1
    self.notoneor = &{
        each is arguments {
            !(s == null || !s || s == 1) and return s
        }
        throw "nothing not-1"
    }
    # defined-or: s //= 1, s=0 stays 0
    window.defor = &{
        each is arguments {
            s != null and return s
        }
        throw "nothing definite"
    }
    # y(v,k) for s
    window.hav = &sy{
        return haks(s).map(k => y(s[k],k))
    }
    # see perl's values()
    self.havs = &s{
        return haks(s).map(k => s [k])
    }
    self.dis = &sc{
        # light over slope
        c ||= 4.23
        isnu(c) and c = {dl:c}
        if (c.dl == 2 && isC(s)) {
            # C:Thing@2 used for &rowcap PK
            $cv = sy&cv && sy&cv != 0.1 ? '@'+cvf(sy&cv) : ''
            $sym = isnode(s) ? 'n:' : 'C:'
            return sym+s.t+cv
        }
        return ki(s,c.dl)
    }
  // misc() hash
    # hash stash, on t.sc[k] or so if C:t
    # < cant handle only k:v
    self.ahk = &tk{
        !isob(t) and throw "!ob"
        # might accum into array at the end if k=[$k]
        $M = [... arguments].slice(2)
        isar(k) and $listend = 1; k = k[0]
        # into .sc.$k...@$M
        if (isC(t)) {
            $nk = 'sc'
            # or in .c|y (making .sc.c... impossible)
            k == 'c' || k == 'y' and nk = k; k = M.shift()
            $h = t[nk]
        }
        else {
            $h = t
        }
        M.unshift(k)
        while (M.length) {
            k = M.shift()
            k == null and debugger
            M.length > 1 and h = h[k] ||= {}
            else {
                $re = h[k]
                if (listend) {
                    $n = M.shift()
                    if (n == 1) {
                        # counter
                        h[k] ||= 0
                        $N = ++h[k]
                        !isnu(N) and throw "listend!num"
                    }
                    else {
                        $N = h[k] ||= []
                        !isar(N) and throw "listend!ar"
                        !N.includes(n) and N.push(n)
                    }
                    return N
                }
                else {
                    !M.length and debugger
                    $v = M.shift()
                    # empty hash at the end ensures+returns hash
                    if (isha(v) && !hak(v)) {
                        h[k] && (!isha(h[k]) || isC(h[k])) and throw "!{}||={}"
                        re = h[k] ||= {}
                    }
                    else {
                        h[k] = v
                    }
                    return re
                }
            }
        }
    };
    # some of the smallest structures
    # reversibly|diffily, create transform theory
    # phenom comes in waves
    # waves have a skin
    # skins relate posture
    # < for even ...arguments, like perl's {@kvs}
    window.hashkv = &kv{
        $args = [...arguments]
        if (args.length == 1) {
            $first = args[0]
            # hashkv('it') -> {it:1}
            !isar(first) and args.push(1)
            else {
                # hashkv([[nc&sip,n]+]) -> {'0 1 2':n}
                #  !N.length -> {}
                $array = isar(first[0])
                # hashkv(['it','es']) -> {it:1,es:1}
                args = []
                each in first {
                    args.push(array ? n[0] : n)
                    args.push(array ? n[1] : 1)
                }
            }
        }
        $c = null
        while (args.length) {
            $k = args.shift()
            c && args.length < 1 and throw "odd hashkv"
            $v = args.shift()
            c ||= {}
            !iskeyish(k) and debugger
            c[k] = v 
        }
        return c || {}
    }
  
  // more type, cv
    # see also dec()
    # print 0.123 as 123, !cv-fatal
    #  see unfatal: cvf(), opposite: scv() (or sca()==scaf())
    # convention of translating, from cv to s
    #  eg cv|s format is 0.1|1, as $C|Lines would say
    self.numf =
    self.cvs = &s{
        !(s >= 0 && s <= 1) and throw "numf!cv"
        return (s+'').substr(2)
    }
    # 0.33 = scv(33), with floating points (gets floaty at precision=17)
    # < collect cv type functions, eg is opposite of numf(0.33)
    self.scv = &ov,{
        return dec(sca(ov),15)
    }
    # various cv compares
    #  c.* may contain more eg see &modselect
    self.gteqcv = &vc{
        v ||= 0
        return (c.gte == null || v >= scv(c.gte))
             && (c.lte == null || v <= scv(c.lte))
             && (c.gt == null || v > scv(c.gt))
             && (c.lt == null || v < scv(c.lt))
             && (c.cv == null || v == scv(c.cv))
    }
    # good for: cvlt(R%boost,3) and return
    self.cvlt = (s,c) => gteqcv(s,{lt:c})
    
    # < vague. for sz(c.ov,2) and return
    #    turn into: sz(c,'ov') (2)+
    #     could t='ycv', or t={io expr} to tug measures
    #      of what it wants to think about against this number
    #    is a paradigm of osc access
    # (qua||0) < 2 and leave
    # sizes something, usu ope|interest for snoozing
    self.lt = &lt{
        t > 1 and t = '0.'+t
        return sz(l,t)
    }
    self.sz = &ns{
        isob(n) and throw "pass value||null"
        return (n || 0) < s
    }
    
    # 's' -> 'sc'
    self.isnk = &k{
        !(k == 'y' || k == 'c' || k == 's') and return
        k == 's' and k = 'sc'
        return k
    }
    # 'sthing' -> ['sc','thing']
    #  could go further into subframe if !string?
    self.splitnkgk = &s{
        $k = isnk(s [0])
        return k ? [k,s.substr(1)] : [s]
    }

  // peel(), arq()
    # hash from 'k:v' or , v=1 if not given
    #  < nestings of the : and , separators
    window.peel = &s,sep,kep{
        s == null || s == '' and return {}
        # < peel token might include [keys], maybe json
        isar(s) and return hashkv(s.map(k => [k,1]))
        # clones supplied hash
        #  this is not for eg &uptonode c arg
        #   allows giving a c to read details from after
        isha(s) and return ex({},s)
        
        if (isst(s)) {
            # shortcut?
            sep ||= ','
            kep ||= ':'
            if (!peelish(s,sep,kep)) {
                return hashkv(s)
            } 
            # < sep|kep?
            # < rebuild for k:that:go:deeply,
            #   or that@link to indentedchunk later
            #    or link object anywhere, if A:L..A:peel
            #    < rebuild a subset of yaml mostly,
            return G&peel,s
        }
        throw "not peely", s
    }
    # 'k:v' from hash
    self.depeel = &s{
        return G&depeel,s
    }
    # null-fatal peel
    window.peli = &l{
        !(isst(l) || isar(l) || isha(l)) and throw "!peli", l
        return peel(l)
    }
    # looks like something to peel,
    #  supposing it will always be 
    window.peelish = &s,sep,kep{
        sep ||= ','
        kep ||= ':'
        return isst(s) && (s.includes(sep) || s.includes(kep))
    }
    # departmentalise c if not already
    #  for s sublating its namespace
    # q.K=1:        c=v -> s.K=v
    # q.K=gk:  c(.K)?=v -> s.K.k=v
    # is basically:
    #  !q.qk and q = {qk:q}
    # q.peely>0: peel(v) if it needs to be housey
    #  not if v is going for c.label.s
    #  
    # smallest totality?
    #  people fall in a ditch that triangle will not fix
    window.arq = &cq{
        $origin = c
        # c fated to mix into s.$K, not s
        #  unless it knows any of these $k
        !q.qk and throw "index"
        # < without any q.qk? does to_housey(c.*.*)
        $qk = haks(q.qk)
        # the default department first
        $K = qk[0]
        $gk = q.qk[K]
        # how c and any c.K should end up
        $housey = isho
        # v must be beyond housey (index)
        $itemic = isit
        
        # try to leave c(.*)? housey
        # may not be possible, if v=C and no more qk
        # eg &Cye solving c="La":
        #   expe() peely=1: -> c={La:1}
        #  + qk.s=1:
        #   exts() peely=0: -> c={s:"La"}
        #   expe() peely=1: -> c={s:{La:1}}
        # more eg below
        $to_housey = &vd{
            # not c if peely=0
            # even c.*.* if peely=2
            !(q.peely && q.peely >= (d||0)) and return v
            return v == null ? null : peel(v)
        }
        if (itemic(c)) {
            # 2-house: c.label.s may be itemic
            # c=C -> c.s=C, then -> c.label.s=C
            gk != 1 and c = hashkv(gk,c)
            else {
                # 1-house: c should be housey
                # c=C -> c.label=C
                # c="st" -> c.label=(peely ? {st:1} : "st")
                c = to_housey(c)
                if (itemic(c)) {
                    # was peely=0, or C passed through peel()
                    # put as default department
                    K != null and c = hashkv(K,c)
                }
                else {
                    # now may have deparments:
                }
            }
        }
        if (housey(c)) {
            # for any department, or the default
            $match = qk.filter(K => hak(c,K))
            if (!hak(match)) {
                # nothing we know about
                #  (that we should try to make housey)
                # c.s:C -> c.label.s=C
                c = gk == 1 ? c : hashkv(gk,c)
                c = hashkv(K,c)
            }
            else {
                each iK match {
                    $v = c[K]
                    $gk = q.qk[K]
                    # leave c.label={...}
                    # < or whatever we want there
                    housey(v) and continue
                    # 2-house: v may be itemic
                    # c.label=C -> c.label.s=C
                    gk != 1 and v = hashkv(gk,v)
                    else {
                        # 1-house: c.label should be housey
                        # c.label="st" -> c.label=(peely ? {st:1} : "st")
                        v = to_housey(v)
                        # may still be itemic if !peely, eg:
                        # c.label=C -> c.label.C (unhousable)
                        isC(v) and throw "c."+K+"=C !",c,v
                    }
                    # < when|how v not housey (domesticate it)
                    isC(v) and throw "c."+K+"=C !",c,v
                    !isha(v) and throw "c."+K+"!housey",c,v
                    v == c[K] and continue
                    # preserves the c passed in
                    c == origin and c = ex({},c)
                    c[K] = v
                }
            }
        }
        else {
            throw "type",c
        }
        if (q.peely == 2) {
            # < c.label.s housey or fatal?
            throw "each qkv c"
        }
        return c
    }
  // ex*()
    self.ex = &sc{
        !s || typeof s != 'object' and throw "ex!s"
        !c || typeof c != 'object' and throw "ex!c"
        each kv c {
            s [k] = v
        }
        # ex(s,c+)
        arguments[2] && [...arguments].slice(2).map(c => ex(s,c))
        return s
    }
    # ex with array merge
    #  eg s|c.via=[one|two] -> s.via=[one,two]
    self.mex = &scq{
        q ||= {}
        if (q.ek) {
            # fatal to want change
        }
        c = exable(c,s)
        return ex(s,c)
    }
    # selective extend
    window.sex = &scqe{
        # < Babz for parsing arguments
        e == 1 and $y = k => c[k] && 1
        q = peli(q)
        each kv q {
            hak(c,k) && (!y || y(k)) and s [k] = c[k]
        }
        return s
    }
    # selectively not extending
    #  nex(c,s,c) extends what isnt in c.* yet
    self.nex = &scq{
        q = peli(q)
        each kv c {
            hak(q,k) and continue
            s [k] = v
        }
        return s
    }
    # text only
    self.tex = &sc{
        each kv c {
            iskeyish(v) and s [k] = c[k]
        }
        return s
    }
    # defined only
    self.dex = &sc{
        each kv c {
            v != null and s [k] = c[k]
        }
        return s
    }
    # selective ex, taking out (unless $k:0)
    #  as in consuming arguments from a c
    window.tax = &s,c,take{
        !c and return s
        !isha(s) and throw "tax s?",s
        !isha(c) and throw "tax c?",c
        take = peli(take)
        each k,remove take {
            !hak(c,k) and continue
            remove and s[k] = delete c[k]
            else { s[k] = c[k] }
        }
        return s
    }
    # < generating type loosen|tighten from pex = p + ex
    window.pex = &sc{
        s = isha(s) ? s : peel(s)
        return ex(s,peel(c))
    }
    # merge s.* if hash|array
    window.ex2 = &scq{
        c = peel(c)
        q ||= {}
        isC(s)||isC(c) and throw "expe..C"
        each kv c {
            $V = s [k]
            if (isar(v) || isar(V)) {
                # both must already be array
                !(isar(v) || isar(V)) and throw "ex2!botharray",k,c,s
                # < merging how. see resolve $n
                V = q.merger ? q.merger(k,V,v)
                    : [...V, ...v]
            }
            elsif (V && isha(V) || v && isha(v)) {
                # allows either to peel, usu 1 -> {}
                isst(V) && isha(v) and V = peel(V)
                isst(v) && isha(V) and v = peel(v)
                #  replace 1->{}
                V = exable(V)
                #  and|or premix arrays in v.*
                v = exable(v,V)
                # mixing v into V
                ex(V,v)
            }
            else {
                # replacing
                V = v
            }
            s [k] = V
        }
        return s
    }
    # will it ex()
    # s = one argument to ex() at a time
    # returns s or a coercion to replace it:
    #  s=null|1 -> {} coercion
    #  s.* and c.* array pre-mixing
    window.exable = &s,c,fatal{
        # returns coercions or false
        !s and return {}
        s == 1 and return {}
        isar(s) and throw "what?"
        if (!isha(s)) {
            fatal and throw "!exable",s,c
            return 0
        }
        # < Cy&sortin patch-conforming c, putting el:8 etc
        #   exable(c,s) becomes lv(s,c)
        #   ex(s,c) becomes el(s,c)
        isC(s) and throw "exC"
        if (c) {
            # premix arrays
            # c,s are the s,c from ex(s,c)! upside down.
            #  here, s merges into c
            #  because we can replace s
            #    as returning a coercion
            #   with a copy with pre-mixed arrays
            # < does it uniq, or have:
            #    a sort-in function on s.* or isC(V)?
            #   if k=ref, has to renumber or create subnet
            s = ex({},s)
            each kv s {
                $V = c[k]
                (!v || !isar(v)) && (!V || !isar(V)) and continue
                # < coerce V==0 -> []?
                V && isar(v) && !isar(V) and throw "ex not<-array"
                v && isar(V) && !isar(v) and throw "ex array<-not"
                s[k] = [...(V||[]), ...(v||[])]
            }
        }
        return s
    }
  // arq()-based
    # may peel non-c.$name looking isst(c) 
    # < peeled into s, not into s.$K
    #   if c.$K is present+string, into c.$K.$k (string)
    # < don't want to have to specify Xo to stay out of it
    #$c = expets({Xo:{pic:2}},'vee:3,figures:2,Xo:3','Xo:Xu')
    # < should see assume t is t
    #$c = expets({Xo:{pic:2}},'t:sno','Xo:t')
    # < not .Vil.Vil='vee'
    #$c = expe({Xo:{pic:2}},'vee','Xo:Vil')
    window.expets = &scqk{
        isst(c) && peelish(c) and c = peel(c)
        return exts(s,c,q,k)
    }
    # s=k:v hash copy after arq()
    #  c can stay string if ^ takes it beyond c.*.*
    # v merges if both hash
    # s|c being C is fatal
    #  < could have something on it?
    # v not being hash is fatal
    #   which is where exts() would give it a key
    #   unless v=1,
    #    logically compatible with v={...}
    window.expe = &scq{
        # ensure c is a hash
        $origin = c
        if (q) {
            # get a list of words
            q = peel(q)
            # arq() is basically:
            !q.qk and q = {qk:q}
            # may departmentalise c, peel c.label
            q.peely = defor(q.peely,1)
            c = arq(c,q)
        }
        return ex2(s,c)
    }
    # s=K.k:v hash copy
    # with q, c may be (already)? departmentalised
    # s.label = "st", c.label = {...} is fatal
    #  in reverse however, s will .label:{...,s:"st"}
    # c="st" or c=K/"st" may -> s=K/"s":"st"
    #  if q.es[K] (not peeled?)
    # eg la:{ya:2} + la:three -> la:{ya:2,s:three} (K="la")
    window.exts = &scqk{
        if (k) {
            # specifying a pair: c.$label.$s = 'the label'
            !isst(q) and throw "q+k"
            q = {qk:hashkv(q,k)}
        }
        else {
            # get a list of words
            q = peel(q)
            !q.qk and q = {qk:q}
            # with a default gk='s'
            $qk = haks(q.qk)
            hak(qk) == 1 && q.qk[qk[0]] == 1 and q.qk[qk[0]] = 's'
            # dont peel c(.label)?="string"
            q.peely = 0
        }
        return expe(s,c,q)
    }
    # hash copy up to a certain key
    window.extil = &scq{
        # < expe q, and q=CODE -> q.cb
        each kv c {
            k == q and break
            s [k] = v
        }
        return s
    }
   
  // &Api, -surrect
    # create a -pi on a node
    me.Api = &acgtstc{
        !isst(t) and throw "which -pi"
        # takes c.t,el (< etc) into a new c
        #  leaving the &pi* with c.ov, etc
        c = tax({},c,'t,el')
        c.el ||= 2
        $b = s.y [t]
        if (!b || c.el <3) {
            $E = s.y [t] = Cye([defor(c.t,s.t),1,{pi:t}])
            Es&z = []
        }
        else {
            E = b
        }
        c.el > 1 and 'times'
        Ey&up ||= s
        # see fi&piinto, perhaps same pi wants to replace?
        $p = sy&up
        !(p && py&ers) && Ey&up != s && Ey&up.c.pi == sc&pi and debugger
        return E
    }
    # s%node remembers ...z b by &pipath
    #  to b el:3 inside a z el:2
    # < to hang b on s^^%higherground
    me.pisurrect = &acgtRzc{
        # the $pi we are about to do, Api c.t
        isst(c) and c = {t:c}
        c ||= {}
        !c.t and throw "b!c.t=$pi"
        # < dubious :
        #  < pi we are about to make is called c.thispi
        
        # via ^^nodey&surrect, for existing z
        $s = me&uptonode,z,c
        $re = me&Api,s,'surrect',{el:3}
        
        # any ($t-$pi/)+ || ""
        $tpith = c.tpith = me&pipath,z,c
        # may just be /-$pi if isnode(z)
        tpith += '/-'+c.t
        $ber = me&fiu,re,tpith,8
        
        # put so &Api will b it
        ber and z.y [c.t] = berc&s
        # remember what it is once created
        return &b{
            c.s = b
            $ber = me&fiu,re,tpith,1
            ber.c = c
        }
    }
  // climb pi
    # see fi&getpi
    # s(y&brackology)?y&ology
    me.yology = &acgts{
        $z = sc&pi == 'brackology' ? s : sy&brackology
        !z and throw "no-brackology"
        $x = z && zy&ology
        !x and throw "no-ology"
        return x
    }
    # s^^^y&R
    me.uptoR = &acgts{
        $z = me.cbu(s,&z{
            # skip RE to s** from E** (which sy&E = zy&Ey&up across s**)            
            zy&ers and z = zy&ers
            return zy&path && zy&R
        })
        !z and debugger
        return zy&R
    }
    # s^^^node
    me.uptonode = &acgtsc{
        c ||= {}
        c.beyond ||= []
        $node
        me.cbu(s,&z{
            # skip RE to s** from E** (which sy&E = zy&Ey&up across s**)            
            zy&ers and z = zy&ers
            # < demand zy&path, yet we want $seven which isn't a node
            zy&path && zy&R && zy&R.c.s == z and return node = z
            c.beyond.unshift(z)
        })
        !node and debugger
        c.path = nodey&path.slice()
        c.node = node
        return node
    }
    # c.non[pi+] path, off the end of c.path[node+]
    me.pipath = &acgtsc{
        c ||= {}
        !c.beyond and me&uptonode,s,c
        $s = c.path.slice(-1)[0]
        $eg = c.beyond.map(z => me&pitorpi,s,z ).join('/')
        #~>8 apipath: eg
        return eg
    }
    # says t+pi compressily
    #  pi sometimes have another t, usu same as last node
    me.pitorpi = &acgtsz{
        # < use hakd() to make {t?,pi?}
        $t = z.t
        $pi = zc&pi && zc&pi != sc&pi
        zc&pi && '-'+zc&pi == z.t and pi = zc&pi; t = ''
        else {
            pi && z.t == s.t
        }
        pi and pi = '-'+pi
        else pi = ''
        return t + pi
    }
   
 // process pi
   
   // -piling c&M[$pi+] to complete all pi around here
    # draws drawings together as plans to complete them
    # find all -pi for s, generating a poc&M to be Yc&M
    me.piling = &acgtRsc{
        $po = me&Api,s,'ling',c
        # searches s for sy&somethingc&pi,
        #  eg s=$fo=-four, finds $D, $br
        $M = []
        $api = v => v && v.c && v.c.pi && M.push(v)
        # perl: api(v) for values %{s.y}
        hav(s.y, v => api(v))
        # and eg $fo/$leg+
        sc&pi && me&ioty,s .map(v => api(v))
        
        
        
        
        
        poc&M = arou(uniq(M),v=>v!=po)
        return po
    }
   
   // &sopi - work on a pi as self or other
    # eg R:seven (self) does -seven cv < 6,
    #   Displaying it through R:seven
    #  R:eight (other) carrying on with non-R:seven aspects
    me.sopi = &acgtRstcq{
        !sy&R and throw "beself"
        q = peel(q)
        $self = sy&R == R
        return &SO{
            $se = self ? me&Api,s,t,c : s.y [t]
            $args = []
            if (q && q.thing) {
                if (self) {
                    # keep instruction for later
                    $D = sey&thing = c.D || sey&thing || s
                    # most probably s/row+
                    D == s and Dc&brackin ||= 1
                }
                else {
                    $D = sey&thing
                }
                !D and throw "unthingD"
                args.push(D)
            }
            !se and throw "unself"
            (self ? S : O)(se, ...args)
            return se
        }
    }
 
 // -eight** - takes a look
   // -eight
    # < drop -seven c.t=i, se.t can be set
    # < num() -> isnu(), for new:
    #   num() fatal isnu() && return cast to number
    #   fum() for scaf()?
    
    me.pieight = &acgtRsc{
        num(c) and c = {ov:scaf(c)}
        c.ov ||= 0.9
        # creates then happens each time
        # < &Api mode for el ||= !E || Ey&R != sy&R ? 2 : 3
        #   is equated to ov > 0.1 el:3
        #  < R|Cy&R == sy&R and self
        #  < el:2 meaning knowing about recreation, times
        #    el:1 is a universal "new thing" signal in the pipe
        #     can be implied for any C
        c.ov > 0.1 and c.el ||= 3
        $E = me&Api,s,'eight',c
        c.ov <= 0.1 and return E
        
        $D = Cye(["Eighting"])
        $Eac = &e{
            ac(E,'z',e)
            #me&bracki,R,D,hashkv(ec&pi,e)
        }
        
        $fo = me&pifour,R,s
        Eac(fo)
        
        each ie ss&z {
            # paragraph of story: -seven a %Yingate
            !ey&R and debugger
            # se exists, is empty, has yology. now other:
            #  now builds further se/** based on that
            $se = me&piseven,R,e,{}
            # < could almost rename that after returning it
            #   would require A:n@1 until the S domed
            Eac(se)
        }
        
        $OLD = 0
        !OLD and me&foraneight,R,s,E
        
        # -eight display
        $brackc = delete Ec&brackology
        $br = me&pibrackology,R,E,ex({D},brackc||{})
        $ol = me&yology,br
        ols&pa = 0.2
        # sorts before four
        # < start early to take place, load D when ...
        oly&cv = 0.117
        # < through -tll (thing looks like) to -act
        #ss&z.length > 5 and me&scroll,27
        
        # 5
        # instead of drawing a button,
        OLD and me&onaneight,R,s,E
        # we apply styles based on ...
        #  (%ope:0 -> distributed dis:0)
        $ys = delete Es&todo5
        ys and ys.map(y => y (ol) )
        
        # < only -four yet, to help -eight sublate
        me&Effected,E,'Ignored' and Es&Ignored = 1; return
        c.ov < 0.6 and return
        # 6
        # < knowing Checkable in, receiving further stim
        # < knowing c.*=row%eto=s is for our attention,
        #    knowing what %%Checkable does at -eight
        #     unless a stronger c.$k knowing sublates that
        $Ch = c.Checkable
        
        # 7
        $d = {compLines: &DdC{
            me&dopi,D,d,C,c
            # normal -vat -> -n, talk of ground things
            Dc&pi == 'n' and delete Dc&pi
        } }
        # < the Lineso top D on ss&string.D
        #   showing the string with chunks inteligised
        me&Linets,s,E,d
        
        # 8
    }
   
   // e -eight
    # $eight remembers|does hidden
    #   makes changes in Effected %%ope otherable
    #  settings may stick onto r%eCsc...
    # < as &togcon layer: for hidingness, undone by ...
    # < as A imposing A
    me.foraneight = &acgtRsE{
        # E-eight visiting
        $go = R.sc['go-eight']
        Ey&R = R
        
        # the thing... can apply before (to %eCsc for Display)
        # < after is complicated, as it ~ -brackology%ope
        
        # goes into c for -brackology/-ology
        # ah() doesn't always .sc (making .sc.c... impossible)
        #  and ensures hash at the end:
        $c = ah(E,'c','brackology','ology','togcon',{})
        c.for ||= {}
        # pops up in togcon_solve, for $ok=itself
        c.for.itself = &q{
            if (q.is != null) {
                # what &togcon has found takes precedence
                me&Effect,Rc&s,E,'togcon',{ope:q.is,dom:1}
            }
            # consuming qualia
            # hide by default is provided by $eight
            $lav = me&Effected,E,{ope:1,go}
            lav == null and return
            # < otherable outcome:
            #  becoming %ope unto the label and its thing (g%ope)
            #   affects the style on the label
            #   and potentially Km%ope (innards)
            #    which may be able to Display & hide,
            #     or be tunneled in (to modulat?) to appear
            q.is = q.Effected = lav
            go and me&nu,"Letsitself",q
        }
        
        # < iconify this effect, next to the shrunken eight label
        #   and know how to open without selfing,
        #    see 'otherable outcome'
        $apply = me&eCscor,'-eight'
        $ef = {t:'shut',s:'',act:&v{
            $style = v ? {dis:0} : {}
            $visit = &n{
                $also = {}
                if (v) {
                    # hiding
                    # for now we are always selfing, huge extra load
                    #  avoid putting into html just to hide it
                    #   and once on, avoid removing just to hide it
                    $b = nc&b
                    isR(n) && (!b || !by&Display) and ns&noDisplay = 1
                }
                else {
                    # revealing
                    # 0,1 hidden,block(r%rowish),inline-block(-ology/*)
                    also.dis = isR(n) ? 1 : 2
                }
                apply(n,ex(also,style))
            }
            me&toureight,R,E,visit
        }}
        # instead of drawing a button,
        #me&fliponoff,R,s,ol,q
        
        # we have F for &togcon,
        #  andor &togcon for F
        
        # which we then apply...
        ac(E,'todo5',&g{
            # gs&ope as Effected
            # default 1, -1..2 or so...
            # <= 0 meaning hidden
            $shut = gs&ope <= 0 ? 1 : 0
            ef.act(shut)
            go and me&nu,"g",g
        })
        
        # colour when OK
        sy&on_ok = &{
            # < %%Effect:check,ok otherable:
            me&eCscor,'-eight:ok' (R,{bgh:'041'})
            # < %%Effect:check,ope=0 (is still; otherable?)
            # already so
            #G&yl:3,&{ q.set(1) }
        }
    }
    # OLD $eight remembers|does hidden
    #  settings may stick onto r%eCsc...
    # < as &togcon layer: for hidingness, undone by ...
    # < as A imposing A
    me.onaneight = &acgtRsE{
        $apply = me&eCscor,'-eight'
        $ol = me&yology,E
        
        $q = {t:'shut',s:'',act:&v{
            $style = v ? {dis:0} : {}
            $visit = &n{
                $also = {}
                # 0,1 hidden,block (assuming r%rowish)
                !v and also.dis = isR(n) ? 1 : 2
                apply(n,ex(also,style))
            }
            me&toureight,R,E,visit
        }}
        me&fliponoff,R,s,ol,q
        
        
        # hide when OK
        sy&on_ok = &{
            me&eCscor,'-eight:ok' (R,{bgh:'041'})
            G&yl:3,&{ q.set(1) }
        }
    }
    # visits each brackology or r of E/* 
    me.toureight = &acgtRE,visit{
        # < grepo (returning the climbed v)
        $N = me&ioty,E .map(z => zy&brackology) .filter(z=>z)
        #~>5 cept: joint(N)
        $eightR = me&uptoR,E
        # each -eight/*//-brackology
        N.map(&z{
            $r = me&uptoR,z
            if (r == eightR) {
                # -four/*%groupthing, so the label remains
                zy&M(&m{
                    # has been visited by R:Display
                    # or is about to be, inc m%eCsc then
                    visit(m)
                })
            }
            else {
                # hide $seven
                visit(r)
            }
        })
    }
   
   // e flips
    me.fliponoff = &acgtRsgq{
        $apply = me&eCscor,q.t
        $on = me&casbut,g,q.t,q.s
        ony&click = &{
            q.set(s.y [q.t] ? 0 : 1)
        }
        q.set = &v{
            apply(on,v ? {fs:13,bri:1.4} : {})
            s.y [q.t] = v
            q.act(v)
        }
        # reapply act on wake
        # < may be too early? yet modulat may %eCsc
        $was = s.y [q.t]
        was != null and q.set(was)
    }
    # casual button
    me.casbut = &acgtgts{
        $n = me&mtsc,g,t,s
        me.nto(R,n,&sTe{
            me&yyt,n,'click',g,n
            # click not wakey
            # < unless un-noDisplay
            T.wake = 'not'
        })
        return n
    }
    # give many n %eCsc.$t = sc style
    #  in or out of time
    me.eCscor = &acgtt{
        return &nc{
            $modon = me&Dispon,n
            #me&eCscorigin,n,t,c
            # can remain on Rs&eCsc.-eight
            me&eCsc,n,t,c (modon)
        }
    }
    # style de-overwriting
    # < BROKE: dis:1->0 reverts to dis:2?
    me.eCscorigin = &acgtntc{
        $origin = ns&eCsc && ns&eCsc[t+"_origin"]
        if (!origin) {
            # create originals
            $oc = {}
            each kv c {
                hak(n.sc,k) and oc[k] = n.sc[k]
            }
            ah(n,'eCsc',t+"_origin",oc)
        }
        else {
            # default them back in
            each kv origin {
                !hak(c,k) and c[k] = v
            }
        }
    }
   
   // -four
    # < may merge -eight with similar -four
    #   eg a sequence of e:clicks each return to Story
    #    whereas a bunch all happen, then return to Story
    me.pifour = &acgtRsc{
        
        $fo = me&Api,s,'four',c
        $gof = me&acting,R,'-four',0
        # merge eight:s/seven:z/row into D/row+%%gate=z
        $D = me&pigate,R,fo,{N:s}
        # start an interactive viewability on it
        $br = me&pibrackology,R,fo,{D}
        bry&M(&Km,{
            # -legs tallies Km/Kn,
            # and unrelatedly mutes Km:gate:
            # < -gate is the source of that, contrib %togcon:
            #    so ope:-1 show Km.t+sizo, no Kn, nothing in -legs
            #   before br renders Km, then finish after
            # < Km, without label, not pointtoable?
            $leg = me&pilegs,R,s,{Km}
            # fatal create each -leg in -four
            me&fiu,fo,leg,2
        })
        
        # out of timer
        $po = me&piling,R,fo
        gof and me&nu,"tugboat",po
        
        return fo
    }
    
   // -seven, read into another
    # self in $seven, continues with $eight
    # < various watchings, eg e:click taints or captures for replay
    me.piseven = &acgtRsc{
        $se = me&sopi,R,s,'seven',c,'thing' (&se,D{
            # the $seven:s itself
            # capture $D = sey&thing
            # display sey&brackology in $seven
            
            # < maybe how to -gate..-vat,
            #   see 'capture any adjusted ology for replay'
            #   specifics for the process its going into,
            #    want tuning in the brackology
            $br = me&pibrackology,R,se,{D,ology:{labelD:1,usuDpi:'gate'}}
            br != sey&brackology and throw "you"
            #me&nu,"See",{s,br,se,D}
        },&se,D{
            # $eight including a -seven,
            #  builds further se/** based on its:
            $br = sey&brackology
            bry&M(&Km,{
                # -seven/-rows: of similarity
                #  allowed one oddness, see -groupbrack_similark
                $tee = joint(me&ioty,Km )
                $mg = Kmy&gate = me&fiu,se,tee,2

                # < hardwired or $Storie-got configuring
                #    &togcon
                # < track approx time of each -seven
                #   species a trail of samples
                tee == 'time' and mgc&ms = 'z'; return

                !Kmc&rows and throw "norows"
                each in Kmc&rows {
                    $gr = me&fiu,mg,i
                    gry&row = n
                    each kv n.sc {
                        $gv = me&fiu,gr,k
                        gvc&s = v
                        gvc&pi = 'vat'
                    }
                }
            })
        })
        return se
    }
    # brackology to C-vat
    # < use in -seven
    me.vatology = &acgtE,br{
        bry&M(&Km,{
            # -seven/-rows: of similarity
            #  allowed one oddness, see -groupbrack_similark
            $tee = joint(me&ioty,Km )
            $mg = Kmy&gate = me&fiu,E,tee,2

            # < hardwired or $Storie-got configuring
            #    &togcon
            # < track approx time of each -seven
            #   species a trail of samples
            #tee == 'time' and mgc&ms = 'z'; return

            !Kmc&rows and throw "norows"
            each in Kmc&rows {
                $gr = me&fiu,mg,i
                gry&row = n
                each kv n.sc {
                    $gv = me&fiu,gr,k
                    gvc&s = v
                    gvc&pi = 'vat'
                }
            }
        })
    }
  // -six brack stringer
    me.pisix = &acgtRsc{
        $E = me&Api,s,'six',c
        $gof = me&acting,R,'-six',0
        
        # keep instruction for later
        $D = Ey&thing = c.D || Ey&thing || s
        
        $br = me&pibrackology,R,E,{D,ology:{labelD:1,usuDpi:'gate'}}
        br != Ey&brackology and throw "you"
        
        # fills E/-row/-vat
        me&vatology,E,br
        
        # E to string
        $d = {compLines: &DdC{
            me&dopi,D,d,C,c
            # normal -vat -> -n, talk of ground things
            Dc&pi == 'n' and delete Dc&pi
        } }
        Ey&made = me&Linets,s,E,d
        
        return E
    }
  // -vat data on data
    me.dopi = &acgtDdCc{
        # C is readonly -seven/**
        #   ro except for expanding arrays
        #  s is the thing itself
        # D is its representation
        $s = c&s
        $p = Cy&up
        if (c&pi == 'vat') {
            !p and throw "-vat toplevel"
            if (isar(s) && pc&pi != 'vat') {
                # expand one array
                Dc&pi = 'array'
                each in s {
                    $gv = me&fiu,C,i
                    gvc&s = n
                    gvc&pi = 'vat'
                }
                return
            }
            # other s=object|data|value become stringified
            !isC(s) and Dc&s = ki(s); return
            Dc&s = s.t
            # avoid talking of R
            isR(s) and return Ds&R = 1
            Dc&pi = 'n'
            # usually -n: a C we can find
            # as a flower amongst|beyond the body of nodes
            $stem = []
            $beyond
            $Xss = c.nlist || []
            $la
            $foundnode = me.cby(s,&zd{
                $t = z.t
                # tell if la^z != z/la
                if (la && !(zs&z && zs&z.includes(la))) {
                    $r = lay&R
                    $rem = ''
                    # < see vv/beginning/3 "Story/Story!%eph/beginning"
                    #   s^^ different to sy&R^^
                    r && !(rs&eph || me&ollbs,r,'eph' ) and rem = '!'
                    !r and rem = '?'
                    #stem[0][0] == 'le-2' and debugger
                    stem[0].push(rem+'%eph')
                }
                la = z
                stem.unshift([t])
                if (Xss.includes(z)) {
                    if (!zy&path) {
                        # capturing %eph from weird times before quiet?
                        Ds&NOTANODE = 1
                        #throw "node!zy&path"
                    }
                    # finish?!
                    return 1
                }
                beyond = 1
                return 0
            })
            !stem.length and throw "nostem C"
            Dc&s = stem.map(l => l.join('')).join('/')
            !foundnode and Dc&pi = 'C'
            else
            beyond and Ds&beyond = 1
        }
    }
 
 // -brackology** - makes a look
    # situating crammed meanings
    #  wildest edge of things, where wheres where
    # < fill with hooks, combine with KnowC?
    #   see CB, which also wants:
    # < brackology with styles
    # < may have already been, shade difference?
    # < Citology, has nk/gk etc scrambling in one pool?
    # < gear in br/* (params|c) sitting near g/** (sc)
    # < K should be %grouping, with no label
    #  < because the Kn labels look enough like it
    # < they could hoist elsewhere, eg the Abodis minimaps
    # < and pipe into projections, gaining extra layout layers
    #   gy&M shall iterate Km for its current group+ology
    # < X.ref for inter-group object link
    # < only changes pop up, shrink in
    # < separate sizology
    #    the brackgroup causes -brack on D?
    
    # start an interactive viewability of brack
    me.pibrackology = &acgtRsc{
        $br = me&Api,s,'brackology',c
        $D = c.D
        !D and throw "!D"
        # g-ology provides bry&M() which iterates g/Km,
        #  which we create after -group**
        $g = me&piology,R,br,ex({D},c.ology||{})
        # Ds&X should be up to date, eg &bracki
        #  or not yet created, eg -gate el:2 D (has )
        #   < it could allkv slep before reindexing it
        Dc&brackin ||= 1
        $X = me&brackXD,D
        !hak(X.k) and return br
        #-1 - only amounts (rows + uniq t)
        # 0 - t-only
        # 1 - with amounts
        # 2 - t:v, for 1 v only (as now)
        # < t-only, of at the toplevel
        if (gs&pow < 0) {
            $op = me&sizo,g,{t:'rows',len:Ds&z.length,opelen:1};
            # < each type of X.*, will be Km mot
            me&sizo,g,{len:hak(X.k)};
            !(op && ops&ope) and return br
        }
        # pre-K** structure pooling
        # < pass D around explicitly
        $gr = me&pigroup,R,br,c
        $Z = gr
        c.group = defor(c.group,'simil')
        if (c.group == 'simil') {
            # i D/K/n o D%X
            Z = me&pigroupbrack_similark,R,gr,c
        }
        
        # piping into: i K/Km/Kn o D...%X  
        # < D iterates rows of %%K:z,n,Km?,...
        # < K knows which d+z it came from, to repipe...
        #   having slep sensors along the pipe,
        #   solo just the changed stuff
        # in this case we want rows grouped away
        me&Kmish,Z,{for:'K'} (&dz{
            # < might be no regroup, direct from %wou
            d == z and debugger
            # < t? i?
            # piped into modulat from the structuring D/K, now z
            # K: are the gy&M iterables
            #  see 'K should be %grouping'
            $K = me&opeKn,g,z.t,{walls:'bd:1.4'}
            # < originate
            Kc&rows = zs&z
           
            Ks&pow = gs&pow
            Ks&ope = gs&ope
            
            Ks&bgh = 581;
            Ks&dis = 2;
            
            # readies zs&X
            me&Kmish,z
            # K/Km:ark-sim/Kn:C-vat
            # has an X-specific iteration,
            # < D/t/-x
            c.tx = zs&X.k
            c.Kms = me&pitxology,R,K,c
            
            me&pitsograph,R,K,c
        })
        # beyond -brackology: i Km-mod o Km,
        #  knowing how to translate interest in those later expressions,
        #  into focusing this -brackology on certain rows/columns/values
        return br
    }
   
 // -group # i -ology/Km {reasoning} o $info**
  
  // pooling -> Km+: -group, &brackXD, &Kmish
    =spec
     < -group makes K for mix of -group*
       mostly we want to:
     
     -groupbrack_similark
      group similar rows: D(/group)/row
     
     < -grouprefs
       
       stepx5: x3CTravel(wakex2), gatex3
        or (wakex2,gate:le-2) if not ^ K/Km/Kn mergible:
         would inject Km with Cn not from that K?
          or inject Kn:gate with Cn&v:
           Cn&v are really multiple, coming from Cn&x.ref
           < iterate &Knish
         yet have them undo if the wake is open
        Cn sizo (explicit x1) if different to Kn sizo
         or (wakex1) if wakex1
       
       puts K=step,node,wake as columns
        because they share a lot of refs
     
     < -groupspace
       puts K=step,node as columns, with an order
        because that is efficient Cn&v^ = Kn&v
         and we can z-order (or something else?) the v**
       or
        because that is Ying/*/** + attention
         and we have a Nodar to order them
      
      should be a pipe, ^ i D o D%X
     
     < D indentifying its structure
       when D = a -group*,
        D provides an iterator for %%Km,D:z
         and more, magical overlaying D:others

      < further D may be another layer of info, relative to origin
         how to traverse the origin to get the grouping
        not the origin in that grouping

      < ideally producing only X (not new D+rows)
        having ways to the original node and indexing qualities against them
        they might have an index of which indexes are important,
         and how to compute metrics for possible layouts
        can &bracko handle that? with joins?
       
       so many X, each perspecting D**
    =spec
    me.pigroup = &acgtRsc{
        $D = me&Api,s,'group'
        c.D and Dy&origin = D
        # Km = agreeable Km,D
        return D
    }
    # D%X
    me.brackXD = &acgtD{
        return Ds&X ||= me&brackX,Ds&z
    }
    me.Kmish = &acgtDc{
        !D and throw "!D"
        c ||= {}
        c.for ||= 'Km'
        me&brackXD,D
        # depth of C before rows
        $d = Dc&brackin
        # < etc, if we are on a K
        #!d && me.cby(&sd{ try while hak(d)<3 })
        $Dp = Dy&up
        !d && Dp && Dpc&brackin and d = Dpc&brackin-1
        !d and throw "noindex"
        # any D-group* y&M interates Cn, before Km
        return &y{
            d == 1 and $N = [D]
            else {
                $index = [...Array(d-1)].map(t=>'*')
                $N = me&ioty,D,index
            }
            N.map(&C{
                c.for == 'K' and y (D,C)
                else {
                    each in Cs&z {
                        nc&drop and continue
                        y (D,C,n)
                    }
                }
            })
        }
    }
    # < Kmish returning what y (D,C,n) returns ^
    me.resultily = &{
        
    }
  
  // structures
   // addition
    # group similar rows
    # allowing a and a+b to fit together,
    #  sizo per column|value communicates the oddness
    # splitting by %%dome:$v
    # < show clearer when Km%ope (tabular?)
    me.pigroupbrack_similark = &acgtRsc{
        $D = me&Api,s,'groupbrack_similark',c
        # i D/K-joint/n o D/n
        # layers of C structure before /n-row
        Dc&brackin = 2
        # keys different to negate groupage
        $kdtng = 1
        # the last of which (D/z) informs K.t (no label)
        # < doing this between K already there? is multiply|divide
        me&Kmish,c.D (&dzn{
            d != c.D and throw "c.D==d"
            $ks = haks(n.sc);
            $matchness = 0;
            $match = null;
            # < D/K indexed already, for K with k
            #   the X.k/$k might union X.grouptype/K
            #    for different types talks about X.k stuff
            each iK Ds&z {
                # < K having indexes already
                $no = haks(K.c).filter(k => !hak(n.sc,k)).length
                # allowing a and a+b to fit together
                no > kdtng and continue
                # splitting by %%dome:$v
                ns&dome != Kc&dome and continue
                $yes = ks.filter(k => hak(K.c,k)).length
                $matched = yes - no
                matched <= matchness and continue
                match = K
                matchness = matched
                #j.t == 'Travel' and me&nu,"matched"+i,[ks.join(','),matched+'('+yes+'/'+no+')'+matchness,c.t]
            }
            if (match && matchness >= ks.length-kdtng) {
                # groups members with <= 1 odd key
                $K = match
                ac(K,'z',n)
            }
            else {
                $K = Cye([ks.join(','),1]);
                # Kc&* are the match
                # < &if
                each kv n.sc {
                    K.c[k] = 1
                }
                Ks&z = [n]
                Ds&z.push(K)
                Ky&up = D
            }
        })
        #N.length == 1 and N = [z]
        return D
    };
   
   // subtraction
    # merge eight:s/seven:z/row into D/row+%%gate=z
    # D-gate/@row+%gate=oD = N/oD/row
    me.pigate = &acgtRsc{
        
        $D = me&Api,s,'gate'
        $N = c.N
        !N and throw "!N"
        Dc&brackin = 1
        # < i $D/@row%gate=@gate y:row o $s/:gate/:row
        # < separation happening. it's not our $row to eat.
        #   separation coming before the row:{} here
        #   better getting at the row in &ind, grouped by arkfor?
        #   and tw mode, or even t mode (dup keep z)
        #   otherwise works:    this v is io's d.row, not brack row
        # i $D/@row row:{ s&gate = s.row[1] } y o $s/:gate/:row
        # instead:
        Ds&z ||= []
        me&ioty,N .map(&z{
            me&ioty,z .map(&t{
                t = Cye(t)
                ts&gate = z
                ac(D,'z',t)
            })
        })
        return D
    }
   
 // -ology # i $metrics o -ology/K**
   // 1 - br+g
    # viewable end of a -process
    # eg -brackology is -brack... -> -ology
    #  at R:eight/-four/-brackology/-ology,
    #   Rs&M += -ology
    me.piology = &acgtRsc{
        $br = s
        $fo = bry&up
        
        me&labelt,R,br,c,{thispi:'ology'}
        $g = me&Api,br,'ology',c
        
        gy&cv = 0.12
        # is appearable thing
        c.appears and ac(R,'M',g)
        # $g is a $pt
        !c.notog and me&togcon,R,g,c.togcon
        # and has a label, etc
        me&ologise,R,g,c
        # br has things from g,
        #  once other inputs them to $g/*
        bry&M = &y{
            me&ioty,g,'groupthing' .map(Km => y(Km))
        }
        # interfaces to its representation
        bry&gog = &y{
            y (g)
        }
        return g
    }
    # generate names over the slope
    # < these types in %Slope hypothetica
    me.labelt = &acgtRscq{
        # must be a pi under Rc&s already:
        $br = s
        $fo = bry&up
        
        # one highly unique:
        # < conveniently named after Rc&s.t,(^^^brc&pi) and c.*,
        #   a compressey mingle of what's around (to it|it to)
        # < once $g created, before its name matters: Y:pi @015
        # with c.* fact:
        $D = c.D
        c.t = c.t || joint([
            # stretches up to Rc&s.t:
            s.t,
            # up two:
            fo && foc&pi,
                brc&pi,
            # pi we're about to make ($g):
            q && q.thispi,
            # and some thing coming at it
            D && Dc&pi && '<-'+Dc&pi
        ])
        
        # one small and concise:
        # all .t are likely to be the same...
        # display title for the c&pi having -brackology above
        #  -four being the last real work,
        #    before the holograms showing it
        c.label ||= D && c.labelD && Dc&pi
            || fo && foc&pi || c.t
        
        # all R/**{,2}/-ology appear
        if (br == Rc&s || fo == Rc&s || foy&up == Rc&s)
            c.appears = 1
    }
    # label clickable, energised, etc
    me.ologise = &acgtRgc{
        $q = {
            walls:'b:2.2',
            label:{walls:'bg'},
        }
        # ex(q,c) with q.label.s = c.label
        c = exts(q,c,'label')
        # < move out
        c.sc and ex(g.sc,c.sc)
        
        $D = c.D
        # colour
        gs&hue = 30
        if (D) {
            if (c.usuDpi && Dc&pi != c.usuDpi) {
                s&ml = -2
                gs&hue = -20
            }
            if (c.labelD && Dc&hu) {
                gs&hue = 100 + Dc&hu * 45
            }
        }
        
        gs&ws = 0
        me&applystylec,g,c,{};
        me&opelabel,g,c.label;
        me&opewires,g;
        # energised
        gs&ope and gs&pow = gs&ope
        gs&pow ||= 0
        if (gs&pow > 1) {
            #gs&float = 'right';
            #gs&dis = 2;
        }
    }
    
   // 3 i K/Km/Kn draw
    # i Km:t c.tx=X.k /t/x
    me.pitxology = &acgtRgc{
        !c.tx and throw "!tx"
        $Kms = [];
        each tx c.tx {
            $Km = me&opeKm,g,t
            Kmc&k = t
            Kmc&x = x
            Kms.push(Km)
        }
        # energise it
        # < sizography of the K+
        gs&pow < 2 and gs&ma = 0.2
        each i,Km Kms {
            Kms&pow = 1
            $con = c.kc && c.kc[k]
            con and ex(Km.sc,con)
            gs&ope > 0 && Kms&ope == null and Kms&ope = 1
            Kms&ope and Kms&pow = gs&pow = 2
            gs&pow ||= 0
            
            if (Kms&pow < 1) {
                Kms&ma = 0.1
                Kmc&left_blank = 1
                continue
            }
            # open
        }
        return Kms
    }
    # draw openable /ref/z
    me.pitsograph = &acgtRgc{
        $Kms = c.Kms
        !Kms and throw "!Kms"
        each i,Km Kms {
            $k = Kmc&k
            $x = Kmc&x
            # total values for key, Km%ope if 1
            me&opesizup,Km,{len:hak(x.ref)}
            Kms&ope <= 0 and continue
            
            fio(Km,['ope',1,{s:":"},'hs:888']);
            $vii = 0;
            each vi,fx x.ref {
                $v = x.refs[vi];
                $lc = me&slabeline,v
                $Kn = me&opeKn,Km,lc.t,{label:{tsc:'y'}}
                Kny&v = v
                ac(Kn,'vis',vi)
                
                $lab = Kny&label;
                $bsize = Knc&size || Knc&sortcv && 1 || 0
                Knc&sortcv = 1;
                lc.C &&
                    fio(Kn,['sym'+vi,112,{s:lc.sym},
                    'label,fs:13,lh:0.8,hs:757']);

                # total rows for this value with this key
                # < light up other k/v/rows this k/v/row has
                Knc&size = 0
                me&sizo,Kn,{len:fx.z.length};
                # many same lc.t pile up many sym, add sizo
                # < fix in -ology
                Knc&size ||= 1
                Knc&size *= 1
                bsize and Knc&size = (Knc&size||1)*1 + bsize*1
                Knc&size == 1 and delete Knc&size
                Knc&size > 1000 and debugger
                Kns&ma = 0.2;
                if (Kns&ope > 0) {
                    each in fx.z {
                        $val = n.sc[k];
                        $na = [g.t,k,vi,i].join("'");
                        $wa = me&opeKn,Kn,na;
                        way&cv = 0.2;
                        was&dis = 1;
                        # sprout icon, some non-nu to click
                        $wan = me&opeKn,wa,'',{label:{tsc:'y'}};
                        if (wans&ope) {
                            # whole row
                            me&mnu,wa,'row',n
                        }
                        else {
                            # for the value
                            me&mnu,wa,k,val;
                        }
                        wany&cv = 0.8;
                    }
                }
            }
        }
        return g
    }
    # a title for $s, data if weird
    # < -vat compat, fliop
    me.slabeline = &acgts{
        $c = {}
        if (isC(s)) {
            c.C = 1
            c.sym = isR(s) ? 'R' : 'C'
        }
        c.t = c.C ? s.t :
            s == null ? '*null' :
            isst(s) ? s :
            isob(s) ? ki(s,2) : ""+s;
        # constrain string size
        if (isst(s) && s.length > 100) {
            $len = '...'+s.length
            $lines = s.split("\n")
            if (lines.length > 1) {
                $firstline = lines[0]
                lines = '*'+lines.length
            }
            $hash = '#'+dig(s)
            c.t = firstline != null ? firstline+len+lines+hash
                : s.substr(0,100)+len+hash
        }
        return c
    }
   
   // 6 o K**, other
    # storable -four/Km/ref
    me.pilegs = &acgtRsc{
        $Km = c.Km
        !Km and throw "!Km"
        c.t ||= joint(Km,'-','gate')
        $mg = me&Api,s,'legs',c
        me&ioty,Km .map(&Kn,{
            $N = me&ioty,Kn
            #me&nu,"Kn:"+Kn.t,N
            $gr = me&fiu,mg,Kn.t
            grc&pi = 'leg'
            Knc&size and grs&size = Knc&size
            gry&leg = Kn
            if (Kn.t != 'gate') {
                $x = Knc&x
                $ii = 0
                # ology modulat compresses same v.t along N
                #  to simplify order of every ref
                each in N {
                    !ns&vis and continue
                each i,vi ns&vis {
                    $fx = x.ref[vi]
                    $v = x.refs[vi];
                    # how many times it was used
                    $gv = me&fiu,gr,''+(ii++)
                    gvc&pi = 'vat'
                    gvc&s = v
                    gvs&size = fx.z.length
                    gvs&size == 1 and delete gvs&size

                    $nN = me&ioty,n
                    each iz nN {
                        #zs&groupthing and debugger
                        # size,sym,label
                    }
                }
                }
            }
            else {
                # mute %%gate after size
                # < in such a way that Te|diff can inflate it
                $aft_size = 0
                each in N {
                    aft_size and ns&dis = 0
                    n.t == 'size' and aft_size = 1
                }
            }
        })
        return mg
    }
   
    
   
   