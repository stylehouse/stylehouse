# Picturity!
   // modulat f
    me.scroll = &acgts{
        s&mh = s;
        s&over = 1
    }
    # in-modulat &nu
    me.mnu = &acgtgts{
        $nu = me&nu,t,s;
        nus&ope = 1;
        me&zN,nu;
        me&zuct,g,nu;
    };
   // misc f
    # selective ex, removing
    #  as in consuming arguments from a c
    window.tax = &s,take,c{
        !c and return s
        !isha(s) || isC(s) || !isha(c) || isC(c) and throw "tax"
        isst(take) and take = G&peel,take
        else
        isar(take) and throw "{map{k:1}take}"
        each k,remove take {
            !hak(c,k) and continue
            remove and s[k] = delete c[k]
            else { s[k] = c[k] }
        }
        return s
    }
    # "$t1-$t2" for [C,C,C{.t==not}]
    window.joint = &N,join,not{
        # ioty may N=C/*
        $M = me&ioty,N .map(n => isC(n) ? n.t : n)
            .filter(t => t != null && (not == null || t != not))
        $s = M.shift()
        join ||= '-'
        each in M {
            # leading joiner-ish thing
            n.startsWith('<'+join) and s += n
            else { s += join+n }
        }
        return s
    }
    window.defor = &sc{
        return s != null ? s : c
    }
    # y(k,v) for s
    window.hav = &sy{
        return haks(s).map(k => y(s[k],k))
    }
   // pi f
    # create a -pi on a node
    me.Api = &acgtstc{
        !isst(t) and throw "which -pi"
        # takes c.t (< etc) into a new c
        c = tax({},'t',c)
        c.el = 2
        $b = s.y [t]
        $E = s.y [t] = Cye([defor(c.t,s.t),1,{pi:t}])
        Es&z ||= []
        Ey&up = s
        return E
    }
    # for s if sc&pi=$k, or sy&$k
    # < used
    window.phisy = &sk{
        $z = sc&pi == k ? s : s.y [k]
        !z || !zc&pi and throw "shocks",z
        return z
    }
    
   // -eight**
    # < drop -seven c.t=i, se.t can be set
    me.pieight = &acgtRsc{
        $E = me&Api,s,'eight',c
        
        $fo = me&pifour,R,s
        me&fiu,E,fo
        # only -four yet, to help -eight sublate
        c.ov < 0.6 and return
        
        each ie ss&z {
            # paragraph of story: -seven a %Yingate
            $se = me&piseven,R,e,{t:i}
            # < could almost rename that after returning it
            #   would require A:n@1 until the S domed
            me&fiu,E,se
            
        }
        # through -tll (thing looks like) to -act
        
        #ss&z.length > 5 and me&scroll,27
        
        # 6
        $d = {
            compLines:&DdC{
                me&dopi,D,d,C,c
            },
        }
        # < the Lineso top D on ss&string.D
        #   showing the string with chunks inteligised
        me&Linets,s,E,d
        
        # &acceptables_reself
        c.Finto &&
            me&nodei,R,c.Finto,{Fin:s,dige:ss&dige}
    }
    # < may merge -eight with similar -four
    #   eg a sequence of e:clicks each return to Story
    #    whereas a bunch all happen, then return to Story
    me.pifour = &acgtRsc{
        $fo = me&Api,s,'four',c
        $gof = me&acting,R,'-four',0
        # merge eight:s/seven:z/row into D/row+%%gate=z
        $D = me&pigate,R,fo,{N:s}
        # start an interactive viewability on it
        $br = me&pibrackology,R,fo,{D}
        bry&M(&Km,{
            $leg = me&pilegs,R,s,{Km}
            # fatal create each -leg in -four
            me&fiu,fo,leg,2
        })
        
        # out of timer
        $po = me&piling,R,fo
        gof and me&nu,"tugboat",po
        
        return fo
    }
    
    # < self in %Yingate, continues with -eight
    me.piseven = &acgtRsc{
        $se = me&Api,s,'seven',c
        
        $g = sy&brackology
        
        gs&z.map(&Km,{
            !Kms&groupthing and return
            # -gate: bunch of rows
            #  each row allowed one oddness, see &brackgroupX
            $tee = me&ioty,Km .map(Kn => Kn.t).join('-')
            # < &fiu,s,z,2 - fatal create?
            me&fiu,se,tee,8 and throw "already a "+tee
            $mg = Kmy&gate = me&fiu,se,tee

            # < hardwired or $Storie-got configuring
            # < track approx time of each -seven
            #   species a trail of samples
            tee == 'time' and mgc&ms = 'z'; return

            !Kmc&rows and throw "norows"
            each in Kmc&rows {
                $gr = me&fiu,mg,i
                gry&row = n
                each kv n.sc {
                    $gv = me&fiu,gr,k
                    gvc&s = v
                    gvc&pi = 'vat'
                }
            }
        })
        return se
    }
  
  // -piling Yc&M[$pi+] to complete
    # draws drawings together as plans to complete them
    # find all -pi for s, generating a poc&M to be Yc&M
    me.piling = &acgtRsc{
        $po = me&Api,s,'ling',c
        # searches s for sy&somethingc&pi,
        #  eg s=$fo=-four, finds $D, $br
        $M = []
        $api = v => v && v.c && v.c.pi && M.push(v)
        hav(s.y, v => api(v))
        # and eg $fo/$leg+
        sc&pi && me&ioty,s .map(v => api(v))
        
        poc&M = arou(uniq(M),v=>v!=po)
        return po
    }
    me.dopi = &acgtDdCc{
        $s = c&s
        if (c&pi == 'vat') {

            # starts s=object|data|value, becomes stringified
            !isC(s) and Dc&s = ki(s); return
            Dc&s = s.t
            # avoid talking of R
            isR(s) and return Ds&R = 1
            Dc&pi = 'n'
            # usually -n: a C we can find
            # as a flower amongst|beyond the body of nodes
            $stem = []
            $beyond
            $Xss = c.nlist || []
            $la
            $foundnode = me.cby(s,&zd{
                $t = z.t
                # tell if la^z != z/la
                if (la && !(zs&z && zs&z.includes(la))) {
                    $r = zy&R
                    $rem = ''
                    # < see vv/beginning/3 "Story/Story!%eph/beginning"
                    #   s^^ different to sy&R^^
                    r && !(rs&eph || me&ollbs,r,'eph' ) and rem = '!'
                    !r and rem = '?'
                    stem[0].push(rem+'%eph')
                }
                la = z
                stem.unshift([t])
                if (Xss.includes(z)) {
                    !zy&path and throw "node!zy&path"
                    # finish?!
                    return 1
                }
                beyond = 1
                return 0
            })
            !stem.length and throw "nostem C"
            Dc&s = stem.map(l => l.join('')).join('/')
            !foundnode and Dc&pi = 'C'
            else
            beyond and Ds&beyond = 1
        }
        # normal -vat -> -n, talk of ground things
        Dc&pi == 'n' and delete Dc&pi
    }
  
  // stylemap - make outsidable
    
 // -brackology** - takes a look
    # situating crammed meanings
    #  wildest edge of things, where wheres where
    # < fill with hooks, combine with KnowC?
    #   see CB, which also wants:
    # < brackology with styles
    # < may have already been, shade difference?
    # < Citology, has nk/gk etc scrambling in one pool?
    
    # start an interactive viewability of brack
    # find openness asap, ology upwards
    me.pibrackology = &acgtRsc{
        $br = me&Api,s,'brackology',c
        $D = c.D
        !D and throw "!D"
      // D-ology
        # br <-> D
        # < maniable
        bry&brack = D;
        Dy&brackology = br;
        # g-ology: the viewable unity
        #  c mostly goes to the -group* later
        #  who render things into g
        # since g == br,
        #  gear in br/* (params) may sit near the %groupthing they are for
        # < that should be %grouping, with no label
        #  < because the Kn labels look enough like it
        # < they could hoist elsewhere, eg the minimaps of Abodis,
        # < any -ology should be able to grok Km/Kn/n, see &KnowC
        #   and pipe into projections, gaining extra layout layers
        #   gy&M shall iterate Km for its current group+ology
        # < g-ology projecting its own gy&ology is short circuit
        #   suppose there must be a mediating force between each -ology
        $g = me&piology,R,br,{D}
        
        # we have bry&ology, so:
        # < -groupbrack <-> -groupology
        
        # < g**s&ope %%Savable?
        # < X.ref for inter-group object link
        # < ny&act from a &acting%ope glow
        # < X == by&X && X.i same?
        # < only changes pop up, shrink in
        # < separate sizology
        #    the brackgroup causes -brack on D?
        
      // D index, size
        # Ds&X should be up to date, eg &bracki
        #  or not yet created, eg -gate el:2 D
        $X = me&brackXD,D
        !hak(X.k) and return br
        #-1 - only amounts (rows + uniq t)
        # 0 - t-only
        # 1 - with amounts
        # 2 - t:v, for 1 v only (as now)
        # < t-only, of at the toplevel
        if (gs&pow < 0) {
            $op = me&sizo,g,{t:'rows',len:Ds&z.length,opelen:1};
            # < each type of X.*, will be Km mot
            me&sizo,g,{len:hak(X.k)};
            !(op && ops&ope) and return br
        }
      // D group
        # pre-K** structure pooling
        $gr = me&pigroup,R,br,c
        # i D/K/n o D%X
        $Z = me&pigroupbrack_similark,R,gr,c
        
        # piping into: i K/Km/Kn o D...%X  
        # < D iterates rows of %%K:z,n,Km?,...
        # < K knows which d+z it came from, to repipe...
        #   having slep sensors along the pipe,
        #   solo just the changed stuff
        # in this case we want rows grouped away
        me&Kmish,Z,{for:'K'} (&dz{
            # < might be no regroup, direct from %wou
            d == z and debugger
            # < t? i?
            # piped into modulat from the structuring D/K, now z
            # K is now a Kn:groupology
            # < only to have no label, the joint(arks)
            $K = me&opeKn,g,z.t,{walls:'bd:1.4'}
            # < originate
            Kc&rows = zs&z
            Ks&pow = gs&pow
            Ks&ope = gs&ope
            
            Ks&bgh = 581;
            Ks&dis = 2;
            
            # readies zs&X
            me&Kmish,z
            # K/Km:ark-sim/Kn:C-vat
            # has an X-specific iteration,
            # < D/t/-x
            c.tx = zs&X.k
            c.Kms = me&pitxology,R,K,c
            
            me&pitsograph,R,K,c
        })
        # beyond -brackology: i Km-mod o Km,
        #  knowing how to translate interest in those later expressions,
        #  into focusing this -brackology on certain rows/columns/values
        return br
    }
   
 // -group # i -ology/Km {reasoning} o $info**
  
  // structure pooling -> Km+
    =spec
     < -group makes K for mix of -group*
       mostly we want to:
     
     -groupbrack_similark
     
     < -grouprefs
       
       stepx5: x3CTravel(wakex2), gatex3
        or (wakex2,gate:le-2) if not ^ K/Km/Kn mergible:
         would inject Km with Cn not from that K?
          or inject Kn:gate with Cn&v:
           Cn&v are really multiple, coming from Cn&x.ref
           < iterate &Knish
         yet have them undo if the wake is open
        Cn sizo (explicit x1) if different to Kn sizo
         or (wakex1) if wakex1
       
       puts K=step,node,wake as columns
        because they share a lot of refs
     
     < -groupspace
       puts K=step,node as columns, with an order
        because that is efficient Cn&v^ = Kn&v
         and we can z-order (or something else?) the v**
       or
        because that is Ying/*/** + attention
         and we have a Nodar to order them
      
      should be a pipe, ^ i D o D%X
     
     < D indentifying its structure
       when D = a -group*,
        D provides an iterator for %%Km,D:z
         and more, magical overlaying D:others

      < further D may be another layer of info, relative to origin
         how to traverse the origin to get the grouping
        not the origin in that grouping

      < ideally producing only X (not new D+rows)
        having ways to the original node and indexing qualities against them
        they might have an index of which indexes are important,
         and how to compute metrics for possible layouts
        can &bracko handle that? with joins?
       
       so many X, each perspecting D**
    =spec
    me.pigroup = &acgtRsc{
        $D = me&Api,s,'group'
        c.D and Dy&origin = D
        # Km = agreeable Km,D
        return D
    }
    # D%X
    me.brackXD = &acgtD{
        return Ds&X ||= me&brackX,Ds&z
    }
    me.Kmish = &acgtDc{
        !D and throw "!D"
        c ||= {}
        c.for = 'Km'
        me&brackXD,D
        # depth of C before rows
        $d = Dc&brackin
        # < etc, if we are on a K
        #!d && me.cby(&sd{ try while hak(d)<3 })
        $Dp = Dy&up
        !d && Dp && Dpc&brackin and d = Dpc&brackin-1
        !d and throw "noindex"
        # any D-group* y&M interates Cn, before Km
        return &y{
            d == 1 and $N = [D]
            else {
                $index = [...Array(d-1)].map(t=>'*')
                $N = me&ioty,D,index
            }
            N.map(&C{
                c.for == 'K' and y (D,C)
                else {
                    each in Cs&z {
                        nc&drop and continue
                        y (D,C,n)
                    }
                }
            })
        }
    }
    # < Kmish returning what y (D,C,n) returns ^
    me.resultily = &{
        
    }
  
  // structures
   // addition
    # regroup similar rows
    # allowing a and a+b to fit together,
    #  sizo per column|value communicates the oddness
    # splitting by %%dome:$v
    # < show clearer when Km%ope (tabular?)
    me.pigroupbrack_similark = &acgtRsc{
        $D = me&Api,s,'groupbrack_similark',c
        # i D/K-joint/n o D/n
        # layers of C structure before /n-row
        Dc&brackin = 2
        # the last of which (D/z) informs K.t (no label)
        # < doing this between K already there? is multiply|divide
        me&Kmish,c.D (&dzn{
            zc&pi != 'gate' and debugger
            d != c.D and throw "c.D==d"
            $ks = haks(n.sc);
            $matchness = 0;
            $match = null;
            # < D/K indexed already, for K with k
            #   the X.k/$k might union X.grouptype/K
            #    for different types talks about X.k stuff
            each iK Ds&z {
                # < K having indexes already
                $no = haks(K.c).filter(k => !hak(n.sc,k)).length
                # allowing a and a+b to fit together
                no > 1 and continue
                # splitting by %%dome:$v
                ns&dome != Kc&dome and continue
                $yes = ks.filter(k => hak(K.c,k)).length
                $matched = yes - no
                matched <= matchness and continue
                match = K
                matchness = matched
                #j.t == 'Travel' and me&nu,"matched"+i,[ks.join(','),matched+'('+yes+'/'+no+')'+matchness,c.t]
            }
            if (match && matchness >= ks.length-1) {
                # groups members with <= 1 odd key
                $K = match
                ac(K,'z',n)
            }
            else {
                $K = Cye([ks.join(','),1]);
                # Kc&* are the match
                # < &if
                each kv n.sc {
                    K.c[k] = 1
                }
                Ks&z = [n]
                Ds&z.push(K)
                Ky&up = D
            }
        })
        #N.length == 1 and N = [z]
        return D
    };
   
   // subtraction
    # D-gate/@row+%gate=oD = N/oD/row
    me.pigate = &acgtRsc{
        $D = me&Api,s,'gate'
        $N = c.N
        !N and throw "!N"
        Dc&brackin = 1
        # < i $D/@row%gate=@gate y:row o $s/:gate/:row
        # < separation happening. it's not our $row to eat.
        #   separation coming before the row:{} here
        #   better getting at the row in &ind, grouped by arkfor?
        #   and tw mode, or even t mode (dup keep z)
        #   otherwise works:    this v is io's d.row, not brack row
        # i $D/@row row:{ s&gate = s.row[1] } y o $s/:gate/:row
        # instead:
        Ds&z ||= []
        me&ioty,N .map(&z{
            me&ioty,z .map(&t{
                t = Cye(t)
                ts&gate = z
                ac(D,'z',t)
            })
        })
        return D
    }
   
  // -ology # i $metrics o -ology/K**
   // 1 - br+g
    # viewable end of a -process
    # eg -brackology is -brack... -> -ology
    #  at R:eight/-four/-brackology/-ology,
    #   Rs&M += -ology
    me.piology = &acgtRsc{
        $br = s
        $fo = bry&up
        # < conveniently named after Rc&s.t,(^^^brc&pi) and c.*
        $D = c.D
        # all .t are likely to be the same...
        c.t ||= joint([s.t, fo && foc&pi, brc&pi, 'ology', D && Dc&pi && '<-'+Dc&pi])
        # display title for the c&pi having -brackology above
        brc&pi == 'brackology' and $ot = foc&pi
        
        $g = me&Api,br,'ology',c
        
        # all R/**{,2}/-ology appear
        $appears = br == Rc&s || fo == Rc&s || foy&up == Rc&s
        appears and ac(R,'M',g)
        
        me&ologise,R,g,{}
        $la = gy&label
        me&zu,"la",la
        #ot and c.label.s = ot
        
        bry&M = &y{
            me&ioty,g,'groupthing' .map(m => y(m))
        }
        return g
    }
    
    # some of the smallest structures
    # reversibly|diffily, create transform theory
    # phenom comes in waves
    # waves have a skin
    # skins relate posture
    window.hashkv = &kv{
        $c = {}
        c[k] = v != null ? v : 1
        return c
    }
    
    # hash from k:v, v=1 if not given
    window.peel = &s,sep{
        s == null and return {}
        if (isst(s)) {
            !s.includes(sep||',') and sep={};sep[s]=1;return sep
            # < sep?
            # < rebuild for k:that:go:deeply,
            #   or that@link to indentedchunk later
            #    or object anywhere, if A:*L..A:peel
            #    < rebuild a subset of yaml mostly,
            return G&peel,s
        }
        isha(s) and return s
        throw "not peely", s
    }
    
    # departmentalise c if not already
    #  for s sublating its namespace
    # q.K=1:        c=v -> s.K=v
    # q.K=gk:  c(.K)?=v -> s.K.k=v
    # is basically:
    #  !q.qk and q = {qk:q}
    # smallest totality?
    #  people fall in a ditch that triangle will not fix
    window.arranq = &cq{
        # c fated to mix into s.$K, not s
        #  unless it knows any of these $k
        !q.qk and throw "index"
        $qk = haks(q.qk)
        # the default department first
        $K = qk[0]
        $gk = q.qk[K]
        
        if (isst(c)) {
            # < peeling this?
            # c="st" -> c.label(.s)?="st"
            c = gk == 1 ? c : hashkv(gk,c)
            c = hashkv(K,c)
        }
        elsif (isha(c)) {
            # for any department, or the default
            $match = qk.filter(K => hak(c,K))
            if (!hak(match)) {
                # c.s:C -> c.label.s=C
                c = gk == 1 ? c : hashkv(gk,c)
                c = hashkv(K,c)
            }
            else {
                each iK match {
                    $v = c[K]
                    # leave c.label={...}
                    isha(v) && !isC(v) and continue
                    # v could be string
                    # c.label=C -> c.label.s=C
                    $gk = q.qk[K]
                    c = gk == 1 ? c : hashkv(gk,c)
                    c = hashkv(K,c)
                }
            }
            # preserves the c passed in
            #c = ex({},c)
        }
        else {
            throw "type"
        }
    }
    # s=k:v hash copy after arranq()
    #  c can stay string if ^ takes it beyond c.*.*
    # v merges if both hash
    # s|c being C is fatal
    #  < could have something on it?
    # v not being hash is fatal
    #   which is where exts() would give it a key
    #   unless v=1,
    #    logically compatible with v={...}
    window.expe = &scq{
        # ensure c is a hash
        $origin = c
        if (q) {
            # get a list of words
            q = peel(q)
            # arranq() is basically:
            !q.qk and q = {qk:q}
            
            # may departmentalise c
            c = qarrang(c,q)
        }
        return ex2(s,c)
    }
    window.ex2 = &scq{
        c = peel(c)
        isC(s)||isC(c) and throw "expe..C"
        each kv c {
            $V = s [k]
            if (V && isha(V) || v && isha(v)) {
                # allows either $v to:
                #  peel if other is hash
                isst(V) && isha(v) and V = peel(V)
                isst(v) && isha(V) and v = peel(v)
                #  replace 1->{}
                V = exable(V)
                #  and|or premix arrays in v.*
                v = exable(v,V)
                # mixing v into V
                ex(V,v)
            }
            else {
                # replacing
                V = v
            }
            s [k] = V
        }
        return s
    }
    # will it ex()
    # s = one argument to ex() at a time
    # returns s or a coercion to replace it:
    #  s=null|1 -> {} coercion
    #  s.* and c.* array pre-mixing
    window.exable = &s,c,fatal{
        # returns coercions or false
        !s and return {}
        s == 1 and return {}
        isar(s) and throw "what?"
        if (!isha(s)) {
            fatal and throw "!exable",s,c
            return 0
        }
        # < Cy&sortin patch-conforming c, putting el:8 etc
        #   exable(c,s) becomes lv(s,c)
        #   ex(s,c) becomes el(s,c)
        isC(s) and throw "exC"
        if (c) {
            # premix arrays
            # c,s are the s,c from ex(s,c)! upside down.
            #  here, s merges into c
            #  because we can replace s
            #    as returning a coercion
            #   with a copy with pre-mixed arrays
            # < does it uniq, or have:
            #    a sort-in function on s.* or isC(V)?
            #   if k=ref, has to renumber or create subnet
            s = ex({},s)
            each kv s {
                $V = c[k]
                (!v || !isar(v)) && (!V || !isar(V)) and continue
                # < coerce V==0 -> []?
                V && isar(v) && !isar(V) and throw "ex not<-array"
                v && isar(V) && !isar(v) and throw "ex array<-not"
                s[k] = [...(V||[]), ...(v||[])]
            }
        }
        return s
    }
    # s=K.k:v hash copy
    # with q, c may be (already)? departmentalised
    # s.label = "st", c.label = {...} is fatal
    #  in reverse however, s will .label:{...,s:"st"}
    #   given q.label:"s"
    # c="st" or c=K/"st" may -> s=K/"s":"st"
    #  if q.es[K] (not peeled?)
    # eg la:{ya:2} + la:three -> la:{ya:2,s:three} (K="la")
    window.exts = &scqk{
        if (k) {
            # specifying a pair
            !isst(q) and throw "q+k"
            q = {qk:hashkv(q,k)}
        }
        else {
            # get a list of words
            q = peel(q)
            !q.qk and q = {qk:q}
            # with a default gk='s'
            $qk = haks(q.qk)
            hak(qk) == 1 && q.qk[qk[0]] == 1 and q.qk[qk[0]] = 's'
        }
        return expe(s,c,q)
    }
    
    # clickable, energised, etc
    me.ologise = &acgtRgc{
        $tog = me&togcon,R
        $q = {
            walls:'b:2.2',
            label:{walls:'bg',tog},
            tog,
        }
        # ex(q,c) with q.label.s = c.label
        exts(q,c,'label')
        # < move out
        c.sc and ex(g.sc,c.sc)
        gs&hue = 30
        gs&ws = 0
        me&applystylec,g,c,{};
        me&opelabel,g,c.label;
        me&opewires,g;
        
        # energised
        gs&ope and gs&pow = gs&ope
        gs&pow ||= 0
        if (gs&pow > 1) {
            #gs&float = 'right';
            #gs&dis = 2;
        }
    }
    # temperature
    # < generalise from label only
    # for within elvising on s-pi,
    #  where its ^^^.t must be uniq
    me.togcon = &acgtR{
        $C = Rs&C
        $z = Rc&s
        return &gq{
            ~>3 Togable: q.name, z.t
            # q.name qualifies up g to R
            $ok = q.name
            !q.name and throw "named!?"
            
            $n = q.n = me&mtsc,g,q.may,q.s,'y'
            
            $issetor = &z,is{
                ~>3 Togs: q.name, z.t, is
                z.y [ok] == null && is != null and z.y [ok] = is
                return z.y [ok]
            }
            $ope = 1
            # -1..2 adjustable
            me.nto(R,n,&sTe{
                $add = e.t.startsWith('C') ? -1 : 1
                # may start from an ope we inherit
                $is = issetor(z,ope) || 0
                is += add
                is > 2 and is = 2
                is < -1 and is = -1
                z.y [ok] = is
            })
            # inherit last defined ok
            zy&R && me.cbu(zy&R,&r{
                $z = rc&s
                if (z) {
                    $te = rs&Te
                    # may remember over null
                    te and issetor(z,te.sc[ok])
                    $is = z.y [ok]
                    if (is != null) {
                        te.sc[ok] = is
                        ope = is; return 1
                    }
                }
                rs&Peace == 4 and return 1
            })
            ns&fs = 9+(ope*2)
            ns&ope = ope
            return n
            # to &vlabinto, &opelabel
        }
    }
   
   // 3 i K/Km/Kn
    # i Km:t c.tx=X.k /t/x
    me.pitxology = &acgtRgc{
        !c.tx and throw "!tx"
        $Kms = [];
        each tx c.tx {
            $Km = me&opeKm,g,t
            #Kmc&k = t
            Kmc&x = x
            Kms.push(Km)
        }
        # energise it
        # < sizography of the K+
        gs&pow < 2 and gs&ma = 0.2
        each i,Km Kms {
            Kms&pow = 1
            $con = c.kc && c.kc[k]
            con and ex(Km.sc,con)
            gs&ope && Kms&ope == null and Kms&ope = 1
            Kms&ope and Kms&pow = gs&pow = 2
            gs&pow ||= 0
            
            if (Kms&pow < 1) {
                Kms&ma = 0.1
                Kmc&left_blank = 1
                continue
            }
            # open
        }
        return Kms
    }
    # draw openable /ref/z
    me.pitsograph = &acgtRgc{
        $Kms = c.Kms
        !Kms and throw "!Kms"
        each i,Km Kms {
            $x = Kmc&x;
            # total values for key, Km%ope if 1
            me&opesizup,Km,{len:hak(x.ref)};
            !Kms&ope and continue
            
            fio(Km,['ope',1,{s:":"},'hs:888']);
            $vii = 0;
            each vi,fx x.ref {
                $v = x.refs[vi];
                $lc = me&slabeline,v
                $Kn = me&opeKn,Km,lc.t,{label:{tsc:'y'}};
                Kny&v = v
                ac(Kn,'vis',vi)
                
                $lab = Kny&label;
                $bsize = Knc&size || Knc&sortcv && 1 || 0
                Knc&sortcv = 1;
                lc.C &&
                    fio(Kn,['sym'+vi,112,{s:lc.sym},
                    'label,fs:13,lh:0.8,hs:757']);

                # total rows for this value with this key
                # < light up other k/v/rows this k/v/row has
                Knc&size = 0
                me&sizo,Kn,{len:fx.z.length};
                # many same lc.t pile up many sym, add sizo
                # < fix in -ology
                Knc&size ||= 1
                Knc&size *= 1
                bsize and Knc&size = (Knc&size||1)*1 + bsize*1
                Knc&size == 1 and delete Knc&size
                Knc&size > 1000 and debugger
                Kns&ma = 0.2;
                if (Kns&ope) {
                    each in fx.z {
                        $val = n.sc[k];
                        $na = [g.t,k,vi,i].join("'");
                        $wa = me&opeKn,Kn,na;
                        way&cv = 0.2;
                        was&dis = 1;
                        # sprout icon, some non-nu to click
                        $wan = me&opeKn,wa,'Ü¤',{label:{tsc:'y'}};
                        if (wans&ope) {
                            # whole row
                            me&mnu,wa,'row',n
                        }
                        else {
                            # for the value
                            me&mnu,wa,k,val;
                        }
                        wany&cv = 0.8;
                    }
                }
            }
        }
        return g
    }
    # a title for $s, data if weird
    # < -vat compat, fliop
    me.slabeline = &acgts{
        $c = {}
        if (isC(s)) {
            c.C = 1
            c.sym = isR(s) ? 'R' : 'C'
        }
        c.t = c.C ? s.t :
            s == null ? '*null' :
            isst(s) ? s :
            isob(s) ? ki(s,2) : ""+s;
        return c
    }
   
   // 6 o K**, other
    # storable -four/Km/ref
    me.pilegs = &acgtRsc{
        $Km = c.Km
        !Km and throw "!Km"
        c.t ||= joint(Km,'-','gate')
        $mg = me&Api,s,'legs',c
        me&ioty,Km .map(&Kn,{
            $N = me&ioty,Kn
            #me&nu,"Kn:"+Kn.t,N
            $gr = me&fiu,mg,Kn.t
            grc&pi = 'leg'
            Knc&size and grs&size = Knc&size
            gry&leg = Kn
            if (Kn.t != 'gate') {
                $x = Knc&x
                $ii = 0
                # ology modulat compresses same v.t along N
                #  to simplify order of every ref
                each in N {
                    !ns&vis and continue
                each i,vi ns&vis {
                    $fx = x.ref[vi]
                    $v = x.refs[vi];
                    # how many times it was used
                    $gv = me&fiu,gr,''+(ii++)
                    gvc&pi = 'vat'
                    gvc&s = v
                    gvs&size = fx.z.length
                    gvs&size == 1 and delete gvs&size

                    $nN = me&ioty,n
                    each iz nN {
                        zs&groupthing and debugger
                        # size,sym,label
                    }
                }
                }
            }
            else {
                # mute %%gate after size
                # < in such a way that Te|diff can inflate it
                $aft_size = 0
                each in N {
                    aft_size and ns&dis = 0
                    n.t == 'size' and aft_size = 1
                }
            }
        })
        return mg
    }
   
    
   
   