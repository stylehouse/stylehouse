# lines of characters, etc!
 
 // -String etc
     // &Stringclue|chew
        # used in &drawtextliner
        me.drawString = &acgtsc{
            c ||= {}
            !isob(c) and c = {tsc:c}
            # detect clue.say|pi|hs (|crush|geo|odd)
            $clue = me&Stringclue,s,{}
            
            $n = me&ts,'string','',c.tsc
            ns&fs = 8
            ns&hs = clue.hs
            
            # always add marks
            me&Stringchew,n,ex(clue,c)
            
            return n
        }
        # string-ish type checker
        me.Stringclue = &acgtsc{
            isob(s) and debugger
            c ||= {}
            c.say = ''+s+''
            
            # undef|null
            s == null and c.pi = 'Null'; c.hs = 559
            else
            # true|false
            isbo(s) and c.pi = 'Bool'; c.hs = 559
            else
            # data was number
            isnu(s) and c.pi = 'Number'
            else
            # number-looking and number-acting
            num(s) and c.pi = 'Num'
            
            else {
                !isst(s) and debugger
                c.hs = 584
                # < large, Lines, binary, base64 etc
                # rudimentary large safety
                $r = c.R
                $large = r && rc&d < 2 ? 150 : 50
                if (c.say.length > large || c.geo) {
                    $geo = c.geo ||= {}
                    $size = me&textsize,c.say,geo
                    if (geo.lines > 12 || geo.length > 200) {
                        # on screen
                        c.say = cint(size,dig(s))
                        c.crush = 1
                        $R = c.R
                        if (R) {
                            # note a crush
                            me&ha,R,'limit:Longstring',{},{size}
                            # becomes Dc&s, as opposed to Ec&s == s
                            Rs&Longstring = c.say
                        }
                    }
                }
                if (c.crush || c.say.match(/\W/)) {
                    c.odd = 1
                }
            }
            
            # colour
            c.pi == 'Null' || c.pi == 'Bool' and c.hs = 559
            c.pi && c.pi.startsWith('Num') and c.hs = 583
            
            return c
        }
        # modulate n/** with coloured bits of string!!
        me.Stringchew = &acgtnc{
            $M = ns&z ||= []
            if (c.crush) {
                m crushed-string  s:~ %fs:20,lh:0.7
                m it  $s:c.say
                return
            }
            # < &tt could say bring it all
            #  < into a codemirror
            # annotating space-types is all we want?
            $L = c.say.split(/(?<=\S)(?=\s+\S)/)
            $la = 0
            $p = me&parserify,'ya'
            each il L {
                # gets nibbled down eg (\n)(    )(stuff)
                p.s = l
                while (p.s.length) {
                    if (p.p(/^ +/)) {
                        $sayspace = c.squishindent ? " " : p.it
                        m space  $s:sayspace
                        $len = p.it.length
                        len > 1 &&
                            m spaces  $s:len %mark,little
                    }
                    if (p.p(/^\t/)) {
                        m tab  s:⇥ %mark,wide
                    }
                    if (p.p(/^\n/)) {
                        m nl  s:␤ %mark
                    }
                    if (p.p(/^\S+/)) {
                        m it  $s:p.it
                    }
                }
            }
            
            each in M {
                ns&mark and ex(n.sc,peel('mr:0.1,lh:0.7,hue:100'))
                # < scale-x?
                ns&wide and ns&lh = 0.5; ns&fs = 16
                ns&little and ns&fs = 7
            }
            
            # < c.subsel a bunch of ｢40｣ to sprinkle through
            #    or anything, with &textsprinkle
            #    a &textarrow could be put somewhere in a -String
            #   if not whole, c.quote=1
            
            # quote whole
            $marks = !c.subsel ? ['｢','｣'] : ['«','»']
            m brack-start  $s:marks[0] %mark,start
            m brack-end  $s:marks[1] %mark
            grepout(M,n => ns&start).map(n => M.unshift(n))
        }
 
 // Diff
   # < copy from Soogle
 
 // Ploy = (D Comp D)**
    # classifies differences
    // Ploy
        # proto io, on 3c&iocall(X|x,...)
        # < compile &iocall to A.3.i.iocall
        me.Ploy_io = &acgt{
            A.3 != A and debugger
          // io, iz
            3c&io = &xkv{
                # all indexes are k:v (&X_t)
                # ~~ c.wild: vx={v:x+}
                v == '.*' and return x[k]
                # or x+
                v == '*' and return havs(x[k])
                v == -1 and return havs(x[k]).pop()
                return fi&Xsimp,x,hashkv(k,v)
            }
            # push to eg sph|nod/$line=i++
            3c&iz = &Xkx{
                $many = 3c&io(X,k,'*')
                $i = hak(many)
                # we may mesh|multi-path|link X...x
                x and ahk(X,k,i,x)
                else {
                    # or new ..x as usu
                    x = 3c&io(X,k,i)
                }
                # meshing may eg i_line|mine
                # < crude avoidance of same-index sequence distribution
                #   having a subset at some locale
                x['i_'+k] = i
                return x
            }
          // o, oy
            3c&o = &xs{
                $path = split(s,/\/|(?=\.)/)
                $N = [x]
                each in path {
                    if (n.startsWith('.')) {
                        # eg bit.l
                        N = N.map(x => x[n.slice(1)])
                    }
                    else {
                        N = flatten(N.map(x => 3c&io(x,n,'*')))
                    }
                }
                return N
            }
            3c&oy = &xsy{
                $N = 3c&o(x,s)
                $lai = hak(N)-1
                $M = []
                each in N {
                    # < gr3p(): y(v,k,setc) about where you are
                    #    and relations nearby, is very almost io
                    $setc = {}
                    0 == i and setc.first = 1
                    lai == i and setc.last = 1
                    
                    $ret = y (n,setc)
                    setc.not and return
                    ret and M.push(ret)
                }
                return M
            }
        }
        me.Ploy = &acgt,nav,Comp{
            A = fi&At,"Ploy"
            A.3 = A
            $X = 3c&X = {A}
            me&Ploy_io

            # nav.* = RE
            # see &Ploy_nod_next
            #  for our swerve into the first_truest after RE
            # < have pointers to these things, time specified. lv C.
            map(&RE,{
                # RE//s (on the same node)
                $s = REy&ers
                !s and debugger
            },nav)
            
            # sph/nod|lin
            $tops = armap(&et{
                # for old|new E**
                $sph = 3c&io(X,'sphere',t)
                sph.sphere = t
                # line 0
                $lin = 3c&iz(sph,'line')
                # node 0
                $nod = me&Ploy_i_nod,sph,e
                $D = nod.D
                !Dy&toLines and debugger
                me&Ploy_i_lin,nod,lin
                return nod
            },nav)
            # join 0
            me&Ploy_i_joi,'given',tops
            
        // Comp/$l -> $sph
            me&boxcap,'Ploy',5 (&ml{
                lc&not = 1
                each il Comp {
                    
                    ly&seqi = i
                    A = A.3
                    me&drawdiffbit,i,l
                    
                    $who = l.t == 'same'
                        # == are for both spheres
                        ? havs(3c&io(X,'sphere','*'))
                        # ++|-- only for sph:new|gone
                        : [3c&io(X,'sphere',l.t)]
                    
                    who.map(sph => me&Ploy_sph,l,sph)
                    
                    A = A.3
                    
                    # after &Ploy_fail
                    3c&not and me&tc,"Abort",'G'; break
                    
                    # to A3:Ploy/A:join+
                    3s&joined and me&Ploy_joined
                }
                
                
                
                # check we found our way back to each sph/nod0
                $lost = tops.slice()
                grop(3s&seemsdone,lost)
                hak(lost) and me&Ploy_fail,"seemsdone",ex({},lost)
            })
            return X
        }
        
        # l -> sph, matching
        me.Ploy_sph = &acgtl,sph{
            3c&not and return
            # to A3:Ploy/A:l+
            #  A:l always up to A3
            A = A.3
            $title = 'l:'+ly&seqi+':'+sph.sphere
            # nod remembered by last sph/lines
            #  can return null if !Dy&toLines
            $a = me&Ploy_nod_arrive,sph,l,title
            !a and 3c&not = 1; return
            A = a
            fatal.isC(A&nod.E)

            !A&nod.joi and debugger
            me&Ploy_joi_arrive

            if (ls&moren) {
                # l%moren is a fold marker, everything inside is t=same
                #  we avoid leaving to nod**, which are spared from Comp
                #  it is otherwise a regular l, for A&nod
                # < (upstream) shouldnt %moren if many is small
                #    > unless many small %moren close together
                $many = hak(ls&moren)
                !(isar(ls&moren) && many) and debugger
                A&nod.hasmoren = many
            }
            me&Ploy_indent_sympathy
            me&Ploy_match
            3c&not and return
            me&Ploy_nod_check
            ls&moren && !(a&newline && a&newnode) and debugger
            # join l sequence
            me&Ploy_joi_lit
            me&Ploy_noded
        }
    
    //  nod
        # ^nod|sph += nod
        me.Ploy_i_nod = &acgtxe{
            $sph = x.sph || x
            # climb /$in** = nod, so nod.up reflects Ey&up
            $nod = 3c&iz(x,'in')
            nod.d = (x.d||0) + 1
            # link sph/$node flatly (width first, !~~ &ind)
            3c&iz(sph,'node',nod)
            # nod knows:
            nod.sph = sph
            nod.E = e
            !ey&R and throw "undone E"
            nod.D = Aof(e,'D')
            # the RE doesnt have a D**
            # < should it? ~~ Js&top: $W@9/*
            #   and the RE/-hat|etc is an osc page
            #    so each page has an encoding defined as pi
            #     which may index pages by something else (t)
            #    and W formats are explained as eg $Wt/1.js
            #     which -js will be able to read,
            nod.D ||= nod.i_node == 0 && nod.E
            # eventually /$line of its diffside
            return nod
        }
        
        
        
        # the usual arrive, think, descent
        #  the usual particle (A.1) is basically nod**
        #   nod is also per sph
        #   A:l is per l
        #    for a nod finding it has /lin/bit
        me.Ploy_nod_arrive = &acgt,sph,l,title{
            A = fi&At,title

            # sph/$line/$bit .l|str
            $lin = 3c&io(sph,'line',-1)
            !lin and throw "nolin"
            $bit = 3c&iz(lin,'bit')
            bit.l = l
            # lc&s is a displayified string, sometimes has s/\n/↯/
            !isst(ls&string) and debugger
            $str = bit.str = ls&string
            # join: one lin to many l
            hak(str)-1 < str.indexOf("\n") and throw "many lin to one l"

            $nod = lin.nod
            # -Fez is C-shy
            $V = nod.prev && nod.prev.A
            nod.A = A
            # a second opinion on next nod, from last A:l
            V && Vs&next && nod != Vs&next and debugger
            
            ex(A.c,{sph,nod,lin,bit})

            # so we A3:Ploy/A:l+
            if (!V || Vc&nod != nod) {
                $D = nod.D
                nod.whole = Dy&toLines
                !isst(nod.whole) and debugger
                !isst(nod.whole) and return me&Ploy_fail,'toLines',{l}
                me&drawnod,nod
            }
            
            return A
        }
        
        
        # next nod|lin
        me.Ploy_noded = &acgt{
            # per sph:
            $nod = A&nod
            $lin = A&lin
            if (a&newnode && a&newline) {
                # tidy away nod
                delete nod.matchtil
                nod.Cindent && nod.Cindent == nod.d-1 and delete nod.Cindent
                nod.ok = 1
                # more nodes
                $next = me&Ploy_nod_next
                if (!a&seemsdone) {
                    !next and return me&Ploy_fail,"nextless"
                    isC(next) and return me&Ploy_fail,"nextC",{next}
                    nod.next = next
                    next.prev = nod
                    nod = a&next = next
                }
                # let join happen
                ac(A.3,'joined',A)
                a&seemsdone and return
            }
            if (a&newline) {
                # tidy away lin
                delete lin.indent_sympathy
                # < until a multi-lines y&toLines
                !a&newnode and debugger
                # make empty lin to use next time around
                lin = 3c&iz(A&sph,'line')
                me&Ploy_i_lin,nod,lin
            }
        }
        # more nodes: nod/*[0] first, then ^^/[nod+1]
        me.Ploy_nod_next = &acgt{
            $E = A&nod.E
            $N
            # as long as we want to go into nod**, see l%moren
            $inward = !A&nod.hasmoren
            # i nod/* o E/*
            if (inward) {
                if (A&nod.i_node == 0) {
                    # is an RE, use first_truest rendition of eg RE/-hat
                    $truest = ahsk(Ey&ers,'y','first_truest','E')
                    # and there is only ever one RE/E (outside/inside &Piing)
                    truest and N = [truest]
                }
                # < generalise o E/*
                N ||= me&ioty,E .filter(e => ey&R)
                # creates all nod/nod:$e for later
                #  and sph/node width first: is not nested: 1, 2, 1/1...
                #   !~~ &ind: 1, 1/1, 2...
                N = N.map(e => me&Ploy_i_nod,A&nod,e )
            }
            $next
            hak(N) and next = N[0]
            else {
                # climb out until a next in
                me&Ay,A&nod,'/^^',{},{} (&nda{
                    # be a node
                    # n/[a+1]: another one after
                    n.in[a.i_in] != a and debugger
                    next = n.in[a.i_in*1+1]
                    if (!next) {
                        if (!n.i_node) {
                            # returns to the root at the end
                            ac(A.3,'seemsdone',n)
                            a&seemsdone = 1
                            d.not = 1
                        }
                        # keep going up
                        return
                    }
                    # we have a node
                    d.not = 1
                })
            }
            return next
        }
    
    //  lin
        me.Ploy_i_lin = &acgt,nod,lin{
            $sph = nod.sph
            sph.line[lin.i_line] != lin and debugger
            # nod/$mine is a subset of sph/$line
            3c&iz(nod,'mine',lin)
            # join: one nod to many lin
            lin.nod = nod
        }
        # line may start with spaces, to imagine into exp
        me.Ploy_indent_sympathy = &acgt{
            # leading bits, until [^ ] is found
            $bit0 = A&bit.i_bit == 0
            bit0 and A&lin.indent_sympathy = 1
            !A&lin.indent_sympathy and return
            
            # < until multi line D, but only when:
            #    flip indent_sympathy back on for lin-1 that BQ ?
            #     ie choose your own next indent for < < ' '
            $lin0 = A&lin.i_mine == 0
            !lin0 and debugger
            
            # we only ever make C-indents (Linesing C/*) outside of D
            !A&bit.str.startsWith('  ') and return delete A&lin.indent_sympathy
            # count ^(  )+
            $level = hak(ksaf(A&bit.str,{bow:s => s != ' ',may:1}))
            $Cindent = Math.floor(level/2)
            # < never odd? or see Lines / BQ
            level != Cindent*2 and debugger
            
            # we sometimes (++  )(==      yada)
            $entirely = hak(A&bit.str) == level
            if (entirely) {
                # (++  ) should keep going
                # maybe even through (++  )(==      )(++yada)
                #!bit0 and debugger
            }
            # more indent on (==      )
            !bit0 and A&nod.Cindent += Cindent
            
            # ends at [^ ]
            !entirely and delete A&lin.indent_sympathy
            
            # the first line of D has the real indent
            if (A&nod.Cindent) {
                # < sanity (was simple before more indent)
                #    - lin>0 should have at least ' ' more than lin0
                Cindent = A&nod.Cindent
            }
            elsif (A&lin.i_mine == 0) {
                # nod/lin 0 == first line of D
                A&nod.Cindent and debugger
                A&nod.Cindent = Cindent
                # < until treating haphazard text as input
                #    eg see codes / spec / pre-tangent
                #     which wouldnt be a Cindent per se
                #  < or BQ-embedded nodes...
                # this is normal when entirely, eg (++  )
                Cindent != A&nod.d-1 && !entirely and debugger
            }
            
            $relevel = Cindent*2
            # may be spread over many bits, eg (++  )(==      )(++  yada)
            #  we only want to trim this one bit
            3c&io(A&lin,'bit','*') .map(&bit,{
                bit != A&bit and relevel -= bit.trimstart||0
            })
            relevel != level and debugger
            relevel < 2 and debugger
            
            # < check what comes off is ' '+
            A&bit.trimstart = relevel
        }
        # note if|how we change exp to make things fit
        me.Ploy_mung = &acgt,bit,t,v{
            ahk(bit,'mung',t,v||1)
        }
        # nod/whole <-> nod/mine/bit
        me.Ploy_match = &acgt{
            $nod = A&nod
            $lin = A&lin
            $bit = A&bit
            # cursor whole to match
            $at = nod.matchtil || 0
            $str = bit.str
            # str never goes beyond \n
            str.slice(-1)[0] == "\n" and a&newline = true
            # whole does
            $whole = nod.whole
            !hak(whole) and debugger
          // lying
            # ignore str indent, coming from D** travel
            bit.trimstart and str = str.slice(bit.trimstart)
            # < dropping \n from bit, via this mechanism
            #   rather than adding one to exp if non-match now
            #    tho it does get us the \n between many nod/lin
            #     that would be visible as exp[-1]=="\n"
            bit.trimend and str = str.slice(0,hak(str)-bit.trimend)
            # < more munging the expression
            #    eg expect sequence number adjustment
            #    eg between different compressions
            #     one might deL->???->enL

            $len = str.length
            $til = at+len
            $exp = whole.slice(at,til)


            if (exp != str && a&newline) {
                # no \n in y&toLines
                me&Ploy_mung,bit,'+␤'
                exp += "\n"
                til -= 1
                $mungnl = 1
            }
                # < sort out indent funcs
                #    we seem to have .d starting at 1->'', etc
                #    Lines wants to indent by ' ' sometimes
                #   this one does it to exp, multiliney
                #   not too straight forward when exp may end in \n
                #    it should follow input strings form?
                #     and separate casting blah->blah\n
                #indents((nod.d-1)*2,exp,
                #    !ahsk(bit,'mung','+␤') && 'notailn'
                #)
            # should yield the whole line?
            mungnl && til != whole.length and debugger
            
          // so
            ex(A.sc,{str,exp})
            if (exp != str) {
                return me&Ploy_fail,'eq'
            }
            
            # may match nothing
            nod.matchtil == til and a&tilstill = 1
            #  that wasn't just (==\n)
            a&tilstill && !(mungnl && exp == "\n") and a&seeknod = 1
            
            nod.matchtil = til
            til == whole.length and a&newnode = true
        }
    
    //  lit, col, jin/lin/col, joi/lit|jin
        # joi/lit .l, /bit
        #  l-ordered bits of either sph
        me.Ploy_joi_lit = &acgt{
            $bit = A&bit
            $l = bit.l
            $la = 3c&io(3s&joi,'lit',-1)
            $lit = la && la.l == l ? la
                : 3c&iz(3s&joi,'lit')
            lit.l = l;
            # lets not inform of the rewire..? its just i_sphere
            (lit.bit ||= []).push(bit)
        }
        
        # lazily nod/lin/col, per nod via joined
        me.Ploy_nod_col = &acgt,nod{
            3c&io(nod,'mine','*') .map(&lin,{
                3c&io(lin,'bit','*') .map(&bit,{
                    me&Ploy_lin_col,lin,bit
                })
                # Lines always t,y,c
                # < reintroduce this... tripped when jois&seeknod
                #hak(lin.col) < 3 and me&Ploy_fail,"endon-col:c|sc",lin.col
            })
        }
        # i lin/col/microcol o lin/bit
        # to see col=$nk=t|y|c|sc, assuming Lines encoding
        me.Ploy_lin_col = &acgt,lin,bit{
            $nod = lin.nod
            $str = bit.str
            if (lin.i_mine == 0) {
                # tidy str
                # < indent column? ~~ lin.indent_sympathy
                lin.indent_sympathy and str = str.slice(0,nod.Cindent)
                # < what is "string".trimEnd() ?
                str.slice(-1)[0] == "\n" and str = str.slice(0,hak(str)-1)
                
                # have columns
                # < other than Lines + tycsc
                # < other than lin0 is nk,gk,quotes,star**
                # names of the next col
                $cols = ['t','y','c','sc']
                # last lin/col
                $col
                $i = 20
                while (hak(cols)) {
                    i-- < 0 and throw "col loops"
                    $had = lin.col && lin.col[cols[0]]
                    had and col = had; cols.shift()
                    else break
                }
                
                # fill up col+ from bit.str
                $N = str.split("\t")
                each is N {
                    if (!col || 0 < i) {
                        # new col
                        $ark = cols.shift()
                        !ark and debugger
                        col = 3c&io(lin,'col',ark)
                        col.ark = ark
                    }
                    # nothing at this point
                    !s.length and continue
                    
                    # since bit may break at any point in a column
                    $mc = 3c&iz(col,'microcol')
                    mc.str = s
                    mc.bit = bit
                    # > keeping in|out points of str in bit, etc
                    
                    # for nod/*lin/*col.changey
                    bit.l.t != 'same' and mc.changey = col.changey = 1
                }
            }
            else {
                me&Ploy_fail,"multiline"
            }
        }
        
        # i joi/#lin:jin/#col:jol/#with:jodol o nod/lin/col
        # joi gathers C.*.* change in stereo (or mono)
        #  only changey
        # < 3c&ioing()?
        me.Ploy_joi_jin = &acgt,joi{
            $lin_quant
            3c&io(joi,'with','*') .map(&nod,{
                $sph = nod.sph
                # sanity: same number of /lin
                lin_quant != null && lin_quant != hak(nod.lin) and debugger
                lin_quant = hak(nod.lin)
                # assumes each node's nod/lin align
                # < see resolve $n
                3c&io(nod,'mine','*') .map(&lin,{
                    # /#lin:jin
                    $jin = 3c&io(joi,'jin',lin.i_mine)
                    3c&io(lin,'col','*') .map(&col,{
                        # /#col:jol
                        fatal.isst(col.ark)
                        $jol = 3c&io(jin,'jol',col.ark)
                        
                        #  /#with:jodol, now per node
                        $jodol = 3c&io(jol,'jodol',nod.i_with)
                        jodol.nod and debugger
                        jodol.nod = nod
                        
                        # col from either node -> shared line, column
                        sex(jin,col,'changey')
                        sex(jol,col,'ark,changey')
                        #  and jodol, is per node
                        sex(jodol,col,'ark,microcol,changey')
                    })
                })
                
            })
            3c&io(joi,'jin','*') .map(&jin,{
                # lin for both nodes
                3c&io(jin,'jol','*') .map(&jol,{
                    # lin/col for both nodes
                    fatal.isst(jol.ark)
                    if (jol.changey) {
                        # make whole of either sph columns
                        # < someday, decompress each via &Lines
                        #    would make whole from nod/lin/bit
                        3c&io(jol,'jodol','*') .map(&jodol,{
                            $nod = jodol.nod
                            jodol.whole = ''
                            3c&io(jodol,'microcol','*') .map(&mc,{
                                jodol.whole += mc.str
                            })
                        })
                    }
                    else {
                        delete jin.jol[jol.ark]
                    }
                })
            })
        }
        
        # classify C.*.* change
        # < to somewhere, for regionating
        # < u Ploy
        me.Ploy_pernkgk = {sc:{'♲':8}}
        me.Ploy_drawjoin_jin = &acgt,joi,g{
            # modulats passed in:
            #  g.joim = the join row
            #  g.ldraw[ly&seqi] = l drawing
            
            # each jodol/microbit.bit.l is in here
            $ls = 3c&io(joi,'lit','*') .map(lit => lit.l)
            3c&io(joi,'jin','*') .map(&jin,{
                # lin for both nodes
                3c&io(jin,'jol','*') .map(&jol,{
                    # changey lin/col for both nodes
                    !jol.changey and debugger
                    $arks = 3c&io(jol,'jodol','*') .map(jodol => jodol.ark)
                    $ark = theone(uniq(arks))
                    $jodols = jol.jodol
                    !hak(jodols) and debugger
                    
                    $arksay = ark == 'sc' ? '%' : ark
                    me&boxcap,arksay,4 (&ml{
                        me&walls,m,'b:2.2h4'
                        $maq = me&tc,'match-quality','6g'
                        maqs&dis = 2
                        $qual = 9
                        $down = &v{
                            qual > v and qual = v
                        }
                        
                        if (ark == 'sc') {
                            # can let a few things off
                            $eith = map(jodol => peel(jodol.whole),jodols)
                            hakd(...havs(eith)).map(&gk,{
                                $know = ahsk(me.Ploy_pernkgk,ark,gk)
                                # < further. seq++ numbers? pointer much changing?
                                know ||= 5
                                !num(know) and debugger
                                down(know)
                                me&boxcap,"gk:"+gk,2 (&ml{
                                    me&walls,m,'b:2.2h4'
                                    lc&s = gk
                                    me&tc,'yup' .sc.dis = 0
                                })
                            })
                        }
                        else {
                            # t|y|c completely
                            down(1)
                            #me&tc,'yup' .sc.dis = 0
                        }
                        
                        maqc&s = qual
                        if (qual == 9) {
                            return mc&not = 1
                        }
                    })
                })
            })
        }
    
    //  joi
        =join
          sequence of nod on either side (nod(-nod)?)
           per either of them having a&newnode
          nod.joi given by &Ploy_join / 3c&ijoin
          draw a join table
            < de-indent every so often
              describing the branch stepped into
          
        =cut
       // join f
        # 3s&joi++, with N=[nod +], initially or by &Ploy_joined
        me.Ploy_i_joi = &acgttN{
            $joi = 3c&joi = 3c&iz(3c&X,'join')
            # reason eg given|leaving
            joi.given = t
            # factoid collection, via &joisc
            joi.sc = {}
            # joi/with=nod, nod.joi
            N.map(&nod,{
                # should be a node
                nod.i_node == null and debugger
                # not yet joined
                nod.i_with != null and debugger
                3c&iz(joi,'with',nod)
                nod.joi and debugger
                nod.joi = joi
            })
            # become the latest join
            3s&joi = joi
            return joi
        }
        me.joisc = &acgt{
            ahk(A&joi,['sc'],...[...arguments].slice(4))
        }
        
        # after nod arrives
        me.Ploy_joi_arrive = &acgtN{
            A&joi = A&nod.joi
        }
        
       // join++
        me.Ploy_joined = &acgt{
            A = fi&At,'join:'+3s&joi.i_join
            # we are the joined joi
            $joi = A&joi = A&old = 3s&joi
            # passes A:l+, are per sph
            $N = delete 3s&joined
            # all done!
            # < or still a stretch?
            a&Fin = !N.some(V => !Vs&seemsdone)
            if (!a&Fin) {
                # make the A&neu joi
                #  mostly so we can notice it going mono
                $nexts = armap(&V{
                    !(Vs&next && Vs&newline && Vs&newnode) and debugger
                    return Vs&next
                },N)

                A&neu = me&Ploy_i_joi,'next',nexts
                # joi linked like nod
                A&old.next = A&neu
                A&neu.prev = A&old
            }
            
            # when joined
            if (1 == hak(joi.lit)) {
                # by a single l, a whole line
                a&nojin = 1
            }
            else {
                # inflate nod/lin/col
                3c&io(joi,'with','*') .map(&nod,{
                    me&Ploy_nod_col,nod
                })
                # and merge to joi/jin/jol
                me&Ploy_joi_jin,joi
            }
            # is there an oddness to join/with <-> N[A&nod]
            me&Ploy_joi_check,joi,N
            
            # joi row
            me&Ploy_drawjoin,joi
            !a&Fin and me&Ploy_joi_next_check
            
            
            #me&Ploy_drawjoin_factoids
            #  any odd rows after that:
            me&Ploy_drawjoin_factoids
            
            a&Fin && me&tc,'Fin','G'
        }
        
        # iterate lit(/bit,nod)
        me.Ploy_drawjoin = &acgt,joi{
            # first and usually only type of row per joi
            #  eg A&modjoi, maybe A&mododd, etc
            $m = me&Ploy_rower
            $l = my&label
            ls&ws = 1
            # allowing the odd message inserted on the next|same line
            A&odd = &ty{
                $m = me&Ploy_rower,'odd'
                A&draw(t,y,m)
            }
            A&draw = &tym{
                me&Ploy_rower_i,m,t (&ml{
                    y (m,l)
                })
            }
            $joim = m
            
            me&Ploy_rower_i,m,'with' (&ml{
                $la
                3c&io(joi,'with','*') .map(&nod,{
                    # show only one same title
                    # < style about that
                    la && nod.E.t == la.E.t and return
                    me&drawnod,nod
                    la = nod
                })
            })
            
            $ldraw = {}
            me&Ploy_rower_i,m,'lit' (&ml{
                # lit.l, /bit|col
                3c&io(joi,'lit','*') .map(&lit,i{
                    $l = lit.l
                    $lm = ldraw[ly&seqi] = me&drawdiffbit,i,l
                    if (ls&moren) {
                        $ll = me&tsc,"moren-foldmarker",'↦'
                        lls&fs = 20
                        me&tc,"moren-size",'x'+hak(ls&moren),'6y'
                    }
                    else
                    l.t == 'same' and lms&bri = 0.6; lmy&label.c.not = 1
                })
            })
            
            me&Ploy_rower_i,m,'jin' (&ml{
                joi.jin and me&Ploy_drawjoin_jin,joi,{joim,ldraw}
            })
            
            # drop other modulats we just restructured
            # < get them to draw only if they are needed... (&Ploy_fail)
            $oktypes = peel('sph<-l,l,nod')
            grop(n => oktypes[ns&type], T.ab.sc.z)
        }
        
        
       // factoids of joi
        =joi
         A&joi.sc.$oddness = [uniq objects...]
          in either A:l (nod match) or A:joined (joi leave)
          during
           nod match
            .behinod=$nod - nod.joi != 3s&joi
            .tilmoves=$nod - as above + empty match
             < ^x2 dont seem to happen
            .tilstill=$nod - empty match
            .seeknod=$nod - as above + it wasnt munged \n$
           joi leave
            .stretch=$nod - behinod when joined
             eg joi@84 is ++'    ' after joi@80 =='    ' started $nod
              < where we would turn joi@80 ++'    '
                 which would turn it %mono
            .stretchy=$nod - doesnt end on joi (no ...\n$)
            .stretching=$nod - began before joi (after the above)
            .stretch=$nod - finally ended
            <<<
             coupled to a joi.prev+%strechy=$nod
             
            .minor=$nod - minimal == (eg '    ', \n$) amongst larger ++|--
           
          cant see any %behinod but is apparently
           
        =cut
        me.Ploy_drawjoin_factoids = &acgt{
            $joi = A&joi
            # more angles
            
            if (hak(joi.sc) == 0) {
                if (!joi.jin) {
                    # no difference
                    $m = joi.modjoi
                    ms&bri = 0.6
                }
                return
            }
            if (hak(joi.sc) == 1) {
                # only %mono
                a&nojin && jois&mono and return
            }
            # no facts without difference
            !joi.jin and debugger
            
            A&odd('lit',&ml{
                me&boxcap,'joi-factoids',2 (&ml{
                    lc&not = 1
                    $lak = haks(joi.sc).pop()
                    each kv joi.sc {
                        me&tc,k,'6y'
                        k == 'stretch' and me&Ploy_tid,v,'joi'
                        lak != k and me&tc,',','6d'
                    }
                })
            })
            
            A&odd('with',&ml{
                me&tt,'joi' () and me&fu,"joi@"+joi.i_join,joi
            })
        }
      
      
        me.Ploy_joi_check = &acgt,joi,N{
            # having %minor details
            $an = {}
            3c&oy(joi,'lit.l',&lc{
                # overall amount shared|not on this joi
                $k = l.t == 'same' ? 'same' : 'diff'
                an.cosize ||= {}
                an.cosize[k] += hak(ls&string)
            })
            
            # notice going %stretchy or continuing the %stretching
            #  ~~ middle, beginning and end (%stretch)
            #   many beginnings (%stretching) may occur
            #    if we share l with several joins with diff \n$
            3c&oy(joi,'lit.l',&lc{
                if (l.t != 'same') {
                    # text they dont share
                    if (c.first) {
                        3c&oy(joi,'with',&nod,{
                            $bit = 3c&o(nod,'mine/bit') [0]
                            # nod began earlier l on a previous joi
                            bit.l != l and me&joisc,'stretching',nod
                        })
                    }
                    if (c.last) {
                        # a nod doesnt have this \n$
                        3c&oy(joi,'with',&nod,{
                            $bit = 3c&o(nod,'mine/bit') .slice(-1)[0]
                            bit.l != l and me&joisc,'stretchy',nod
                        })
                    }
                }
            })
            # a %stretch is finally joined
            # notice when N...nod.joi are different
            # < always combined with mono joins?
            #   may have blips of stereo amongst
            #   we want to sweep below for clarity
            #    ie turn l:== into l:++ (like its neighbours)
            #    adding l:-- after, on a new joi for that one nod?
            # < any bit progress once decohered is what to see
            #    a nod matching that is not on the current joi
            N.map(&V{
                $nj = Vc&nod.joi
                if (nj != joi) {
                    # a node keeps matching after a while
                    # < boxlink to itsthe last box:joi
                    $ji = nj.i_join
                    me&joisc,'stretch',Vc&nod
                }
            })
        }
        
        # is|goes mono!
        me.Ploy_joi_next_check = &acgt{
            $send = &say,{
                A&odd('with',&{
                    me&tc,say,'G'
                })
            }
            if (hak(A&old.with) == 1) {
                $nod = havs(A&old.with)[0]
                # this sphere is the only one for a while
                me&joisc,'mono',nod.sph
            }
                
            $withs = spant(hak(A&old.with),hak(A&neu.with))
            if (withs == '2 1') {
                # starts non-joins - whole lines for only one sph
                #  the other, eg gone, will not consume any l:new
                me&joisc,'enmono',1
                A&neu.last_good = A&old
            }
            if (withs == '1 1') {
                # passes along...
                !A&old.sc.mono and debugger
                A&neu.last_good = A&old.last_good
            }
            if (withs == '1 2') {
                # resumed matching after non-joins (joins with.length == 1)
                A&neu.resumes = A&old.last_good
                me&joisc,'demono',1
            }
        }
        
        me.Ploy_nod_check = &acgt{
            # for a nod matching
            if (3s&joi != A&joi) {
                # previous other nod joined, we are left behind
                me&joisc,'behinod',A&nod
                if (!a&tilstill) {
                    # something
                    me&joisc,'tilmoves',A&nod
                }
            }
            
            
            
            
            
            if (a&seeknod) {
                # nothing excepting \n$
                # perhaps about to mono join
                #  ie only one 3s&joined (that was a&newnode)
                me&joisc,'seeknod',A&nod
            }
        }
        
        
    // drawing row+
        # $m:row re-opens a &boxcap column for eg /with
        me.Ploy_rower_i = &acgtmt{
            return &y{
                !me&fiu,m,t,8 and debugger
                me&boxcap,t,4,2,m (&ml{
                    y (m,l)
                })
            }
        }
        # boxcap for some kind of row, for a joi
        me.Ploy_rower = &acgtk{
            # kind may also odd|fail
            $modk = "mod"+(k||'joi')
            $m = A&joi[modk]
            if (!m) {
                # name it after this row
                $i = A&joi.i_join
                $name = cint('join',i,k)
                m = A&joi[modk] =
                me&boxcap,'join:'+i,3 (&ml{
                    ms&type = cint('join',k)
                    # label is the first column
                    lc&s = k || i
                    ls&bri = 0.6
                    ls&dis = 4
                    k and ls&fs = 7
                    # < how to border rows
                    
                    # with...E
                    me&boxcap,'with',4 (&ml{
                        lc&not = 1
                        mc&maybeempty = 1
                        ms&fs = 7
                        ms&maw = 6
                        ms&miw = 3
                    })
                    # lit...l
                    me&boxcap,'lit',4 (&ml{
                        lc&not = 1
                        mc&maybeempty = 1
                    })
                    # jin... discernibles
                    me&boxcap,'jin',4 (&ml{
                        lc&not = 1
                        mc&maybeempty = 1
                        ms&maw = 6
                        ms&miw = 3
                    })
                })
            }
            return m
        }
        # columns 2-4 span, for larger breakdowns, eg &Ploy_fail
        me.Ploy_spannyrower = &acgtt{
            return &y{
                return me&boxcap,t,3 (&ml{
                    me&boxcap,'spanny',4 (&ml{
                        lc&not = 1
                        mc&maybeempty = 1
                        ms&tag = 'td'
                        ahk(m.sc,'attr','colspan',3)
                        
                        y (m,l)
                    })
                })
            }
        }
        
    // drawing f
        # name|number n:E.t, j:$i...
        # see also &Ploy_identify
        # < should become -Difmo/joi/E**?
        me.Ploy_tid = &acgtvk{
            isar(v) and return coint(armap(v => me&Ploy_tid,v,k , v))
            k and v = v[k]
            !ish(v) and debugger
            $type = v.i_join ? 'j'
                : v.i_node ? 'n'
                :'?'
            $t = v.i_join ? v.i_join
                : v.i_node ? v.E.t
                : '?'
            me&tc,cint(type,t),'6G'
        }
        # not to be confused with $bit, which it maps to
        me.drawdiffbit = &acgttl{
            $name = cint(t,l.t)
            return me&boxcap,name,'5y' (&m,la{
                me&walls,m,'bd:1.1'
                ms&type = 'l'
                lac&s = 
                    l.t == 'new' ? '++' :
                    l.t == 'gone' ? '--' :
                    l.t == 'same' ? '==' : l.t
                
                $to = me&drawString,ls&string,{tsc:'y',squishindent:1}
                tos&ws = 4
                me&walls,to,'bd:2.2,bg:000'
            })
        }
        me.drawnod = &acgt,nod{
            $E = nod.E
            return me&boxcap,E.t,'1' (&ml{
                lc&not = 1
                ms&type = 'nod'
            me&boxcap,E.t,'2' (&ml{
                me&walls,m,'bd:3.3h4'
                ms&ml = (nod.d-1) * 0.6
                me&drawsym,'E'
                $sph = nod.sph
                sph.sphere == 'gone' and ms&bg = '#300'
            })
            })
        }
        me.drawsym = &acgtt{
            $sym = me&tsc,"sym",t
            $m = T.ab
            grop(sym, ms&z)
            ms&z.unshift(sym)
            pex(sym.sc,'fs:13,lh:0.8,hs:757')
            
        }
        
        me.drawbunchliner = &acgtc{
            each kv c {
                isst(v) and me&drawtextliner,{},k,v
                else me&drawnontextliner,k,v
            }
        }
        me.drawnontextliner = &acgtts{
            !isst(t) and throw "drawnontextliner!title"
            return me&boxcap,t,'5' (&ml{
                me&walls,m,'bd:1.3h4'
                # &Ploy_identify may have munged:
                me&tsc,'s',dis(s),'6y'
            })
        }
        
    // f, fail
        me.Ploy_fail = &acgttc{
            # stop l++
            3c&not = 1
            
            # nod|joi has errors
            # < create ^^%strange
            grep([A&joi,A&nod]).map(&blame,{
                $x = 3c&iz(blame,'!'+t)
                c and pex(x,c)
            })
            
            # display in modulat
            me&Ploy_spannyrower,"fail" (&ml{
                me&walls,m,'ba:3.1h6'
                #ls&dis = 3
                ls&hue = 200
                me&tc,"A:"+A.t,'6' .sc.ml = 1
                me&tsc,"error:",'!'+t,'G'
                
                
                me&boxcap,"env",5 (&ml{
                    lc&not = 1
                    $inner = &tcy{
                        c = me&Ploy_identify,c
                        me&boxcap,t,3 (&ml{
                            ls&dis = 4
                            ls&ws = 1
                            me&drawbunchliner,c
                            y and y (m,l)
                        })
                    }

                    c and inner('ar',c)
                    inner('A&',me&novelAc,A.c ,&m{ ms&hue = 33 })
                    inner('a&',A.sc,&m{ ms&hue = 66 })
                })
            })
        }
        
        me.novelAc = &acgtc{
            return nex({},c,'X,ip,sip')
        }

        # turn c={k:sph|nod|lin +} to idc
        me.Ploy_identify = &acgtc{
            c = ex({},c)
            each ts c {
                # leave non-objects in
                !isha(s) and continue
                $h = {}
                $looks
                map(&vk{
                    if (isob(v)) {
                        if (looks == 'bit' && k == 'mung') {
                            # know this object displays
                            h[k] = me&loosedepeel,v
                            return
                        }
                        # or leave out objects
                        return
                    }
                    $ma = k.match(/^i_(\w+)$/)
                    if (ma) {
                        h[ma[1]] = v
                        looks = ma[1]
                        return
                    }
                    # a word or so
                    h[k] = v
                },s)
                c[t] = h
            }
            return c
        }
        me.loosedepeel = &acgtc{
            return coint(armap(&vk{
                v == 1 and return k
                iske(v) || isC(v) and return cint(k,v)
                return cint(k,dis(v))
            }, c))
        }
 
 // Ply = Ness + Comp <
    =pod
      probably GOING, Ploy is much better
       tho this does know how to y&thing at -seven, etc.
        and only has one D, the other is a Ness
      < into X
      < with A
      < recovery
    =cut
    // Plymergent f
      // draw thing
        # wild repurposing the symbols of &Rthingo
        me.thingosym = &acgts{
            $sym = me&tc,s,'b'
            syms&lh = 0.5
            syms&fs = 20
            return sym
        }
        # a named string bubble, clue odd chars
        # < know where in l|E...
        me.drawtextliner = &acgtdts{
            !isst(t) and throw "drawtextliner!title"
            !isst(s) and throw "drawtextliner!text"
            $Om = T.ab
            $m = me&boxcap,t,'5' (&ml{
                me&walls,m,'bd:1.1'
                Om.y [t] = m
                
                $to = me&drawString,s,'y'
                tos&ws = 1
                me&walls,to,'bd:2.2,bg:000'
                Om.y [t+'s'] = to
            })
            return m
        }
        # < to having diff chunks floating around!
        me.textarrow = &acgtO{
            $b = O ? me&tc,O,"=>",'B' : me&tc,"=>",'B'
            by&cv = 0.0001
            bs&fs = 20
            bs&lh = 0.6
            bs&ab = 1
            bs&ml = -2
            O and grepout(Os&z,b); Os&z.unshift(b)
            return b
        }
        # passing y&thing acknowledged
        me.drawtextthing = &acgttdn{
            $oth = ny&thing
            oth && me&boxcap,t,'5' (&ml{
                me&walls,m,'bd:2.2h6'
                othy&cv != 0.1 and me&tc,cvf(othy&cv),'G'
                !me&mergent_oktothing,d,n and me&tc,"!used"
                $sum = me&textsize,oths&string
                me&thingosym,'⦄' .sc.fs = 15
                me&tc,sum,'y'
            })
        }
                
        # y&thing sanity check: into z requires zy&thing used on slope
        # < was %%oust to slope
        me.mergent_oktothing = &acgtdz,fatal{
            # it must exist in order to z
            $th = zy&thing
            if (!th) {
                !fatal and return null
                throw "tosphere!thing"
            }
            
            if (!hak(ths&use)) {
                !fatal and return 0
                throw "tosphere!use"
            }
            $slopers = d.slope.map(z => zy&ers)
            !hak(slopers) and throw "!slopers"
            if (!hak(grepout(slopers,ths&use))) {
                if (!slopers.slice(-2)[0]) {
                    # sloper no ers, perhaps because it was synthesized
                    $nu = zy&up
                    nu && nu.t != d.slope.slice(-2)[0].t and debugger
                    if (nu && ths&use.includes(nuy&C)) {
                        !fatal and me&tc,"//^//",'G'
                        return 1
                    }
                }
                !fatal and return 0
                throw "tosphere!used"
            }
            
            return 1
        }
      // close
        # if no Lines can be found
        # eg E...-inx/up|z are hidden from stringify
        me.mergent_avoids_unLinesed = &acgtdn{
            # anything goes so long as marked by layout symbol '~' above
            # < could be on the thing above, value =~ / \*$/
            !ahsk(n,'y','up','y','D','sc','~') and return
            me&drawtextnofurther,d,'layout:hid'
            # relies on returning from anywhere()
            return 1
        }
        # &Rthingo-ish complaint
        me.drawtextnofurther = &acgtdt{
            !isst(t) and throw "complain"
            me&thingosym,'⛔'
            me&tc,t,'6y'
            d.nofurther = 1
            # fade line
            $O = d.O
            $Om = d.Om
            Os&opa = 0.6
            # shrink everything inside, since indent O%ml depends on O%fs
            each in Os&z {
                ns&fs = 6
                # < make faster grounding for T.ab<-{&tc}
                #   these are attached now because they are the label or more T.ab
            }
            # (toL s/string//)
            Omy&toLs and Omy&toLs.sc.dis=0
            return 1
        }
      
    me.Plymergent = &acgtREs,Ness,Comp{
      // Ply box, all[] from anywhere(n**)
        # see ds&morenth
        # < trace ourselves through every ^^^*y&thing%string
        #    kind of like a report vortex
        #    lets go as it wanders off the -Ness/*/*
        #     seeing slope into W
        #   ind slice it for all Lines at l%moren
        #  < real as the E|exp**:n walk
        #    many **:n to navigate with Comp
        #     exp having gone, E having new
        #    $exp** to resurrect relics from,
        #     for D->modulat totality,
        #      so we can then Diff the modulats, and make good visual
        $Ply = me&boxcap,'Ply','1' (&Ply,l{
        lc&not = 1
        # clue any change inside, become Plyy&offendEd[] later
        $radiate = &vd{
            ds&changey ||= 0
            ds&changey += v
            d.up && radiate(v*0.3,d.up)
        }
        # l = Comp[upto]
        $upto = 0
        # [d+]
        $all = []
        # Ness** as long as possible
        #  y&thing are for the outsphere
        #  y&C=This/Eight** follow E** down
        #   once Ness** runs out
        # < wander into Ness**, with diff )
        $anywhere = &nd{
            d ||= {}
            # < for a set of trees
            d.n = n
            d.slope = (d.slope||[]).slice()
            d.sc = {z:[]}
            d.up and d.up.sc.z.push(d)
            all.push(d)
      
      // Ply stuff<->things!
            me&boxcap,"Ply"+n.t,'1' (&ml{
            ls&deco = 1
            lc&s = n.t
            ms&ml = 1
            $O = d.O = m
            $pl = me&tc,"place"
            plc&s = ''
            # intoable insphere, y&C from Ness**
            # in (Ness|This|exp)**//E-seven**
            #  slope begins This/here**

            $z
            $Om
            # notice outsphere features...
            me&boxcap,"Out",'g' (&ml{
                d.Om = Om = m
                me&walls,m,'bd:2.2h3'
                ms&fs = 6
                
                # gives Omy&toL(s)?
                ny&toLines
                    && me&drawtextliner,d,"toL",ny&toLines

                # < swathes of %moren may be entirely
                me&drawtextthing,'thing',d,n
                
                $D = ny&D
                D && Dy&thing && Dy&thing != ny&thing
                    && me&drawtextthing,'Dthing',d,D

                z = ny&C
                z || d.ins and d.slope.push(z||n)
                # < isn't always E?
                z and ds&E = z
                else
                d.ins and ds&E = n
                
                # < &Saturn into here!
                # at Ness..-seven the ** dries up
                if (!d.ins && !hak(ns&z)) {
                    if (!z) {
                        # we may be on a missing -seven
                        ds&goneseven = 1
                        d.nofurther = 1
                        return me&tc,"GONE",'b'
                    }
                    d.ins = d
                    ds&pi = 'seven'
                    # must =be a 
                    !z and return me&tc,"GONE",'b'
                    !hak(zs&z) and throw "deadend"
                    me&mergent_oktothing,d,z,'fatal'
                    me&tc,"yC",'G'
                }
                if (d.up && d.ins == d.up) {
                    # the RE
                    ds&pi = 'six'
                    me&walls,O,'bd:4.2h3'
                    # < which E** are selected
                    # see TheingE 2951: sets y&C
                    #  like there is up in Ness/*/*, see &EsyncThis
                    !z and me&drawtextnofurther,d,"non-main"
                }
                if (d.up && d.up.sc.pi == 'six') {
                    # the Ey&main itself
                    ds&pi = 'five'
                }
                ds&pi and me&tc,pl,"-"+ds&pi,'G'
            })
            d.nofurther and return
            
      // E<->l
            # lingering l, or nothing
            $l = null
            me&boxcap,"E",'g' (&m{
                me&walls,m,'bd:2.2h3'
            // Comp/l and E...n...Lines
              
              // l = Comp[upto]
                # eitherings, any substring of Lines
                l = Comp[upto]
                if (d.morend) {
                    $nd = d.morend
                    # n's l is not in Comp/*, last one that was:
                    $ul = nd.l
                    nd.moreni ||= 0
                    l = uls&moren [nd.moreni]
                    me&tsc,'morening',"^"
                }
                !l and d.offtape = 1; return me&tc,"off","b"
                d.l = l
                
                # last l%ope, l/* (indentitively) is folded into l%moren
                if (ls&moren) {
                    me&tc,"x"+hak(ls&moren),'6d'
                    # < &strange <-> T.ab
                    d.morend and debugger; me&tc,"inside-morend",'!','b'
                    d.morend = d
                    if (d.ins == d.up) {
                        # -six whole y&thing check
                        ds&morenth = 1
                    }
                }
                
                $skipgone = &L{
                    # L == l that may be gone!
                    L.t != 'gone' and return
                    me&tc,"Agone",'6y'
                    # wash up on the next E in iteration
                    ac(d,'goners',L)
                    ac(d,'subComp',L)
                    ac(d,'chaComp',L)
                    # pull until we uncover a same, continue as
                    l = Comp[++upto]
                    l = skipgone(l) || l
                    # dedupes (see this line in while(l) below)
                    l.t != 'same' and ac(d,'chaComp',l)
                    # line-splitting not near folds
                    l && ls&moren && l.t != 'same' and debugger
                    return l
                }
                l = skipgone(l) || l
                
                # everything we visit should be open, may %moren
                ls&ope == '1' and 'ok'
                else
                ls&ope and me&tc,dis({ope:ls&ope}),'y'
                else {
                    me&tc,'shut','y'
                }
                
              // Lines = ny&toLines or so
                # into R'The'
                $D = ny&D
                D and me&tc,"D",'G'
                $th = ny&thing
                
                $Lines = ny&toLines
                #D && Dy&toLines and me&tc,"DtoL"
                D && Dy&thing and me&tc,"Dth"
                D && Dy&thing and Lines = Dy&thing.sc.string; me&tc,"Dth",'6y'
                if (ds&morenth) {
                    # -six whole y&thing check
                    Lines = ths&string
                    !Lines and debugger
                }
                if (!Lines) {
                    Lines = th && ths&string
                    Lines and me&tc,"th",6
                }
                if (!Lines) {
                    Lines = D && Dy&toLines
                    Lines and me&tc,"DtoL",6
                }
                if (!Lines && D) {
                    $Dth = Dy&thing
                    Lines = Dth && Dths&string
                    Lines and me&tc,"Dth",6
                }
                
                !Lines && me&mergent_avoids_unLinesed,d,n and return
                # < test all of these recover
                !Lines and return me&tc,"lost-string",'b'
                !hak(ns&z) and me&tc,'/$','g'
                
              // could be easy
                # < func text lib
                # if we indent this
                $indLines = indents(ls&level,Lines)
                # and we aren't looking at folded or interesting l
                if (!d.morend && l.t == 'same'
                    # it should look like the rest of l
                    && ls&string == indLines) {
                    ds&good = me&ts,"match-quality-good","2"
                    # and we associate d (for E**) with it
                    ac(d,'subComp',l)
                    upto++
                    return
                }
                
              // or break apart Lines, gradually l
                $Lin = Lin_Lines(indLines)
                $Li = 0
                $nd = d.morend
                nd = nd != d && nd
                $ul = nd && nd.l
                while (l) {
                    
                    $aLine = Lin[Li]
                    # non-first bit
                    Li && nd and l = uls&moren [nd.moreni]
                    aLine == null and break
                    l.t != 'same' and ac(d,'chaComp',l)
                    if (ls&string.length && !hak(ls&string.split('')
                        .filter(s => s != ' ')) ) {
                        me&tc,"Aspacey",'6y'
                    }
                    skipgone(l) and continue
                    
                    ul && ul != l && ls&moren and me&tc,"(moremore)",'6y'
                    
                    $good_luck = 0
                    if (d.up && d.up.sc.recoveredup) {
                        debugger
                    }
                    if (d.up && d.up.sc.recovering_since) {
                        $string = ls&string.replace(/\n$/,'')
                        good_luck = aLine.includes(string)
                        #me&drawtextliner,d,"l::",ls&string
                        #me&drawtextliner,d,"a::",aLine+"\n"
                        #!good_luck and debugger
                    }
                    # first bit should look good
                    if (good_luck || ls&string == aLine+"\n") {
                        Li++
                        ac(d,'subComp',l)
                        if (nd) {
                            nd.moreni ++
                            # if we're in ul%moren/l, we can't be l%ope
                            #  so checks the entirety of y&thing if possible
                        }
                        elsif (ds&morenth) {
                            # check off a bunch more l in this while
                            #  already has Lines from y&thing
                            if (!th) {
                                ds&good = me&tc,"1+"
                                me&tc,"no-th",'b'
                                Li == 1 and upto++; return
                                break
                            }
                            $ul = l
                            # start using uls%moren
                            $nd = d
                            d.moreni = 0
                            # eventually seek next Comp/l
                            upto++
                        }
                        else {
                            ds&good = me&tc,"1"
                            Li == 1 and upto++; return
                            break
                        }
                    }
                    else {
                        # or at least starts with l
                        me&tc,",."+Li,'c'
                        if (!nd && !ls&string.endsWith("\n")) {
                            if (aLine.startsWith(ls&string)) {
                                ac(d,'subComp',l)
                                # sub-Line at a time
                                me&tc,"+",'6y'
                                aLine = aLine.substr(ls&string.length)
                                $waslev = ls&level
                                # go forwards, skipping goners
                                l = Comp[++upto]
                                l = skipgone(l) || l
                                $islev = ls&level
                                # level might increase onto a change
                                # < really?
                                if (waslev < islev) {
                                    $morelev = islev-waslev
                                    me&tc,"ind+="+morelev,'6y'
                                    aLine = indents(morelev,aLine,1)
                                }
                                Lin[Li] = aLine
                                continue
                            }
                        }
                        break
                    }
                }
             
              // non-easy OK
                Li and me&tc,"("+Li+")",'6y'
                if (!l) {
                    ds&good = me&ts,"match-quality-okay","7"
                    # already counted upto++ going into ul%moren (either of two ways)
                    return
                }
                if (hak(Lin) > 1) {
                    # others may then!
                    me&tc,"+more"
                }
            
            // lingering confusedly?
                $interesting = 1
                ||
                (n.t == 'maaaagic' && n.y.up.t == 'origin_X')
                ||
                (n.t == 'A' && n.y.up.t == '-Fez'
                    && n.y.up.y.up.t == 'node_hand_U')
                ||
                (n.t == 'maaaagic')
                
                if (interesting) {
                    me&drawtextliner,d,"l",ls&string
                    aLine ? me&drawtextliner,d,"a",aLine
                        : me&drawtextliner,d,"L",Lines
                }
                
                
                # maybe just the start of it
                if (Lines) {
                    me&ts,"lingering-confusedly",'??'
                    
                    if (ls&string.includes(Lines)) {
                        me&tc,"oooook@"+upto
                        return
                    }
                }
            })
      
      // stat
            # < dodgy
            $next = ds&pi == 'seven' ? zs&z : ns&z
            
            if (ds&good) {
                # mute toL!
                $Ls = Omy&toLs
                Ls and Lsc&not = 1
                me&tc,"OK"
            }
            
            if (ds&chaComp) {
                me&boxcap,"~",'g' (&m{
                    me&tt,'d' () and me&tc,"dsc"+dis(d.sc),'1G'
                    each il ds&subComp {
                        me&drawtextliner,d,l.t,ls&string
                    }
                    me&boxcap,"ExtraAfter?",1 (&{
                        # and the non-same ones
                        #  may inc the non-match after, not in %subComp
                        each il ds&chaComp {
                            grap(l,ds&subComp) and continue
                            me&drawtextliner,d,l.t,ls&string
                        }
                    })
                })
            }
            d.nofurther and return
            
      // recursion?
            $cant = t => me&thingosym,'⦄'+t .sc.fs = 15
            if (hak(next) && ds&good) {
                $not = 0
                # don't recurse unless Comp says
                #Comp[upto] != l and debugger
                $ln = Comp[upto]
                if (!d.morend && ln && l && l != ln && lns&level <= ls&level) {
                    #me&fu,"Leaving:"+slant(d.slope),{d,ln,l}
                    # may end on a single line E, so no l%moren
                    #  eg X.A is a one-liner, yet we can see n/* t,y,c,sc
                    return cant('E...')
                }
                # < should only l%moren instead of !l%ope
                !(l && ls&ope) and return cant('l')
                else
                # see ds&morenth for -six whole y&thing check
                #  doesn't involve E**, what we avoid here:
                # since E** feeds Lines one-C at a time, avoid the folds.
                #  essentially ignoring a bunch of stuff already marked as boring.
                #  they must be opened back in Diff.
                ls&moren and return cant('m')
                # and not far
                #hak(d.slope) > 5 and return me&thingosym,'⦄>'
                # el2 -six can skip unpacking all the newness
                elsif (ds&pi == 'six' && 'new' == joint(ds&subComp)) {
                    me&tc,"Looks-new"
                    # requires the rest of -six** Comp to be new
                    $rest = Comp.slice(upto)
                    $restofsix = ksaf(rest,{bow:ul => uls&level <= ls&level,may:1})
                    
                    $frontier = !grap(ul => ul.t != 'new', restofsix)
                    if (frontier) {
                        ds&want_recovery = 1
                        ds&el2six = 1
                        next = []
                        cant('el2-six**')
                    }
                    else {
                        me&tc,"el2-six**,not-all-new",'6'
                    }
                }
            }
            
            each iz next {
                !ds&good and cant("!good"); break
                $dd = ex(ex({},d),{up:d})
                anywhere(z,dd)
                # happens when E** shows un-Ret potential
                #  little to no flood control
                dd.offtape and me&tc,'off-tape'; break
                
                ds&recoveredup and me&tc,"/Recoveredup",'g'; break
            }
            
      // recovery?
            # and here, at every crux to a later depth first
            if (!ds&good || ds&want_recovery) {
                $dup = d.up
                if (dups&good) {
                    # < voice the four options for choosing a goodlevel
                   // attempt recovery at first Comp%level <= that
                    $goodlevel = dup.l.sc.level
                    if (ds&good) {
                        # we may be skipping an el -six OK
                        goodlevel = d.l.sc.level
                    }
                    else {
                        # in a (==1-six\n)(~~2-six\n)(==3-six\n)
                        #  recover to the next six
                        $prevd = ksaf(dups&z,{bow:d}) [0]
                        $maybelevel = prevd && prevd.l.sc.level
                    }
                    if (maybelevel) {
                        if (maybelevel && maybelevel == goodlevel + 2) {
                            goodlevel = maybelevel
                        }
                        else {
                            maybelevel = 0
                            # < shouldn't really depend on a maybelevel
                            if (hak(ds&subComp)) {
                                # this might be a (==      )(--other)
                                # < handle everything better
                                $few = ds&subComp.slice(0,3).map(l => ls&string).join('')
                                $sublevel = me&getindent,few
                                # < not strange but just odd
                                if (sublevel > goodlevel) {
                                    goodlevel = sublevel
                                }
                                else {
                                    sublevel == goodlevel and me&tc,"subComp==goodlevel"
                                    sublevel = 0
                                }
                            }
                            else {
                                me&tc,"unsure"+dis({maybelevel,"^/<":prevd.l.sc.string})
                            }
                        }
                    }
                    
                   // aim Comp[upto], notting d recursion up to it!
                    $indup = upto
                    $max = 1000
                    $maxed = 0
                    $la2
                    $la
                    $nl
                    me&boxcap,"Recovering",1 (&ml{
                    ms&ml = 1
                    ls&ml = -1
                    
                    me&tt,'d' () and me&tc,"dsc"+dis(d.sc),'1G'
                    me&tc,"good<="+goodlevel,'6'
                    maybelevel and me&ts,'maybelevel-got-from-^/<','(same-indent)','6y'
                    sublevel and me&ts,'sublevel-got-from-%subComp-parts','(part-indent)','6y'
                    $lastline
                    $opecovered = me&tt,"covered" ()
                    while (maxed++<max) {
                        la2 = la
                        la = nl
                        indup++
                        nl = Comp[indup]
                        !nl && !ahsk(Om,'y','lingering-confu') and me&tc,'Once','G'
                        !nl and break
                        $heady = la && las&string.endsWith("  ")
                            || nls&string.startsWith("  ")
                        !heady and continue
                        
                        
                        $cover = me&boxcap,"Coveredup",1,2 (&ml{
                            me&walls,m,'b:2.2'
                            
                            $t = '+'+(indup-upto)
                            lastline = me&drawtextliner,d,t,nls&string
                            if (nls&level > goodlevel && la2) {
                                # perhaps it is wrong!
                                # < not carrying %level over empties:
                                #    (==      \n)(==    )(++somewhat  \n)
                                $may = la2s&string.endsWith("\n")
                                    && las&string.match(/^ +$/)
                                $relevel = may && me&getindent,las&string+nls&string
                                if (may && relevel != nls&level) {
                                    me&tc,"lies!lev:"+relevel
                                    nls&level = relevel
                                    # this was carried
                                    las&level = me&getindent,las&string
                                    # carry on from there
                                }
                            }
                        })
                        # close draw of covered lines
                        !opecovered and cover.c.not = 1
                        
                        if (nls&level <= goodlevel) {
                            # < move last line up to box:Recovering
                            lastlinec&not = 1
                            me&drawtextliner,d,lastline.t,nls&string
                            break
                        }
                    }
                    # < add a d.path
                    maxed >= max and ~>0 Ply recovermuch: maxed, slant(me.cby(d).map(d => d.n))
                    !nl and return
                    })
                    if (!nl) {
                        ds&el2six and return me&tc,"new-tail"
                        return ac(Ply,'strange','unrecoverable!nl')
                    }
                    $wasupto = upto
                    upto = Comp.indexOf(nl)
                    
                    # find corresponding d to skip iteration until
                    $done = 0
                    while (maxed<max) {
                        if (!done) {
                            if (dup.l && dup.l.sc.level < goodlevel) {
                                done = 1
                            }
                            else dups&recoveredup = 1
                        }
                        dup = dup.up
                        !dup and break
                        
                        # < radiate to last dups&good and break
                        if (dups&pi == 'six') {
                            # hang %changey
                            radiate(upto-wasupto,dup)
                        }
                        if (!done) {
                            if (hak(dup.slope)*2 < nls&level) {
                                dups&recovering_since = d
                            }
                        }
                    }
                    #ahk(Om,'y','lingering-confu',1)
                    #    || me&fu,"@"+n.t,{d,l,nl,n,upto,total:Comp.length,dup}
                }
                else ac(Ply,'strange','unrecoverable')
            }
            
            
            
            })
        }
        
      // aft: radiate changey %ope -> E !
        anywhere(Ness)
        
        # get -seven/-six with change inside
        reverse(all).map(&d{
            $cha = hak(ds&chaComp)
            cha and radiate(cha,d)
        })
        
        # < boxlink Diff|Ply**
        #   scopes the change could be viewed from
        # < -six should redirect %%ope, as it is REy&main
        $Es = []
        each id all {
            !ds&changey and continue
            # we only make -seven/-six/-five out to d%pi
            #  they may not reflect the Ec&pi
            #  eg RE-Fez/E-Fez are -six/-five to d
            !ds&pi and continue
            # mark Ply**
            me&textarrow,d.O
            # to visit d%E
            $E = ds&E
            !E and debugger
            ahk(Ply,['y'],'offendEd',{E,d})
            Es.push(E)
        }
        #me&nu,"Wouldvis",Es
        
        # /box:Ply
        })
        me&boxcap,'strange!',5 (&m{
            # me&walls,m,'b:3.2'
            each is Plys&strange {
                me&tc,dis(s),'B'
            }
        })
        # < move outside
        Plys&ml = -6
        return Ply
        if (0 && 'look-around-lines') {
            $mai = Comp.findIndex(l => ls&string.includes("maaaagic"))
            
            
            
            
            
            
            
            
            
            me&boxcap,'wonk','1' (&ml{
                $some = Comp.slice(mai-3,mai+3)
                each in some {
                    me&boxcap,'line','1G' (&ml{
                        lc&s = n.t
                        lc&s.length == 3 and lc&s += "!"
                        $t = me&tc,'doov','g'
                        tc&s = enj(ns&string)
                        ts&ws = 1

                    })
                }
            })
        }
    }   
        
 // chunkology
    # follows the universal plant-in-the-lobby pattern:
    #   headings followed by empty lines do not a chunk make
    # < all known limitations involve io-happy regroup:
    # < joining b in ((...,0),(1,2,2,1,2,2,1):b):a
    #    esp if a > 80, we could look harder
    #    b is otherwise 3 chunks, none big enough, also:
    # < pre|post-amble, braces or comments, if gap beyond
    #   (1,2,2,1),0,(1,2,2,1)
    # see &chunksoflines various < 20 for some stumbling into:
    # < play with which being open gives near 100 lines
    #   or 100 lines per 1000 lines, or so
    # < when aging/inserting folds,
    #     open those the cursor/diff is mostly in
   // cm side
    # all at once
    #   no memo, usu rarely happens via s&valuecha()
    me.cm_chunksfold = &acgt,cm,z,ch{
        z ||= Cye([C.t,1,{s:cm.getValue()}]);
        $lines = zc&s.split("\n");
        # not the osc C?
        z == C and z = Cye(['lod',1]);
        # split that up
        !zs&chunks and me&chunksoflines,z,lines;
        # the existing marks
        $ope = me&cm_foldmap,cm
        # adjust to C
        me&cm_foldCode,z,ope,cm,ch;
        return z
    }
    # our chunks match|make a fold
    # < z**%ope=1/0, changing what is
    # < top-down lazily, %open/%closed/* to instantly:
    #   pop open, yet close more chunks within that
    #    (closing a then a/b opens a)
    me.cm_foldCode = &acgtz,ope,cm,ch{
        $found = [];
        if (zs&commentsey) {
            $mark = '#'+'c '
            cm.options.foldOptions ||= {};
            cm.options.foldOptions.rangeFinder = &cm,pos{
                $from = pos.line;
                if (from > 0 && !cm.getLine(from).includes(mark)) {
                    # not on a #c, use indent
                    $f = cm.getHelpers(pos,'fold')[0];
                    $range = f(cm,pos);
                    !range and ~>5 seekup til #c?:
                    return range
                }
                $end = cm.lastLine();
                $to = from;
                while (to < end) {
                    $text = cm.getLine(to+1);
                    text && text.includes(mark) and break
                    to++
                }
                if (to > from) { return {
                    from: CodeMirror.Pos(from, cm.getLine(from).length),
                    to: CodeMirror.Pos(to, cm.getLine(to).length)
                }}
            }
        }
        #$topdown = zs&chunks.slice().reverse();
        each is zs&chunks {
            $f = ope[ss&line];
            ss&line *= 1
            if (ch) {
                debugger
                ch.from && ss&line+2 < ch.from.line and continue
                ch.to && ss&line-2 > ch.to.line and continue
            }
            # for Glimpes
            f and fy&chunk = s
            elsif (ss&proper) {
                # this checks again that fold makes sense
                $fo = cm.foldCode(CodeMirror.Pos(ss&line,0));
                found.push(fo)
                !fo and continue
                nofo = 0
                # doesn't make an $f
                # open widgets
                me&cm_mark_refoldable,fo,cm;
            }
        }
        # see stylehouse/CodeMirror.git 0a8f8455f2d48
        #  you might also findMarksAt after !cm.foldCode
        found.length && !found.filter(n => n).length and ~>5 cm_foldCode none found:
    }
    # current folds by line, inc open if refold marked
    me.cm_foldmap = &acgt,cm{
        $M = cm.getAllMarks()
        .filter(n => n.__isreFold && n.otherend || n.__isFold)
        .map(&n{
            $pos = n.find();
            # they get lost on big copy+paste
            !(pos.to && pos.from) and return 
            n.otherend and pos = {from:pos,to:n.otherend.find()}
            return Cye(['fold',1,{},{mark:n,
                line: pos.from.line,
                toline: pos.to.line
            }])
        }).filter(f=>f);
        $ope = {};
        each if M {
            ope[fs&line] = f
        }
        return ope
    }
    # an open fold having close buttons at each end
    me.cm_mark_refoldable = &acgtm,cm{
        $refoldable;
        refoldable = &m{
            m._handlers and delete m._handlers.clear;
            m.on('clear',&from,to{
                !(from && to) and return ~>5 lost fold:
                $N;
                $foldagain = &{
                    $pos = N[0].find();
                    N.map(n => n.clear())
                    !pos and return
                    #~>3 foldat: pos.line
                    $fo = cm.foldCode(pos);
                    !fo and return ~>5 lost refold:
                    refoldable(fo);
                };
                N = [from,to].map(&l{
                    $sym = l == from ? "\u21A6" : "\u21A4";
                    $widget = $('<n>'+sym+'</n>')
                        .on('click',foldagain)
                        # < clickable large floaty things...
                        #.css('font-size','280%')
                        .css('color','#7c9')[0];
                    $lop = cm.setBookmark(l,{widget});
                    lop.__isreFold = 1;
                    return lop;
                });
                N[0].otherend = N[1]
            })
        };
        refoldable(m);
    }
   // lines side
    # s/$c**, also s%chunks = [c in reverse (depth first)]
    me.chunksoflines = &acgts,lines{
        # starting from s = the whole document!
        ss&line = 0;
        ss&toline = lines.length-1;
        # i $s/$c each divisible chunk
        $N = me&indo,s,{dl:15} (&sd{
            # keep small chunks, no further
            #ss&toline-ss&line < 20 and return s

            me&chunkchunksoflines,s,lines;
            !ss&z and throw "nochunks"
            
            # drop small chunks
            ss&z.filter(c => 1+cs&toline-cs&line < 20)
                .map(c => me&fiu,s,c,9 );
            
            # and any one chunk same as the parent chunk
            ss&z.length == 1 && ss&z
            .filter(c => cs&line == ss&line).map(&c{
                #cs&toline != ss&toline and throw "was shorter!!"
                me&fiu,s,c,9
            });
            return s
        });
       // etc
        $z = s;
        $resetN = &{
            N = [s];
            sy&tw = {};
            ss&z = [];
        }
        $assign = &N,lines{
            # assign their substrings 
            N.map(&s{
                #ss&string = lines.slice(ss&line,ss&toline+1).join("\n");
                ss&lines = 1+(ss&toline-ss&line);
                ss&lines < 20 and delete ss&proper
            });
            $rev = N.slice().reverse();

            # size supposing s/*%folded are each 1 line
            rev.filter(s => s == z || ss&proper).map(&s{
                ss&size = ss&lines;
                ss&z .filter(c => cs&proper).map(&c{
                    ss&size -= cs&lines-1;
                });
                if (ss&size < 20 && 
                    !(ss&size > 5 && ss&heading))
                    delete ss&proper
            })
            
            return rev
        };
        $rev = assign(N,lines);
       // or #c
        if (ss&lines > 100 && ss&size > ss&lines*0.1) {
            # didnt fold much, fallback to #c-markers
            $mark = '#'+'c '
            $wasN = N;
            resetN();
            # < why does this leave a few?
            #ss&z.map(c => me&fiu,s,c,9);
            #ss&z.map(c => me&fiu,s,c,9);
            #ss&z.map(c => me&fiu,s,c,9);
            $la;
            each il lines {
                la && !l.includes(mark) and continue
                i *= 1;
                $c = Cye(['chunk@'+i,1]);
                la and las&toline = i-1
                cs&line = i;
                cs&proper = 1;
                me&fiu,s,c;
                la = c;
                N.push(c);
            }
            las&toline = i;
            rev = assign(N,lines);
            
            if (ss&size > ss&lines*0.1) {
                ~>7 chunksoflines confused by: s.t
            }
            elsif (ss&lines / ss&z.length > ss&lines / 2) {
                #~>7 chunksoflines uncommentsey: s.t
            }
            else {
                ss&commentsey = 1;
            }
            if (!ss&commentsey) {
                resetN();
                wasN.filter(c => c != s)
                    .map(c => me&fiu,s,c && N.push(c) );
                rev = assign(N,lines);
            }
        }
        ss&chunks = rev;
    }
    # i $s/$chunk+
    #  relating s%(to)lines -> lines
    me.chunkchunksoflines = &acgts,lines{
        $chunk = &sil{
            $c = Cye(['chunk@'+i,1]);
            cs&line = l;
            me&fiu,s,c;
            return c
        }
        $c = null;
        $i = 0;
        $li = ss&line || 0;
        $laindent = ss&indent || 0;
        $ltoindent = {};
        while (lines[li+i] != null) {
            $l = lines[li+i];
            $indent = ltoindent[li+i] ||= l.match(/^(\s*)(.*)$/);
            $stuff = indent[2];
            indent = indent[1].length;
            $p = c;

            # level this chunk is based at
            $cind = c && cs&indent || 0;
            
            # remaining at s's indent is not c-worthy
            !c && ss&line && indent == ss&indent and i++; continue
            else
            !c and c = chunk(s,i,li+i)
            else
            !i and throw "i=0"
            else
            # not minding empty lines
            !stuff and indent = laindent; 'grow'
            else
            # < python-ish indent-implied blocks. would ignore:
            stuff[0] == '#' && indent == cind and 'grow'
            else
            # (1,2),(1) or (2,3),(1)
            if (cind == indent && indent < laindent
                || cind > indent) {
                c = chunk(s,i,li+i)
            }
            else
            # (1,1),(2) -> (1),(1,2)
            if (cind < indent && laindent <= cind
                && (ps&toline - ps&line > 0
                    || ps&line == ss&line)) {
                c = chunk(s,i,li+i);
                cs&laindent = laindent;
                if (ps&line != ss&line && laindent != ss&indent) {
                    # borrow the 1, or start indent from here
                    cs&indent = laindent;
                    ps&toline--;
                    cs&line--;
                    if (!/\S/.test(lines[cs&line])) {
                        # no plant-in-the-lobby trick, open
                        # consume the skipped over !stuff
                        cs&spacedopen = 1;
                        while (1) {
                            cs&spacedopen++ >4 and throw "big cs&spacedopen"
                            /\S/.test(lines[cs&line]) and break
                            cs&line--;
                        }
                    }
                    
                }
            }
            else
            # chunks with something further inside will cm.doFold
            #  unless they're /^#/, no prob
            # ie only the (1,2) of (1,1,1),(1,2)
            indent > cind and cs&proper = 1
            # various reasons un-proper, eg (2, ,3)
            cs&spacedopen and delete cs&proper
            
            if (p != c) {
                $lindo = ltoindent[cs&line];
                lindo[2][0] == '/' and cs&heading = 1
            }

            if (cs&indent == null) {
                cs&indent = indent
            }
            cs&toline = li+i;
            cs&toline >= ss&toline and break
            laindent = indent;
            i++;
        }
    }

 // common
     // about text
        # < nibble-sized view of thing?
        #    2-nibble top Line's t,y + whole textsize
        me.textsize = &acgtsc{
            c ||= {}
            !isst(s) and throw "textsize!st"
            $lin = s.split("\n")
            lin.slice(-1)[0] == '' and lin.pop()
            c.lines = hak(lin)
            c.length = s.length
            return 'x'+c.lines+'*'+c.length
        }
     // forms of text
        # turn %string back into y&toLines
        # huh
        me.unfixstring = &acgts{
            return s.replace(/\n$/,'')
        }
        # < GOING moved to Pictures, yet for R%Codap (editor)
        self.numf = &s{
            !(s >= 0 && s <= 1) and throw "numf!cv"
            return (s+'').substr(2)
        }
 
 // Storables
    # check t%dige%string
    # sanity Quanta: 
    #  as opposed to Qish, of its names (of/t etc)
    me.storable = &acgts{
        $dige = ss&dige
        !dige and throw "storable s!%dige"
        !ss&string and throw "storable s!%string"
        dig(ss&string) != dige and throw "storable broke dige"
        return dige
    }
    
    # make t%dige%string
    me.Linets = &acgttsd{
        ts&string = me&Lineso,s,d
        ts&dige = dig(ts&string)
    }
    # returns %string (/\n$/) &toL,s**
    #  was &Serialise. 
    me.Lineso = &acgtsd{
        return me&indo,s,ex({},d||{}) (&s,d{
            $Y = sy&Y;
            d.where && !d.where(s,d) and s = 0
            d.what and s = d.what(s,d)
            !s and d.not = 1; return
            $part;
            try {
                # < as Y T.act, spec args
                part = 'scan';
                !isC(s) and throw "Not C"
                sc&N and throw "mightbe R"
                
                part = 'clone';
                $D = d.D = Cye(s);
                d.up && d.up.D and Dy&up = d.up.D
                
                part = 'Compress';
                me&Compress,D
                Y && Ys&compLines and Ys&compLines(D,d,s)
                d.compLines and $already = d.compLines(D,d,s)
                already and return already
                
                part = 'toLines';
                d.toLines = d.jsony ? enj(D) : me&enL,D
                Ds&H && !d.toLines.match(/(H):(\w+)\b/) and throw "%H not so gc will see it"
            }
            catch (er) {
                ~enLinesR: ki(d.path,2)+"   !"+part+"! "+er
                #me&Rec,R,'err';
                d.toLines = "[error} "+ki(s);
                #Rs&err = "enLinesR: "+part+": "+er;
                #n err  $s:Rs&err
                d.nofurther = 1
                # in case we dont throw new Error(...)
                # < generalise handling, fix up toLines: throw "Leaky...
                isst(er) and throw "Lineso: "+er, d.path
                # this Babz into er.catches+={stack,tc=[further]}; throw er
                throw er, 'further', d.path
            }
            sy&toLines = d.toLines;
            return d.toLines
        })
        + "\n"
    }
    
    # o y $s**
    #  was &Copy (made R:Copy)
    # < more like &acceptables_reself, %string -> lv sense etc
    me.Clone = &acgtsd{
        $dupN = []
        $neu = me&indo,s,d (&sd{
            $z = d.O = Cye(s)
            z.y [d.ytag||'Clone'] = s
            $du = d.up
            $pz = du && du.O
            # rebuilding y&tw and s&z, dup fatal
            if (pz) {
                me&fiu,pz,z,8 and dupN.push(z)
                # el:4 for leaving dups in pz%z
                me&fiu,pz,z,4
            }
            return z
        }) [0]
        if (hak(dupN)) {
            ~>3 Clone dups: s.t, joint(dupN)
        }
        return neu
    }
    
    # &ballLines climbing s, knowing R
    #  replaces: Describing via awaking everything with %Lines
    # < wants errors, compression pointers:
    # < n Leaps -code ballLines:Yingr # doing:
    #   .c resolving &ballLines, figuring R+Rc&s
    me.ballLines = &acgtRs{
        $d = {};
        d.R = R;
        d.where = &sd{
            $r = d.R;
            sc&noencode and return 0
            !r and return 1
            rc&s == s and return 1
            # RbitX follow it down, using last time
            #  which should have all the nodes
            # < resyncing by sy&R? wants visual clue, ioland
            # 
            $found = [];
            $x = rc&V && rc&V.x || {};
            each tX x {
                each ir X.z {
                    rs&ball && rc&s == s and d.R = r; return 1
                }
            }
            delete d.R
            return 1
        }
        d.compLines = &Dd{
            $r = d.R;
            !r and return
            rs&eph and return d.not = 1
            rs&compLines and rs&compLines(D,d)
        }
        return me&Lineso,s,d
    }
    
    # see Jay Y:osc 7
    # make W.js usable for:
    #  boot: w:Twoism loadI, page includes Hunt.js (moved out of W/)
    #  u: @Search Talks.js
    #   < without the lookup step (you know %dige)
    me.jsso = &acgttd{
        # have just been Lineso'd
        $W = me&ioty,t .filter(n => nc&W == 'of');
        !d.dige and throw "W.1 !dige"
        $clone = &s{
            $D = Cye(s);
            # < do anything now?
            G&Compress,D;
            d.compLines and d.compLines(D,d)
            return D
        }
        $shush = &s{
            return s.replace(/\W+/g,'_')
        }
        
        # first function, on the first line, should be a toc
        # one item per line of it, including line number ranges
        # flat list, to include toc
        $N = [];
        each iI W {
            $z = me&ioty,I;
            I = W[i] = clone(I)
            Iy&cv ||= 0.1;
            $Icv = cvf(Iy&cv)
            z.map(&n{
                n = clone(n);
                ny&cv ||= 0.1;
                ns&name = shush([t.t,d.dige,I.t,Icv,
                    n.t,cvf(ny&cv)].join('_'));
                !nc&s.match(/^function/) and throw "doesnt ^function", n
                nc&s = nc&s.replace(/^function/,'function '+ns&name)
                ac(I,'z',n);
                N.push(n)
            })
        }
        each in N {
            !nc&s.match(/\n$/) and throw "No trailing \\n", n
            ns&lines = nc&s.split("\n").length
        }
        
        # [ind t y c sc]+
        $toc = [];
        each iI W {
            toc.push(['',I.t,cvf(Iy&cv),I.c,I.sc]);
            me&ioty,I .map(&n{
                toc.push(['  ',I.t,cvf(Iy&cv),n.c,n.sc]);
            })
            delete Is&z;
        }
        # also ^function...{\n and \n}\n$
        $toc_lines = toc.length + 3; 
        $code_lines = 0;
        each in N {
            ns&line = toc_lines + code_lines;
            code_lines += ns&lines;
        }
        $codes = [];
        each in N {
            codes.push(nc&s);
            delete nc&s;
        }
        $name = shush([t.t,d.dige].join("_"))
        $cur = shush([t.t,'current'].join("_"))
        return [
            "function "+cur+" () { return "+name+"() }\n",
            "function "+name+" () { return [\n",
            # data and code has indent
            ... toc.map(l => l[0]+enj(l)+",\n"),
            "]}\n",
            ... codes
        ].join('')
    }
 
 // Lines string<->thing de?construction
  
  // &Compress, &oleak, &cmuted
    # check data depth or (yaml encoded) length
    #  bails encode as soon as depth > $d*3
    #  has to finish to figure length
    me.oleak = &acgtsdl{
        $fail = 0;
        $was = window.maxyamling;
        window.maxyamling = d * 3;
        $code;
        try { code = jsyaml.safeDump(s) }
        catch (er) {
            window.maxyamling = was;
            er.message != "Too much to yaml" and throw er
            fail = 1;
        }
        if (l && code && code.length > l) {
            fail = 'large-ish'
        }
        window.maxyamling = was;
        return fail
    }
    
    # string avoids various things
    # < an embryonic composited sub, like thro, 
    # < the opposite, collected from n and something else...
    # < use the d (state from G&ind) to make links for duplicated objects
    # see j/7 K: used to mute any ref not gk =~ /x$/
    me.Compress = &acgtsd{
        # will be gone if we $s = Cye(...)
        delete ss&z;
        
        # especially if pi
        ss&J and delete sc&s;
        typeof sc&s == 'object' and delete sc&s
        typeof ss&J == 'object' and delete ss&J
        
        # makes c.code -> c.mc=code
        #  would otherwise c.mc=code:$arfgunc
        me&cmuted,s,{mute:{c:['code'],sc:[]}}
    }
    # drop C.*.* objects other than Object|Array
    #  eg c.on (HTMLDivElement) -> c.mc=on
    # < Be properties
    me.cmuted = &acgtsc{
        $mute = c.mute;
        $sep = ' '
        $unmuted_objects = [Object,Array];
        each nk,gks mute {
            $he = s[nk];
            $muted = {};
            each gk,v he {
                gks[gk] and muted[gk] = 1; continue
                # data should be limited somehow...
                typeof v != 'object' and continue
                unmuted_objects.indexOf(v.constructor) >= 0 and continue
                # name of v.constructor
                muted[gk] = G&arfgunc,v || 1;
                
            }
            each gk,reason muted {
                delete he[gk]
            }
            !hak(muted) and continue
            # say that it is muted, eg c&mc = 'the muted keys'
            #  in a space separated peel (hash)
            $ou = 'm' + nk[0]
            $was = s.c[ou]
            was and ex(muted,G&peel,was,{sep} )
            s.c[ou] = G&depeel,muted,{sep}
        }
    }
  
  // Lines types
    # < use from o that can conjoin the many C
    # aims for simplicity of notation for &deL, G&C, G&peel
    # block quotes (BQ) big strings or data after the  line
    # uses json for anything complicated
    # z insides done by the process around this one Line
    #  - they have the same indent as BQs
    #    but their t should json or not look like BQ
    # < put BQ at an odd indent... 1 space for keys, 3 for values
    #    as long as key|value|nextC always ^\S
    #   needs to convert all of W/ for this
    #    probably not that many instances of it
    # notice if gk|v will break if encoded via peel()
    # < dealing with c = enj(number) when eg c&s=5? -5?
    #   everything except y&cv may decode as string, eg via peel()
    #    unless it is inside c.* for enj(c)
    # < there is probably a looser Lines scheme...
    #   which should not have to include \t all the time,
    #   but may json quote if spacey .t
    #   or if c gets spacey and cant just join with more space to sc
    #    which will need to happen anyway if sc is spacey
    #   < ende - the symmetrical encode|decode thingkitexture
    me.Lines_types_is = null
    me.Lines_types = &acgt{
        $is = me.Lines_types_is
        is and return is
        $is = {}
        
        $ty = {}
        # breaks the \t=09,\n=0a of the enclosing Line
        ty.lowdown = "[\\u{0}-\\u{a}]"
        # start of hemisphere (c|sc) that wants dej()
        ty.jsoning = "^[\\[\\{\"]"
        # y,c may have %sc,starting,early
        # < from &enL (now from ws:digwaypoll)
        ty.earlysc = "^%"
        # < return line count?
        ty.multiline = "\\n"
        ty.wordyspace = "^\\w[\\w ]*$"
        
        # v never starts hem. can contain a lot, even ':'
        #  since peel splits by all ',', then one ':' each
        ty.unsafe_v = [ty.lowdown,','].join('|')
        # k might start hem. must not look like jsoning.
        ty.unsafe_k = [ty.earlysc,ty.jsoning,ty.unsafe_v,':'].join('|')
        
        $func = &ty{
            is[t] = &s{
                $notstring = typeof s != 'string' && typeof s != 'number'
                notstring and throw "Lines_types.is!string", s
                return y (s+'')
            }
        }
        # must define $t for a function
        haks(ty).map(&t{
            $m = RegExp(ty[t],'u')
            func(t, s => m.exec(s) )
            if (t.startsWith('un')) {
                # derives is.safe_k(k)
                func(t.substr(2), s => !is[t](s) )
            }
        })
        # also, aesthetics
        is.fitsin = (v,s) => (''+s).length <= v
        is.good_k = s => is.fitsin(23,s) && is.safe_k(s)
        is.good_v = s => is.fitsin(64,s) && is.safe_v(s)
        is.screedy = s => !is.fitsin(42,s)  && is.multiline(s)
        me.Lines_types_is = is
        return is
    }
    
   // indents, struct types
    # Lines C may have indented bits after
    # < at one space, inconfusible with C/C indent
    me.LinesBQ_indent = '  '
    # for N|i of '  ', starting with i=1 -> ''!
    # < rename. GONE? used once.
    #   could call &indents,(d-1)*2,s,'notailn'
    self.indent = &ds{
        d == 0 and throw "d!>0"
        isar(d) and d = hak(d)
        s and throw "< splitindjoint"
        # 1:'',2:'  ',3:'    '...
        return new Array(1*d).join('  ')
    }
    # &ind (around &enL) uses '  ', BQ-ish things use:
    self.indents = &l,v,notailn{
        num(l) and l = new Array(1+l*1).join(' ')
        !isst(l) and throw "indent ' '?"
        $vs = [];
        # "the","lines" <- "the\n","lines\n"
        v = Lin_Lines(v)
        each is v {
            vs.push(l+s)
        }
        !notailn and vs.push('')
        return vs.join("\n")
    }
    # $L = ["the","lines"] <- "the\nlines\n"
    self.Lin_Lines = &v{
        v = isar(v) ? v : v.split("\n")
        # chomp off the tail end
        v.slice(-1)[0] == '' and v.pop()
        return v
    }
    # we take the indent off to make it Cy&deLines!
    self.unindents = &d,v,notailn{
        !num(d) and throw "indent d"
        $vs = [];
        v = Lin_Lines(v)
        each is v {
            # bite off space
            $space = s.substr(0,d)
            space.split('').some(a => a!=' ') and debugger
            
            vs.push(s.substr(d))
        }
        !notailn and vs.push('')
        return vs.join("\n")
    }
  
  // &enL toLines - C to string
    A.I.i.y.tw.toLines.c.code =
    me.enL = &acgts{
        
        s and C = s;
        $t = C.t;
        $y = C.y.cv;
        # hath
        $h = {};
        h.c  = ex({},C.c||{});
        h.sc = ex({},C.sc||{});
        delete hs&z;
        # needs json
        $n = {};
        # needs blockquote
        $q = {};
        # as determined by
        $is = me&Lines_types
      
      // sayability!
        # check out how sayable the values on the line are
        # for c/sc as peelable, 
        # < we can know thing:thing:thing
        #   means thing = 'thing:thing'
        # GOING is.safe_v,safe_k
        $peelok = /^[\w\.\-%\/:]+$/;
        $nameok = /^\w[\w\.\-%\/]*$/;
        # GOING is.good_k
        $simp = &s{
            s = ''+s;
            return is.safe_k(s) && s.length < 24
        };
        # inject 2sphere
        $lod = &n,nk,gk,v{
            n[nk] ||= {}
            n[nk][gk] = v
        };
        each nk,gk,v h {
            if (!is.good_k(gk)) {
                lod(n,nk,gk,v)
                continue
            }
            if (typeof v != 'string' && typeof v != 'number') {
                # is > 4*3 nodes or encodes to > 42 chars
                if (me&oleak,v,4,42 ) {
                    me&oleak,v,24 and throw "Leaky "+nk+"."+gk+": "+ki(v);
                    # big enough to quote, simplifies remainder
                    lod(q,nk,gk,v);
                }
                else {
                    # ref too small to quote, json hemisphere
                    lod(n,nk,gk,v);
                }
            }
            else {
                if (is.screedy(v)) {
                    # long enough to quote
                    lod(q,nk,gk,v);
                }
                else if (is.good_v(v)) {
                    # decipherable to G&peel
                }
                else {
                    # midway to unwieldy
                    lod(n,nk,gk,v);
                }
            }
        }}

      // sayableparts!
        # quote freaks (q), json freaks (n), everything (h)
        each nk,gkv n {
            $g = h[nk]
            !hak(g) and debugger
            $gnotq = grepout(haks(g),k => !(q[nk]&&q[nk][k]))
            $gnotnorq = grepout(gnotq,k => !n[nk][k])
            # reasons not to n -> q
            # nothing else in the spot
            !hak(gnotnorq) and continue
            # complex keys must be json
            # < making blockquote opener: sc "anykey":
            #    requires tight match right of :
            #     requires eny(v) on the next line, as for !string
            #     < unless parse everything at once
            haks(gkv).some(k => !is.wordyspace(k)) and continue
            # reasons to become a quote:
            # among g that are not q
            if (hak(gkv) / hak(gnotq) < 0.34) {
                # mostly not n in the spot
                each kv gkv {
                    lod(q,nk,k,v)
                }
            }
            else {
                each kv gkv {
                    is.fitsin(23,k) and continue
                    lod(q,nk,k,v)
                }
            }
        }
        
        # remove quoted things and their need of json from the line
        each nk,gk,v q {
            h[nk] and delete h[nk][gk]
            n[nk] and delete n[nk][gk]
        }}
        # all freaks got quoted
        each nk,gkv n {
            !hak(gkv) and delete n[nk]
        }
      
      // encoded bits
        # may pass a T.enj_catch, so functions can warn/show up as 'CODE'
        $enj = &s{ return window.enj(s,T) };

        # t can be messy, very long (as opposed to is.good_k)
        $l = is.safe_k(t) ? t : enj(t);

        # y.cv = 1 is implied
        !y and y = 1
        y = numf(y)
        y = y == "1" ? '' : y
        # -suchpi can be attached to it
        if (h.c.pi && !(n.c && n.c.pi)) {
            $pi = delete h.c.pi
            y += '-'+pi
        }
        l += "\t"+y

        # one way or another
        $hem = ['c','sc'];
        each i,nk hem {
            $v = h[nk];
            if (nk == 'c' && 0 == hak(v)) {
                # blank
                l += "\t";
            }
            else if (nk == 'c' && 1 == hak(v) && hak(v,'s')) {
                # t y "the s" sc
                l += "\t"+enj(v.s+'')
            }
            else if (n[nk]) {
                # json bits: t y {W:"At"} {et:3,se:"te",ra:1}
                l += "\t"+enj(v)
            }
            else if (hak(v)) {
                # G&peel bits: t y W:At et:3,se:te,ra
                l += "\t"+G&depeel,v
            }
        }

      // indented bits
        $L = [];
        # < quoting with Line other N/C looking vals
        each nk,gk,v q {
            # < sanity. nk will be c|sc
            #   should be covered? see complex keys must be json
            !is.safe_k(gk) and debugger
            # specifically, see &deL $indenting
            !is.wordyspace(gk) and debugger
            !nk.match(/^\w+$/) and debugger
            $k = me.LinesBQ_indent
                +nk+" "+gk+":"
            if (typeof v != 'string') {
                # BQ yaml data
                # < rename T.eny_trace, its error handler uses
                T.eny_nkgk = [nk,gk]
                $v = eny(v,T)
                delete T.eny_nkgk
                k += "\n"+indents(me.LinesBQ_indent+'  ',v,1)
            }
            else if (is.safe_v(v)) {
                # simple strings
                # < not confusible into 'Thing 2'?
                k += " "+v
            }
            else if (!v.match(/\n$/)) {
                # BQ implies trailing \n
                k += " "+enj(v);
            }
            else {
                # BQ string
                k += " |\n"+indents(me.LinesBQ_indent+'  ',v,1)
            }
            k = k.replace(/\n\s*$/,'');
            L.push(k);
        }}
        
        # extra lines (L) sorted, larger bits after smaller
        L = L.sort();
        $tidy = [];
        $large = [];
        each is L {
            s.length > 300 ? large.push(s) : tidy.push(s)
        }
        l = [l];
        tidy.length and l.push(tidy.join("\n"))
        large.length and l.push(large.join("\n"))
        l = l.join("\n");
        
        return l
    }
   
  // &deL readLines - string to [C+]
    # for $C = &deL1 <\<''
    #   Atoms -with spaces %when,you,cant,type,tabs
    me.simpdeL = &acgts{
        $L = s.split("\n").map(&s{
            !hak(s) and return s
            $p = me&parserify,s
            p.p(/^( +)/)
            $m = p.s.split('  ')
            hak(m) == 1 and m = p.s.split(' ')
            # t,y,c,sc = 0,1,2,3
            m[3] && m[3].startsWith('%') and m[3] = m[3].slice(1)
            return (p.1||'')+m.join("\t")
        }).join("\n")
        return theone( me&deL,L,{attach:'fiu'} )
    }
    A.I.i.y.tw.readLines.c.code =
    me.deL = &acgts,opt{
        
        opt ||= {};
        $is = me&Lines_types
        $L = Lin_Lines(s);
        $oL = [];
        $tot = L.length;
        # N=[C+]
        $N = [];
        $stack = [];
        $paniconce = 0;
        while (L.length) {
        
      // rowing
        $l = L.shift();
        # rebuild what y&toLine was here
        $Line = [l]
        # first line of each Line+indented-stuff only, a trace
        # < a stack
        oL.push(l);
        # < shouldn't happen, BQ blank lines are indented
        !l.length and continue
        $lin = l.match(/^(\s*)(.*)$/);
        $ind = lin[1];
        $d = ind.length / 2;
        l = lin[2];
        $li = l.split("\t");
        $t = li[0];
        $y = li[1];
        $c = li[2];
        $sc = li[3];
        # sc can kick in early, still one \t
        y && y [0] == '%' and sc = y.substr(1); y = '';
        c && c [0] == '%' and sc = c.substr(1); c = '';
        y && opt.y1 && opt.y1[0] == '%' and (opt.tosc ||= {})[opt.y1.slice(1)] = y; y = '';
        # t may be crazy string
        is.jsoning(t) and t = dej(t);
        if (y && y.includes('-')) {
            # 33-suchpi
            $m = y.split('-')
            $pi = m [1]
            !pi || m[2] != null and throw "!33-suchpi",y
            y = m [0]
        }
        y ||= "1"
        y * 1 == NaN and debugger
        # < see scv(cv)
        y = {cv:1*('0.'+y)}
        
        # c&s as a fifth thing on the line
        $s = li[4];
        if (s && is.jsoning(s)) {
            s = dej(s)
        }
        if (c && c.startsWith('"')) {
            s = dej(c)
            c = {}
        }
        else if (c && is.jsoning(c)) {
            c = dej(c)
        }
        else if (c) {
            c = G&peel,c
        }
        else { c = {} }
        
        s != null and c.s = s
        pi and c.pi = pi
        
        if (sc && is.jsoning(sc)) {
            sc = dej(sc)
        }
        else if (sc) {
            sc = G&peel,sc
        }
        else { sc = {} }
        
        
        $C = {t,y,c,sc}
        
      // indented bits
        
        $k
        $v
        $indenting = &{
            !L.length and return
            $m = L[0].match("^"+ind+me.LinesBQ_indent
                +"(\\w[\\w ]+):(?: (\\||.+))?$")
            !m and return
            k = m[1]
            v = m[2]
            return 1
        };
        while (indenting()) {
            $string
            if (v === '|') {
                string = 1;
                v = undefined;
            }
            v && v.match(/^\W/) and v = dej(v)
            Line.push(L.shift())
            k = k.split(' ');
            $nk = k.shift();
            $gk = k.join(' ');
            if (!v) {
                $s = [];
                $one;
                $blockquoting = &{
                    !L.length and return;
                    $m = L[0].match("^"+ind+me.LinesBQ_indent
                        +"  (.*)$");
                    !m and return;
                    one = m[1];
                    return 1;
                }
                while (blockquoting()) {
                    s.push(one);
                    L.shift();
                }
                v = s.join("\n");
                # console.log("Loaded "+nk+gk+": "+v+'  Next: '+L[0]);
                if (!string) {
                    v = jsyaml.safeLoad(v);
                }
                else {
                    !v.match(/\n$/) and v = v+"\n"
                }
            }
            C[nk][gk] = v;
        }
      
      // attach
        # the chunk of string goes with it
        Cy&deLines = unindents(d*2,Line,1)
        d.toFixed() != d and ~fractionalind: d, C, T.readinglv
        d = 1 * d.toFixed();
        if (d > 0) {
            $p
            $dl = d;
            while (dl--) {
                p = stack[dl];
                p and break
            }
            if (dl < d - 1) {
                $few = oL.slice(-3);
                if (! paniconce++) {
                    ~toomuchind: d, dl, T.readinglv, few
                    debugger
                }
                d = dl+1;
            }
            # use io?
            if (opt.attach == 'fiu') {
                me&fiu,p,C
            }
            else {
                ps&z ||= [];
                ps&z.push(C);
                # tv/tw/in/next?
                $tv =
                p.y.tv ||= {};
                tv[C.t] ||= {};
                tv[C.t][C.y.cv] = C;
            }
            # a mass inCing, dialecting
        }
        else {
            N.push(C);
        }
        stack[d] = C;
        while (stack[d+1])
            stack.pop();
            opt.tosc and ex(C.sc,opt.tosc);
        
        }
        return N
    }
 
 // string<O>string
   
