# lines of characters, etc!!
 
 // -String etc
     // &Stringclue|chew
        # used in &drawtextliner
        me.drawString = &acgtsc{
            c ||= {}
            !isob(c) and c = {tsc:c}
            # detect clue.say|pi|hs (|crush|geo|odd)
            $clue = me&Stringclue,s,{}
            
            $n = me&ts,'string','',c.tsc
            ns&fs = 8
            ns&hs = clue.hs
            
            # always add marks
            me&Stringchew,n,ex(clue,c)
            
            return n
        }
        # string-ish type checker
        me.Stringclue = &acgtsc{
            isob(s) and debugger
            c ||= {}
            c.say = ''+s+''
            
            # undef|null
            s == null and c.pi = 'Null'; c.hs = 559
            else
            # true|false
            isbo(s) and c.pi = 'Bool'; c.hs = 559
            else
            # data was number
            isnu(s) and c.pi = 'Number'
            else
            # number-looking and number-acting
            num(s) and c.pi = 'Num'
            
            else {
                !isst(s) and debugger
                c.hs = 584
                # < large, Lines, binary, base64 etc
                # rudimentary large safety
                $r = c.R
                $large = r && rc&d < 2 ? 150 : 50
                if (c.say.length > large || c.geo) {
                    $geo = c.geo ||= {}
                    $size = me&textsize,c.say,geo
                    if (geo.lines > 12 || geo.length > 200) {
                        # on screen
                        c.say = cint(size,dig(s))
                        c.crush = 1
                        $R = c.R
                        if (R) {
                            # note a crush
                            me&ha,R,'limit:Longstring',{},{size}
                            # becomes Dc&s, as opposed to Ec&s == s
                            Rs&Longstring = c.say
                        }
                    }
                }
                if (c.crush || c.say.match(/\W/)) {
                    c.odd = 1
                }
            }
            
            # colour
            c.pi == 'Null' || c.pi == 'Bool' and c.hs = 559
            c.pi && c.pi.startsWith('Num') and c.hs = 583
            
            return c
        }
        # modulate n/** with coloured bits of string!!
        me.Stringchew = &acgtnc{
            $M = ns&z ||= []
            if (c.crush) {
                m crushed-string  s:~ %fs:20,lh:0.7
                m it  $s:c.say
                return
            }
            # < &tt could say bring it all
            #  < into a codemirror
            # annotating space-types is all we want?
            $L = c.say.split(/(?<=\S)(?=\s+\S)/)
            $la = 0
            $p = me&parserify,'ya'
            each il L {
                # gets nibbled down eg (\n)(    )(stuff)
                p.s = l
                while (p.s.length) {
                    if (p.p(/^ +/)) {
                        $sayspace = c.squishindent ? " " : p.it
                        m space  $s:sayspace
                        $len = p.it.length
                        len > 1 &&
                            m spaces  $s:len %mark,little
                    }
                    if (p.p(/^\t/)) {
                        m tab  s:⇥ %mark,wide
                    }
                    if (p.p(/^\n/)) {
                        m nl  s:␤ %mark
                    }
                    if (p.p(/^\S+/)) {
                        m it  $s:p.it
                    }
                }
            }
            
            each in M {
                ns&mark and ex(n.sc,peel('mr:0.1,lh:0.7,hue:100'))
                # < scale-x?
                ns&wide and ns&lh = 0.5; ns&fs = 16
                ns&little and ns&fs = 7
            }
            
            # < c.subsel a bunch of ｢40｣ to sprinkle through
            #    or anything, with &textsprinkle
            #    a &textarrow could be put somewhere in a -String
            #   if not whole, c.quote=1
            
            # quote whole
            $marks = !c.subsel ? ['｢','｣'] : ['«','»']
            m brack-start  $s:marks[0] %mark,start
            m brack-end  $s:marks[1] %mark
            grepout(M,n => ns&start).map(n => M.unshift(n))
        }
 
 // Diff
   # < copy from Soogle
 
 // Ploy = (D Comp/l+ D)**
    # classifies differences
    // Ploy
        # proto io, on 3c&io|iz|o(X|x,...)
        # < compile &iocall to A.3.i.iocall
        me.Ploy_io = &acgt{
            A.3 != A and debugger
            3c&io = &xkv{
                # all indexes are k:v (&X_t)
                # ~~ c.wild: vx={v:x+}
                v == '.*' and return x[k]
                # or x+
                v == '*' and return havs(x[k])
                v == -1 and return havs(x[k]).pop()
                return fi&Xsimp,x,hashkv(k,v)
            }
            # push to eg sph|nod/$line=i++
            3c&iz = &Xkx{
                $many = 3c&io(X,k,'*')
                $i = hak(many)
                # we may mesh|multi-path|link X...x
                x and ahk(X,k,i,x)
                else {
                    # or new ..x as usu
                    x = 3c&io(X,k,i)
                }
                # meshing may eg i_line|mine
                # < crude avoidance of same-index sequence distribution
                #   having a subset at some locale
                x['i_'+k] = i
                return x
            }
            3c&o = &xsy{
                $path = split(s,/\/|(?=\.)/)
                $N = [x]
                each in path {
                    if (n.startsWith('.')) {
                        # eg bit.l
                        N = N.map(x => x[n.slice(1)])
                    }
                    else {
                        N = flatten(N.map(x => 3c&io(x,n,'*')))
                    }
                }
                if (y) {
                    $lai = hak(N)-1
                    $M = []
                    each in N {
                        # < gr3p(): y(v,k,setc) about where you are
                        #    and relations nearby, is very almost io
                        $setc = {i}
                        0 == i and setc.first = 1
                        lai == i and setc.last = 1

                        $ret = y (n,setc)
                        setc.not and return
                        ret and M.push(ret)
                    }
                    # y() as grep(armap(y,N))
                    N = M
                }
                return N
            }
        }
        me.Ploy = &acgt,nav,Comp{
          // A:Ploy init
            A = fi&At,"Ploy"
            A.3 = A
            me&Ploy_io
            
            me&boxcap,'Ploy',5 (&ml{
                
                lc&not = 1
                # options
                me&Ploy_spannyrower,'conf' (&ml{
                    # if you &Ploy_fail, these draw the context in time for it:
                    me&boxcap,'pass1' (&ml{
                        # drawjoin as soon as it is joined
                        #  omits l that belongs to a later joi
                        me&tt,'only' () and 3c&single_pass = 1
                        me&tc,',','6y'
                        # draw l etc as it goes
                        #  we then replace them with a drawjoin
                        me&tt,'lasap' () and 3c&accreting_modulat = 1
                    })
                    # shows the possible fixes...
                    me&tt,'nofix' () and 3c&nofix = 1
                })
            })
            # pass 1
            # make joined nod from l+
            me&Ploy_Comp_sph,nav,Comp
            
            if (!3c&single_pass) {
                # decide how to rewrite Comp/l+ for less %stretch
                me&Ploy_joins_fix
                
                3c&not and me&tc,"Abort",'G'; return
                if (a&fixed_Comp) {
                    # doctored input data for clearer diffs, see fix joi%stretch
                    me&Ploy_spannyrower,'fix' (&ml{
                        a&fixed_joins .map(&joi,{
                            me&Ploy_tid,joi
                        })
                    })
                    if (!3c&nofix) {
                        # around again
                        me&Ploy_Comp_sph,nav,a&fixed_Comp
                    }
                }
                
                # group like stuff
                me&Ploy_regions
                
                3c&o(3c&X,'join',&joi,{
                    A = fi&At,'joins:'+joi.i_join
                    A&joi = joi
                    # happens every &Ploy_joined if 3c&single_pass
                    me&Ploy_drawjoin
                    A = A.3
                })
            }
            return 3c&X
        }
        # makes X, l+ -> sph+
        me.Ploy_Comp_sph = &acgt,nav,Comp{
            $X = 3c&X = {A}
            3c&Comp = Comp

            # check nav.* = RE
            # see &Ploy_nod_next
            #  for our swerve into the first_truest after RE
            # < have pointers to these things, time specified. lv C.
            map(&RE,{
                # RE//s (on the same node)
                $s = REy&ers
                !s and debugger
            },nav)
            
            # sph/nod|lin
            $tops = armap(&et{
                # for old|new E**
                $sph = 3c&io(X,'sphere',t)
                sph.sphere = t
                # line 0
                $lin = 3c&iz(sph,'line')
                # node 0
                $nod = me&Ploy_i_nod,sph,e
                $D = nod.D
                !Dy&toLines and debugger
                me&Ploy_i_lin,nod,lin
                return nod
            },nav)
            # join 0
            me&Ploy_i_joi,'given',tops
            
            
          // Comp/$l -> $sph
                
            each il Comp {

                ly&seqi = i
                A = A.3
                3c&accreting_modulat
                    && me&drawdiffbit,i,l

                $who = l.t == 'same'
                    # == are for both spheres
                    ? havs(3c&io(X,'sphere','*'))
                    # ++|-- only for sph:new|gone
                    : [3c&io(X,'sphere',l.t)]

                who.map(sph => me&Ploy_sph,l,sph)

                A = A.3

                # after &Ploy_fail
                3c&not and me&tc,"Abort",'G'; break

                # to A3:Ploy/A:join+
                3s&joined and me&Ploy_joined
            }

            # check we found our way back to each sph/nod0
            $lost = tops.slice()
            grop(3s&seemsdone,lost)
            hak(lost) and me&Ploy_fail,"seemsdone",ex({},lost)
                
            return X
        }
        
        # l -> sph, matching
        me.Ploy_sph = &acgtl,sph{
            3c&not and return
            # to A3:Ploy/A:l+
            #  A:l always up to A3
            A = A.3
            $title = 'l:'+ly&seqi+':'+sph.sphere
            # nod remembered by last sph/lines
            #  can return null if !Dy&toLines
            $a = me&Ploy_nod_arrive,sph,l,title
            !a and 3c&not = 1; return
            A = a
            fatal.isC(A&nod.E)

            !A&nod.joi and debugger
            me&Ploy_joi_arrive

            if (ls&moren) {
                # l%moren is a fold marker, everything inside is t=same
                #  we avoid leaving to nod**, which are spared from Comp
                #  it is otherwise a regular l, for A&nod
                # < (upstream) shouldnt %moren if many is small
                #    > unless many small %moren close together
                $many = hak(ls&moren)
                !(isar(ls&moren) && many) and debugger
                A&nod.hasmoren = many
            }
            me&Ploy_indent_sympathy
            me&Ploy_match
            3c&not and return
            me&Ploy_nod_check
            ls&moren && !(a&newline && a&newnode) and debugger
            # join l sequence
            me&Ploy_joi_lit
            me&Ploy_noded
        }
    
    //  nod
        # ^nod|sph += nod
        me.Ploy_i_nod = &acgtxe{
            $sph = x.sph || x
            # climb /$in** = nod, so nod.up reflects Ey&up
            $nod = 3c&iz(x,'in')
            nod.d = (x.d||0) + 1
            # link sph/$node flatly (width first, !~~ &ind)
            3c&iz(sph,'node',nod)
            # nod knows:
            nod.sph = sph
            nod.E = e
            !ey&R and throw "undone E"
            nod.D = Aof(e,'D')
            # the RE doesnt have a D**
            # < should it? ~~ Js&top: $W@9/*
            #   and the RE/-hat|etc is an osc page
            #    so each page has an encoding defined as pi
            #     which may index pages by something else (t)
            #    and W formats are explained as eg $Wt/1.js
            #     which -js will be able to read,
            nod.D ||= nod.i_node == 0 && nod.E
            # eventually /$line of its diffside
            return nod
        }
        
        
        
        # the usual arrive, think, descent
        #  the usual particle (A.1) is basically nod**
        #   nod is also per sph
        #   A:l is per l
        #    for a nod finding it has /lin/bit
        me.Ploy_nod_arrive = &acgt,sph,l,title{
            A = fi&At,title

            # sph/$line/$bit .l|str
            $lin = 3c&io(sph,'line',-1)
            !lin and throw "nolin"
            $bit = 3c&iz(lin,'bit')
            bit.l = l
            # lc&s is a displayified string, sometimes has s/\n/↯/
            !isst(ls&string) and debugger
            $str = bit.str = ls&string
            # join: one lin to many l
            hak(str)-1 < str.indexOf("\n") and throw "many lin to one l"

            $nod = lin.nod
            # -Fez is C-shy
            $V = nod.prev && nod.prev.A
            nod.A = A
            # a second opinion on next nod, from last A:l
            V && Vs&next && nod != Vs&next and debugger
            
            ex(A.c,{sph,nod,lin,bit})

            # so we A3:Ploy/A:l+
            if (!V || Vc&nod != nod) {
                $D = nod.D
                nod.whole = Dy&toLines
                !isst(nod.whole) and debugger
                !isst(nod.whole) and return me&Ploy_fail,'toLines',{l}
                3c&accreting_modulat and me&drawnod,nod
            }
            
            return A
        }
        
        
        # next nod|lin
        me.Ploy_noded = &acgt{
            # per sph:
            $nod = A&nod
            $lin = A&lin
            if (a&newnode && a&newline) {
                # tidy away nod
                delete nod.matchtil
                nod.Cindent && nod.Cindent == nod.d-1 and delete nod.Cindent
                nod.ok = 1
                # more nodes
                $next = me&Ploy_nod_next
                if (!a&seemsdone) {
                    !next and return me&Ploy_fail,"nextless"
                    isC(next) and return me&Ploy_fail,"nextC",{next}
                    nod.next = next
                    next.prev = nod
                    nod = a&next = next
                }
                # let join happen
                ac(A.3,'joined',A)
                a&seemsdone and return
            }
            if (a&newline) {
                # tidy away lin
                delete lin.indent_sympathy
                # < until a multi-lines y&toLines
                !a&newnode and debugger
                # make empty lin to use next time around
                lin = 3c&iz(A&sph,'line')
                me&Ploy_i_lin,nod,lin
            }
        }
        # more nodes: nod/*[0] first, then ^^/[nod+1]
        me.Ploy_nod_next = &acgt{
            $E = A&nod.E
            $N
            # as long as we want to go into nod**, see l%moren
            $inward = !A&nod.hasmoren
            # i nod/* o E/*
            if (inward) {
                if (A&nod.i_node == 0) {
                    # is an RE, use first_truest rendition of eg RE/-hat
                    $truest = ahsk(Ey&ers,'y','first_truest','E')
                    # and there is only ever one RE/E (outside/inside &Piing)
                    truest and N = [truest]
                }
                # < generalise o E/*
                N ||= me&ioty,E .filter(e => ey&R)
                # creates all nod/nod:$e for later
                #  and sph/node width first: is not nested: 1, 2, 1/1...
                #   !~~ &ind: 1, 1/1, 2...
                N = N.map(e => me&Ploy_i_nod,A&nod,e )
            }
            $next
            hak(N) and next = N[0]
            else {
                # climb out until a next in
                me&Ay,A&nod,'/^^',{},{} (&nda{
                    # be a node
                    # n/[a+1]: another one after
                    n.in[a.i_in] != a and debugger
                    next = n.in[a.i_in*1+1]
                    if (!next) {
                        if (!n.i_node) {
                            # returns to the root at the end
                            ac(A.3,'seemsdone',n)
                            a&seemsdone = 1
                            d.not = 1
                        }
                        # keep going up
                        return
                    }
                    # we have a node
                    d.not = 1
                })
            }
            return next
        }
    
    //  lin
        me.Ploy_i_lin = &acgt,nod,lin{
            $sph = nod.sph
            sph.line[lin.i_line] != lin and debugger
            # nod/$mine is a subset of sph/$line
            3c&iz(nod,'mine',lin)
            # join: one nod to many lin
            lin.nod = nod
        }
        # line may start with spaces, to imagine into exp
        me.Ploy_indent_sympathy = &acgt{
            # leading bits, until [^ ] is found
            $bit0 = A&bit.i_bit == 0
            bit0 and A&lin.indent_sympathy = 1
            !A&lin.indent_sympathy and return
            
            # < until multi line D, but only when:
            #    flip indent_sympathy back on for lin-1 that BQ ?
            #     ie choose your own next indent for < < ' '
            $lin0 = A&lin.i_mine == 0
            !lin0 and debugger
            
            # we only ever make C-indents (Linesing C/*) outside of D
            !A&bit.str.startsWith('  ') and return delete A&lin.indent_sympathy
            # count ^(  )+
            $level = hak(ksaf(A&bit.str,{bow:s => s != ' ',may:1}))
            $Cindent = Math.floor(level/2)
            # < never odd? or see Lines / BQ
            level != Cindent*2 and debugger
            
            # we sometimes (++  )(==      yada)
            $entirely = hak(A&bit.str) == level
            if (entirely) {
                # (++  ) should keep going
                # maybe even through (++  )(==      )(++yada)
                #!bit0 and debugger
            }
            # more indent on (==      )
            !bit0 and A&nod.Cindent += Cindent
            
            # ends at [^ ]
            !entirely and delete A&lin.indent_sympathy
            
            # the first line of D has the real indent
            if (A&nod.Cindent) {
                # < sanity (was simple before more indent)
                #    - lin>0 should have at least ' ' more than lin0
                Cindent = A&nod.Cindent
            }
            elsif (A&lin.i_mine == 0) {
                # nod/lin 0 == first line of D
                A&nod.Cindent and debugger
                A&nod.Cindent = Cindent
                # < until treating haphazard text as input
                #    eg see codes / spec / pre-tangent
                #     which wouldnt be a Cindent per se
                #  < or BQ-embedded nodes...
                # this is normal when entirely, eg (++  )
                Cindent != A&nod.d-1 && !entirely and debugger
            }
            
            $relevel = Cindent*2
            # may be spread over many bits, eg (++  )(==      )(++  yada)
            #  we only want to trim this one bit
            3c&io(A&lin,'bit','*') .map(&bit,{
                bit != A&bit and relevel -= bit.trimstart||0
            })
            relevel != level and debugger
            relevel < 2 and debugger
            
            # < check what comes off is ' '+
            A&bit.trimstart = relevel
        }
        # note if|how we change exp to make things fit
        me.Ploy_mung = &acgt,bit,t,v{
            ahk(bit,'mung',t,v||1)
        }
        # nod/whole <-> nod/mine/bit
        me.Ploy_match = &acgt{
            $nod = A&nod
            $lin = A&lin
            $bit = A&bit
            # cursor whole to match
            $at = nod.matchtil || 0
            $str = bit.str
            # str never goes beyond \n
            str.slice(-1)[0] == "\n" and a&newline = true
            # whole does
            $whole = nod.whole
            !hak(whole) and debugger
          // lying
            # ignore str indent, coming from D** travel
            bit.trimstart and str = str.slice(bit.trimstart)
            # < dropping \n from bit, via this mechanism
            #   rather than adding one to exp if non-match now
            #    tho it does get us the \n between many nod/lin
            #     that would be visible as exp[-1]=="\n"
            bit.trimend and str = str.slice(0,hak(str)-bit.trimend)
            # < more munging the expression
            #    eg expect sequence number adjustment
            #    eg between different compressions
            #     one might deL->???->enL

            $len = str.length
            $til = at+len
            $exp = whole.slice(at,til)


            if (exp != str && a&newline) {
                # no \n in y&toLines
                me&Ploy_mung,bit,'+␤'
                exp += "\n"
                til -= 1
                $mungnl = 1
            }
                # < sort out indent funcs
                #    we seem to have .d starting at 1->'', etc
                #    Lines wants to indent by ' ' sometimes
                #   this one does it to exp, multiliney
                #   not too straight forward when exp may end in \n
                #    it should follow input strings form?
                #     and separate casting blah->blah\n
                #indents((nod.d-1)*2,exp,
                #    !ahsk(bit,'mung','+␤') && 'notailn'
                #)
            # should yield the whole line?
            mungnl && til != whole.length and debugger
            
          // so
            ex(A.sc,{str,exp})
            if (exp != str) {
                return me&Ploy_fail,'eq'
            }
            
            # may match nothing
            nod.matchtil == til and a&tilstill = 1
            #  that wasn't just (==\n)
            a&tilstill && !(mungnl && exp == "\n") and a&seeknod = 1
            
            nod.matchtil = til
            til == whole.length and a&newnode = true
        }
    
    //  lit, col, jin/lin/col, joi /lit, /jin/jol/gol
        # joi/lit .l, /bit
        #  l-ordered bits of either sph
        me.Ploy_joi_lit = &acgt{
            $bit = A&bit
            $l = bit.l
            $la = 3c&io(3s&joi,'lit',-1)
            $lit = la && la.l == l ? la
                : 3c&iz(3s&joi,'lit')
            lit.l = l;
            # lets not inform of the rewire..? its just i_sphere
            (lit.bit ||= []).push(bit)
        }
        
        # i lin/col/microcol o lin/bit
        # lazily nod/lin/col, per nod via joined
        # to see col=$nk=t|y|c|sc, assuming Lines encoding
        me.Ploy_lin_col = &acgt,lin,joi{
            lin.i_mine != 0 and return me&Ploy_fail,"multiline",lin
            lin.i_mine == null and debugger
            $nod = lin.nod
            if (lin.col) {
                # may rebuild lin/col with more bits upon joi%stretch
                nod.joi == joi and debugger
                !jois&stretch and debugger
                delete lin.col
            }
            $indent_sympathy = 1
            3c&o(lin,'bit',&bit,{
                $str = bit.str
                # tidy str
                # < what is "string".trimEnd() ?
                str.slice(-1)[0] == "\n" and str = str.slice(0,hak(str)-1)
                
                # have columns
                # < other than Lines + tycsc
                # < other than lin0 is nk,gk,quotes,star**
                # names of the next col
                $cols = ['t','y','c','sc']
                # last lin/col
                $col
                $i = 20
                while (hak(cols)) {
                    i-- < 0 and throw "col loops"
                    $had = lin.col && lin.col[cols[0]]
                    had and col = had; cols.shift()
                    else break
                }
                
                # fill up col+ from bit.str
                $N = str.split("\t")
                # indent column ~~ lin.indent_sympathy
                if (indent_sympathy) {
                    if (N[0].startsWith('  ')) {
                        # make an initial non-\t-delimited column for indent
                        $til = N[0].split('').findIndex(v => v != ' ')
                        til < 0 and til = hak(N[0])
                        $spaces = N[0].slice(0,til)
                        N[0] = N[0].slice(til)
                        # nothing left
                        !hak(N[0]) and N.shift()
                        # something left, no more indenting
                        else indent_sympathy = 0
                        
                        # may split indent, then other columns take it
                        lin.col && cint(haks(lin.col)) != 'indent' and debugger
                        # < cargoey
                        $nk = 'indent'
                        $incol = 3c&io(lin,'col',nk)
                        incol.nk = nk
                        $mc = 3c&iz(incol,'microcol')
                        mc.str = spaces
                        mc.bit = bit
                        # for nod/*lin/*col.changey
                        bit.l.t != 'same' and mc.changey = incol.changey = 1
                    }
                    else indent_sympathy = 0
                }
                each is N {
                    if (!col || i > 0) {
                        # new col
                        $nk = cols.shift()
                        !nk and debugger
                        col = 3c&io(lin,'col',nk)
                        col.nk = nk
                    }
                    # nothing at this point
                    !s.length and continue
                    
                    # since bit may break at any point in a column
                    $mc = 3c&iz(col,'microcol')
                    mc.str = s
                    mc.bit = bit
                    # > keeping in|out points of str in bit, etc
                    
                    # for nod/*lin/*col.changey
                    bit.l.t != 'same' and mc.changey = col.changey = 1
                }
            })
            # Lines always t,y,c
            # < reintroduce this... tripped when jois&seeknod
            #hak(lin.col) < 3 and me&Ploy_fail,"endon-col:c|sc",lin.col
        }
        
        # i joi/#lin:jin/#col:jol/#with:jodol o nod/lin/col
        # joi gathers C.*.* change in stereo (or mono)
        #  only changey
        me.Ploy_joi_jin = &acgt,joi{
            $lin_quant
            me&Ploy_joi_nods,joi .map(&nod,{
                $sph = nod.sph
                # sanity: same number of /lin
                lin_quant != null && lin_quant != hak(nod.lin) and debugger
                lin_quant = hak(nod.lin)
                # assumes each node's nod/lin align
                # < see resolve $n
                3c&io(nod,'mine','*') .map(&lin,{
                    # /#lin:jin
                    $jin = 3c&io(joi,'jin',lin.i_mine)
                    3c&io(lin,'col','*') .map(&col,{
                        # /#col:jol
                        fatal.isst(col.nk)
                        $jol = 3c&io(jin,'jol',col.nk)
                        
                        #  /#with:jodol, now per node
                        #   not quite #with: nod may be from joi/with|loosely
                        $jodol = 3c&iz(jol,'jodol')
                        jodol.nod and debugger
                        jodol.nod = nod
                        
                        # col from either node -> shared line, column
                        sex(jin,col,'changey')
                        sex(jol,col,'nk,changey')
                        #  and jodol, is per node
                        sex(jodol,col,'nk,microcol,changey')
                    })
                })
                
            })
            3c&io(joi,'jin','*') .map(&jin,{
                # lin for both nodes
                3c&io(jin,'jol','*') .map(&jol,{
                    # lin/col for both nodes
                    # the column should have an $nk ark, eg c
                    $nk = jol.nk
                    fatal.isst(nk)
                    if (!jol.changey) {
                        delete jin.jol[nk]
                        return
                    }
                    $jodols = 3c&o(jol,'jodol')
                    !hak(jodols) and debugger
                    
                    # whole of either sph columns
                    # < someday, decompress each via &Lines
                    #    would make whole from nod/lin/bit
                    jodols .map(&jodol,{
                        $nod = jodol.nod
                        $mcs = 3c&o(jodol,'microcol')
                        jodol.whole = armap(mc => mc.str, mcs).join('')
                        if (hak(mcs) > 1 && nk == 't') {
                            # could be for either or both nod
                            # < not to include indent in the t column
                            me&joisc,'tsplit',1
                        }
                    })
                    
                    # < the rest here is pulled from &Ploy_drawjoin_jin,
                    #   which is still too MassiveViewController
                    #    compute and present should be split

                    # changes.$nk, or ."$nk$gk" if sc
                    # degree of change, lower is more serious
                    $degree = 1
                    $knowing = ahsk(me.Ploy_knowing_nkgk,nk)
                    if (knowing) {
                        # parse the sc column
                        # gk=sc aka %, so we can concat the usual notation of eg %♲
                        $ark = knowing.ark || nk
                        degree = 5
                        # i $nk:jol/$gk:gol/#jodol:nogol.v
                        # collect nk/gk/v
                        jodols .map(&jodol,{
                            $s = jodol.whole
                            # < use a sub of &Lines
                            $h = jodol.decoded = s.startsWith('{') ? dej(s) : peel(s)
                            each gk,v h {
                                # col/gol are nk/gk
                                $gol = 3c&io(jol,'gol',gk)
                                fatas(gol,'gk',gk)
                                jodol.i_jodol == null and debugger
                                # each nod's v
                                $nogol = 3c&io(gol,'nogol',jodol.i_jodol)
                                fatas(nogol,'jodol',jodol)
                                nogol.v = v
                            }
                            return h
                        })
                        # difference nk/gk/v (there is a v per jodol)
                        3c&o(jol,'gol',&gol,{
                            $gk = gol.gk
                            $nogols = 3c&o(gol,'nogol')
                            $vs = armap(_=>_.v, nogols)
                            if (vs[0] != vs[1] || hak(vs) == 1) {
                                # < diff refs, etc etc. osc|sustain-ing what-is
                                # < further. seq++ numbers? pointer much changing?
                                
                                # how serious is the change
                                #  so far, ~%♲ is not a big deal
                                $gol_degree = ahsk(knowing,'gk_degree',gk) || degree
                                # joi.changes.$nk$gk=degree
                                ahk(joi,'changes',ark+gk,gol_degree)
                                # joi/jin/jol/gol.degree
                                gol.degree = gol_degree
                                # the various *.changey=1 are deduced from l, not treeaged thusly
                                # most serious percolates to jol.degree
                                #  ie, lots of 8 is still just 8
                                #  usu (5,8) is 5
                                if (!jol.degree || jol.degree > gol.degree) {
                                    jol.degree = gol.degree
                                }
                            }
                        })
                    }
                    else {
                        jol.degree = degree
                        ahk(joi,'changes',nk,degree)
                    }
                })
            })
        }
        
        # classify C.*.* change
        # < to somewhere, for regionating
        # < u Ploy
        me.Ploy_knowing_nkgk = {sc:{ark:'%',gk_degree:{'♲':8}}}
        me.Ploy_drawjoin_jin = &acgt,joi{
            # each jodol/microbit.bit.l is in here
            $ls = 3c&io(joi,'lit','*') .map(lit => lit.l)
            3c&io(joi,'jin','*') .map(&jin,{
                # lin for both nodes
                3c&io(jin,'jol','*') .map(&jol,{
                    # changey lin/col for both nodes
                    # various *.changey=1 are deduced from l
                    !jol.changey and debugger
                    # joi.changes.$nk$gk=degree
                    !joi.changes and debugger
                    # most serious percolates to jol.degree (may also be gol.degree)
                    !jol.degree and debugger
                    $nk = jol.nk
                    fatal.isst(nk)
                    # gk=sc aka %, so we can concat the usual notation of eg %♲
                    $ark = ahsk(me.Ploy_knowing_nkgk,nk,'ark') || nk
                    
                    me&boxcap,ark,4 (&ml{
                        me&walls,m,'b:2.2h4'
                        $maq = me&tsc,'match-quality',jol.degree,'6g'
                        maqs&dis = 2
                        3c&o(jol,'gol',&gol,{
                            !gol.degree and return
                            $gk = gol.gk
                            me&boxcap,"gk:"+gk,2 (&ml{
                                me&walls,m,'b:2.2h4'
                                mc&maybeempty = 1
                                lc&s = gk
                            })
                        })
                    })
                })
            })
        }
    
    //  joi
        =join
          sequence of nod on either side (nod(-nod)?)
           per either of them having a&newnode
          nod.joi given by &Ploy_join / 3c&ijoin
          draw a join table
            < de-indent every so often
              describing the branch stepped into
          
        =cut
       // join f
        # 3s&joi++, with N=[nod +], initially or by &Ploy_joined
        me.Ploy_i_joi = &acgttN{
            $joi = 3c&joi = 3c&iz(3c&X,'join')
            # reason eg given|leaving
            joi.given = t
            # factoid collection, via &joisc
            joi.sc = {}
            # joi/with=nod, nod.joi
            N.map(&nod,{
                # should be a node
                nod.i_node == null and debugger
                # not yet joined
                nod.i_with != null and debugger
                3c&iz(joi,'with',nod)
                nod.joi and debugger
                nod.joi = joi
            })
            # become the latest join
            3s&joi = joi
            return joi
        }
        # joi%$k = $v adds a factoid
        #  args k,v or joi,k,v
        me.joisc = &acgt{
            $args = [...arguments].slice(4)
            $joi = ish(args[0]) ? args.shift() : A&joi
            $k = args.shift()
            $v = args.shift()
            $was = joi.sc[k]
            was && was != v and debugger
            joi.sc[k] = v
        }
        
        # after nod arrives
        me.Ploy_joi_arrive = &acgtN{
            A&joi = A&nod.joi
        }
        
       // join++
        me.Ploy_joined = &acgt{
            A = fi&At,'join:'+3s&joi.i_join
            # we are the joined joi
            $joi = A&joi = A&old = 3s&joi
            # may defer one nod due to not matching any bits, eg joi@49
            me&Ploy_joined_unbitnod
            # passes A:l+, are per sph
            $N = delete 3s&joined
            # all done!
            # < or still a stretch?
            a&Fin = !N.some(V => !Vs&seemsdone)
            if (!a&Fin) {
                # make the A&neu joi
                #  mostly so we can notice it going mono
                $nexts = armap(&V{
                    !(Vs&next && Vs&newline && Vs&newnode) and debugger
                    return Vs&next
                },N)
                
                if (joi.unbitnod) {
                    # carrying an unmatching nod through %mono of the other sphere
                    hak(nexts) > 1 and debugger
                    nexts.push(joi.unbitnod)
                }

                A&neu = me&Ploy_i_joi,'next',nexts
                # joi linked like nod
                A&old.next = A&neu
                A&neu.prev = A&old
            }
            
            
            # is there an oddness to joi/with <-> N[A&nod]
            #  extra nod are put in: joi/loosely
            me&Ploy_joi_stretch_check,joi,N
            # note joi%mono etc, now that unbitnod may have shrunk joi/with
            me&Ploy_joi_mono_check
            
            # when joined (perhaps with /loosely)
            if (hak(joi.lit) > 1) {
                # multiple l, compute columns
                
                # inflate nod/lin/col
                me&Ploy_joi_nods,joi .map(&nod,{
                    3c&o(nod,'mine',&lin,{
                        me&Ploy_lin_col,lin,joi
                    })
                })
                # and merge to joi/jin/jol
                me&Ploy_joi_jin,joi
            }
            me&Ploy_joi_sameness_check,joi
            
            # joi row
            3c&single_pass and me&Ploy_drawjoin
        }
        # may defer one nod due to not matching any bits
        me.Ploy_joined_unbitnod = &acgt{
            $joi = A&joi
            $unbitnods = grep(nod => !hak(3c&o(nod,'mine/bit')),
                3c&o(joi,'with'))
            $nod = theone(unbitnods)
            !nod and return
            joi.unbitnod and debugger
            joi.unbitnod = nod
            # remove joi association
            delete joi.with[nod.i_with]
            delete nod.i_with
            delete nod.joi
            # then joins nexts
        }
        
        # iterate lit(/bit,nod)
        me.Ploy_drawjoin = &acgt{
            $joi = A&joi
            # first and usually only type of row per joi
            #  eg A&modjoi, maybe A&mododd, etc
            $m = me&Ploy_rower
            $l = my&label
            ls&ws = 1
            # allowing the odd message inserted on the next|same line
            A&odd = &ty{
                $m = me&Ploy_rower,'odd'
                A&draw(t,y,m)
            }
            A&draw = &tym{
                me&Ploy_rower_i,m,t (&ml{
                    y (m,l)
                })
            }
          // this row/with|lit|jin
            me&Ploy_rower_i,m,'with' (&ml{
                $la
                3c&io(joi,'with','*') .map(&nod,{
                    # show only one same title
                    # < style about that
                    la && nod.E.t == la.E.t and return
                    me&drawnod,nod
                    la = nod
                })
            })
            
            $ldraw = {}
            me&Ploy_rower_i,m,'lit' (&ml{
                # lit.l, /bit|col
                3c&io(joi,'lit','*') .map(&lit,i{
                    $l = lit.l
                    $lm = ldraw[ly&seqi] = me&drawdiffbit,i,l
                    if (ls&moren) {
                        $ll = me&tsc,"moren-foldmarker",'↦'
                        lls&fs = 20
                        me&tc,"moren-size",'x'+hak(ls&moren),'6y'
                    }
                    else
                    l.t == 'same' and lms&bri = 0.6; lmy&label.c.not = 1
                })
            })
            
            me&Ploy_rower_i,m,'jin' (&ml{
                joi.jin and me&Ploy_drawjoin_jin,joi
            })
          // etc
            # any odd rows after that:
            me&Ploy_drawjoin_factoids
            me&Ploy_drawjoin_fixes
            me&Ploy_drawjoin_regions
            
            if (3c&accreting_modulat) {
                # drop other modulats we just restructured
                # < get them to draw only if they are needed, on+before &Ploy_fail
                $oktypes = peel('sph<-l,l,nod')
                grop(n => oktypes[ns&type], T.ab.sc.z)
            }
        }
      
       // joi%$factoid
        =joi
         A&joi.sc.$oddness = [uniq objects...]
          in either A:l (nod match) or A:joined (joi leave)
           they both have A&joi
          during
           &Ploy_sph (nod matches $l)
            %behinod=$nod - nod.joi != 3s&joi
            %tilmoves=$nod - as above + empty match
             < ^x2 dont seem to happen
            %tilstill=$nod - empty match
            %seeknod=$nod - as above + it wasnt munged \n$
            
           &Ploy_joined (nod+ leaving -> joi leaving)
            %stretchy=$nod - doesnt end on joi (no ...\n$)
            %stretching=$nod - began before joi (after the above)
             < happens too much
            %stretch=$nod - finally ended
             eg joi@86 is ++'    ' after joi@82 =='    ' started E:1 2
             < are coupled to a joi.prev+%strechy=$nod
            
            %enmono, %mono, %demono - while joining only 1 nod
             
            %sameness=$ratio - low or high sameness
              ignores ^\s+(++    ) and the near-sameness of only %♲
               # code: any illegal syntax eg /(+/ is potential otherlang
             eg joi@56 should have very low sameness, just (==\n)
              < joi@48 is very similar, should be all there.
                 joi@56 has low sameness, different nod.d
                 joi@55 very high sameness, different nod.d
                see fix / stretch
             eg joi@71 has low sameness
              < (==s) microbit in different column: gone t, new y
            %tsplit when col:t has a bit-boundary (>1 microbits)
            
            < %noddoff - different nod.d
            < %numeric - number++
         
         A&joi.changes.$nk$gk? = 1
          seeing jodol** change
          not suggesting the diff is going ugly
          < but if it could be rearranged to minimise these...
        =cut
        # if any factoids, put on the odd row
        me.Ploy_drawjoin_factoids = &acgt{
            $joi = A&joi
            # more angles
            
            if (hak(joi.sc) == 0) {
                # no factoids
                if (!joi.jin) {
                    # no difference
                    $m = joi.modjoi
                    ms&bri = 0.6
                }
                return
            }
            # factoids usu follow some difference now tabulated in /jin...
            if (!joi.jin) {
                $about = haks(joi.sc)
                grop(['enmono','mono','demono'],about)
                # < joi.debug, similar to but not a factoid...
                hak(about) and 1
                else return
            }
            
            $withnods = 0
            A&odd('with',&ml{
                me&tt,'joi' () and me&fu,"joi@"+joi.i_join,joi
                me&tt,'nod' () and withnods = 1
            })
            withnods and me&Ploy_drawjoin_nods
            
            A&odd('lit',&ml{
                me&boxcap,'joi-factoids',2 (&ml{
                    lc&not = 1
                    $lak = haks(joi.sc).pop()
                    each kN joi.sc {
                        me&boxcap,"fact:"+k,'6y' (&ml{
                            lc&s = k
                            mc&maybeempty = 1
                            $v = N
                            #each iv N {
                                # sees the forward-er 3s&joi on a nod.joi
                                k == 'tilmoves' and me&Ploy_tid,v
                                k.startsWith('stretch') and me&Ploy_tid,v,'joi'
                                k == 'sameness' and me&tsc,"ratio",cvs(v)||'Nil','6b'
                                else
                                !ish(v) and me&tsc,"value",dis(v),'6b'
                            #}
                        })
                    }
                })
            })
            
        }
        # nods = joi/with+loosely
        me.Ploy_joi_nods = &acgt,joi{
            return [... 3c&o(joi,'with'),
                # possible non-belonging nods on joi%stretch
                
                ... 3c&o(joi,'loosely')]
        }
        
        # odd row may expand per nod
        # < %stretch(ing) add the nod to joi/with_stretch=nod?
        me.Ploy_drawjoin_nods = &acgt{
            $joi = A&joi
            $nods = me&Ploy_joi_nods,joi
            # < mapkv(): y returns [k,v]
            $tw = {}
            nods.map(nod => tw[nod.sph.sphere] = nod )
            each sphere,nod tw {
                $m = me&Ploy_rower,sphere
                ms&hue = sphere == 'new' ? 60 : 130
                A&draw('with',&ml{
                    me&drawnod,nod
                },m)
                A&draw('lit',&ml{
                    $ls = 3c&o(joi,'lit.l')
                    $inters = me&drawintersplice,"l-belonging"
                    3c&o(nod,'mine/bit',&bit,c{
                        $l = bit.l
                        # if this l belongs before|after this joi
                        $belongs = ls.includes(l)
                        !belongs && !(jois&stretchy || jois&stretch) and debugger
                        inters(belongs)
                        $lm = me&drawdiffbit,c.i,l
                        !belongs and lms&opa = 0.6
                    })
                },m)
                A&draw('jin',&ml{
                    me&tt,'nood' () and me&fu,sphere+":nod@"+joi.i_join,nod
                    !3c&o(joi,'with') .includes(nod) and me&tc,"loose",'6y'
                },m)
            }
        }
        
        
        
        # joi/with supplemented by joi/loosely
        me.Ploy_joi_stretch_check = &acgt,joi,N{
            # beginning to go %stretchy
            # < continuing the %stretching, may many
            #   ie nod has bits here yet begins|ends on other joi
            3c&o(joi,'lit.l',&lc{
                if (l.t != 'same') {
                    # text they dont share
                    if (c.last) {
                        # a nod doesnt have this \n$
                        3c&o(joi,'with',&nod,{
                            $bit = 3c&o(nod,'mine/bit') .slice(-1)[0]
                            bit.l != l and me&joisc,'stretchy',nod
                        })
                    }
                }
            })
            # a %stretch is finally joined
            # notice when N...nod.joi are different
            # < always combined with mono joins?
            #   may have blips of stereo amongst
            #   we want to sweep below for clarity
            #    ie turn l:== into l:++ (like its neighbours)
            #    adding l:-- after, on a new joi for that one nod?
            # < any bit progress once decohered is what to see
            #    a nod matching that is not on the current joi
            N.map(&V{
                $nj = Vc&nod.joi
                if (nj != joi) {
                    # a node keeps matching after a while
                    # < boxlink to itsthe last box:joi
                    $ji = nj.i_join
                    me&joisc,'stretch',Vc&nod
                    # let joi know of these other nodes
                    3c&iz(joi,'loosely',Vc&nod)
                }
            })
        }
        # is|goes mono!
        me.Ploy_joi_mono_check = &acgt{
            $joi = A&joi
            if (hak(joi.with) == 1) {
                $nod = havs(joi.with)[0]
                # this sphere is the only one for a while
                me&joisc,'mono',nod.sph
            }
            
            # A&neu is too new to count /with yet, see unbitnod
            #  joi (A&old) and joi.prev have accurate /with now
            $prev = joi.prev
            !prev and return
            $withs = spant(hak(prev.with),hak(joi.with))
            if (withs == '2 1') {
                # starts non-joins - whole lines for only one sph
                #  the other, eg gone, will not consume any l:new
                me&joisc,prev,'enmono',1
            }
            if (withs == '1 1') {
                # passes along...
                !prevs&mono and debugger
            }
            if (withs == '1 2') {
                # resumes matching after non-joins (single joi/with)
                me&joisc,prev,'demono',1
            }
        }
        # after jin makes joi.changes
        me.Ploy_joi_sameness_check = &acgt,joi{
            $lits = 3c&o(joi,'lit')
            $dont = cint(haks(joi.changes)) == '%♲'
            hak(lits) == 1 || dont and return
            # overall amount shared|not on this joi
            $an = {}
            lits.map(&lit,{
                $l = lit.l
                $quantity = hak(ls&string)
                # indent doesnt count, eg joi@69 (==      )
                #  no other uses of trimstart?
                $trims = grep(3c&o(lit,'bit',bit => bit.trimstart))
                if (hak(trims)) {
                    # lit/bit join 1-2 bit.up.nod, by the same l
                    hak(trims) > 2 and debugger
                    hak(uniq(trims)) > 1 and debugger
                    quantity -= trims[0]
                }

                $k = l.t == 'same' ? 'same' : 'diff'
                an.cosize ||= {}
                an.cosize[k] ||= 0
                # < leaving out ^ oddly not fatal to v (Try@3 / js oddities)
                an.cosize[k] += quantity
            })
            # < &ind + ex()
            $sa = map(v => dec(v,2), &c{
                hak(c) > 2 and debugger
                # same/0 == 1
                !c.diff and return 1
                $same = c.same || 0
                return same / (same + c.diff)
            },an)

            # hardly any or lots of similarity
            if (sa.cosize <= 0.22 || sa.cosize >= 0.78) {
                me&joisc,'sameness',sa.cosize
            }
        }
        
        # for a nod matching
        me.Ploy_nod_check = &acgt{
            if (3s&joi != A&joi) {
                # previous other nod joined, we are left behind
                me&joisc,'behinod',A&nod
                if (!a&tilstill) {
                    # something matched after joi moves on
                    #  ie goes %mono, leaving nod.joi behind
                    #  write the later joi on the earlier nod.joi
                    me&joisc,'tilmoves',3s&joi
                }
            }
            
            
            
            
            
            if (a&seeknod) {
                # nothing excepting \n$
                # perhaps about to mono join
                #  ie only one 3s&joined (that was a&newnode)
                me&joisc,'seeknod',A&nod
            }
        }
       
       // fix joi%stretch
        =stretch
         possible untanglement of joi%stretchy
           see Fus@7
            
            joi@48:
              ｢ 18sc⇥-Hash⇥｣  ++｢⇥♲␤｣
               ++｢ 20...␤｣ # many
                   ++｢ 24src⇥-Num⇥"1812"｣  ｢␤｣
             want:
              ｢ 18sc⇥-Hash⇥｣ ++｢⇥♲｣ ｢␤｣
               ++｢ 20...␤｣ # many
                   ++｢ 24src⇥-Num⇥"1812"␤｣ 
             good starter?
               
            
            joi@71:
               ++｢ 2｣  ｢ 6｣  ++｢ 2of⇥-Ha｣  ｢s｣  ++｢h⇥␤｣
                # gone|new E:sc|of
               ++｢ 12...␤｣ # many
                  ++｢ 22sr｣  ｢c⇥-Hash⇥␤｣
                  # finishing E:sc loosely
                  #  high sameness but much different Cindent
                  #  also nk:t microbit>1 is undesirable
                  ｢ 4｣  ++｢ 201812⇥-anx⇥⇥~␤｣
                  # gone|new E:1 2|1812
                  #  no sameness, much different Cindent
                    ++｢ 26z⇥-Array⇥␤｣ # many
               ++｢ 6sc⇥-Hash⇥⇥♲␤｣
                # correct E:sc location
                #  findable only via Cindent + starts same
             ++｢ 4｣  ｢1 2⇥-anA⇥"A more"⇥~｣  ++｢,♲:^3:7/having 4.sc.todo//-hat/1 2｣  ｢␤｣
               # new E:1 2
               # @86, %stretch from @71 E:1 2
             want:
               ++｢ 8of⇥-Hash⇥␤｣
                ++｢ 12...␤｣ # many
              ｢ 6sc⇥-Hash⇥⇥♲␤｣
              ｢ 41 2⇥-anA⇥"A more"⇥~｣ ++｢,♲:^3:7/having 4.sc.todo//-hat/1 2｣ ｢␤｣
             bit more difficult...
           
            < joi%tsplit should discourage E:sc on joi@81
               just having different nod.d works for now...
         
         < release as indentsual-diff-match-patch
           perhaps it is easier to cost:
            similarity earlier > difference later (per line)
            closer indent
            
        =cut
        me.Ploy_joins_fix = &acgt{
            $jois = 3c&o(3c&X,'join')
            $joi
          // f
            $afix = &joi2,t,c{
                c = pex({t},c||{})
                # the origin of this fix, eg joi@71
                c.joi = joi
                # may c.add|rm=nod to add|remove from joi's lit's Comp/l
                ahk(joi2,['fix'],c)
            }
            $lin0whole = &nod,{
                return 3c&o(nod,'mine/bit',_=>_.str).join('')
            }
           // walk jois
            # step over some joi%mono to the end of a %stretch
            $yon_demono = &joi,{
                $i = joi.i_join*1
                $dem
                while (1) {
                    i += 1
                    $ojo = jois[i]
                    !ojo and break
                    !ojos&mono and debugger
                    ojos&demono and dem = ojo; break
                }
                !dem and joi.fix = ahk(joi,'fix','fail','nodem'); return
                $nod = dems&stretch
                !(nod && nod.joi == joi) and debugger
                return dem
            }
            # search further with nod/lin0
            $yon_lin0match = &joi,dem{
                $nod = dems&stretch
                $whole = lin0whole(nod)
                dem = null
                $maybe
                $i = joi.i_join*1
                while (1) {
                    i += 1
                    $ojo = jois[i]
                    !ojo and break
                    # find one (%mono) of the other sph, same nod.d
                    !ojos&mono and continue
                    $nod2 = theone(3c&o(ojo,'with'))
                    nod2.sph == nod.sph and debugger
                    nod2.d != nod.d and continue
                    # and string match
                    $whole2 = lin0whole(nod2)
                    if (whole != whole2) {
                        # < approximate is okay if it is best
                        #   ie fully cost the nod.d, creating %tsplit, etc
                        maybe = {nod2,whole2}
                        $most2 = whole2.slice(0, dec(hak(whole2)*0.66,0) )
                        !whole.startsWith(most2) and continue
                    }
                    dem = ojo
                    break
                }
                # < do a looser string match
                !dem && maybe and debugger
                return dem
            }
          // gather fixes
            $fixed = []
            each i,joi jois {
                !(jois&stretchy && jois&enmono) and continue
                # find eg joi@56, where joi@48 completes
                $dem = yon_demono(joi)
                !dem and continue
                $nod = dems&stretch
                if (jois&sameness != null && jois&sameness <= 0.2) {
                    # dis-join an earlier low-sameness
                    # at joi@71 -> @81 (many joi.lit @71)
                    # or joi@82 -> @86 (only indent @82)
                    #  both having != indent, low sameness
                    # joi@81 is not where to match it
                    $nod2 = theone(3c&o(dem,'with'))
                    if (nod2.d != nod.d) {
                        afix(dem,'notd',{rm:nod,cmp:nod2.d+'|'+nod.d})
                        # search further with nod/lin0
                        dem = yon_lin0match(joi,dem)
                        !dem and debugger
                    }
                    afix(joi,'early',{rm:nod})
                    afix(dem,'later',{add:nod})
                    fixed.push(dem)
                }
                else {
                    # dis-join a later low-sameness
                    # at joi@48
                    #  few joi.lit there, the later l has low sameness
                    #  ie it put off matching a mere "\n" for many lines
                    #   ending on a different nod.d (unconsidered)
                    if (dems&sameness != null && dems&sameness <= 0.1) {
                        # make it all ++, put the same bit back on joi@48
                        $gobit = 3c&o(dem,'lit') .slice(-1)[0]
                        # < remove \n$ from the ++, add an == with it
                        afix(joi,'allin',{add:nod})
                        afix(dem,'notin',{rm:nod})
                        fixed.push(joi)
                    }
                    else {
                        afix(joi,'unsame',{fail:1})
                        debugger
                    }
                }
            }
          // apply fixes
            each i,joi jois {
                each if joi.fix {
                    $nod = f.add || f.rm
                    !nod and continue
                    f.add && f.rm and debugger
                    $sphere = nod.sph.sphere
                    $osphere = sphere == 'new' ? 'gone' : 'new'
                    $ls = 3c&o(joi,'lit.l') .slice()
                    $ols = ls.slice()
                    $bitl = 3c&o(nod,'mine/bit.l')
                    if (f.add) {
                        # shattered bits to put together, eg joi@71->@85
                        $whole = bitl.map(l => ls&string).join('')
                        each il bitl {
                            # eg joi@86 matches after one new->same
                            ls.includes(l) and continue
                            # see if it starts like that
                            $ol = ls[0]
                            # initially, relying on ls.includes(l) for the rest
                            if (ols&string == ls&string) {
                                i > 0 and debugger
                                # new->same, eg also joi@86
                                $bol = Cye(['same',1])
                                bols&string = ls&string
                                ls[0] = bol
                                continue
                            }
                            # see if we can add it to the end
                            $ol = ls.slice(-1)[0]
                            if (ols&string.endsWith(ls&string)) {
                                # nibble eg \n$ at joi@48
                                $nol = Cye([ol.t,1])
                                nols&string = ols&string.slice(0,-hak(ls&string))
                                $bol = Cye(['same',1])
                                bols&string = ls&string
                                ls.splice(-1,1, nol,bol)
                                continue
                            }
                            # or edgily, eg joi@85 is all same except (++⇥♲)
                            $most = whole.slice(0, dec(hak(whole)*0.66,0) )
                            if (ols&string.startsWith(most)) {
                                # beginning
                                $Nl = []
                                $nol = Cye(['same',1,{},{string:''}])
                                $nib = 0
                                while (ols&string[nib] == whole[nib]) {
                                    nols&string += whole[nib]
                                    nib ++
                                }
                                hak(nols&string) and Nl.push(nol)
                                
                                # end
                                $eol = Cye(['same',1,{},{string:''}])
                                nib = -1
                                while (ols&string.slice(nib)[0] == whole.slice(nib)[0]) {
                                    eols&string = whole.slice(nib)[0] + eols&string
                                    nib --
                                }
                                
                                # their middle
                                $from = hak(nols&string)
                                if (from + hak(eols&string) < hak(ols&string)) {
                                    $mol = Cye([osphere,1])
                                    $til = hak(ols&string) - hak(eols&string)
                                    mols&string = ols&string.slice(from,til)
                                    Nl.push(mol)
                                }
                                
                                # our middle
                                if (hak(nols&string) + hak(eols&string) < hak(whole)) {
                                    $mol = Cye([sphere,1])
                                    mols&string = whole.slice(hak(nols&string),hak(eols&string))
                                    hak(mols&string) and Nl.push(mol)
                                }
                                
                                hak(eols&string) and Nl.push(eol)
                                
                                ls = Nl
                                break
                            }
                            ls.push(Cye(['new',1,{},{string:'SPESH:'+whole}]))
                            debugger
                            break
                        }
                    }
                    if (f.rm) {
                        $Nl = grep(l => l.t != sphere, ls)
                        $l = Cye([osphere,1])
                        ls&string = Nl.map(l => ls&string).join('')
                        ls = [l]
                    }
                    # merge sequences of same l.t
                    $la = null
                    grop(&l{
                        if (la && l.t == la.t) {
                            las&string += ls&string
                            return 1
                        }
                        la = l
                    },ls)
                    joi.reComp = ls
                }
            }
            
          // redo Comp -> Ploy again
            # may have no need to
            !fixed and return
            a&fixed_joins = fixed
            a&fixed_Comp = flatten(
                map(joi => joi.reComp || 3c&o(joi,'lit.l'), jois)
            )
            
            # sanity: applied fixes dont change either sphere's whole string
            $samp = {was:3c&Comp,is:a&fixed_Comp}
            $sphs = ['new','gone']
            each it sphs {
                $sa = map(&L{
                    return L.filter(l => l.t == 'same' || l.t == t)
                        .map(l => ls&string).join('')
                },samp)
                sa.was == sa.is and continue
                me&Ahdiffany,'sph:'+t,'see',sa.was,sa.is
                debugger
            }
        }
        me.Ploy_drawjoin_fixes = &acgt{
            $joi = A&joi
            !joi.fix and return
            $m = me&Ploy_rower,'fix'
            ms&hue = 200
            
            # rebuilt l+
            me&Ploy_rower_i,m,'lit' (&ml{
                each il joi.reComp {
                    me&drawdiffbit,i,l
                }
            })
            # the facts leading to rebuild
            A&draw('jin',&ml{
                
                each if joi.fix {
                    # see &Ploy_joins_fix / afix()
                    $c = ex({},f)
                    me&boxcap,"fix:"+c.t,'2g' (&ml{
                        ms&ml = 2
                        me&walls,m,'b:2.2h4'
                        mc&maybeempty = 1
                        lc&s = delete c.t
                        $origin = delete c.joi
                        origin != joi and me&Ploy_tid,origin
                        each kv c {
                            me&boxcap,"fix-data",2 (&ml{
                                lc&not = 1
                                me&tsc,"key",k,'b'
                                ish(v) and me&Ploy_tid,v
                                else me&tc,dis(v)
                            })
                        }
                    })
                }
            },m)
        }
        
    //  reg
        =pod
          group like stuff
           Ploy/region
            of consistent conditions
             and how to draw them
            ie sub-nod** we would dimly light
             or show whole things of either sph

           conditions:
            joi.changes.%♲|c|allnew etc
           make reg
            spreads to
             next joi, linearly
              < unless drop in nod.d from where reg started
             < inners
               eg E:1 starts reg:%♲, spreads to /c/again joi@22
               is already there with the 'not counting' of lafew_relevant_overs()

            higher levels of:
              < continuation of an Eref: ♲
                 about the one ♲:^3:7/having 4.sc.todo//-hat/1
                   mentions the gone t from our ^2
                    presenting the usual new-version-of-same we can often see...
                  followed by lots of simple ♲
                   which say ref continuity continues into here
                    > when it doesnt

           make are
              hoist interestingness
                > venn types of change over space
                > forward mungible change|seq
        =cut
        # group like stuff
        me.Ploy_regions = &acgt{
            # rolling recent conditions
            $regs = []
            $jois = 3c&o(3c&X,'join')
            !hak(jois) and debugger
           // f
            # convert joi%mono to joi.changes.allnew|gone
            #  to have all relevant conditions in joi.changes.*
            each i,joi jois {
                $sph = jois&mono
                !sph and continue
                ahk(joi,'changes',sph.sphere,3)
            }
            # return the last few joi a reg should have in /matches
            $lafew_relevant_overs = &reg,{
                $more = reg.over.slice(-10)
                if (reg.t == '%♲') {
                    grop(&joi,{
                        # not counting == E%Fun|String, since not Eref-able
                        joi.changes and return
                        $nod = havs(joi.with)[0]
                        $r = Aof(nod.E)
                        rs&Fun || rs&String and return 1
                        # or if it keeps the same Eref
                        $D = nod.D
                        D.sc['♲'] and return 1
                    },more)
                }
                return more.slice(-5)
            }
            $reg_ends = &reg,joi{
                ahk(joi,['regs'],'end',reg)
                reg.ends = joi.i_join
            }
            
            $inplace = &sd{
                isfu(d) and d = {y:d}
                d = ex({},d||{})
                d.path = (d.path||[]).slice();
                (d.visit ||= []).push(s)
                
                d.d ||= 0
                d.d++
                d.d > 100 and debugger; return
                
                d.y && d.y (s,d)
                d.not and return
                d.path.push(s)
                3c&o(s,'placed',&z,{
                    inplace(z,d)
                })
            }
            
           // reg <- joi
            each i,joi jois {
                # whats here
                $cond = ex({},joi.changes || {})
                # counted into|against regs
                each i,reg regs {
                    grop(&degree,k{
                        if (reg.t == k) {
                            ahk(reg,['matches'],joi)
                            reg.degree > degree and reg.degree = degree
                            # dont cond -> new reg
                            return 1
                        }
                    },cond)
                    ahk(reg,['over'],joi)
                }
                # until they seem lost
                # < rounding off branches
                grop(&reg,{
                    # last few /over=joi this reg should have in /matches
                    $lafew = lafew_relevant_overs(reg)
                    $had = grep(reg.matches, lafew)
                    $qual = hak(had) / hak(lafew)
                    #joi.sc['regqua'+reg.t] = qual
                    
                    if (qual < 0.4) {
                        # trim end of region to last matching joi
                        $endjoi = had.slice(-1)[0]
                        !endjoi and debugger
                        $overs = ksaf(reg.over,{aft:endjoi})
                        !hak(overs) and debugger
                        # trim reg/match
                        #endjoi.sc['regtrim'+reg.t] = hak(overs)
                        grop(overs,reg.over)
                        reg_ends(reg,endjoi)
                        # remove from regs[]
                        return 1
                    }
                },regs)
                # unknown cond -> new reg
                each k,degree cond {
                    # new reg!
                    $reg = 3c&iz(3c&X,'region')
                    reg.t = k
                    reg.degree = degree
                    ahk(joi,['regs'],'start',reg)
                    reg.starts = joi.i_join
                    ahk(reg,['matches'],joi)
                    ahk(reg,['over'],joi)
                    regs.push(reg)
                }
            }
            # any still active now end
            each i,reg regs {
                reg_ends(reg,joi)
            }
           
           // hier place**
            # hier joi** wrt regs
            # subset of joins leading to regions
            $top = 3c&iz(3c&X,'place')
            $stack = [top]
            $regs = []
            each i,joi jois {
                # get nod.d
                $nods = me&Ploy_joi_nods,joi
                $h = {}
                nods.map(nod => ahk(h,[nod.d],nod))
                $depths = haks(h)
                hak(depths) != 1 and debugger
                $nod = h[depths[0]].shift()
                
                # create place hierarchy via stack=[place+]
                if (i == 0) {
                    $place = stack[0]
                    place.d = 1
                }
                else {
                    $prev = stack[nod.d-1]
                    $place = 3c&iz(3c&X,'place')
                    # in relation to
                    $up = stack[nod.d-2]
                    place.d = nod.d
                    place.up = up
                    3c&iz(up,'placed',place)
                    # from here in
                    stack[nod.d-1] = place
                    while (hak(stack) > nod.d) {
                        # eg d=2 should have stack x2
                        stack.pop()
                    }
                }
                
                # for one joi
                place.joi and debugger
                place.joi = joi
                
                # with many regs
                if (joi.regs) {
                    each i,reg joi.regs.start {
                        regs.push(reg)
                    }
                }
                each i,reg regs {
                    ahk(place,['regs'],reg)
                    !reg.over.includes(joi) and debugger
                }
                if (joi.regs) {
                    each i,reg joi.regs.end {
                        grop([reg],regs)
                    }
                }
            }
            # should all come off again
            hak(regs) and debugger
           
           // < percolate
            # percolate change to ancestors
            $places = 3c&o(3c&X,'place')
            inplace(top,&place,d{
                each i,reg place.regs {
                    each i,up d.path {
                        ahk(up,['inter'],reg.degree,reg.t,place.d,place)
                    }
                }
                # for further consciousness of how good a place it is for what
                place.sc = {}
            })
            
            # chasing place.inter.*
            # <<<
            #  until it reduces to one reg
            #   call that an area
            #    it may leave off tips further inside
            #  one region may split if straddling branches
            #  ancestors, siblings dimly glow...
            # into something easy for -Difmo to get
            #  might swap %zuct for lum diag
            me&boxcap,"places",1 (&ml{
                me&walls,m,'bd:2.2'
              inplace(top,&place,d{
                d.cap = me&boxcap,"place"+place.i_place,1,0,d.cap (&ml{
                    ms&ml = 0.3
                    me&walls,m,'bd:2.2'
                    mc&maybeempty = 1
                    $nod = havs(place.joi.with)[0]
                    !nod and debugger
                    lc&s = nod.E.t
                    ls&fs = 6
                    
                    # regs here
                    $regs = place.regs
                    if (regs) {
                        # just means joi is in a region high in this condition
                        #  have to check joi.changes[reg.t] to know if joi has reg
                        $regts = place.regs.map(reg => reg.t)
                        $degree = place.regs.map(reg => reg.degree).sort()[0]
                        me&tsc,"regs-had",coint(regts),'y'
                        me&tsc,'match-quality',degree,'6g'
                    }
                    if (!place.inter) {
                        if (place.placed) {
                            # mark closed?!
                            $many = hak(inplace(place))
                            many <3 and 'showing them is easier'
                            else {
                                places&toomany = many-1
                                me&tc,'⦄','b'
                                me&tc,'..'+many
                            }
                        }
                        return
                    }
                    
                    # regs from here/**
                    me&boxcap,"inter",2 (&ml{
                        me&walls,m,'bd:2.2'
                        ms&fs = 6
                        lc&s = '**'
                        each degree,regts place.inter {
                            degree < 5 and delete ls&fs
                            me&tsc,"regs-in",coint(haks(regts)),'y'
                            me&tsc,'match-quality',degree,'g'
                        }
                    })
                })
              })
            })
            
           // done
            
            me&boxcap,"regions",5 (&ml{
                3c&o(3c&X,'region',&reg,{
                    $ze = me&boxcap,"reg"+reg.i_region,3 (&ml{
                        me&walls,m,'bd:2.2'
                        me&tsc,'cond-match',reg.t,'G'
                        me&boxcap,"joi" (&ml{
                            me&tsc,'joi-started',reg.starts,'6y'
                            me&tc,"->"
                            me&tsc,'joi-ended',reg.ends,'6y'
                        })
                        me&tsc,'match',hak(reg.matches)
                        me&tsc,'over','/'+hak(reg.over)
                    })
                    me&ioty,ze .map(&n{
                        ns&dis = 4
                    })
                })
            })
        }
        # oddrow: regs start|end at a join
        me.Ploy_drawjoin_regions = &acgt{
            $joi = A&joi
            !joi.regs and return
            
            $m = me&Ploy_rower,'regs'
            ms&hue = 260
            
            me&Ploy_rower_i,m,'lit' (&ml{
                $regs = sex({},joi.regs,'end,start')
                each th regs {
                    me&boxcap,t,2 (&ml{
                        each i,reg h {
                            me&boxcap,"reg"+reg.i_region,2 (&ml{
                                me&walls,m,'bd:2.2'
                                me&tsc,'cond-match',reg.t,'G'
                            })
                        }
                    })
                }
            })
        }
        
    // drawing row+
        # $m:row re-opens a &boxcap column for eg /with
        me.Ploy_rower_i = &acgtmt{
            return &y{
                !me&fiu,m,t,8 and debugger
                me&boxcap,t,4,2,m (&ml{
                    y (m,l)
                })
            }
        }
        # boxcap for some kind of row, for a joi
        me.Ploy_rower = &acgtk{
            # kind may also odd|fail|fix|etc
            $modk = "mod"+(k||'joi')
            $m = A&joi[modk]
            if (!m) {
                # name it after this row
                $i = A&joi.i_join
                $name = cint('join',i,k)
                m = A&joi[modk] =
                me&boxcap,name,3 (&ml{
                    ms&type = cint('join',k)
                    # label is the first column
                    lc&s = k || i
                    ls&bri = 0.6
                    ls&dis = 4
                    k and ls&fs = 7
                    # < how to border rows
                    
                    # with...E
                    me&boxcap,'with',4 (&ml{
                        lc&not = 1
                        mc&maybeempty = 1
                        ms&fs = 7
                        ms&maw = 6
                        ms&miw = 3
                    })
                    # lit...l
                    me&boxcap,'lit',4 (&ml{
                        lc&not = 1
                        mc&maybeempty = 1
                    })
                    # jin... discernibles
                    me&boxcap,'jin',4 (&ml{
                        lc&not = 1
                        mc&maybeempty = 1
                        ms&maw = 6
                        ms&miw = 3
                    })
                })
            }
            return m
        }
        # columns 2-4 span, for larger breakdowns, eg &Ploy_fail
        me.Ploy_spannyrower = &acgtt{
            return &y{
                return me&boxcap,t,3 (&ml{
                    me&boxcap,'spanny',4 (&ml{
                        lc&not = 1
                        mc&maybeempty = 1
                        ms&tag = 'td'
                        ahk(m.sc,'attr','colspan',3)
                        
                        y (m,l)
                    })
                })
            }
        }
        
    // drawing f
        # name|number n:E.t, j:$i...
        # see also &Ploy_identify
        # < should become -Difmo/joi/E**?
        me.Ploy_tid = &acgtvk{
            k and v = v[k]
            !ish(v) and debugger
            $type = v.i_join ? 'j'
                : v.i_node ? 'n'
                :'?'
            $t = v.i_join ? v.i_join
                : v.i_node ? v.E.t
                : '?'
            me&tc,cint(type,t),'6G'
        }
        # not to be confused with $bit, which it maps to
        me.drawdiffbit = &acgttl{
            $name = cint(t,l.t)
            return me&boxcap,name,'5y' (&m,la{
                me&walls,m,'bd:1.1'
                ms&type = 'l'
                lac&s = 
                    l.t == 'new' ? '++' :
                    l.t == 'gone' ? '--' :
                    l.t == 'same' ? '==' : l.t
                
                $to = me&drawString,ls&string,{tsc:'y',squishindent:1}
                tos&ws = 4
                me&walls,to,'bd:2.2,bg:000'
            })
        }
        me.drawnod = &acgt,nod{
            $E = nod.E
            return me&boxcap,E.t,'1' (&ml{
                lc&not = 1
                ms&type = 'nod'
            me&boxcap,E.t,'2' (&ml{
                me&walls,m,'bd:3.3h4'
                ms&ml = (nod.d-1) * 0.6
                me&drawsym,'E'
                $sph = nod.sph
                sph.sphere == 'gone' and ms&bg = '#300'
            })
            })
        }
        me.drawsym = &acgtt{
            $sym = me&tsc,"sym",t
            $m = T.ab
            grop(sym, ms&z)
            ms&z.unshift(sym)
            pex(sym.sc,'fs:13,lh:0.8,hs:757')
            
        }
        
        me.drawbunchliner = &acgtc{
            each kv c {
                isst(v) and me&drawtextliner,{},k,v
                else me&drawnontextliner,k,v
            }
        }
        me.drawnontextliner = &acgtts{
            !isst(t) and throw "drawnontextliner!title"
            return me&boxcap,t,'5' (&ml{
                me&walls,m,'bd:1.3h4'
                # &Ploy_identify may have munged:
                me&tsc,'s',dis(s),'6y'
            })
        }
        # for a series of calls with v = {0,0,1,1,1,0}
        #  put markers between the 0,1 and 1,0, pointing at the 1
        me.drawintersplice = &acgtt{
            $first = 1
            $inside = 1
            return &v{
                if (v && !inside) {
                    # after some that dont
                    inside = 1
                    $n = me&tsc,t+'-starts',"\u21A6"
                    ns&fs = 12
                    ns&co = '7c9'
                }
                if (!v && inside) {
                    inside = 0
                    if (!first) {
                        $n = me&tsc,t+'-stops',"\u21A4"
                        ns&fs = 12
                        ns&co = '7c9'
                    }
                }
                first = 0
            }
        }
        
    // f, fail
        me.Ploy_fail = &acgttc{
            # stop l++
            3c&not = 1
            
            # nod|joi has errors
            # < create ^^%strange
            grep([A&joi,A&nod]).map(&blame,{
                $x = 3c&iz(blame,'!'+t)
                c and pex(x,c)
            })
            
            # display in modulat
            me&Ploy_spannyrower,"fail" (&ml{
                me&walls,m,'ba:3.1h6'
                #ls&dis = 3
                ls&hue = 200
                me&tc,"A:"+A.t,'6' .sc.ml = 1
                me&tsc,"error:",'!'+t,'G'
                
                
                me&boxcap,"env",5 (&ml{
                    lc&not = 1
                    $inner = &tcy{
                        c = me&Ploy_identify,c
                        me&boxcap,t,3 (&ml{
                            ls&dis = 4
                            ls&ws = 1
                            me&drawbunchliner,c
                            y and y (m,l)
                        })
                    }

                    c and inner('ar',c)
                    inner('A&',me&novelAc,A.c ,&m{ ms&hue = 33 })
                    inner('a&',A.sc,&m{ ms&hue = 66 })
                })
            })
        }
        
        me.novelAc = &acgtc{
            return nex({},c,'X,ip,sip')
        }

        # turn c={k:sph|nod|lin +} to idc
        me.Ploy_identify = &acgtc{
            c = ex({},c)
            each ts c {
                # leave non-objects in
                !isha(s) and continue
                $h = {}
                $looks
                map(&vk{
                    if (isob(v)) {
                        if (looks == 'bit' && k == 'mung') {
                            # know this object displays
                            h[k] = me&loosedepeel,v
                            return
                        }
                        # or leave out objects
                        return
                    }
                    $ma = k.match(/^i_(\w+)$/)
                    if (ma) {
                        h[ma[1]] = v
                        looks = ma[1]
                        return
                    }
                    # a word or so
                    h[k] = v
                },s)
                c[t] = h
            }
            return c
        }
        me.loosedepeel = &acgtc{
            return coint(armap(&vk{
                v == 1 and return k
                iske(v) || isC(v) and return cint(k,v)
                return cint(k,dis(v))
            }, c))
        }
 
 // Ply = Ness + Comp <
    =pod
      probably GOING, Ploy is much better
       tho this does know how to y&thing at -seven, etc.
        and only has one D, the other is a Ness
      < into X
      < with A
      < recovery
    =cut
    // Plymergent f
      // draw thing
        # wild repurposing the symbols of &Rthingo
        me.thingosym = &acgts{
            $sym = me&tc,s,'b'
            syms&lh = 0.5
            syms&fs = 20
            return sym
        }
        # a named string bubble, clue odd chars
        # < know where in l|E...
        me.drawtextliner = &acgtdts{
            !isst(t) and throw "drawtextliner!title"
            !isst(s) and throw "drawtextliner!text"
            $Om = T.ab
            $m = me&boxcap,t,'5' (&ml{
                me&walls,m,'bd:1.1'
                Om.y [t] = m
                
                $to = me&drawString,s,'y'
                tos&ws = 1
                me&walls,to,'bd:2.2,bg:000'
                Om.y [t+'s'] = to
            })
            return m
        }
        # < to having diff chunks floating around!
        me.textarrow = &acgtO{
            $b = O ? me&tc,O,"=>",'B' : me&tc,"=>",'B'
            by&cv = 0.0001
            bs&fs = 20
            bs&lh = 0.6
            bs&ab = 1
            bs&ml = -2
            O and grepout(Os&z,b); Os&z.unshift(b)
            return b
        }
        # passing y&thing acknowledged
        me.drawtextthing = &acgttdn{
            $oth = ny&thing
            oth && me&boxcap,t,'5' (&ml{
                me&walls,m,'bd:2.2h6'
                othy&cv != 0.1 and me&tc,cvf(othy&cv),'G'
                !me&mergent_oktothing,d,n and me&tc,"!used"
                $sum = me&textsize,oths&string
                me&thingosym,'⦄' .sc.fs = 15
                me&tc,sum,'y'
            })
        }
                
        # y&thing sanity check: into z requires zy&thing used on slope
        # < was %%oust to slope
        me.mergent_oktothing = &acgtdz,fatal{
            # it must exist in order to z
            $th = zy&thing
            if (!th) {
                !fatal and return null
                throw "tosphere!thing"
            }
            
            if (!hak(ths&use)) {
                !fatal and return 0
                throw "tosphere!use"
            }
            $slopers = d.slope.map(z => zy&ers)
            !hak(slopers) and throw "!slopers"
            if (!hak(grepout(slopers,ths&use))) {
                if (!slopers.slice(-2)[0]) {
                    # sloper no ers, perhaps because it was synthesized
                    $nu = zy&up
                    nu && nu.t != d.slope.slice(-2)[0].t and debugger
                    if (nu && ths&use.includes(nuy&C)) {
                        !fatal and me&tc,"//^//",'G'
                        return 1
                    }
                }
                !fatal and return 0
                throw "tosphere!used"
            }
            
            return 1
        }
      // close
        # if no Lines can be found
        # eg E...-inx/up|z are hidden from stringify
        me.mergent_avoids_unLinesed = &acgtdn{
            # anything goes so long as marked by layout symbol '~' above
            # < could be on the thing above, value =~ / \*$/
            !ahsk(n,'y','up','y','D','sc','~') and return
            me&drawtextnofurther,d,'layout:hid'
            # relies on returning from anywhere()
            return 1
        }
        # &Rthingo-ish complaint
        me.drawtextnofurther = &acgtdt{
            !isst(t) and throw "complain"
            me&thingosym,'⛔'
            me&tc,t,'6y'
            d.nofurther = 1
            # fade line
            $O = d.O
            $Om = d.Om
            Os&opa = 0.6
            # shrink everything inside, since indent O%ml depends on O%fs
            each in Os&z {
                ns&fs = 6
                # < make faster grounding for T.ab<-{&tc}
                #   these are attached now because they are the label or more T.ab
            }
            # (toL s/string//)
            Omy&toLs and Omy&toLs.sc.dis=0
            return 1
        }
      
    me.Plymergent = &acgtREs,Ness,Comp{
      // Ply box, all[] from anywhere(n**)
        # see ds&morenth
        # < trace ourselves through every ^^^*y&thing%string
        #    kind of like a report vortex
        #    lets go as it wanders off the -Ness/*/*
        #     seeing slope into W
        #   ind slice it for all Lines at l%moren
        #  < real as the E|exp**:n walk
        #    many **:n to navigate with Comp
        #     exp having gone, E having new
        #    $exp** to resurrect relics from,
        #     for D->modulat totality,
        #      so we can then Diff the modulats, and make good visual
        $Ply = me&boxcap,'Ply','1' (&Ply,l{
        lc&not = 1
        # clue any change inside, become Plyy&offendEd[] later
        $radiate = &vd{
            ds&changey ||= 0
            ds&changey += v
            d.up && radiate(v*0.3,d.up)
        }
        # l = Comp[upto]
        $upto = 0
        # [d+]
        $all = []
        # Ness** as long as possible
        #  y&thing are for the outsphere
        #  y&C=This/Eight** follow E** down
        #   once Ness** runs out
        # < wander into Ness**, with diff )
        $anywhere = &nd{
            d ||= {}
            # < for a set of trees
            d.n = n
            d.slope = (d.slope||[]).slice()
            d.sc = {z:[]}
            d.up and d.up.sc.z.push(d)
            all.push(d)
      
      // Ply stuff<->things!
            me&boxcap,"Ply"+n.t,'1' (&ml{
            ls&deco = 1
            lc&s = n.t
            ms&ml = 1
            $O = d.O = m
            $pl = me&tc,"place"
            plc&s = ''
            # intoable insphere, y&C from Ness**
            # in (Ness|This|exp)**//E-seven**
            #  slope begins This/here**

            $z
            $Om
            # notice outsphere features...
            me&boxcap,"Out",'g' (&ml{
                d.Om = Om = m
                me&walls,m,'bd:2.2h3'
                ms&fs = 6
                
                # gives Omy&toL(s)?
                ny&toLines
                    && me&drawtextliner,d,"toL",ny&toLines

                # < swathes of %moren may be entirely
                me&drawtextthing,'thing',d,n
                
                $D = ny&D
                D && Dy&thing && Dy&thing != ny&thing
                    && me&drawtextthing,'Dthing',d,D

                z = ny&C
                z || d.ins and d.slope.push(z||n)
                # < isn't always E?
                z and ds&E = z
                else
                d.ins and ds&E = n
                
                # < &Saturn into here!
                # at Ness..-seven the ** dries up
                if (!d.ins && !hak(ns&z)) {
                    if (!z) {
                        # we may be on a missing -seven
                        ds&goneseven = 1
                        d.nofurther = 1
                        return me&tc,"GONE",'b'
                    }
                    d.ins = d
                    ds&pi = 'seven'
                    # must =be a 
                    !z and return me&tc,"GONE",'b'
                    !hak(zs&z) and throw "deadend"
                    me&mergent_oktothing,d,z,'fatal'
                    me&tc,"yC",'G'
                }
                if (d.up && d.ins == d.up) {
                    # the RE
                    ds&pi = 'six'
                    me&walls,O,'bd:4.2h3'
                    # < which E** are selected
                    # see TheingE 2951: sets y&C
                    #  like there is up in Ness/*/*, see &EsyncThis
                    !z and me&drawtextnofurther,d,"non-main"
                }
                if (d.up && d.up.sc.pi == 'six') {
                    # the Ey&main itself
                    ds&pi = 'five'
                }
                ds&pi and me&tc,pl,"-"+ds&pi,'G'
            })
            d.nofurther and return
            
      // E<->l
            # lingering l, or nothing
            $l = null
            me&boxcap,"E",'g' (&m{
                me&walls,m,'bd:2.2h3'
            // Comp/l and E...n...Lines
              
              // l = Comp[upto]
                # eitherings, any substring of Lines
                l = Comp[upto]
                if (d.morend) {
                    $nd = d.morend
                    # n's l is not in Comp/*, last one that was:
                    $ul = nd.l
                    nd.moreni ||= 0
                    l = uls&moren [nd.moreni]
                    me&tsc,'morening',"^"
                }
                !l and d.offtape = 1; return me&tc,"off","b"
                d.l = l
                
                # last l%ope, l/* (indentitively) is folded into l%moren
                if (ls&moren) {
                    me&tc,"x"+hak(ls&moren),'6d'
                    # < &strange <-> T.ab
                    d.morend and debugger; me&tc,"inside-morend",'!','b'
                    d.morend = d
                    if (d.ins == d.up) {
                        # -six whole y&thing check
                        ds&morenth = 1
                    }
                }
                
                $skipgone = &L{
                    # L == l that may be gone!
                    L.t != 'gone' and return
                    me&tc,"Agone",'6y'
                    # wash up on the next E in iteration
                    ac(d,'goners',L)
                    ac(d,'subComp',L)
                    ac(d,'chaComp',L)
                    # pull until we uncover a same, continue as
                    l = Comp[++upto]
                    l = skipgone(l) || l
                    # dedupes (see this line in while(l) below)
                    l.t != 'same' and ac(d,'chaComp',l)
                    # line-splitting not near folds
                    l && ls&moren && l.t != 'same' and debugger
                    return l
                }
                l = skipgone(l) || l
                
                # everything we visit should be open, may %moren
                ls&ope == '1' and 'ok'
                else
                ls&ope and me&tc,dis({ope:ls&ope}),'y'
                else {
                    me&tc,'shut','y'
                }
                
              // Lines = ny&toLines or so
                # into R'The'
                $D = ny&D
                D and me&tc,"D",'G'
                $th = ny&thing
                
                $Lines = ny&toLines
                #D && Dy&toLines and me&tc,"DtoL"
                D && Dy&thing and me&tc,"Dth"
                D && Dy&thing and Lines = Dy&thing.sc.string; me&tc,"Dth",'6y'
                if (ds&morenth) {
                    # -six whole y&thing check
                    Lines = ths&string
                    !Lines and debugger
                }
                if (!Lines) {
                    Lines = th && ths&string
                    Lines and me&tc,"th",6
                }
                if (!Lines) {
                    Lines = D && Dy&toLines
                    Lines and me&tc,"DtoL",6
                }
                if (!Lines && D) {
                    $Dth = Dy&thing
                    Lines = Dth && Dths&string
                    Lines and me&tc,"Dth",6
                }
                
                !Lines && me&mergent_avoids_unLinesed,d,n and return
                # < test all of these recover
                !Lines and return me&tc,"lost-string",'b'
                !hak(ns&z) and me&tc,'/$','g'
                
              // could be easy
                # < func text lib
                # if we indent this
                $indLines = indents(ls&level,Lines)
                # and we aren't looking at folded or interesting l
                if (!d.morend && l.t == 'same'
                    # it should look like the rest of l
                    && ls&string == indLines) {
                    ds&good = me&ts,"match-quality-good","2"
                    # and we associate d (for E**) with it
                    ac(d,'subComp',l)
                    upto++
                    return
                }
                
              // or break apart Lines, gradually l
                $Lin = Lin_Lines(indLines)
                $Li = 0
                $nd = d.morend
                nd = nd != d && nd
                $ul = nd && nd.l
                while (l) {
                    
                    $aLine = Lin[Li]
                    # non-first bit
                    Li && nd and l = uls&moren [nd.moreni]
                    aLine == null and break
                    l.t != 'same' and ac(d,'chaComp',l)
                    if (ls&string.length && !hak(ls&string.split('')
                        .filter(s => s != ' ')) ) {
                        me&tc,"Aspacey",'6y'
                    }
                    skipgone(l) and continue
                    
                    ul && ul != l && ls&moren and me&tc,"(moremore)",'6y'
                    
                    $good_luck = 0
                    if (d.up && d.up.sc.recoveredup) {
                        debugger
                    }
                    if (d.up && d.up.sc.recovering_since) {
                        $string = ls&string.replace(/\n$/,'')
                        good_luck = aLine.includes(string)
                        #me&drawtextliner,d,"l::",ls&string
                        #me&drawtextliner,d,"a::",aLine+"\n"
                        #!good_luck and debugger
                    }
                    # first bit should look good
                    if (good_luck || ls&string == aLine+"\n") {
                        Li++
                        ac(d,'subComp',l)
                        if (nd) {
                            nd.moreni ++
                            # if we're in ul%moren/l, we can't be l%ope
                            #  so checks the entirety of y&thing if possible
                        }
                        elsif (ds&morenth) {
                            # check off a bunch more l in this while
                            #  already has Lines from y&thing
                            if (!th) {
                                ds&good = me&tc,"1+"
                                me&tc,"no-th",'b'
                                Li == 1 and upto++; return
                                break
                            }
                            $ul = l
                            # start using uls%moren
                            $nd = d
                            d.moreni = 0
                            # eventually seek next Comp/l
                            upto++
                        }
                        else {
                            ds&good = me&tc,"1"
                            Li == 1 and upto++; return
                            break
                        }
                    }
                    else {
                        # or at least starts with l
                        me&tc,",."+Li,'c'
                        if (!nd && !ls&string.endsWith("\n")) {
                            if (aLine.startsWith(ls&string)) {
                                ac(d,'subComp',l)
                                # sub-Line at a time
                                me&tc,"+",'6y'
                                aLine = aLine.substr(ls&string.length)
                                $waslev = ls&level
                                # go forwards, skipping goners
                                l = Comp[++upto]
                                l = skipgone(l) || l
                                $islev = ls&level
                                # level might increase onto a change
                                # < really?
                                if (waslev < islev) {
                                    $morelev = islev-waslev
                                    me&tc,"ind+="+morelev,'6y'
                                    aLine = indents(morelev,aLine,1)
                                }
                                Lin[Li] = aLine
                                continue
                            }
                        }
                        break
                    }
                }
             
              // non-easy OK
                Li and me&tc,"("+Li+")",'6y'
                if (!l) {
                    ds&good = me&ts,"match-quality-okay","7"
                    # already counted upto++ going into ul%moren (either of two ways)
                    return
                }
                if (hak(Lin) > 1) {
                    # others may then!
                    me&tc,"+more"
                }
            
            // lingering confusedly?
                $interesting = 1
                ||
                (n.t == 'maaaagic' && n.y.up.t == 'origin_X')
                ||
                (n.t == 'A' && n.y.up.t == '-Fez'
                    && n.y.up.y.up.t == 'node_hand_U')
                ||
                (n.t == 'maaaagic')
                
                if (interesting) {
                    me&drawtextliner,d,"l",ls&string
                    aLine ? me&drawtextliner,d,"a",aLine
                        : me&drawtextliner,d,"L",Lines
                }
                
                
                # maybe just the start of it
                if (Lines) {
                    me&ts,"lingering-confusedly",'??'
                    
                    if (ls&string.includes(Lines)) {
                        me&tc,"oooook@"+upto
                        return
                    }
                }
            })
      
      // stat
            # < dodgy
            $next = ds&pi == 'seven' ? zs&z : ns&z
            
            if (ds&good) {
                # mute toL!
                $Ls = Omy&toLs
                Ls and Lsc&not = 1
                me&tc,"OK"
            }
            
            if (ds&chaComp) {
                me&boxcap,"~",'g' (&m{
                    me&tt,'d' () and me&tc,"dsc"+dis(d.sc),'1G'
                    each il ds&subComp {
                        me&drawtextliner,d,l.t,ls&string
                    }
                    me&boxcap,"ExtraAfter?",1 (&{
                        # and the non-same ones
                        #  may inc the non-match after, not in %subComp
                        each il ds&chaComp {
                            grap(l,ds&subComp) and continue
                            me&drawtextliner,d,l.t,ls&string
                        }
                    })
                })
            }
            d.nofurther and return
            
      // recursion?
            $cant = t => me&thingosym,'⦄'+t .sc.fs = 15
            if (hak(next) && ds&good) {
                $not = 0
                # don't recurse unless Comp says
                #Comp[upto] != l and debugger
                $ln = Comp[upto]
                if (!d.morend && ln && l && l != ln && lns&level <= ls&level) {
                    #me&fu,"Leaving:"+slant(d.slope),{d,ln,l}
                    # may end on a single line E, so no l%moren
                    #  eg X.A is a one-liner, yet we can see n/* t,y,c,sc
                    return cant('E...')
                }
                # < should only l%moren instead of !l%ope
                !(l && ls&ope) and return cant('l')
                else
                # see ds&morenth for -six whole y&thing check
                #  doesn't involve E**, what we avoid here:
                # since E** feeds Lines one-C at a time, avoid the folds.
                #  essentially ignoring a bunch of stuff already marked as boring.
                #  they must be opened back in Diff.
                ls&moren and return cant('m')
                # and not far
                #hak(d.slope) > 5 and return me&thingosym,'⦄>'
                # el2 -six can skip unpacking all the newness
                elsif (ds&pi == 'six' && 'new' == joint(ds&subComp)) {
                    me&tc,"Looks-new"
                    # requires the rest of -six** Comp to be new
                    $rest = Comp.slice(upto)
                    $restofsix = ksaf(rest,{bow:ul => uls&level <= ls&level,may:1})
                    
                    $frontier = !grap(ul => ul.t != 'new', restofsix)
                    if (frontier) {
                        ds&want_recovery = 1
                        ds&el2six = 1
                        next = []
                        cant('el2-six**')
                    }
                    else {
                        me&tc,"el2-six**,not-all-new",'6'
                    }
                }
            }
            
            each iz next {
                !ds&good and cant("!good"); break
                $dd = ex(ex({},d),{up:d})
                anywhere(z,dd)
                # happens when E** shows un-Ret potential
                #  little to no flood control
                dd.offtape and me&tc,'off-tape'; break
                
                ds&recoveredup and me&tc,"/Recoveredup",'g'; break
            }
            
      // recovery?
            # and here, at every crux to a later depth first
            if (!ds&good || ds&want_recovery) {
                $dup = d.up
                if (dups&good) {
                    # < voice the four options for choosing a goodlevel
                   // attempt recovery at first Comp%level <= that
                    $goodlevel = dup.l.sc.level
                    if (ds&good) {
                        # we may be skipping an el -six OK
                        goodlevel = d.l.sc.level
                    }
                    else {
                        # in a (==1-six\n)(~~2-six\n)(==3-six\n)
                        #  recover to the next six
                        $prevd = ksaf(dups&z,{bow:d}) [0]
                        $maybelevel = prevd && prevd.l.sc.level
                    }
                    if (maybelevel) {
                        if (maybelevel && maybelevel == goodlevel + 2) {
                            goodlevel = maybelevel
                        }
                        else {
                            maybelevel = 0
                            # < shouldn't really depend on a maybelevel
                            if (hak(ds&subComp)) {
                                # this might be a (==      )(--other)
                                # < handle everything better
                                $few = ds&subComp.slice(0,3).map(l => ls&string).join('')
                                $sublevel = me&getindent,few
                                # < not strange but just odd
                                if (sublevel > goodlevel) {
                                    goodlevel = sublevel
                                }
                                else {
                                    sublevel == goodlevel and me&tc,"subComp==goodlevel"
                                    sublevel = 0
                                }
                            }
                            else {
                                me&tc,"unsure"+dis({maybelevel,"^/<":prevd.l.sc.string})
                            }
                        }
                    }
                    
                   // aim Comp[upto], notting d recursion up to it!
                    $indup = upto
                    $max = 1000
                    $maxed = 0
                    $la2
                    $la
                    $nl
                    me&boxcap,"Recovering",1 (&ml{
                    ms&ml = 1
                    ls&ml = -1
                    
                    me&tt,'d' () and me&tc,"dsc"+dis(d.sc),'1G'
                    me&tc,"good<="+goodlevel,'6'
                    maybelevel and me&ts,'maybelevel-got-from-^/<','(same-indent)','6y'
                    sublevel and me&ts,'sublevel-got-from-%subComp-parts','(part-indent)','6y'
                    $lastline
                    $opecovered = me&tt,"covered" ()
                    while (maxed++<max) {
                        la2 = la
                        la = nl
                        indup++
                        nl = Comp[indup]
                        !nl && !ahsk(Om,'y','lingering-confu') and me&tc,'Once','G'
                        !nl and break
                        $heady = la && las&string.endsWith("  ")
                            || nls&string.startsWith("  ")
                        !heady and continue
                        
                        
                        $cover = me&boxcap,"Coveredup",1,2 (&ml{
                            me&walls,m,'b:2.2'
                            
                            $t = '+'+(indup-upto)
                            lastline = me&drawtextliner,d,t,nls&string
                            if (nls&level > goodlevel && la2) {
                                # perhaps it is wrong!
                                # < not carrying %level over empties:
                                #    (==      \n)(==    )(++somewhat  \n)
                                $may = la2s&string.endsWith("\n")
                                    && las&string.match(/^ +$/)
                                $relevel = may && me&getindent,las&string+nls&string
                                if (may && relevel != nls&level) {
                                    me&tc,"lies!lev:"+relevel
                                    nls&level = relevel
                                    # this was carried
                                    las&level = me&getindent,las&string
                                    # carry on from there
                                }
                            }
                        })
                        # close draw of covered lines
                        !opecovered and cover.c.not = 1
                        
                        if (nls&level <= goodlevel) {
                            # < move last line up to box:Recovering
                            lastlinec&not = 1
                            me&drawtextliner,d,lastline.t,nls&string
                            break
                        }
                    }
                    # < add a d.path
                    maxed >= max and ~>0 Ply recovermuch: maxed, slant(me.cby(d).map(d => d.n))
                    !nl and return
                    })
                    if (!nl) {
                        ds&el2six and return me&tc,"new-tail"
                        return ac(Ply,'strange','unrecoverable!nl')
                    }
                    $wasupto = upto
                    upto = Comp.indexOf(nl)
                    
                    # find corresponding d to skip iteration until
                    $done = 0
                    while (maxed<max) {
                        if (!done) {
                            if (dup.l && dup.l.sc.level < goodlevel) {
                                done = 1
                            }
                            else dups&recoveredup = 1
                        }
                        dup = dup.up
                        !dup and break
                        
                        # < radiate to last dups&good and break
                        if (dups&pi == 'six') {
                            # hang %changey
                            radiate(upto-wasupto,dup)
                        }
                        if (!done) {
                            if (hak(dup.slope)*2 < nls&level) {
                                dups&recovering_since = d
                            }
                        }
                    }
                    #ahk(Om,'y','lingering-confu',1)
                    #    || me&fu,"@"+n.t,{d,l,nl,n,upto,total:Comp.length,dup}
                }
                else ac(Ply,'strange','unrecoverable')
            }
            
            
            
            })
        }
        
      // aft: radiate changey %ope -> E !
        anywhere(Ness)
        
        # get -seven/-six with change inside
        reverse(all).map(&d{
            $cha = hak(ds&chaComp)
            cha and radiate(cha,d)
        })
        
        # < boxlink Diff|Ply**
        #   scopes the change could be viewed from
        # < -six should redirect %%ope, as it is REy&main
        $Es = []
        each id all {
            !ds&changey and continue
            # we only make -seven/-six/-five out to d%pi
            #  they may not reflect the Ec&pi
            #  eg RE-Fez/E-Fez are -six/-five to d
            !ds&pi and continue
            # mark Ply**
            me&textarrow,d.O
            # to visit d%E
            $E = ds&E
            !E and debugger
            ahk(Ply,['y'],'offendEd',{E,d})
            Es.push(E)
        }
        #me&nu,"Wouldvis",Es
        
        # /box:Ply
        })
        me&boxcap,'strange!',5 (&m{
            # me&walls,m,'b:3.2'
            each is Plys&strange {
                me&tc,dis(s),'B'
            }
        })
        # < move outside
        Plys&ml = -6
        return Ply
        if (0 && 'look-around-lines') {
            $mai = Comp.findIndex(l => ls&string.includes("maaaagic"))
            
            
            
            
            
            
            
            
            
            me&boxcap,'wonk','1' (&ml{
                $some = Comp.slice(mai-3,mai+3)
                each in some {
                    me&boxcap,'line','1G' (&ml{
                        lc&s = n.t
                        lc&s.length == 3 and lc&s += "!"
                        $t = me&tc,'doov','g'
                        tc&s = enj(ns&string)
                        ts&ws = 1

                    })
                }
            })
        }
    }   
        
 // chunkology
    # follows the universal plant-in-the-lobby pattern:
    #   headings followed by empty lines do not a chunk make
    # < all known limitations involve io-happy regroup:
    # < joining b in ((...,0),(1,2,2,1,2,2,1):b):a
    #    esp if a > 80, we could look harder
    #    b is otherwise 3 chunks, none big enough, also:
    # < pre|post-amble, braces or comments, if gap beyond
    #   (1,2,2,1),0,(1,2,2,1)
    # see &chunksoflines various < 20 for some stumbling into:
    # < play with which being open gives near 100 lines
    #   or 100 lines per 1000 lines, or so
    # < when aging/inserting folds,
    #     open those the cursor/diff is mostly in
   // cm side
    # all at once
    #   no memo, usu rarely happens via s&valuecha()
    me.cm_chunksfold = &acgt,cm,z,ch{
        z ||= Cye([C.t,1,{s:cm.getValue()}]);
        $lines = zc&s.split("\n");
        # not the osc C?
        z == C and z = Cye(['lod',1]);
        # split that up
        !zs&chunks and me&chunksoflines,z,lines;
        # the existing marks
        $ope = me&cm_foldmap,cm
        # adjust to C
        me&cm_foldCode,z,ope,cm,ch;
        return z
    }
    # our chunks match|make a fold
    # < z**%ope=1/0, changing what is
    # < top-down lazily, %open/%closed/* to instantly:
    #   pop open, yet close more chunks within that
    #    (closing a then a/b opens a)
    me.cm_foldCode = &acgtz,ope,cm,ch{
        $found = [];
        if (zs&commentsey) {
            $mark = '#'+'c '
            cm.options.foldOptions ||= {};
            cm.options.foldOptions.rangeFinder = &cm,pos{
                $from = pos.line;
                if (from > 0 && !cm.getLine(from).includes(mark)) {
                    # not on a #c, use indent
                    $f = cm.getHelpers(pos,'fold')[0];
                    $range = f(cm,pos);
                    !range and ~>5 seekup til #c?:
                    return range
                }
                $end = cm.lastLine();
                $to = from;
                while (to < end) {
                    $text = cm.getLine(to+1);
                    text && text.includes(mark) and break
                    to++
                }
                if (to > from) { return {
                    from: CodeMirror.Pos(from, cm.getLine(from).length),
                    to: CodeMirror.Pos(to, cm.getLine(to).length)
                }}
            }
        }
        #$topdown = zs&chunks.slice().reverse();
        each is zs&chunks {
            $f = ope[ss&line];
            ss&line *= 1
            if (ch) {
                debugger
                ch.from && ss&line+2 < ch.from.line and continue
                ch.to && ss&line-2 > ch.to.line and continue
            }
            # for Glimpes
            f and fy&chunk = s
            elsif (ss&proper) {
                # this checks again that fold makes sense
                $fo = cm.foldCode(CodeMirror.Pos(ss&line,0));
                found.push(fo)
                !fo and continue
                nofo = 0
                # doesn't make an $f
                # open widgets
                me&cm_mark_refoldable,fo,cm;
            }
        }
        # see stylehouse/CodeMirror.git 0a8f8455f2d48
        #  you might also findMarksAt after !cm.foldCode
        found.length && !found.filter(n => n).length and ~>5 cm_foldCode none found:
    }
    # current folds by line, inc open if refold marked
    me.cm_foldmap = &acgt,cm{
        $M = cm.getAllMarks()
        .filter(n => n.__isreFold && n.otherend || n.__isFold)
        .map(&n{
            $pos = n.find();
            # they get lost on big copy+paste
            !(pos.to && pos.from) and return 
            n.otherend and pos = {from:pos,to:n.otherend.find()}
            return Cye(['fold',1,{},{mark:n,
                line: pos.from.line,
                toline: pos.to.line
            }])
        }).filter(f=>f);
        $ope = {};
        each if M {
            ope[fs&line] = f
        }
        return ope
    }
    # an open fold having close buttons at each end
    me.cm_mark_refoldable = &acgtm,cm{
        $refoldable;
        refoldable = &m{
            m._handlers and delete m._handlers.clear;
            m.on('clear',&from,to{
                !(from && to) and return ~>5 lost fold:
                $N;
                $foldagain = &{
                    $pos = N[0].find();
                    N.map(n => n.clear())
                    !pos and return
                    #~>3 foldat: pos.line
                    $fo = cm.foldCode(pos);
                    !fo and return ~>5 lost refold:
                    refoldable(fo);
                };
                N = [from,to].map(&l{
                    $sym = l == from ? "\u21A6" : "\u21A4";
                    $widget = $('<n>'+sym+'</n>')
                        .on('click',foldagain)
                        # < clickable large floaty things...
                        #.css('font-size','280%')
                        .css('color','#7c9')[0];
                    $lop = cm.setBookmark(l,{widget});
                    lop.__isreFold = 1;
                    return lop;
                });
                N[0].otherend = N[1]
            })
        };
        refoldable(m);
    }
   // lines side
    # s/$c**, also s%chunks = [c in reverse (depth first)]
    me.chunksoflines = &acgts,lines{
        # starting from s = the whole document!
        ss&line = 0;
        ss&toline = lines.length-1;
        # i $s/$c each divisible chunk
        $N = me&indo,s,{dl:15} (&sd{
            # keep small chunks, no further
            #ss&toline-ss&line < 20 and return s

            me&chunkchunksoflines,s,lines;
            !ss&z and throw "nochunks"
            
            # drop small chunks
            ss&z.filter(c => 1+cs&toline-cs&line < 20)
                .map(c => me&fiu,s,c,9 );
            
            # and any one chunk same as the parent chunk
            ss&z.length == 1 && ss&z
            .filter(c => cs&line == ss&line).map(&c{
                #cs&toline != ss&toline and throw "was shorter!!"
                me&fiu,s,c,9
            });
            return s
        });
       // etc
        $z = s;
        $resetN = &{
            N = [s];
            sy&tw = {};
            ss&z = [];
        }
        $assign = &N,lines{
            # assign their substrings 
            N.map(&s{
                #ss&string = lines.slice(ss&line,ss&toline+1).join("\n");
                ss&lines = 1+(ss&toline-ss&line);
                ss&lines < 20 and delete ss&proper
            });
            $rev = N.slice().reverse();

            # size supposing s/*%folded are each 1 line
            rev.filter(s => s == z || ss&proper).map(&s{
                ss&size = ss&lines;
                ss&z .filter(c => cs&proper).map(&c{
                    ss&size -= cs&lines-1;
                });
                if (ss&size < 20 && 
                    !(ss&size > 5 && ss&heading))
                    delete ss&proper
            })
            
            return rev
        };
        $rev = assign(N,lines);
       // or #c
        if (ss&lines > 100 && ss&size > ss&lines*0.1) {
            # didnt fold much, fallback to #c-markers
            $mark = '#'+'c '
            $wasN = N;
            resetN();
            # < why does this leave a few?
            #ss&z.map(c => me&fiu,s,c,9);
            #ss&z.map(c => me&fiu,s,c,9);
            #ss&z.map(c => me&fiu,s,c,9);
            $la;
            each il lines {
                la && !l.includes(mark) and continue
                i *= 1;
                $c = Cye(['chunk@'+i,1]);
                la and las&toline = i-1
                cs&line = i;
                cs&proper = 1;
                me&fiu,s,c;
                la = c;
                N.push(c);
            }
            las&toline = i;
            rev = assign(N,lines);
            
            if (ss&size > ss&lines*0.1) {
                ~>7 chunksoflines confused by: s.t
            }
            elsif (ss&lines / ss&z.length > ss&lines / 2) {
                #~>7 chunksoflines uncommentsey: s.t
            }
            else {
                ss&commentsey = 1;
            }
            if (!ss&commentsey) {
                resetN();
                wasN.filter(c => c != s)
                    .map(c => me&fiu,s,c && N.push(c) );
                rev = assign(N,lines);
            }
        }
        ss&chunks = rev;
    }
    # i $s/$chunk+
    #  relating s%(to)lines -> lines
    me.chunkchunksoflines = &acgts,lines{
        $chunk = &sil{
            $c = Cye(['chunk@'+i,1]);
            cs&line = l;
            me&fiu,s,c;
            return c
        }
        $c = null;
        $i = 0;
        $li = ss&line || 0;
        $laindent = ss&indent || 0;
        $ltoindent = {};
        while (lines[li+i] != null) {
            $l = lines[li+i];
            $indent = ltoindent[li+i] ||= l.match(/^(\s*)(.*)$/);
            $stuff = indent[2];
            indent = indent[1].length;
            $p = c;

            # level this chunk is based at
            $cind = c && cs&indent || 0;
            
            # remaining at s's indent is not c-worthy
            !c && ss&line && indent == ss&indent and i++; continue
            else
            !c and c = chunk(s,i,li+i)
            else
            !i and throw "i=0"
            else
            # not minding empty lines
            !stuff and indent = laindent; 'grow'
            else
            # < python-ish indent-implied blocks. would ignore:
            stuff[0] == '#' && indent == cind and 'grow'
            else
            # (1,2),(1) or (2,3),(1)
            if (cind == indent && indent < laindent
                || cind > indent) {
                c = chunk(s,i,li+i)
            }
            else
            # (1,1),(2) -> (1),(1,2)
            if (cind < indent && laindent <= cind
                && (ps&toline - ps&line > 0
                    || ps&line == ss&line)) {
                c = chunk(s,i,li+i);
                cs&laindent = laindent;
                if (ps&line != ss&line && laindent != ss&indent) {
                    # borrow the 1, or start indent from here
                    cs&indent = laindent;
                    ps&toline--;
                    cs&line--;
                    if (!/\S/.test(lines[cs&line])) {
                        # no plant-in-the-lobby trick, open
                        # consume the skipped over !stuff
                        cs&spacedopen = 1;
                        while (1) {
                            cs&spacedopen++ >4 and throw "big cs&spacedopen"
                            /\S/.test(lines[cs&line]) and break
                            cs&line--;
                        }
                    }
                    
                }
            }
            else
            # chunks with something further inside will cm.doFold
            #  unless they're /^#/, no prob
            # ie only the (1,2) of (1,1,1),(1,2)
            indent > cind and cs&proper = 1
            # various reasons un-proper, eg (2, ,3)
            cs&spacedopen and delete cs&proper
            
            if (p != c) {
                $lindo = ltoindent[cs&line];
                lindo[2][0] == '/' and cs&heading = 1
            }

            if (cs&indent == null) {
                cs&indent = indent
            }
            cs&toline = li+i;
            cs&toline >= ss&toline and break
            laindent = indent;
            i++;
        }
    }

 // common
     // about text
        # < nibble-sized view of thing?
        #    2-nibble top Line's t,y + whole textsize
        me.textsize = &acgtsc{
            c ||= {}
            !isst(s) and throw "textsize!st"
            $lin = s.split("\n")
            lin.slice(-1)[0] == '' and lin.pop()
            c.lines = hak(lin)
            c.length = s.length
            return 'x'+c.lines+'*'+c.length
        }
     // forms of text
        # turn %string back into y&toLines
        # huh
        me.unfixstring = &acgts{
            return s.replace(/\n$/,'')
        }
        # < GOING moved to Pictures, yet for R%Codap (editor)
        self.numf = &s{
            !(s >= 0 && s <= 1) and throw "numf!cv"
            return (s+'').substr(2)
        }
 
 // Storables
    # check t%dige%string
    # sanity Quanta: 
    #  as opposed to Qish, of its names (of/t etc)
    me.storable = &acgts{
        $dige = ss&dige
        !dige and throw "storable s!%dige"
        !ss&string and throw "storable s!%string"
        dig(ss&string) != dige and throw "storable broke dige"
        return dige
    }
    
    # make t%dige%string
    me.Linets = &acgttsd{
        ts&string = me&Lineso,s,d
        ts&dige = dig(ts&string)
    }
    # returns %string (/\n$/) &toL,s**
    #  was &Serialise. 
    me.Lineso = &acgtsd{
        return me&indo,s,ex({},d||{}) (&s,d{
            $Y = sy&Y;
            d.where && !d.where(s,d) and s = 0
            d.what and s = d.what(s,d)
            !s and d.not = 1; return
            $part;
            try {
                # < as Y T.act, spec args
                part = 'scan';
                !isC(s) and throw "Not C"
                sc&N and throw "mightbe R"
                
                part = 'clone';
                $D = d.D = Cye(s);
                d.up && d.up.D and Dy&up = d.up.D
                
                part = 'Compress';
                me&Compress,D
                Y && Ys&compLines and Ys&compLines(D,d,s)
                d.compLines and $already = d.compLines(D,d,s)
                already and return already
                
                part = 'toLines';
                d.toLines = d.jsony ? enj(D) : me&enL,D
                Ds&H && !d.toLines.match(/(H):(\w+)\b/) and throw "%H not so gc will see it"
            }
            catch (er) {
                ~enLinesR: ki(d.path,2)+"   !"+part+"! "+er
                #me&Rec,R,'err';
                d.toLines = "[error} "+ki(s);
                #Rs&err = "enLinesR: "+part+": "+er;
                #n err  $s:Rs&err
                d.nofurther = 1
                # in case we dont throw new Error(...)
                # < generalise handling, fix up toLines: throw "Leaky...
                isst(er) and throw "Lineso: "+er, d.path
                # this Babz into er.catches+={stack,tc=[further]}; throw er
                throw er, 'further', d.path
            }
            sy&toLines = d.toLines;
            return d.toLines
        })
        + "\n"
    }
    
    # o y $s**
    #  was &Copy (made R:Copy)
    # < more like &acceptables_reself, %string -> lv sense etc
    me.Clone = &acgtsd{
        $dupN = []
        $neu = me&indo,s,d (&sd{
            $z = d.O = Cye(s)
            z.y [d.ytag||'Clone'] = s
            $du = d.up
            $pz = du && du.O
            # rebuilding y&tw and s&z, dup fatal
            if (pz) {
                me&fiu,pz,z,8 and dupN.push(z)
                # el:4 for leaving dups in pz%z
                me&fiu,pz,z,4
            }
            return z
        }) [0]
        if (hak(dupN)) {
            ~>3 Clone dups: s.t, joint(dupN)
        }
        return neu
    }
    
    # &ballLines climbing s, knowing R
    #  replaces: Describing via awaking everything with %Lines
    # < wants errors, compression pointers:
    # < n Leaps -code ballLines:Yingr # doing:
    #   .c resolving &ballLines, figuring R+Rc&s
    me.ballLines = &acgtRs{
        $d = {};
        d.R = R;
        d.where = &sd{
            $r = d.R;
            sc&noencode and return 0
            !r and return 1
            rc&s == s and return 1
            # RbitX follow it down, using last time
            #  which should have all the nodes
            # < resyncing by sy&R? wants visual clue, ioland
            # 
            $found = [];
            $x = rc&V && rc&V.x || {};
            each tX x {
                each ir X.z {
                    rs&ball && rc&s == s and d.R = r; return 1
                }
            }
            delete d.R
            return 1
        }
        d.compLines = &Dd{
            $r = d.R;
            !r and return
            rs&eph and return d.not = 1
            rs&compLines and rs&compLines(D,d)
        }
        return me&Lineso,s,d
    }
    
    # see Jay Y:osc 7
    # make W.js usable for:
    #  boot: w:Twoism loadI, page includes Hunt.js (moved out of W/)
    #  u: @Search Talks.js
    #   < without the lookup step (you know %dige)
    me.jsso = &acgttd{
        # have just been Lineso'd
        $W = me&ioty,t .filter(n => nc&W == 'of');
        !d.dige and throw "W.1 !dige"
        $clone = &s{
            $D = Cye(s);
            # < do anything now?
            G&Compress,D;
            d.compLines and d.compLines(D,d)
            return D
        }
        $shush = &s{
            return s.replace(/\W+/g,'_')
        }
        
        # first function, on the first line, should be a toc
        # one item per line of it, including line number ranges
        # flat list, to include toc
        $N = [];
        each iI W {
            $z = me&ioty,I;
            I = W[i] = clone(I)
            Iy&cv ||= 0.1;
            $Icv = cvf(Iy&cv)
            z.map(&n{
                n = clone(n);
                ny&cv ||= 0.1;
                ns&name = shush([t.t,d.dige,I.t,Icv,
                    n.t,cvf(ny&cv)].join('_'));
                !nc&s.match(/^function/) and throw "doesnt ^function", n
                nc&s = nc&s.replace(/^function/,'function '+ns&name)
                ac(I,'z',n);
                N.push(n)
            })
        }
        each in N {
            !nc&s.match(/\n$/) and throw "No trailing \\n", n
            ns&lines = nc&s.split("\n").length
        }
        
        # [ind t y c sc]+
        $toc = [];
        each iI W {
            toc.push(['',I.t,cvf(Iy&cv),I.c,I.sc]);
            me&ioty,I .map(&n{
                toc.push(['  ',I.t,cvf(Iy&cv),n.c,n.sc]);
            })
            delete Is&z;
        }
        # also ^function...{\n and \n}\n$
        $toc_lines = toc.length + 3; 
        $code_lines = 0;
        each in N {
            ns&line = toc_lines + code_lines;
            code_lines += ns&lines;
        }
        $codes = [];
        each in N {
            codes.push(nc&s);
            delete nc&s;
        }
        $name = shush([t.t,d.dige].join("_"))
        $cur = shush([t.t,'current'].join("_"))
        return [
            "function "+cur+" () { return "+name+"() }\n",
            "function "+name+" () { return [\n",
            # data and code has indent
            ... toc.map(l => l[0]+enj(l)+",\n"),
            "]}\n",
            ... codes
        ].join('')
    }
 
 // Lines string<->thing de?construction
  
  // &Compress, &oleak, &cmuted
    # check data depth or (yaml encoded) length
    #  bails encode as soon as depth > $d*3
    #  has to finish to figure length
    me.oleak = &acgtsdl{
        $fail = 0;
        $was = window.maxyamling;
        window.maxyamling = d * 3;
        $code;
        try { code = jsyaml.safeDump(s) }
        catch (er) {
            window.maxyamling = was;
            er.message != "Too much to yaml" and throw er
            fail = 1;
        }
        if (l && code && code.length > l) {
            fail = 'large-ish'
        }
        window.maxyamling = was;
        return fail
    }
    
    # string avoids various things
    # < an embryonic composited sub, like thro, 
    # < the opposite, collected from n and something else...
    # < use the d (state from G&ind) to make links for duplicated objects
    # see j/7 K: used to mute any ref not gk =~ /x$/
    me.Compress = &acgtsd{
        # will be gone if we $s = Cye(...)
        delete ss&z;
        
        # especially if pi
        ss&J and delete sc&s;
        typeof sc&s == 'object' and delete sc&s
        typeof ss&J == 'object' and delete ss&J
        
        # makes c.code -> c.mc=code
        #  would otherwise c.mc=code:$arfgunc
        me&cmuted,s,{mute:{c:['code'],sc:[]}}
    }
    # drop C.*.* objects other than Object|Array
    #  eg c.on (HTMLDivElement) -> c.mc=on
    # < Be properties
    me.cmuted = &acgtsc{
        $mute = c.mute;
        $sep = ' '
        $unmuted_objects = [Object,Array];
        each nk,gks mute {
            $he = s[nk];
            $muted = {};
            each gk,v he {
                gks[gk] and muted[gk] = 1; continue
                # data should be limited somehow...
                typeof v != 'object' and continue
                unmuted_objects.indexOf(v.constructor) >= 0 and continue
                # name of v.constructor
                muted[gk] = G&arfgunc,v || 1;
                
            }
            each gk,reason muted {
                delete he[gk]
            }
            !hak(muted) and continue
            # say that it is muted, eg c&mc = 'the muted keys'
            #  in a space separated peel (hash)
            $ou = 'm' + nk[0]
            $was = s.c[ou]
            was and ex(muted,G&peel,was,{sep} )
            s.c[ou] = G&depeel,muted,{sep}
        }
    }
  
  // Lines types
    # < use from o that can conjoin the many C
    # aims for simplicity of notation for &deL, G&C, G&peel
    # block quotes (BQ) big strings or data after the  line
    # uses json for anything complicated
    # z insides done by the process around this one Line
    #  - they have the same indent as BQs
    #    but their t should json or not look like BQ
    # < put BQ at an odd indent... 1 space for keys, 3 for values
    #    as long as key|value|nextC always ^\S
    #   needs to convert all of W/ for this
    #    probably not that many instances of it
    # notice if gk|v will break if encoded via peel()
    # < dealing with c = enj(number) when eg c&s=5? -5?
    #   everything except y&cv may decode as string, eg via peel()
    #    unless it is inside c.* for enj(c)
    # < there is probably a looser Lines scheme...
    #   which should not have to include \t all the time,
    #   but may json quote if spacey .t
    #   or if c gets spacey and cant just join with more space to sc
    #    which will need to happen anyway if sc is spacey
    #   < ende - the symmetrical encode|decode thingkitexture
    me.Lines_types_is = null
    me.Lines_types = &acgt{
        $is = me.Lines_types_is
        is and return is
        $is = {}
        
        $ty = {}
        # breaks the \t=09,\n=0a of the enclosing Line
        ty.lowdown = "[\\u{0}-\\u{a}]"
        # start of hemisphere (c|sc) that wants dej()
        ty.jsoning = "^[\\[\\{\"]"
        # y,c may have %sc,starting,early
        # < from &enL (now from ws:digwaypoll)
        ty.earlysc = "^%"
        # < return line count?
        ty.multiline = "\\n"
        ty.wordyspace = "^\\w[\\w ]*$"
        
        # v never starts hem. can contain a lot, even ':'
        #  since peel splits by all ',', then one ':' each
        ty.unsafe_v = [ty.lowdown,','].join('|')
        # k might start hem. must not look like jsoning.
        ty.unsafe_k = [ty.earlysc,ty.jsoning,ty.unsafe_v,':'].join('|')
        
        $func = &ty{
            is[t] = &s{
                $notstring = typeof s != 'string' && typeof s != 'number'
                notstring and throw "Lines_types.is!string", s
                return y (s+'')
            }
        }
        # must define $t for a function
        haks(ty).map(&t{
            $m = RegExp(ty[t],'u')
            func(t, s => m.exec(s) )
            if (t.startsWith('un')) {
                # derives is.safe_k(k)
                func(t.substr(2), s => !is[t](s) )
            }
        })
        # also, aesthetics
        is.fitsin = (v,s) => (''+s).length <= v
        is.good_k = s => is.fitsin(23,s) && is.safe_k(s)
        is.good_v = s => is.fitsin(64,s) && is.safe_v(s)
        is.screedy = s => !is.fitsin(42,s)  && is.multiline(s)
        me.Lines_types_is = is
        return is
    }
    
   // indents, struct types
    # Lines C may have indented bits after
    # < at one space, inconfusible with C/C indent
    me.LinesBQ_indent = '  '
    # for N|i of '  ', starting with i=1 -> ''!
    # < rename. GONE? used once.
    #   could call &indents,(d-1)*2,s,'notailn'
    self.indent = &ds{
        d == 0 and throw "d!>0"
        isar(d) and d = hak(d)
        s and throw "< splitindjoint"
        # 1:'',2:'  ',3:'    '...
        return new Array(1*d).join('  ')
    }
    # &ind (around &enL) uses '  ', BQ-ish things use:
    self.indents = &l,v,notailn{
        num(l) and l = new Array(1+l*1).join(' ')
        !isst(l) and throw "indent ' '?"
        $vs = [];
        # "the","lines" <- "the\n","lines\n"
        v = Lin_Lines(v)
        each is v {
            vs.push(l+s)
        }
        !notailn and vs.push('')
        return vs.join("\n")
    }
    # $L = ["the","lines"] <- "the\nlines\n"
    self.Lin_Lines = &v{
        v = isar(v) ? v : v.split("\n")
        # chomp off the tail end
        v.slice(-1)[0] == '' and v.pop()
        return v
    }
    # we take the indent off to make it Cy&deLines!
    self.unindents = &d,v,notailn{
        !num(d) and throw "indent d"
        $vs = [];
        v = Lin_Lines(v)
        each is v {
            # bite off space
            $space = s.substr(0,d)
            space.split('').some(a => a!=' ') and debugger
            
            vs.push(s.substr(d))
        }
        !notailn and vs.push('')
        return vs.join("\n")
    }
  
  // &enL toLines - C to string
    A.I.i.y.tw.toLines.c.code =
    me.enL = &acgts{
        
        s and C = s;
        $t = C.t;
        $y = C.y.cv;
        # hath
        $h = {};
        h.c  = ex({},C.c||{});
        h.sc = ex({},C.sc||{});
        delete hs&z;
        # needs json
        $n = {};
        # needs blockquote
        $q = {};
        # as determined by
        $is = me&Lines_types
      
      // sayability!
        # check out how sayable the values on the line are
        # for c/sc as peelable, 
        # < we can know thing:thing:thing
        #   means thing = 'thing:thing'
        # GOING is.safe_v,safe_k
        $peelok = /^[\w\.\-%\/:]+$/;
        $nameok = /^\w[\w\.\-%\/]*$/;
        # GOING is.good_k
        $simp = &s{
            s = ''+s;
            return is.safe_k(s) && s.length < 24
        };
        # inject 2sphere
        $lod = &n,nk,gk,v{
            n[nk] ||= {}
            n[nk][gk] = v
        };
        each nk,gk,v h {
            if (!is.good_k(gk)) {
                lod(n,nk,gk,v)
                continue
            }
            if (typeof v != 'string' && typeof v != 'number') {
                # is > 4*3 nodes or encodes to > 42 chars
                if (me&oleak,v,4,42 ) {
                    me&oleak,v,24 and throw "Leaky "+nk+"."+gk+": "+ki(v);
                    # big enough to quote, simplifies remainder
                    lod(q,nk,gk,v);
                }
                else {
                    # ref too small to quote, json hemisphere
                    lod(n,nk,gk,v);
                }
            }
            else {
                if (is.screedy(v)) {
                    # long enough to quote
                    lod(q,nk,gk,v);
                }
                else if (is.good_v(v)) {
                    # decipherable to G&peel
                }
                else {
                    # midway to unwieldy
                    lod(n,nk,gk,v);
                }
            }
        }}

      // sayableparts!
        # quote freaks (q), json freaks (n), everything (h)
        each nk,gkv n {
            $g = h[nk]
            !hak(g) and debugger
            $gnotq = grepout(haks(g),k => !(q[nk]&&q[nk][k]))
            $gnotnorq = grepout(gnotq,k => !n[nk][k])
            # reasons not to n -> q
            # nothing else in the spot
            !hak(gnotnorq) and continue
            # complex keys must be json
            # < making blockquote opener: sc "anykey":
            #    requires tight match right of :
            #     requires eny(v) on the next line, as for !string
            #     < unless parse everything at once
            haks(gkv).some(k => !is.wordyspace(k)) and continue
            # reasons to become a quote:
            # among g that are not q
            if (hak(gkv) / hak(gnotq) < 0.34) {
                # mostly not n in the spot
                each kv gkv {
                    lod(q,nk,k,v)
                }
            }
            else {
                each kv gkv {
                    is.fitsin(23,k) and continue
                    lod(q,nk,k,v)
                }
            }
        }
        
        # remove quoted things and their need of json from the line
        each nk,gk,v q {
            h[nk] and delete h[nk][gk]
            n[nk] and delete n[nk][gk]
        }}
        # all freaks got quoted
        each nk,gkv n {
            !hak(gkv) and delete n[nk]
        }
      
      // encoded bits
        # may pass a T.enj_catch, so functions can warn/show up as 'CODE'
        $enj = &s{ return window.enj(s,T) };

        # t can be messy, very long (as opposed to is.good_k)
        $l = is.safe_k(t) ? t : enj(t);

        # y.cv = 1 is implied
        !y and y = 1
        y = numf(y)
        y = y == "1" ? '' : y
        # -suchpi can be attached to it
        if (h.c.pi && !(n.c && n.c.pi)) {
            $pi = delete h.c.pi
            y += '-'+pi
        }
        l += "\t"+y

        # one way or another
        $hem = ['c','sc'];
        each i,nk hem {
            $v = h[nk];
            if (nk == 'c' && 0 == hak(v)) {
                # blank
                l += "\t";
            }
            else if (nk == 'c' && 1 == hak(v) && hak(v,'s')) {
                # t y "the s" sc
                l += "\t"+enj(v.s+'')
            }
            else if (n[nk]) {
                # json bits: t y {W:"At"} {et:3,se:"te",ra:1}
                l += "\t"+enj(v)
            }
            else if (hak(v)) {
                # G&peel bits: t y W:At et:3,se:te,ra
                l += "\t"+G&depeel,v
            }
        }

      // indented bits
        $L = [];
        # < quoting with Line other N/C looking vals
        each nk,gk,v q {
            # < sanity. nk will be c|sc
            #   should be covered? see complex keys must be json
            !is.safe_k(gk) and debugger
            # specifically, see &deL $indenting
            !is.wordyspace(gk) and debugger
            !nk.match(/^\w+$/) and debugger
            $k = me.LinesBQ_indent
                +nk+" "+gk+":"
            if (typeof v != 'string') {
                # BQ yaml data
                # < rename T.eny_trace, its error handler uses
                T.eny_nkgk = [nk,gk]
                $v = eny(v,T)
                delete T.eny_nkgk
                k += "\n"+indents(me.LinesBQ_indent+'  ',v,1)
            }
            else if (is.safe_v(v)) {
                # simple strings
                # < not confusible into 'Thing 2'?
                k += " "+v
            }
            else if (!v.match(/\n$/)) {
                # BQ implies trailing \n
                k += " "+enj(v);
            }
            else {
                # BQ string
                k += " |\n"+indents(me.LinesBQ_indent+'  ',v,1)
            }
            k = k.replace(/\n\s*$/,'');
            L.push(k);
        }}
        
        # extra lines (L) sorted, larger bits after smaller
        L = L.sort();
        $tidy = [];
        $large = [];
        each is L {
            s.length > 300 ? large.push(s) : tidy.push(s)
        }
        l = [l];
        tidy.length and l.push(tidy.join("\n"))
        large.length and l.push(large.join("\n"))
        l = l.join("\n");
        
        return l
    }
   
  // &deL readLines - string to [C+]
    # for $C = &deL1 <\<''
    #   Atoms -with spaces %when,you,cant,type,tabs
    me.simpdeL = &acgts{
        $L = s.split("\n").map(&s{
            !hak(s) and return s
            $p = me&parserify,s
            p.p(/^( +)/)
            $m = p.s.split('  ')
            hak(m) == 1 and m = p.s.split(' ')
            # t,y,c,sc = 0,1,2,3
            m[3] && m[3].startsWith('%') and m[3] = m[3].slice(1)
            return (p.1||'')+m.join("\t")
        }).join("\n")
        return theone( me&deL,L,{attach:'fiu'} )
    }
    A.I.i.y.tw.readLines.c.code =
    me.deL = &acgts,opt{
        
        opt ||= {};
        $is = me&Lines_types
        $L = Lin_Lines(s);
        $oL = [];
        $tot = L.length;
        # N=[C+]
        $N = [];
        $stack = [];
        $paniconce = 0;
        while (L.length) {
        
      // rowing
        $l = L.shift();
        # rebuild what y&toLine was here
        $Line = [l]
        # first line of each Line+indented-stuff only, a trace
        # < a stack
        oL.push(l);
        # < shouldn't happen, BQ blank lines are indented
        !l.length and continue
        $lin = l.match(/^(\s*)(.*)$/);
        $ind = lin[1];
        $d = ind.length / 2;
        l = lin[2];
        $li = l.split("\t");
        $t = li[0];
        $y = li[1];
        $c = li[2];
        $sc = li[3];
        # sc can kick in early, still one \t
        y && y [0] == '%' and sc = y.substr(1); y = '';
        c && c [0] == '%' and sc = c.substr(1); c = '';
        y && opt.y1 && opt.y1[0] == '%' and (opt.tosc ||= {})[opt.y1.slice(1)] = y; y = '';
        # t may be crazy string
        is.jsoning(t) and t = dej(t);
        if (y && y.includes('-')) {
            # 33-suchpi
            $m = y.split('-')
            $pi = m [1]
            !pi || m[2] != null and throw "!33-suchpi",y
            y = m [0]
        }
        y ||= "1"
        y * 1 == NaN and debugger
        # < see scv(cv)
        y = {cv:1*('0.'+y)}
        
        # c&s as a fifth thing on the line
        $s = li[4];
        if (s && is.jsoning(s)) {
            s = dej(s)
        }
        if (c && c.startsWith('"')) {
            s = dej(c)
            c = {}
        }
        else if (c && is.jsoning(c)) {
            c = dej(c)
        }
        else if (c) {
            c = G&peel,c
        }
        else { c = {} }
        
        s != null and c.s = s
        pi and c.pi = pi
        
        if (sc && is.jsoning(sc)) {
            sc = dej(sc)
        }
        else if (sc) {
            sc = G&peel,sc
        }
        else { sc = {} }
        
        
        $C = {t,y,c,sc}
        
      // indented bits
        
        $k
        $v
        $indenting = &{
            !L.length and return
            $m = L[0].match("^"+ind+me.LinesBQ_indent
                +"(\\w[\\w ]+):(?: (\\||.+))?$")
            !m and return
            k = m[1]
            v = m[2]
            return 1
        };
        while (indenting()) {
            $string
            if (v === '|') {
                string = 1;
                v = undefined;
            }
            v && v.match(/^\W/) and v = dej(v)
            Line.push(L.shift())
            k = k.split(' ');
            $nk = k.shift();
            $gk = k.join(' ');
            if (!v) {
                $s = [];
                $one;
                $blockquoting = &{
                    !L.length and return;
                    $m = L[0].match("^"+ind+me.LinesBQ_indent
                        +"  (.*)$");
                    !m and return;
                    one = m[1];
                    return 1;
                }
                while (blockquoting()) {
                    s.push(one);
                    L.shift();
                }
                v = s.join("\n");
                # console.log("Loaded "+nk+gk+": "+v+'  Next: '+L[0]);
                if (!string) {
                    v = jsyaml.safeLoad(v);
                }
                else {
                    !v.match(/\n$/) and v = v+"\n"
                }
            }
            C[nk][gk] = v;
        }
      
      // attach
        # the chunk of string goes with it
        Cy&deLines = unindents(d*2,Line,1)
        d.toFixed() != d and ~fractionalind: d, C, T.readinglv
        d = 1 * d.toFixed();
        if (d > 0) {
            $p
            $dl = d;
            while (dl--) {
                p = stack[dl];
                p and break
            }
            if (dl < d - 1) {
                $few = oL.slice(-3);
                if (! paniconce++) {
                    ~toomuchind: d, dl, T.readinglv, few
                    debugger
                }
                d = dl+1;
            }
            # use io?
            if (opt.attach == 'fiu') {
                me&fiu,p,C
            }
            else {
                ps&z ||= [];
                ps&z.push(C);
                # tv/tw/in/next?
                $tv =
                p.y.tv ||= {};
                tv[C.t] ||= {};
                tv[C.t][C.y.cv] = C;
            }
            # a mass inCing, dialecting
        }
        else {
            N.push(C);
        }
        stack[d] = C;
        while (stack[d+1])
            stack.pop();
            opt.tosc and ex(C.sc,opt.tosc);
        
        }
        return N
    }
 
 // string<O>string
   
