# 
 // Diff
   # < copy from Soogle
 
 // Ploy = (D Comp/l+ D)**
    # classifies differences, annotating merged modulat
    # see -Difmo
    =note
       tests,
        < reduce examples to a single feature
       Fus@7 / "..thence net" before c2ca1264be04e2 "splitting moments of ground"
         is referred to by all joi@cv comments in here (unless noted)
          it has now moved on!
         < park stable version somewhere in a museum
       
       bugs:
         worked around by &Ploy_joins_unfixable
         which notices and separates diff-tangle
          Fus@7:
           "..gets it" is ugly, wants better tools to figure the figuring out
            < a big ugly '..gets it'-Difmo
               see &Ploy_joins_fix / sweepin
               I dont really understand why the c|sc should appear in yls/ rather than synco/
                possibly treating array indices as less-compelling might help
                or &typeup c|sc to Emp|Uni, from -Hash, which can also sidle us into yls/*
                c|sc is really stretching from ugly matches on joi@23|27?
                  the joi@27 is easier to see
               see fix fail:place-stack-gap
                some of it (c?) has an indent mismatch
                caused by many joi%separate_ls in a row wanting to group all their ++|--
                 will still be stack-gappy?
                needs more desire to keep E/* together...
                 esp indent change probably applying to all
                  a region finds indent change, and magnetises l for it
                right now,
                 we have (--c) on joi@
                -Difmo about this gets ugly
                 &drawleftwing jam, pos:2 not seen above+, where it could help
                  may benefit from keeping -Difmo out of mirguts (a mirage)
              higher levels:
               even more muck-about with diffs to make them present good
                human wants to isolate the todo|synco/* limb
                 and connect c-c, sc-sc...
                 about pulling apart a mingled diff until etc
               the joi@26 is changing A.t but not C.t of A:loading
                it may be noticed that either nod.Ec&s is the same object
           "..receives response" fixes wrong
             < Ploy fail:fix:sanity-whole-same for that
               strangely a&fixed_Comp
                see ls&string.startsWith('\t-Number')
               sph:gone gains a '\t-Number\t"1"' before the 'waiting\t-Number\t"1"'
               de-fail-ing it
                we go around and fail:eq
                 it looks like ...=='\t-Number\t"'...=='1"'... should be ++, as the ... are
               < or is Comp corrupted?
               < was it jois&Ntilmoves?
              whack. but we can just have no -Difmo!
           "..wantsback" fixes wrong
               more instances of the same fix bug as "..receives response"
              matching sph far away from each other
               on nothingnesses like 'c\t-Hash\t\n'
              would work better|faster if it resolved D** first,
               then made diffs where not exact... avoiding far-flung merges
           "..then believes" fixes wrong
              these are starting to show their samenesses
               something bigger than a Ploy.region,
                more bindy to E**
                detect swathes of either nod** drift, failure of those fixes esp
       
       < sphere-hopping... to see between fix|nofix joi
       < test &intivity, see resolve $n
    =cut
    // Ploy
        # proto io, on 3c&io|iz|o(X|x,...)
        # < compile &iocall to A.3.i.iocall
        me.Ploy_io = &acgt{
            A.3 != A and debugger
            3c&io = &xkv{
                # all indexes are k:v (&X_t)
                # ~~ c.wild: vx={v:x+}
                v == '.*' and return x[k]
                # or x+
                v == '*' and return havs(x[k])
                v == -1 and return havs(x[k]).pop()
                return fi&Xsimp,x,hashkv(k,v)
            }
            # push to eg sph|nod/$line=i++
            3c&iz = &Xkx{
                $many = 3c&io(X,k,'*')
                $i = hak(many)
                # we may mesh|multi-path|link X...x
                x and ahk(X,k,i,x)
                else {
                    # or new ..x as usu
                    x = 3c&io(X,k,i)
                }
                # meshing may eg i_line|mine
                # < crude avoidance of same-index sequence distribution
                #   having a subset at some locale
                x['i_'+k] = i
                return x
            }
            3c&o = &xsy{
                $path = split(s,/\/|(?=\.)/)
                $N = [x]
                each in path {
                    if (n.startsWith('.')) {
                        # eg bit.l
                        N = N.map(x => x[n.slice(1)])
                    }
                    else {
                        N = flatten(N.map(x => 3c&io(x,n,'*')))
                    }
                }
                if (y) {
                    $lai = hak(N)-1
                    $M = []
                    each in N {
                        # < gr3p(): y(v,k,setc) about where you are
                        #    and relations nearby, is very almost io
                        $setc = {i}
                        0 == i and setc.first = 1
                        lai == i and setc.last = 1

                        $ret = y (n,setc)
                        setc.not and return
                        ret and M.push(ret)
                    }
                    # y() as grep(armap(y,N))
                    N = M
                }
                return N
            }
        }
        me.Ploy = &acgt,nav,Comp{
          // A:Ploy init
            A = fi&At,"Ploy"
            A.3 = A
            me&Ploy_io
            # we may edit l in &Ploy_joins_fix
            Comp = Comp.map(n => Cye(n))
            
            me&boxcap,'Ploy',5 (&ml{
                
                lc&not = 1
                # options
                me&Ploy_spannyrower,'conf' (&ml{
                    # if you &Ploy_fail, these draw the context in time for it:
                    me&boxcap,'pass1' (&ml{
                        me&walls,m,'b:2.2'
                        # drawjoin as soon as it is joined
                        #  omits l that belongs to a later joi
                        me&tt,'only' () and 3c&single_pass = 1
                        me&tc,',','6y'
                        # draw l etc as it goes
                        #  we then replace them with a drawjoin
                        me&tt,'lasap' () and 3c&accreting_modulat = 1
                    })
                    # shows the possible fixes...
                    me&tt,'nofix' () and 3c&nofix = 1
                    me&boxcap,'pass2' (&ml{
                        me&walls,m,'b:2.2'
                        # < wants to subjunk extra -six** for zippable spheres
                        me&tt,'show-jois' () and 3c&show_jois = 1
                        me&tc,',','6y'
                        me&tt,'show-regs' () and 3c&show_regs = 1
                    })
                })
            })
            # pass 1
            # make joined nod from l+
            me&Ploy_Comp_sph,nav,Comp
            
            $show_jois = &{
                if (3c&not || 3c&show_jois) {
                    3c&o(3c&X,'join',&joi,{
                        A = fi&At,'joins:'+joi.i_join
                        A&joi = joi
                        # happens at &Ploy_joined if &tt:lasap
                        !3c&accreting_modulat and me&Ploy_drawjoin
                        A = A.3
                    })
                    !3c&not and return
                    # draw a few more l for context
                    me&boxcap,"l...",1 (&ml{
                        $bit = 3c&fail_bit
                        !bit and return
                        $l = bit.l
                        3c&Comp.slice(ly&seqi,ly&seqi*1+5).map(&li{
                            me&drawdiffbit,i,l .sc.dis = 1
                        })
                    })
                }
            }
            3c&not and me&tc,"Abort",'G'; show_jois(); return
            
            # decide how to rewrite Comp/l+ for less %stretch
            me&Ploy_joins_fix
            
            3c&single_pass and me&Ploy_fail,'single-pass'
            
            if (a&fixed_Comp) {
                # doctored input data for clearer diffs, see fix joi%stretch
                me&Ploy_spannyrower,'fix' (&ml{
                    a&fixed_joins .map(&joi,{
                        me&Ploy_tid,joi
                    })
                })
                3c&not and me&tc,"Abort",'G'; show_jois(); return
                if (!3c&nofix) {
                    # around again
                    me&tc,"second-pass..."
                    me&Ploy_Comp_sph,nav,a&fixed_Comp
                }
            }

            # group like stuff
            me&Ploy_regions

            3c&not and me&tc,"Abort",'G'; show_jois(); return
            show_jois()
            
            return 3c&X
        }
        # makes X, l+ -> sph+
        me.Ploy_Comp_sph = &acgt,nav,Comp{
            $X = 3c&X = {A}
            3c&Comp = Comp

            # check nav.* = RE
            # see &Ploy_nod_next
            #  for our swerve into the first_truest after RE
            # < have pointers to these things, time specified. lv C.
            map(&RE,{
                # RE//s (on the same node)
                $s = REy&ers
                !s and debugger
            },nav)
            
            # sph/nod|lin
            $tops = armap(&et{
                # for old|new E**
                $sph = 3c&io(X,'sphere',t)
                sph.sphere = t
                # line 0
                $lin = 3c&iz(sph,'line')
                # node 0
                $nod = me&Ploy_i_nod,sph,e
                $D = nod.D
                !Dy&toLines and debugger
                me&Ploy_i_lin,nod,lin
                return nod
            },nav)
            # join 0
            me&Ploy_i_joi,'given',tops
            
            
          // Comp/$l -> $sph
            $final = Comp.slice(-1)[0]
            each il Comp {

                ly&seqi = i
                A = A.3
                3c&accreting_modulat
                    && me&drawdiffbit,i,l

                $who = l.t == 'same'
                    # == are for both spheres
                    ? havs(3c&io(X,'sphere','*'))
                    # ++|-- only for sph:new|gone
                    : [3c&io(X,'sphere',l.t)]

                who.map(sph => me&Ploy_sph,l,sph)

                A = A.3

                # after &Ploy_fail
                3c&not and me&tc,"Abort",'G'; break
                l == final and 3s&joi.final = 1

                # to A3:Ploy/A:join+
                3s&joined and me&Ploy_joined
            }

            # check we found our way back to each sph/nod0
            $lost = tops.slice()
            grop(3s&seemsdone,lost)
            hak(lost) and me&Ploy_fail,"seemsdone",ex({},lost)
                
            return X
        }
        
        # l -> sph, matching
        me.Ploy_sph = &acgtl,sph{
            3c&not and return
            # to A3:Ploy/A:l+
            #  A:l always up to A3
            A = A.3
            $title = 'l:'+ly&seqi+':'+sph.sphere
            # nod remembered by last sph/lines
            #  can return null if !Dy&toLines
            $a = me&Ploy_nod_arrive,sph,l,title
            !a and 3c&not = 1; return
            A = a
            fatal.isC(A&nod.E)

            !A&nod.joi and return me&Ploy_fail,"joi-less-nod"
            me&Ploy_joi_arrive

            if (ls&moren) {
                # l%moren is a fold marker, everything inside is t=same
                #  we avoid leaving to nod**, which are spared from Comp
                #  it is otherwise a regular l, for A&nod
                # < (upstream) shouldnt %moren if many is small
                #    > unless many small %moren close together
                $many = hak(ls&moren)
                !(isar(ls&moren) && many) and debugger
                A&nod.hasmoren = many
            }
            me&Ploy_indent_sympathy
            me&Ploy_match
            3c&not and return
            me&Ploy_nod_check
            ls&moren && !(a&newline && a&newnode) and debugger
            # join l sequence
            me&Ploy_joi_lit
            me&Ploy_noded
        }
    
    //  nod
        # ^nod|sph += nod
        me.Ploy_i_nod = &acgtxe{
            $sph = x.sph || x
            # climb /$in** = nod, so nod.up reflects Ey&up
            $nod = 3c&iz(x,'in')
            nod.d = (x.d||0) + 1
            # link sph/$node flatly (width first, !~~ &ind)
            3c&iz(sph,'node',nod)
            # nod knows:
            nod.sph = sph
            nod.E = e
            !ey&R and throw "undone E"
            nod.D = Aof(e,'D')
            # the RE (nod.i_node=0) doesnt have a D**
            # < should it? ~~ Js&top: $W@9/*
            #   and the RE/-hat|etc is an osc page
            #    so each page has an encoding defined as pi
            #     which may index pages by something else (t)
            #    and W formats are explained as eg $Wt/1.js
            #     which -js will be able to read,
            nod.D ||= nod.i_node == 0 && nod.E
            
            # eventually /$line of its diffside
            return nod
        }
        
        
        
        # the usual arrive, think, descent
        #  the usual particle (A.1) is basically nod**
        #   nod is also per sph
        #   A:l is per l
        #    for a nod finding it has /lin/bit
        me.Ploy_nod_arrive = &acgt,sph,l,title{
            A = fi&At,title

            # sph/$line/$bit .l|str
            $lin = 3c&io(sph,'line',-1)
            !lin and throw "nolin"
            $bit = 3c&iz(lin,'bit')
            bit.l = l
            # lc&s is a displayified string, sometimes has s/\n/↯/
            !isst(ls&string) and debugger
            $str = bit.str = ls&string
            # join: one lin to many l
            hak(str)-1 < str.indexOf("\n") and throw "many lin to one l"

            $nod = lin.nod
            # -Fez is C-shy
            $V = nod.prev && nod.prev.A
            nod.A = A
            # a second opinion on next nod, from last A:l
            V && Vs&next && nod != Vs&next and debugger
            
            ex(A.c,{sph,nod,lin,bit})

            # so we A3:Ploy/A:l+
            if (!V || Vc&nod != nod) {
                $D = nod.D
                nod.whole = Dy&toLines
                !isst(nod.whole) and debugger
                !isst(nod.whole) and return me&Ploy_fail,'toLines',{l}
                3c&accreting_modulat and me&drawnod,nod
            }
            
            return A
        }
        
        
        # next nod|lin
        me.Ploy_noded = &acgt{
            # per sph:
            $nod = A&nod
            $lin = A&lin
            if (a&newnode && a&newline) {
                # tidy away nod
                delete nod.matchtil
                #   indent implied by nod.d
                nod.indlev && nod.indlev/2 == nod.d-1 and delete nod.indlev
                nod.ok = 1
                # more nodes
                $next = me&Ploy_nod_next
                if (!a&seemsdone) {
                    !next and return me&Ploy_fail,"nextless"
                    isC(next) and return me&Ploy_fail,"nextC",{next}
                    nod.next = next
                    next.prev = nod
                    nod = a&next = next
                }
                # let join happen
                ac(A.3,'joined',A)
                a&seemsdone and return
            }
            if (a&newline) {
                # tidy away lin
                delete lin.indent_sympathy
                # < until a multi-lines y&toLines
                !a&newnode and debugger
                # make empty lin to use next time around
                lin = 3c&iz(A&sph,'line')
                me&Ploy_i_lin,nod,lin
            }
        }
        # more nodes: nod/*[0] first, then ^^/[nod+1]
        me.Ploy_nod_next = &acgt{
            $E = A&nod.E
            $N
            # as long as we want to go into nod**, see l%moren
            $inward = !A&nod.hasmoren
            # i nod/* o E/*
            if (inward) {
                if (A&nod.i_node == 0) {
                    # is an RE, use first_truest rendition of eg RE/-hat
                    $truest = ahsk(Ey&ers,'y','first_truest','E')
                    # and there is only ever one RE/E (outside/inside &Piing)
                    truest and N = [truest]
                }
                # < generalise o E/*
                N ||= me&ioty,E .filter(e => ey&R)
                # creates all nod/nod:$e for later
                #  and sph/node width first: is not nested: 1, 2, 1/1...
                #   !~~ &ind: 1, 1/1, 2...
                N = N.map(e => me&Ploy_i_nod,A&nod,e )
            }
            $next
            hak(N) and next = N[0]
            else {
                # climb out until a next in
                me&Ay,A&nod,'/^^',{},{} (&nda{
                    # be a node
                    # n/[a+1]: another one after
                    n.in[a.i_in] != a and debugger
                    next = n.in[a.i_in*1+1]
                    if (!next) {
                        if (!n.i_node) {
                            # returns to the root at the end
                            ac(A.3,'seemsdone',n)
                            a&seemsdone = 1
                            d.not = 1
                        }
                        # keep going up
                        return
                    }
                    # we have a node
                    d.not = 1
                })
            }
            return next
        }
    
    //  lin
        me.Ploy_i_lin = &acgt,nod,lin{
            $sph = nod.sph
            sph.line[lin.i_line] != lin and debugger
            # nod/$mine is a subset of sph/$line
            3c&iz(nod,'mine',lin)
            # join: one nod to many lin
            lin.nod = nod
        }
        # line may start with spaces, to imagine into exp
        me.Ploy_indent_sympathy = &acgt{
            # leading bits, until [^ ] is found
            $bit0 = A&bit.i_bit == 0
            bit0 and A&lin.indent_sympathy = 1
            !A&lin.indent_sympathy and return
            
            # < until multi line D, but only when:
            #    flip indent_sympathy back on for lin-1 that BQ ?
            #     ie choose your own next indent for < < ' '
            $lin0 = A&lin.i_mine == 0
            !lin0 and debugger
            
            # usu make Cindents (two spaces each, Linesing C/*) outside of D
            #  sometimes eg (-- )(==    )(-- ) # when unindenting Cindent:2<-3
            !A&bit.str.startsWith(' ') and return delete A&lin.indent_sympathy
            # count ^( )+
            $level = hak(ksaf(A&bit.str,{bow:s => s != ' ',may:1}))
            $Cindent = Math.floor(level/2)
            # < never odd? or see Lines / BQ
            if (level != Cindent*2) {
                # < check these coagulate even
                ac(A.3,'oddindentlevel',A&bit)
            }
            
            # we sometimes (++  )(==      yada)
            $entirely = hak(A&bit.str) == level
            if (entirely) {
                # (++  ) should keep going
                # maybe even through (++  )(==      )(++yada)
                #!bit0 and debugger
            }
            else {
                # ends at [^ ]
                delete A&lin.indent_sympathy
            }
            if (A&bit.i_bit > 0) {
                # more bits of indent coagulate
                A&nod.indlev += level
            }
            
            # the first line of D has the real indent
            if (A&nod.indlev) {
                # < sanity (was simple before more indent)
                #    - lin>0 should have at least ' ' more than lin0
                level = A&nod.indlev
            }
            elsif (A&lin.i_mine == 0) {
                # nod/lin 0 == first line of D
                A&nod.indlev and debugger
                A&nod.indlev = level
                # < until treating haphazard text as input
                #    eg see codes / spec / pre-tangent
                #     which wouldnt be a Cindent per se
                #  < or BQ-embedded nodes...
                # this is normal when entirely indent, eg (++  )
                # once non-space starts we should be at a predictable Cindent
                if (Cindent != A&nod.d-1 && !entirely) {
                    uniq(3c&o(A&joi,'with',nod => nod.E.t)) == 1 and debugger
                    else {
                        A&joi.sc.disparate_nodd_Cintent = 1
                    }
                }
            }
            
            $relevel = level
            # may be spread over many bits of indent
            #  eg (++  )(==      )(++  yada)
            #  we only want to trim  ^^ this one bit
            3c&io(A&lin,'bit','*') .map(&bit,{
                bit != A&bit and relevel -= bit.trimstart||0
            })
            #relevel != level and debugger
            #relevel < 2 and debugger
            
            # < check what comes off is ' '+
            A&bit.trimstart = relevel
        }
        # note if|how we change exp to make things fit
        me.Ploy_mung = &acgt,bit,t,v{
            ahk(bit,'mung',t,v||1)
        }
        # nod/whole <-> nod/mine/bit
        me.Ploy_match = &acgt{
            $nod = A&nod
            $lin = A&lin
            $bit = A&bit
            # cursor whole to match
            $at = nod.matchtil || 0
            $str = bit.str
            # str never goes beyond \n
            str.slice(-1)[0] == "\n" and a&newline = true
            # whole does
            $whole = nod.whole
            !hak(whole) and debugger
          // lying
            # ignore str indent, coming from D** travel
            bit.trimstart and str = str.slice(bit.trimstart)
            # < dropping \n from bit, via this mechanism
            #   rather than adding one to exp if non-match now
            #    tho it does get us the \n between many nod/lin
            #     that would be visible as exp[-1]=="\n"
            bit.trimend and str = str.slice(0,hak(str)-bit.trimend)
            # < more munging the expression
            #    eg expect sequence number adjustment
            #    eg between different compressions
            #     one might deL->???->enL

            $len = str.length
            $til = at+len
            $exp = whole.slice(at,til)


            if (exp != str && a&newline) {
                # no \n in y&toLines
                me&Ploy_mung,bit,'+␤'
                exp += "\n"
                til -= 1
                $mungnl = 1
            }
                # < sort out indent funcs
                #    we seem to have .d starting at 1->'', etc
                #    Lines wants to indent by ' ' sometimes
                #   this one does it to exp, multiliney
                #   not too straight forward when exp may end in \n
                #    it should follow input strings form?
                #     and separate casting blah->blah\n
                #indents((nod.d-1)*2,exp,
                #    !ahsk(bit,'mung','+␤') && 'notailn'
                #)
            # should yield the whole line?
            mungnl && til != whole.length and $shoulded = 1
            
          // so
            ex(A.sc,{str,exp})
            if (exp != str) {
                return me&Ploy_fail,'eq'
            }
            # always with the above fail?
            shoulded and debugger
            
            # may match nothing
            nod.matchtil == til and a&tilstill = 1
            #  that wasn't just (==\n)
            a&tilstill && !(mungnl && exp == "\n") and a&seeknod = 1
            
            nod.matchtil = til
            til == whole.length and a&newnode = true
        }
    
    //  lit, col, jin/lin/col, joi /lit, /jin/jol/gol
        # joi/lit .l, /bit
        #  l-ordered bits of either sph
        me.Ploy_joi_lit = &acgt{
            $bit = A&bit
            $l = bit.l
            $la = 3c&io(3s&joi,'lit',-1)
            $lit = la && la.l == l ? la
                : 3c&iz(3s&joi,'lit')
            lit.l = l;
            # lets not inform of the rewire..? its just i_sphere
            (lit.bit ||= []).push(bit)
        }
        
        # i lin/col/microcol o lin/bit
        # lazily nod/lin/col, per nod via joined
        # to see col=$nk=t|y|c|sc, assuming Lines encoding
        me.Ploy_lin_col = &acgt,lin,joi{
            lin.i_mine != 0 and return me&Ploy_fail,"multiline",lin
            lin.i_mine == null and debugger
            $nod = lin.nod
            if (lin.col) {
                # may rebuild lin/col with more bits upon joi%stretch
                nod.joi == joi and debugger
                !jois&stretch and debugger
                delete lin.col
            }
            $indent_sympathy = 1
            3c&o(lin,'bit',&bit,{
                $str = bit.str
                # tidy str
                # < what is "string".trimEnd() ?
                str.slice(-1)[0] == "\n" and str = str.slice(0,hak(str)-1)
                
                # have columns
                # < other than Lines + tycsc
                # < other than lin0 is nk,gk,quotes,star**
                # names of the next col
                $cols = ['t','y','c','sc']
                # last lin/col
                $col
                $i = 20
                while (hak(cols)) {
                    i-- < 0 and throw "col loops"
                    $had = lin.col && lin.col[cols[0]]
                    had and col = had; cols.shift()
                    else break
                }
                
                # fill up col+ from bit.str
                $N = str.split("\t")
                # indent column ~~ lin.indent_sympathy
                if (indent_sympathy) {
                    if (N[0].startsWith('  ')) {
                        # make an initial non-\t-delimited column for indent
                        $til = N[0].split('').findIndex(v => v != ' ')
                        til < 0 and til = hak(N[0])
                        $spaces = N[0].slice(0,til)
                        N[0] = N[0].slice(til)
                        # nothing left
                        !hak(N[0]) and N.shift()
                        # something left, no more indenting
                        else indent_sympathy = 0
                        
                        # may split indent, then other columns take it
                        lin.col && cint(haks(lin.col)) != 'indent' and debugger
                        # < cargoey
                        $nk = 'indent'
                        $incol = 3c&io(lin,'col',nk)
                        incol.nk = nk
                        $mc = 3c&iz(incol,'microcol')
                        mc.str = spaces
                        mc.bit = bit
                        # for nod/*lin/*col.changey
                        bit.l.t != 'same' and mc.changey = incol.changey = 1
                    }
                    else indent_sympathy = 0
                }
                each is N {
                    if (!col || i > 0) {
                        # new col
                        $nk = cols.shift()
                        !nk and debugger
                        col = 3c&io(lin,'col',nk)
                        col.nk = nk
                    }
                    # nothing at this point
                    !s.length and continue
                    
                    # since bit may break at any point in a column
                    $mc = 3c&iz(col,'microcol')
                    mc.str = s
                    mc.bit = bit
                    # > keeping in|out points of str in bit, etc
                    
                    # for nod/*lin/*col.changey
                    bit.l.t != 'same' and mc.changey = col.changey = 1
                }
            })
            # Lines always t,y,c
            # < reintroduce this... tripped when jois&seeknod
            #hak(lin.col) < 3 and me&Ploy_fail,"endon-col:c|sc",lin.col
        }
        
        # i joi/#lin:jin/#col:jol/#with:jodol o nod/lin/col
        # joi gathers C.*.* change in stereo (or mono)
        #  only changey
        me.Ploy_knowing_nkgk = {sc:{ark:'%',gk_degree:{'♲':{degree:7,if1_degree:8}}}}
        me.Ploy_joi_jin = &acgt,joi{
            $lin_quant
            me&Ploy_joi_nods,joi .map(&nod,{
                $sph = nod.sph
                # sanity: same number of /lin
                lin_quant != null && lin_quant != hak(nod.lin) and debugger
                lin_quant = hak(nod.lin)
                # assumes each node's nod/lin align
                # < see resolve $n
                3c&io(nod,'mine','*') .map(&lin,{
                    # /#lin:jin
                    $jin = 3c&io(joi,'jin',lin.i_mine)
                    3c&io(lin,'col','*') .map(&col,{
                        # /#col:jol
                        fatal.isst(col.nk)
                        $jol = 3c&io(jin,'jol',col.nk)
                        
                        #  /#with:jodol, now per node
                        #   not quite #with: nod may be from joi/with|loosely
                        $jodol = 3c&iz(jol,'jodol')
                        jodol.nod and debugger
                        jodol.nod = nod
                        
                        # col from either node -> shared line, column
                        sex(jin,col,'changey')
                        sex(jol,col,'nk,changey')
                        #  and jodol, is per node
                        sex(jodol,col,'nk,microcol,changey')
                    })
                })
                
            })
            3c&io(joi,'jin','*') .map(&jin,{
                # lin for both nodes
                3c&io(jin,'jol','*') .map(&jol,{
                    # lin/col for both nodes
                    # the column should have an $nk ark, eg c
                    $nk = jol.nk
                    fatal.isst(nk)
                    if (!jol.changey) {
                        delete jin.jol[nk]
                        return
                    }
                    $jodols = 3c&o(jol,'jodol')
                    !hak(jodols) and debugger
                    
                    # whole of either sph columns
                    # < someday, decompress each via &Lines
                    #    would make whole from nod/lin/bit
                    jodols .map(&jodol,{
                        $nod = jodol.nod
                        $mcs = 3c&o(jodol,'microcol')
                        jodol.whole = armap(mc => mc.str, mcs).join('')
                        if (hak(mcs) > 1 && nk == 't') {
                            # could be for either or both nod
                            # < not to include indent in the t column
                            me&joisc,'tsplit',1
                        }
                    })
                    
                    # < the rest here is pulled from &Ploy_drawjoin_jin,
                    #   which is still too MassiveViewController
                    #    compute and present should be split

                    # changes.$nk, or ."$nk$gk" if sc
                    # degree of change, lower is more serious
                    $degree = 1
                    $knowing = ahsk(me.Ploy_knowing_nkgk,nk)
                    if (knowing) {
                        # parse the sc column
                        # gk=sc aka %, so we can concat the usual notation of eg %♲
                        $ark = knowing.ark || nk
                        degree = 5
                        # i $nk:jol/$gk:gol/#jodol:nogol.v
                        # collect nk/gk/v
                        jodols .map(&jodol,{
                            $s = jodol.whole
                            # < use a sub of &Lines
                            $h = jodol.decoded = s.startsWith('{') ? dej(s) : peel(s)
                            each gk,v h {
                                # col/gol are nk/gk
                                $gol = 3c&io(jol,'gol',gk)
                                fatas(gol,'gk',gk)
                                jodol.i_jodol == null and debugger
                                # each nod's v
                                $nogol = 3c&io(gol,'nogol',jodol.i_jodol)
                                fatas(nogol,'jodol',jodol)
                                nogol.v = v
                            }
                            return h
                        })
                        # difference nk/gk/v (there is a v per jodol)
                        3c&o(jol,'gol',&gol,{
                            $gk = gol.gk
                            $nogols = 3c&o(gol,'nogol')
                            $vs = armap(_=>_.v, nogols)
                            if (vs[0] != vs[1] || hak(vs) == 1) {
                                # < diff refs, etc etc. osc|sustain-ing what-is
                                # < further. seq++ numbers? pointer much changing?
                                
                                # how serious is the change
                                $deg = degree
                                $how = ahsk(knowing,'gk_degree',gk)
                                if (how) {
                                    # so far %♲ is low severity (7), %♲:1 even lower (8)
                                    how.degree and deg = how.degree
                                    if (how.if1_degree && vs[0] == 1) {
                                        deg = how.if1_degree
                                    } 
                                }
                                # joi.changes.$nk$gk=degree
                                ahk(joi, 'changes',ark+gk, deg)
                                # joi/jin/jol/gol.degree
                                gol.degree = deg
                                # the various *.changey=1 are deduced from l, not treeaged thusly
                                # most serious percolates to jol.degree
                                #  ie, lots of 8 is still just 8
                                #  usu (5,8) is 5
                                if (!jol.degree || jol.degree > gol.degree) {
                                    jol.degree = gol.degree
                                }
                            }
                        })
                    }
                    else {
                        jol.degree = degree
                        ahk(joi,'changes',nk,degree)
                    }
                })
            })
        }
        
        # classify C.*.* change
        # < to somewhere, for regionating
        # < u Ploy
        me.Ploy_drawjoin_jin = &acgt,joi{
            # each jodol/microbit.bit.l is in here
            $ls = 3c&io(joi,'lit','*') .map(lit => lit.l)
            3c&io(joi,'jin','*') .map(&jin,{
                # lin for both nodes
                3c&io(jin,'jol','*') .map(&jol,{
                    # changey lin/col for both nodes
                    # various *.changey=1 are deduced from l
                    !jol.changey and debugger
                    # joi.changes.$nk$gk=degree
                    !joi.changes and debugger
                    # most serious percolates to jol.degree (may also be gol.degree)
                    !jol.degree and debugger
                    $nk = jol.nk
                    fatal.isst(nk)
                    # gk=sc aka %, so we can concat the usual notation of eg %♲
                    $ark = ahsk(me.Ploy_knowing_nkgk,nk,'ark') || nk
                    
                    me&boxcap,ark,4 (&ml{
                        me&walls,m,'b:2.2h4'
                        $maq = me&tsc,'match-quality',jol.degree,'6g'
                        maqs&dis = 2
                        3c&o(jol,'gol',&gol,{
                            !gol.degree and return
                            $gk = gol.gk
                            me&boxcap,"gk:"+gk,2 (&ml{
                                me&walls,m,'b:2.2h4'
                                mc&maybeempty = 1
                                lc&s = gk
                            })
                        })
                    })
                })
            })
        }
    
    //  joi
        =join
          sequence of nod on either side (nod(-nod)?)
           per either of them having a&newnode
          nod.joi given by &Ploy_join / 3c&ijoin
          draw a join table
            < de-indent every so often
              describing the branch stepped into
          
        =cut
       // join f
        # 3s&joi++, with N=[nod +], initially or by &Ploy_joined
        me.Ploy_i_joi = &acgttN{
            $joi = 3c&joi = 3c&iz(3c&X,'join')
            # reason eg given|leaving
            joi.given = t
            # factoid collection, via &joisc
            joi.sc = {}
            # joi/with=nod, nod.joi
            N.map(&nod,{
                # should be a node
                nod.i_node == null and debugger
                # not yet joined
                nod.i_with != null and debugger
                3c&iz(joi,'with',nod)
                nod.joi and debugger
                nod.joi = joi
            })
            # become the latest join
            3s&joi = joi
            return joi
        }
        # joi%$k = $v adds a factoid
        #  args k,v or joi,k,v
        me.joisc = &acgt{
            $args = [...arguments].slice(4)
            $joi = ish(args[0]) ? args.shift() : A&joi
            $k = args.shift()
            $v = args.shift()
            $was = joi.sc[k]
            if (was && was != v) {
                # now the oddity of multiple %tilmoves
                #  ie stretching match across >2 other nods
                # < create a compression pattern of Ploy/**-Fez types...
                #    ambavail by Stories/**
                #    novelty arrives on the scene of eg Fus@7...
                ahk(joi,['sc'],'N'+k,was)
            }
            joi.sc[k] = v
        }
        
        # after nod arrives
        me.Ploy_joi_arrive = &acgtN{
            A&joi = A&nod.joi
        }
        
       // join++
        me.Ploy_joined = &acgt{
            A = fi&At,'join:'+3s&joi.i_join
            # we are the joined joi
            $joi = A&joi = A&old = 3s&joi
            # may defer one nod due to not matching any bits, eg joi@49
            me&Ploy_joined_unbitnod
            # passes A:l+, are per sph
            $N = delete 3s&joined
            # all done!
            # < or still a stretch?
            a&Fin = !N.some(V => !Vs&seemsdone)
            if (!a&Fin) {
                # make the A&neu joi
                #  mostly so we can notice it going mono
                $nexts = grep(armap(&V{
                    !(Vs&next && Vs&newline && Vs&newnode) and debugger
                    return Vs&next
                },N))
                
                if (joi.unbitnod) {
                    # carrying an unmatching nod through %mono of the other sphere
                    hak(nexts) > 1 and debugger
                    nexts.push(joi.unbitnod)
                }

                A&neu = me&Ploy_i_joi,'next',nexts
                # joi linked like nod
                A&old.next = A&neu
                A&neu.prev = A&old
            }
            
            
            # is there an oddness to joi/with <-> N[A&nod]
            #  extra nod are put in: joi/loosely
            me&Ploy_joi_stretch_check,joi,N
            # note joi%mono etc, now that unbitnod may have shrunk joi/with
            me&Ploy_joi_mono_check
            
            # when joined (perhaps with /loosely)
            if (hak(joi.lit) > 1) {
                # multiple l, compute columns
                
                # inflate nod/lin/col
                me&Ploy_joi_nods,joi .map(&nod,{
                    3c&o(nod,'mine',&lin,{
                        me&Ploy_lin_col,lin,joi
                    })
                })
                # and merge to joi/jin/jol
                me&Ploy_joi_jin,joi
            }
            me&Ploy_joi_sameness_check,joi
            
            # joi row
            3c&accreting_modulat and me&Ploy_drawjoin
        }
        # may defer one nod due to not matching any bits
        me.Ploy_joined_unbitnod = &acgt{
            $joi = A&joi
            $unbitnods = grep(nod => !hak(3c&o(nod,'mine/bit')),
                3c&o(joi,'with'))
            $nod = theone(unbitnods)
            !nod and return
            joi.unbitnod and debugger
            joi.unbitnod = nod
            # remove joi association
            delete joi.with[nod.i_with]
            delete nod.i_with
            delete nod.joi
            # then joins nexts
        }
        
        # iterate lit(/bit,nod)
        me.Ploy_drawjoin = &acgt{
            $joi = A&joi
            # first and usually only type of row per joi
            #  eg A&modjoi, maybe A&mododd, etc
            $m = me&Ploy_rower
            $l = my&label
            ls&ws = 1
            # allowing the odd message inserted on the next|same line
            A&odd = &ty{
                $m = me&Ploy_rower,'odd'
                A&draw(t,y,m)
            }
            A&draw = &tym{
                me&Ploy_rower_i,m,t (&ml{
                    y (m,l)
                })
            }
          // this row/with|lit|jin
            me&Ploy_rower_i,m,'with' (&ml{
                $la
                $nods = me&Ploy_joi_nods,joi
                # are their nod.d the same...
                $fact = hak(nods) == 1 && "1"
                if (!fact) {
                    $ddiff = nods[0].d - nods[1].d
                    ddiff and fact = ddiff > 0 ? "+"+ddiff : ddiff
                }
                fact and me&tsc,"nod.d-fact",fact,'g' .sc.ab = 1
                
                3c&io(joi,'with','*') .map(&nod,{
                    # show only one same title
                    # < style about that
                    la && nod.E.t == la.E.t and return
                    me&drawnod,nod
                    la = nod
                })
            })
            
            $ldraw = {}
            me&Ploy_rower_i,m,'lit' (&ml{
                # lit.l, /bit|col
                3c&io(joi,'lit','*') .map(&lit,i{
                    $l = lit.l
                    $lm = ldraw[ly&seqi] = me&drawdiffbit,i,l
                    if (ls&moren) {
                        $ll = me&tsc,"moren-foldmarker",'↦'
                        lls&fs = 20
                        me&tc,"moren-size",'x'+hak(ls&moren),'6y'
                    }
                    else
                    l.t == 'same' and lms&bri = 0.6; lmy&label.c.not = 1
                })
            })
            
            me&Ploy_rower_i,m,'jin' (&ml{
                joi.jin and me&Ploy_drawjoin_jin,joi
            })
          // etc
            # any odd rows after that:
            me&Ploy_drawjoin_factoids
            me&Ploy_drawjoin_fixes
            me&Ploy_drawjoin_regions
            
            if (3c&accreting_modulat) {
                # drop other modulats we just restructured
                # < get them to draw only if they are needed, on+before &Ploy_fail
                $oktypes = peel('sph<-l,l,nod')
                grop(n => oktypes[ns&type], T.ab.sc.z)
            }
        }
      
       // joi%$factoid
        =joi
         A&joi.sc.$oddness = [uniq objects...]
          in either A:l (nod match) or A:joined (joi leave)
           they both have A&joi
          during
           &Ploy_sph (nod matches $l)
            %behinod=$nod - nod.joi != 3s&joi
            %tilmoves=$nod - as above + empty match
             < ^x2 dont seem to happen
            %tilstill=$nod - empty match
            %seeknod=$nod - as above + it wasnt munged \n$
            
           &Ploy_joined (nod+ leaving -> joi leaving)
            %stretchy=$nod - doesnt end on joi (no ...\n$)
            %stretching=$nod - began before joi (after the above)
             < happens too much
            %stretch=$nod - finally ended
             eg joi@86 is ++'    ' after joi@82 =='    ' started E:1 2
             < are coupled to a joi.prev+%strechy=$nod
            
            %enmono, %mono, %demono - while joining only 1 nod
             
            %sameness=$ratio - low or high sameness
              ignores ^\s+(++    ) and the near-sameness of only %♲
               # code: any illegal syntax eg /(+/ is potential otherlang
             eg joi@56 should have very low sameness, just (==\n)
              < joi@48 is very similar, should be all there.
                 joi@56 has low sameness, different nod.d
                 joi@55 very high sameness, different nod.d
                see fix / stretch
             eg joi@71 has low sameness
              < (==s) microbit in different column: gone t, new y
            %tsplit when col:t has a bit-boundary (>1 microbits)
            
            < %noddoff - different nod.d
            < %numeric - number++
         
         A&joi.changes.$nk$gk? = 1
          seeing jodol** change
          not suggesting the diff is going ugly
          < but if it could be rearranged to minimise these...
        =cut
        # if any factoids, put on the odd row
        me.Ploy_drawjoin_factoids = &acgt{
            $joi = A&joi
            # more angles
            
            if (hak(joi.sc) == 0) {
                # no factoids
                if (!joi.jin) {
                    # no difference
                    $m = joi.modjoi
                    ms&bri = 0.6
                }
                return
            }
            # factoids usu follow some difference now tabulated in /jin...
            if (!joi.jin) {
                $about = haks(joi.sc)
                grop(['enmono','mono','demono'],about)
                # < joi.debug, similar to but not a factoid...
                hak(about) and 1
                else return
            }
            
            $withnods = 0
            A&odd('with',&ml{
                me&tt,'joi' () and me&fu,"joi@"+joi.i_join,joi
                me&tt,'nod' () and withnods = 1
            })
            withnods and me&Ploy_drawjoin_nods
            
            A&odd('lit',&ml{
                me&boxcap,'joi-factoids',2 (&ml{
                    lc&not = 1
                    $lak = haks(joi.sc).pop()
                    each kN joi.sc {
                        me&boxcap,"fact:"+k,'6y' (&ml{
                            lc&s = k
                            mc&maybeempty = 1
                            $v = N
                            #each iv N {
                                # sees the forward-er 3s&joi on a nod.joi
                                k == 'tilmoves' and me&Ploy_tid,v
                                k.startsWith('stretch') and me&Ploy_tid,v,'joi'
                                k == 'sameness' and me&tsc,"ratio",v==1&&1||cvs(v)||'Nil','6b'
                                else
                                !ish(v) and me&tsc,"value",dis(v),'6b'
                            #}
                        })
                    }
                })
            })
            
        }
        # nods = joi/with+loosely
        me.Ploy_joi_nods = &acgt,joi{
            return [... 3c&o(joi,'with'),
                # possible non-belonging nods on joi%stretch
                
                ... 3c&o(joi,'loosely')]
        }
        
        # odd row may expand per nod
        # < %stretch(ing) add the nod to joi/with_stretch=nod?
        me.Ploy_drawjoin_nods = &acgt{
            $joi = A&joi
            $nods = me&Ploy_joi_nods,joi
            # < mapkv(): y returns [k,v]
            $tw = {}
            nods.map(nod => tw[nod.sph.sphere] = nod )
            each sphere,nod tw {
                $m = me&Ploy_rower,sphere
                ms&hue = sphere == 'new' ? 60 : 130
                A&draw('with',&ml{
                    me&drawnod,nod
                },m)
                A&draw('lit',&ml{
                    $ls = 3c&o(joi,'lit.l')
                    $inters = me&drawintersplice,"l-belonging"
                    3c&o(nod,'mine/bit',&bit,c{
                        $l = bit.l
                        # if this l belongs before|after this joi
                        $belongs = ls.includes(l)
                        !belongs && !(jois&stretchy || jois&stretch) and debugger
                        inters(belongs)
                        $lm = me&drawdiffbit,c.i,l
                        !belongs and lms&opa = 0.6
                    })
                },m)
                A&draw('jin',&ml{
                    me&tt,'nood' () and me&fu,sphere+":nod@"+joi.i_join,nod
                    !3c&o(joi,'with') .includes(nod) and me&tc,"loose",'6y'
                },m)
            }
        }
        
        
        
        # joi/with supplemented by joi/loosely
        me.Ploy_joi_stretch_check = &acgt,joi,N{
            # beginning to go %stretchy
            # < continuing the %stretching, may many
            #   ie nod has bits here yet begins|ends on other joi
            3c&o(joi,'lit.l',&lc{
                if (l.t != 'same') {
                    # text they dont share
                    if (c.last) {
                        # a nod doesnt have this \n$
                        3c&o(joi,'with',&nod,{
                            $bit = 3c&o(nod,'mine/bit') .slice(-1)[0]
                            bit.l != l and me&joisc,'stretchy',nod
                        })
                    }
                }
            })
            # a %stretch is finally joined
            # notice when N...nod.joi are different
            # < always combined with mono joins?
            #   may have blips of stereo amongst
            #   we want to sweep below for clarity
            #    ie turn l:== into l:++ (like its neighbours)
            #    adding l:-- after, on a new joi for that one nod?
            # < any bit progress once decohered is what to see
            #    a nod matching that is not on the current joi
            N.map(&V{
                $nj = Vc&nod.joi
                if (nj != joi) {
                    # a node keeps matching after a while
                    # < boxlink to itsthe last box:joi
                    $ji = nj.i_join
                    me&joisc,'stretch',Vc&nod
                    # let joi know of these other nodes
                    3c&iz(joi,'loosely',Vc&nod)
                }
            })
        }
        # is|goes mono!
        me.Ploy_joi_mono_check = &acgt{
            $joi = A&joi
            if (hak(joi.with) == 1) {
                $nod = havs(joi.with)[0]
                # this sphere is the only one for a while
                me&joisc,'mono',nod.sph
            }
            
            # A&neu is too new to count /with yet, see unbitnod
            #  joi (A&old) and joi.prev have accurate /with now
            $prev = joi.prev
            !prev and return
            $withs = spant(hak(prev.with),hak(joi.with))
            if (withs == '2 1') {
                # starts non-joins - whole lines for only one sph
                #  the other, eg gone, will not consume any l:new
                me&joisc,prev,'enmono',1
            }
            if (withs == '1 1') {
                # passes along...
                !prevs&mono and debugger
            }
            if (withs == '1 2') {
                # resumes matching after non-joins (single joi/with)
                me&joisc,prev,'demono',1
            }
        }
        # after jin makes joi.changes
        me.Ploy_joi_sameness_check = &acgt,joi{
            $lits = 3c&o(joi,'lit')
            $dont = cint(haks(joi.changes)) == '%♲'
            hak(lits) == 1 || dont and return
            # overall amount shared|not on this joi
            $an = {}
            lits.map(&lit,{
                $l = lit.l
                $quantity = hak(ls&string)
                # indent doesnt count, eg joi@69 (==      )
                #  no other uses of trimstart?
                $trims = grep(3c&o(lit,'bit',bit => bit.trimstart))
                if (hak(trims)) {
                    # lit/bit join 1-2 bit.up.nod, by the same l
                    hak(trims) > 2 and debugger
                    hak(uniq(trims)) > 1 and debugger
                    quantity -= trims[0]
                }

                $k = l.t == 'same' ? 'same' : 'diff'
                an.cosize ||= {}
                an.cosize[k] ||= 0
                # < leaving out ^ oddly not fatal to v (Try@3 / js oddities)
                an.cosize[k] += quantity
            })
            
            # < &ind + ex()
            $sa = map(v => dec(v,2), &c{
                hak(c) > 2 and debugger
                # same/0 == 1
                !c.diff and return 1
                $same = c.same || 0
                return same / (same + c.diff)
            },an)
            
            # hardly any or lots of similarity
            if (sa.cosize <= 0.22 || sa.cosize >= 0.78) {
                me&joisc,'sameness',sa.cosize
            }
            # < sameness=1 may coincide with joi%indent
            #    where trimstart ignored difference
        }
        
        # for a nod matching
        me.Ploy_nod_check = &acgt{
            if (3s&joi != A&joi) {
                # previous other nod joined, we are left behind
                me&joisc,'behinod',A&nod
                if (!a&tilstill) {
                    # something matched after joi moves on
                    #  ie goes %mono, leaving nod.joi behind
                    #  write the later joi on the earlier nod.joi
                    me&joisc,'tilmoves',3s&joi
                }
            }
            
            
            
            
            
            if (a&seeknod) {
                # nothing excepting \n$
                # perhaps about to mono join
                #  ie only one 3s&joined (that was a&newnode)
                me&joisc,'seeknod',A&nod
            }
        }
       
       // fix joi%stretch
        =stretch
         possible untanglement of joi%stretchy
           see Fus@7
            
            joi@48:
              ｢ 18sc⇥-Hash⇥｣  ++｢⇥♲␤｣
               ++｢ 20...␤｣ # many
                   ++｢ 24src⇥-Num⇥"1812"｣  ｢␤｣
             want:
              ｢ 18sc⇥-Hash⇥｣ ++｢⇥♲｣ ｢␤｣
               ++｢ 20...␤｣ # many
                   ++｢ 24src⇥-Num⇥"1812"␤｣ 
             good starter?
               
            
            joi@71:
               ++｢ 2｣  ｢ 6｣  ++｢ 2of⇥-Ha｣  ｢s｣  ++｢h⇥␤｣
                # gone|new E:sc|of
               ++｢ 12...␤｣ # many
                  ++｢ 22sr｣  ｢c⇥-Hash⇥␤｣
                  # finishing E:sc loosely
                  #  high sameness but much different Cindent
                  #  also nk:t microbit>1 is undesirable
                  ｢ 4｣  ++｢ 201812⇥-anx⇥⇥~␤｣
                  # gone|new E:1 2|1812
                  #  no sameness, much different Cindent
                    ++｢ 26z⇥-Array⇥␤｣ # many
               ++｢ 6sc⇥-Hash⇥⇥♲␤｣
                # correct E:sc location
                #  findable only via Cindent + starts same
             ++｢ 4｣  ｢1 2⇥-anA⇥"A more"⇥~｣  ++｢,♲:^3:7/having 4.sc.todo//-hat/1 2｣  ｢␤｣
               # new E:1 2
               # @86, %stretch from @71 E:1 2
             want:
               ++｢ 8of⇥-Hash⇥␤｣
                ++｢ 12...␤｣ # many
              ｢ 6sc⇥-Hash⇥⇥♲␤｣
              ｢ 41 2⇥-anA⇥"A more"⇥~｣ ++｢,♲:^3:7/having 4.sc.todo//-hat/1 2｣ ｢␤｣
             bit more difficult...
           
            < joi%tsplit should discourage E:sc on joi@81
               just having different nod.d works for now...
         
         < release as indentsual-diff-match-patch
           perhaps it is easier to cost:
            similarity earlier > difference later (per line)
            closer indent
            
        =cut
        # give up on really badly joined nod**
        #  separating into entire ++ and --
        me.Ploy_joins_unfixable = &acgt{
           // generate joi.crap.$reason
            $jois = 3c&o(3c&X,'join')
            each i,joi jois {
                $crap = {}
                # two|near nod.d
                $nods = me&Ploy_joi_nods,joi
                if (hak(nods) == 2) {
                    $nod1 = nods.shift()
                    $nod2 = nods.shift()
                    $off = nod1.d - nod2.d
                    off < 0 and off *= 1
                    off > 3 and crap.d = 1
                }
                else {
                    crap.mono = 1
                }
                
                jois&sameness != null && jois&sameness < 0.3 and crap.diff = 1
                
                jois&stretch || jois&stretchy and crap.stretch = 1
                
                hak(crap) and jois&crap = cint(haks(crap)); joi.crap = crap
            }
            
           // find nod** containing vastly crap joi
            $joi = jois[0]
            $nods = me&Ploy_joi_nods,joi
            # how to get to nod/*nod
            $may_iterate = nod => havs(nod.in) || []
            $N = []
            $yy = &nod,d{
                # upwardly
                # here
                $joi = nod.joi
                $am = hak(joi.crap)
                !am and d.good = 1
                am > 1 and d.crap = 1
                d.total = 1
                map(k => d[k] && ahk(d,'bey',0,k,1),['good','crap','total'])
                # beyond
                each in d.z {
                    each dist,k,sum n.bey {
                        $already = ahsk(d,'bey',dist+1,k) || 0
                        ahk(d,'bey',dist+1,k, already+sum)
                    }}
                }
                # come together (dist is unused)
                d.sums = {}
                each dist,k,sum d.bey {
                    d.sums[k] ||= 0
                    d.sums[k] += sum
                }}
                N.push(d)
            }
            nods.map(nod => me&inlace,nod,{may_iterate,yy} )
            $any = 0
            N.map(&d{
                $nod = d.s
                $joi = nod.joi
                $p = d.up
                !p and return
                # on a good join with many inside
                d.crap || d.sums.total < 16 and return
                hak(d.sums) < 3 and return
                $marginal = d.sums.total - d.sums.good
                
                jois&crapsia = dec(marginal / d.sums.total,2)
                    +' '+ dec(d.sums.crap / d.sums.total,2)
                    +' x'+ d.sums.total
                    
                dec(d.sums.crap / d.sums.total,2) < 0.3 and return
                # vastly crap!
                jois&crapcap = d
                any = 1
            })
            !any and return
           
           // group joi
            # joi%crapcap spreads down either nod**
            $caps = []
            $y = &nod,d{
                $joi = nod.joi
                
                $cap = d.crapcap
                cap ||= joi.transcap
                if (cap) {
                    # to transmit between sph without finding joi%crapcap
                    d.crapcap = joi.transcap = cap
                    cap.joins ||= []
                    cap.joins[joi.i_join] = joi
                }
                elsif (jois&crapcap) {
                    # this is our d from the last &inlace, will be inherited
                    d.crapcap = jois&crapcap
                    caps.push(d.crapcap)
                }
            }
            nods.map(nod => me&inlace,nod,{may_iterate,y} )
            # and once more to transmit between sph
            #  without finding joi%crapcap on the way in
            #  so eg '..wantsback' joi@69:
            #  flows in through E:dige, then to its E:0,
            #   then on to joi@70 E:seconds, otherwise not joi%capped
            me&inlace,nods[0],{may_iterate,y}
            
           // sanity
            # we should find joi%crapcap twice (thrice?)
            #  since it was a good join
            caps = uniq(caps)
            !hak(caps) and debugger
            hak(caps) > 1 and debugger
            $cap_per_joi = {}
            each id caps {
                # this d is from the 'find nod**' &inlace
                $nod = d.s
                $joi = nod.joi
                jois&capped = 1
                
                # sanity: cap occurs in one sphere
                cap_per_joi[joi.i_join] and debugger
                cap_per_joi[joi.i_join] = 1
                # sanity: cap is a good joi
                $nods = me&Ploy_joi_nods,joi
                hak(nods) != 2 and debugger
                $la = null
                each i,ojo d.joins {
                    # sanity: no gaps
                    if (la && d.joins[i-1] != ojo.prev) {
                        if (!d.joins[i-1]) {
                            $prevooj = d.joins[i-2]
                            # gaps never > 1 joi
                            !prevooj and debugger
                            $ooj = ojo.prev
                            $no = me&Ploy_joi_nods,ooj [0]
                            # if no ooj/with=nod, there is no nod.joi=ooj
                            #  aka joi%stuttered:
                            #   [(==...)(--...\n)] [(++...\n)]:ooj
                            if (!hak(ooj.with) && no.joi != ooj
                                && no.joi == d.joins[i-2]) {
                                oojs&surprisecap = 'missstuttered'
                            }
                            else {
                                !(no && no.joi == ooj) and ~>0 Ploy gappy: R.t
                                # if the missing joi:ooj/nod:no/^/joi:poj
                                $poj = no.up.joi
                                #  started before the joi
                                #   ie, ooj is a sibling of one we have,
                                #    descendant of something outside the joi%crapcap**
                                if (poj.i_join < joi.i_join) {
                                    oojs&surprisecap = 'siblingofbefore'
                                }
                                #   or is descendent of such
                                elsif (pojs&surprisecap) {
                                    debugger
                                    oojs&surprisecap = 'descendantofbefore'
                                }
                            }
                            if (oojs&surprisecap) {
                                # just add it in...
                                # < we should know where the other nod** was
                                #   for the duration of the joi>>joi selection...
                                d.joins[i-1] = ooj
                            }
                            else {
                                me&Ploy_fail,'Gappy',{joi:ooj}
                            }
                        }
                    }
                    la = ojo
                }
            }
            
           // simplify their l+
            each id caps {
                # this d is from the 'find nod**' &inlace
                $nod = d.s
                $joi = nod.joi
                jois&capped = 1
                
                each i,ojo d.joins {
                    # ignored by &Ploy_joins_fix
                    ojos&capped = joi
                }
                
                # redo Comp
                $sphere_ls = {new:[],gone:[]}
                each i,ojo d.joins {
                    ojo.reComp = []
                    $ls = 3c&o(ojo,'lit.l') .slice()
                    each il ls {
                        $ks = l.t == 'same' ? ['new','gone'] : [l.t]
                        each ik ks {
                            $nl = Cye([k,1,{},l.sc])
                            sphere_ls[k] ||= []
                            sphere_ls[k].push(nl)
                        }
                    }
                }
                
                $capl = 3c&o(joi,'lit.l') .map(Cye)
                # sneak this over to -Difmo, through joi+ replacing
                # < keeping tractogram through joi+ replacing,
                #   the fail:whole check, fixes, etc...
                capl[0].sc.crapcap = 1
                joi.reComp = map(Cye,[
                    ...capl,
                    ...sphere_ls.new,
                    ...sphere_ls.gone
                ])
                # merge sequences of same l.t
                me&Ploy_ls_tidy,joi.reComp
                #me&fu,"crapcap_redo:"+nod.E.t+'@'+nod.d,joi.reComp
            }
        }
        # < refactor
        me.Ploy_joins_fix = &acgt{
            # give up on really badly joined nod**
            me&Ploy_joins_unfixable
            
            $jois = 3c&o(3c&X,'join')
            # copy the original Comp, we edit l%string
            # < dont edit l%string, clone to joi.reComp
            $oComp = 3c&Comp.map(Cye)
            $joi
          // f
            $afix = &joi2,t,c{
                c = pex({t},c||{})
                # the origin of this fix, eg joi@71
                c.joi = joi
                # may c.add|rm=nod to add|remove from joi's lit's Comp/l
                ahk(joi2,['fix'],c)
            }
            $lin0whole = &nod,{
                return 3c&o(nod,'mine/bit',_=>_.str).join('')
            }
           // walk jois
            # step over some joi%mono to the end of a %stretch
            $yon_demono = &joi,{
                jois&tilmoves and return jois&tilmoves
                $i = joi.i_join*1
                $dem
                while (1) {
                    i += 1
                    $ojo = jois[i]
                    !ojo and break
                    !ojos&mono and debugger
                    ojo.final and ojos&demono ||= 1
                    ojos&demono and dem = ojo; break
                }
                !dem and debugger; joi.fix = ahk(joi,'fix','fail','nodem'); return
                $nod = dems&stretch
                if (!(nod && nod.joi == joi)) {
                    # stretching through multiple joi?
                    jois&many_tilmoves_demono_confused = 1
                    !nod.joi.sc.Ntilmoves and debugger
                }
                return dem
            }
            # search further with nod/lin0
            $yon_lin0match = &joi,dem{
                $nod = dems&stretch
                $whole = lin0whole(nod)
                dem = null
                $maybe
                $i = joi.i_join*1
                while (1) {
                    i += 1
                    $ojo = jois[i]
                    !ojo and break
                    # find one (%mono) of the other sph, same nod.d
                    !ojos&mono and continue
                    $nod2 = theone(3c&o(ojo,'with'))
                    # < study this
                    nod2.sph == nod.sph and return ojo
                    nod2.d != nod.d and continue
                    # and string match
                    $whole2 = lin0whole(nod2)
                    if (whole != whole2) {
                        # < approximate is okay if it is best
                        #   ie fully cost the nod.d, creating %tsplit, etc
                        maybe = {nod2,whole2}
                        $most2 = whole2.slice(0, dec(hak(whole2)*0.66,0) )
                        !whole.startsWith(most2) and continue
                    }
                    dem = ojo
                    break
                }
                # < do a looser string match
                !dem && maybe and debugger
                return dem
            }
          
          // gather fixes
            $fixed = a&fixed = []
            each i,joi jois {
                jois&crapcap and fixed.push(fixed); continue
                jois&capped and continue
                if (!hak(joi.with)) {
                    $ojo = jois[i-1]
                    ojo.fix and debugger
                    $nod = theone(3c&o(joi,'loosely'))
                    afix(ojo,'stutter',{add:nod})
                    afix(joi,'stuttered',{rm:nod})
                    jois&stuttered = 1
                }
                # most others are in this situation:
                !(jois&stretchy && jois&enmono) and continue
                # find eg joi@56, where joi@48 completes
                $dem = yon_demono(joi)
                !dem || dems&capped and continue
                $nod = dems&stretch
                
                if (jois&sameness != null && jois&sameness <= 0.2) {
                    # dis-join an earlier low-sameness
                    # at joi@71 -> @81 (many joi.lit @71)
                    # or joi@82 -> @86 (only indent @82)
                    #  both having != indent, low sameness
                    # joi@81 is not where to match it
                    $nod2 = theone(3c&o(dem,'with'))
                    if (!jois&tilmoves && nod2.d != nod.d) {
                        $noddoff = dem
                        # search further with nod/lin0
                        $dembet = yon_lin0match(joi,dem)
                        dembet and dem = dembet
                        !dem and debugger
                    }
                    if (0 && (nod.E.t == 'c' || ahsk(joi,'changes','t') && nod.prev.keepc)) {
                        # < GOING a hack.
                        $addto = nod.keepc = nod.prev.keepc || joi
                        # second one doesnt appear in drawfixes l?
                        $adding = nod.prev.keepc ? {sweepin:nod} : {add:nod}
                        afix(addto,'earlier',adding)
                        afix(dem,'lateier',{rm:nod})
                        fixed.push(dem)
                    }
                    else {
                        # < flattening o-mode &josc?
                        #   this seems to be the only joi%* that may many
                        # partial matches over many joi
                        
                        # only one joi.fix may happen before corrupting data
                        #  also might joi%N?tilmoves/*->rm(nod)
                        $doit = me&Ploy_plotfix,joi,dem,nod
                        !doit and continue
                        # lets do it
                        afix(joi,'early',{rm:nod})
                        doit(afix)
                        afix(dem,'later',{add:nod})
                        fixed.push(dem)
                    }
                    #noddoff and afix(noddoff,'notd',{rm:nod,cmp:nod2.d+'|'+nod.d})
                }
                else {
                    # dis-join a later low-sameness
                    # at joi@48
                    #  few joi.lit there, the later l has low sameness
                    #  ie it put off matching a mere "\n" for many lines
                    #   ending on a different nod.d (unconsidered)
                    if (dems&sameness != null && dems&sameness <= 0.1) {
                        # make it all ++, put the same bit back on joi@48
                        $gobit = 3c&o(dem,'lit') .slice(-1)[0]
                        # < remove \n$ from the ++, add an == with it
                        $doit = me&Ploy_plotfix,joi,dem,nod
                        !doit and continue
                        afix(joi,'allin',{add:nod})
                        doit(afix)
                        afix(dem,'notin',{rm:nod})
                        fixed.push(joi)
                    }
                    else {
                        afix(joi,'unsame',{fail:1})
                        debugger
                    }
                }
            }
          
          // apply fixes
            each i,joi jois {
                each if joi.fix {
                    $nod = f.sweepin || f.add || f.rm
                    !nod and continue
                    f.add && f.rm and debugger
                    $sphere = nod.sph.sphere
                    $osphere = sphere == 'new' ? 'gone' : 'new'
                    $ls = 3c&o(joi,'lit.l') .slice()
                    $ols = ls.slice()
                    $bitl = 3c&o(nod,'mine/bit.l')
                    if (f.add) {
                        # shattered bits to put together, eg joi@71->@85
                        $whole = bitl.map(l => ls&string).join('')
                        each il bitl {
                          // usu
                            # eg joi@86 matches after one new->same
                            ls.includes(l) and continue
                            # see if it starts like that
                            $ol = ls[0]
                            # initially, relying on ls.includes(l) for the rest
                            if (ols&string == ls&string) {
                                i > 0 and debugger
                                # new->same, eg also joi@86
                                $bol = Cye(['same',1])
                                bols&string = ls&string
                                ls[0] = bol
                                continue
                            }
                            # see if we can add it to the end
                            $ol = ls.slice(-1)[0]
                            if (ols&string.endsWith(ls&string)) {
                                # nibble eg \n$ at joi@48
                                $nol = Cye([ol.t,1])
                                nols&string = ols&string.slice(0,-hak(ls&string))
                                $bol = Cye(['same',1])
                                bols&string = ls&string
                                ls.splice(-1,1, nol,bol)
                                continue
                            }
                            # or edgily, eg joi@85 is all same except (++⇥♲)
                            $most = whole.slice(0, dec(hak(whole)*0.66,0) )
                            if (ols&string.startsWith(most)) {
                                # beginning
                                $Nl = []
                                $nol = Cye(['same',1,{},{string:''}])
                                $nib = 0
                                while (ols&string[nib] == whole[nib]) {
                                    nols&string += whole[nib]
                                    nib ++
                                }
                                hak(nols&string) and Nl.push(nol)
                                
                                # end
                                $eol = Cye(['same',1,{},{string:''}])
                                nib = -1
                                while (ols&string.slice(nib)[0] == whole.slice(nib)[0]) {
                                    eols&string = whole.slice(nib)[0] + eols&string
                                    nib --
                                }
                                
                                # their middle
                                $from = hak(nols&string)
                                if (from + hak(eols&string) < hak(ols&string)) {
                                    $mol = Cye([osphere,1])
                                    $til = hak(ols&string) - hak(eols&string)
                                    mols&string = ols&string.slice(from,til)
                                    hak(mols&string) and Nl.push(mol)
                                }
                                
                                # our middle
                                if (hak(nols&string) + hak(eols&string) < hak(whole)) {
                                    $mol = Cye([sphere,1])
                                    mols&string = whole.slice(hak(nols&string),hak(eols&string))
                                    hak(mols&string) and Nl.push(mol)
                                }
                                
                                hak(eols&string) and Nl.push(eol)
                                
                                ls = Nl
                                break
                            }
                            
                          // adjacent to unlike joi line
                            # maybe these lines dont belong together
                            # < new might be better placed before the joi%stretchy
                            #    by indent?
                            ls = me&Ploy_joi_separate_ls,joi,nod
                            jois&separate_ls = 1
                            break
                        }
                    }
                    if (f.sweepin) {
                        # < GOING? a hack.
                        # were adjacent nod, sweep back together!
                        $whole = bitl.map(l => ls&string).join('')
                        ls = me&Ploy_joi_separate_ls,joi
                        ls.splice(1,0, Cye([sphere,1,{},{string:whole}]) )
                    }
                    if (f.rm) {
                        # bits from some sphere to be sifted out
                        #  quite cruxical we dont use joi/with=nod
                        #   as we may not have it..?
                        $Nl = grep(l => l.t != sphere, ls)
                        $l = Cye([osphere,1])
                        ls&string = Nl.map(l => ls&string).join('')
                        ls = [l]
                    }
                // thence
                    # merge sequences of same l.t
                    me&Ploy_ls_tidy,ls
                    map(&l{
                        # < where from?
                        $nli = ls&string.indexOf("\n")
                        if (nli >=0 && nli+1 != hak(ls&string)) {
                            me&Ploy_fail,"fix:weird-nl",{l}
                        }
                        if (!hak(ls&string)) {
                            me&Ploy_fail,"fix:empty-string",{l}
                        }
                    },ls)
                    !hak(ls) && !jois&stuttered and debugger
                    joi.reComp = ls
                }
            }
            
          // redo Comp -> Ploy again
            # < may have no need to!
            a&fixed_joins = fixed
            $N = a&fixed_Comp = []
            each i,joi jois {
                $ls = joi.reComp || 3c&o(joi,'lit.l')
                each il ls {
                    N.push(l)
                }
            }
            grop(&l{
                ly&becomes_separate_ls and return 1
                if (0 && ls&string.startsWith("\t-Number")) {
                    #debugger
                    return 1
                }
            },N)
            
            # sanity: applied fixes dont change either sphere's whole string
            $samp = {was:oComp,is:a&fixed_Comp}
            $sphs = ['new','gone']
            each it sphs {
                $sa = map(&L{
                    return L.filter(l => l.t == 'same' || l.t == t)
                        .map(l => ls&string).join('')
                },samp)
                sa.was == sa.is and continue
                
                me&Ahdiffany,'sph:'+t,'see',sa.was,sa.is
                me&strange,"fix:sanity-whole-same"
                continue
                
                me&Ploy_fail,"fix:sanity-whole-same"
            }
        }
        # where we might joi->add(nod), dem->rm(nod)
        #  also might joi%N?tilmoves/*->rm(nod)
        #  and check only one joi.fix may happen before corrupting data
        me.Ploy_plotfix = &acgt,joi,dem,nod{
            $ojois = grep(flatten([jois&Ntilmoves,jois&tilmoves]))
            # only one joi.fix may happen before corrupting data
            $already = grep(ojo => ojo.fix, [...ojois,joi,dem])
            if (hak(already)) {
                # lets not do it
                $jids = coint(already.map(ojo => ojo.i_join))
                me&tc,"Already:j:"+jids,'b'
                jois&unfixable = jids
                return
            }
            return &afix,{
                # lets do it
                ojois.map(&ojo,{
                    # not the final place we want to put it
                    ojo == dem and return
                    afix(ojo,'notin',{rm:nod})
                })
            }
        }
        # merge sequences of same l.t
        me.Ploy_ls_tidy = &acgt,ls{
            $la = null
            grop(&l{
                !hak(ls&string) and return 1
                if (la && !las&string.includes("\n") && l.t == la.t) {
                    las&string += ls&string
                    return 1
                }
                la = l
            },ls)
        }
        # make [l+], a continuous bunch of ++|--
        #  and possibly add $nod on the end... if it is much later
        # < fix f.add may resort to this... it seems to fail:fix-whole
        # < mapkv(): y returns k|[k,v]
        me.Ploy_joi_separate_ls = &acgt,joi,nod{
            $N = []
            $nods = me&Ploy_joi_nods,joi
            $addin = &nod,{
                $sphere = nod.sph.sphere
                $ls = 3c&o(joi,'lit.l')
                $bits = 3c&o(nod,'mine/bit')
                each i,bit bits {
                    $l = bit.l
                    ly&becomes_separate_ls = 1
                    # fyi, if this l belongs before|after this joi
                    # < check they are only from the joi%stretch we are fixing wrt
                    $belongs = ls.includes(l)
                    l = Cye(l)
                    # either is all ++|--, unsharing eg \n$
                    l.t = sphere
                    N.push(l)
                }
            }
            nods.map(nod => addin(nod))
            nod && !nods.includes(nod) and addin(nod)
            return N
        }
        
        me.Ploy_drawjoin_fixes = &acgt{
            $joi = A&joi
            !joi.fix and return
            $m = me&Ploy_rower,'fix'
            ms&hue = 200
            
            # rebuilt l+
            me&Ploy_rower_i,m,'lit' (&ml{
                each il joi.reComp {
                    me&drawdiffbit,i,l
                }
            })
            # the facts leading to rebuild
            A&draw('jin',&ml{
                
                each if joi.fix {
                    # see &Ploy_joins_fix / afix()
                    $c = ex({},f)
                    me&boxcap,"fix:"+c.t,'2g' (&ml{
                        ms&ml = 2
                        me&walls,m,'b:2.2h4'
                        mc&maybeempty = 1
                        lc&s = delete c.t
                        $origin = delete c.joi
                        origin != joi and me&Ploy_tid,origin
                        each kv c {
                            me&boxcap,"fix-data",2 (&ml{
                                lc&not = 1
                                me&tsc,"key",k,'b'
                                ish(v) and me&Ploy_tid,v
                                else me&tc,dis(v)
                            })
                        }
                    })
                }
            },m)
        }
    
    
    //  reg -> pla
        =pod
          group like stuff
           Ploy/region
            of consistent conditions
             and how to draw them
            ie sub-nod** we would dimly light
             or show whole things of either sph

           conditions:
            joi.changes.%♲|c|allnew etc
           make reg
            spreads to
             next joi, linearly
              < unless drop in nod.d from where reg started
             < inners
               eg E:1 starts reg:%♲, spreads to /c/again joi@22
               is already there with the 'not counting' of lafew_relevant_overs()

            higher levels of:
              < continuation of an Eref: ♲
                 about the one ♲:^3:7/having 4.sc.todo//-hat/1
                   mentions the gone t from our ^2
                    presenting the usual new-version-of-same we can often see...
                  followed by lots of simple ♲
                   which say ref continuity continues into here
                    > when it doesnt

           make are
              hoist interestingness
                > venn types of change over space
                > forward mungible change|seq
        =cut
        # group like stuff
        me.Ploy_regions = &acgt{
            # rolling recent conditions
            $regs = []
            $jois = 3c&o(3c&X,'join')
            !hak(jois) and debugger
           // f
            # convert joi%mono to joi.changes.allnew|gone
            #  to have all relevant conditions in joi.changes.*
            each i,joi jois {
                $sph = jois&mono
                !sph and continue
                ahk(joi,'changes',sph.sphere,3)
            }
            # return the last few joi a reg should have in /matches
            $lafew_relevant_overs = &reg,{
                $more = reg.over.slice()
                if (reg.t == '%♲') {
                    grop(&joi,{
                        # not counting == E%Fun|String, since not Eref-able
                        joi.changes and return
                        $nod = havs(joi.with)[0]
                        $r = Aof(nod.E)
                        rs&Fun || rs&String and return 1
                        # or if it keeps the same Eref
                        $D = nod.D
                        D.sc['♲'] and return 1
                    },more)
                }
                return more.slice(-5)
            }
            $reg_ends = &reg,joi{
                ahk(joi,['regs'],'end',reg)
                reg.ends = joi.i_join
            }
           
           // reg <- joi
            # joi.regs.(start|had|end) = [reg+]
            # reg.matches = [joi+] that had the cond of reg
            # reg.over = [joi+] during that reg's start..end,
            each i,joi jois {
                # whats here
                $cond = ex({},joi.changes || {})
                $nod = havs(joi.with)[0]
                if (!nod) {
                    me&Ploy_fail,"joi:with",{joi}
                    return
                }
                # counted into|against regs
                each i,reg regs {
                    grop(&degree,k{
                        if (reg.t == k) {
                            ahk(reg,['matches'],joi)
                            ahk(joi,['regs'],'had',reg)
                            reg.degree > degree and reg.degree = degree
                            # dont cond -> new reg
                            return 1
                        }
                    },cond)
                    ahk(reg,['over'],joi)
                }
                # until they seem lost
                # < rounding off branches
                grop(&reg,{
                    # last few /over=joi this reg should have in /matches
                    $lafew = lafew_relevant_overs(reg)
                    $had = grep(reg.matches, lafew)
                    $qual = hak(had) / hak(lafew)
                    #joi.sc['regqua'+reg.t] = qual
                    
                    if (qual < 0.4) {
                        # trim end of region to last matching joi
                        $endjoi = had.slice(-1)[0]
                        !endjoi and debugger
                        $overs = ksaf(reg.over,{aft:endjoi})
                        !hak(overs) and debugger
                        # trim reg/match
                        #endjoi.sc['regtrim'+reg.t] = hak(overs)
                        grop(overs,reg.over)
                        reg_ends(reg,endjoi)
                        # remove from regs[]
                        return 1
                    }
                },regs)
                # unknown cond -> new reg
                each k,degree cond {
                    # new reg!
                    $reg = 3c&iz(3c&X,'region')
                    reg.t = k
                    reg.degree = degree
                    ahk(joi,['regs'],'start',reg)
                    reg.starts = joi.i_join
                    ahk(joi,['regs'],'had',reg)
                    ahk(reg,['matches'],joi)
                    ahk(reg,['over'],joi)
                    regs.push(reg)
                }
            }
            # any still active now end
            each i,reg regs {
                reg_ends(reg,joi)
            }
           
           // hier place** <- joi
            # hier joi** wrt regs
            # subset of joins leading to regions
            $top = 3c&iz(3c&X,'place')
            $stack = [top]
            $regs = []
            each i,joi jois {
                
                # get nod.d
                $nods = me&Ploy_joi_nods,joi
                # pla.with - more inclusive
                # < sph:old first already?
                nods = me&sortial,nods,nod=>nod.sph.sphere=='new','sort,flat'
                $nod = nods.slice(-1)[0]
                !nod and debugger
                # check indent-only change
                $depths = uniq(nods.map(nod => nod.d))
                # < stack per sph?
                #hak(depths) != 1 and debugger
                
                # create place hierarchy via stack=[place+]
                if (i == 0) {
                    $place = stack[0]
                    place.d = 1
                }
                else {
                    $prev = stack[nod.d-1]
                    $place = 3c&iz(3c&X,'place')
                    # in relation to
                    $up = stack[nod.d-2]
                    if (!up) {
                        jois&pla_stack_gap = 1
                        #me&Ploy_fail,"place-stack-gap",{joi,nod}
                        # not conjuncted with indent:
                        hak(depths) != 1 and debugger
                        up = stack.slice(-1)[0]
                        !up and return me&Ploy_fail,"stack-empty",{joi,nod}
                    }
                    place.d = nod.d
                    place.up = up
                    3c&iz(up,'placed',place)
                    # from here in
                    stack[nod.d-1] = place
                    while (hak(stack) > nod.d) {
                        # eg d=2 should have stack x2
                        stack.pop()
                    }
                }
                
                $pla = place
                pla.with = nods
                pla.anod = nod
                # for one joi
                place.joi and debugger
                place.joi = joi
                
                # with many regs
                if (joi.regs) {
                    each i,reg joi.regs.start {
                        regs.push(reg)
                    }
                }
                each i,reg regs {
                    ahk(place,['regs'],reg)
                    !reg.over.includes(joi) and debugger
                }
                if (joi.regs) {
                    each i,reg joi.regs.end {
                        grop([reg],regs)
                    }
                }
            }
            # should all come off again
            hak(regs) and debugger
           
           // f pla
            # see &ind, which cannot travel otherways than ss&z
            $inplace = &sd{
                isfu(d) and d = {y:d}
                d ||= {}
                # can iterate pla** or d**
                d.may_iterate = (s) => s.placed && 3c&o(s,'placed')
                return me&inlace,s,d
            }
            # scan pla**, require ratio of true y(pla)
            $inplace_ratio = &pla,ratio,y,{
                $trve = 0
                $total = 1
                inplace(pla,&pla,d{
                    $ret = y (pla,d)
                    ret and trve++
                    total = hak(d.visit)
                    if (total > 3 && trve / total < ratio) {
                        d.abort = 1
                    }
                })
                return total > 3 && trve / total > ratio
            }
            # argulate a pla** chase
            $inplacing = &pla,y,yy{
                $call = &y{
                    return &pla,d{
                        # its parent and past life
                        $eld = pla.up
                        $joi = pla.joi
                        # just means reg covers this joi, ie reg.over = [joi+]
                        $regs = pla.regs
                        # this means reg matches this joi, ie reg.matches = [joi+]
                        $had = ahsk(joi,'regs','had')

                        y (pla,d,eld,joi,regs,had)
                    }
                }
                $d = {extend:'hadbyall'}
                d.y = call(y)
                yy and d.yy = call(yy)
                return inplace(pla,d)
            }
           
           // pla** percolate
            # percolate change to ancestors
            $places = 3c&o(3c&X,'place')
            inplace(top,&place,d{
                each i,reg place.regs {
                    each i,up d.path {
                        ahk(up,['conregpla'],reg.t,place)
                        # or by degrees and at depths
                        ahk(up,['inter'],reg.degree,reg.t,place.d,place)
                    }
                }
                # for further consciousness of how good a place it is for what
                place.sc = {}
            })
            
            =pod
             chasing place.inter.*
              until it reduces to one reg, etc
              
             < it may leave off tips further inside
               # see how -Difmo looks first
               eg joi@86 E:1 2
                could say "88% %♲", &tt inflate pla/**
              
             into something easy for -Difmo to get
              might swap %zuct for lum diag
            =cut
            
            # pla + reg had|no-more|reduced-set
            # diags in the order they would show up on a -Difrow
            inplacing(top,&pla,d,eld,joi,regs,had{
                # had matched
                each i,reg had {
                    $c = ahk(pla,'sc','regtc',reg.t,{})
                    # reg.degree is the lowest (most severe) per any of its /matches
                    # pla/#reg.degree shall be wrt itself
                    $degree = ahsk(joi,'changes',reg.t)
                    degree and c.degree = degree
                }
                $degree = grep(havs(plas&regtc).map(c => c.degree)).sort()[0]
                degree and plas&degree = degree
                
                if (!pla.inter) {
                    # no more /** had regs
                    if (pla.placed) {
                        $many = hak(inplace(pla))
                        # < allow so-much geo within, to then eg dl=2
                        #   depends on backpressure of the whole set of diags
                        many >= 4 and plas&toomany = many-1
                    }
                    if (!had) {
                        # nothing much node
                        plas&non = 'nofurther'
                    }
                    return
                }

                # regs from /** are a subset of regs from ^/**
                $refining = hak(eld.conregpla) > hak(pla.conregpla)
                    # not too few to pla%con
                    && sum(havs(pla.conregpla).map(hak)) > 3
                if (!d.up || refining) {
                    # /** contains such reg.t
                    plas&con = coint(haks(pla.conregpla))
                }
            })
            
           // pla <- misc
            # may become more severe $v, returns most severe
            $mostdeg = &pla,v{
                $was = ahsk(pla,'most','degree')
                v and !was || was > v and ahk(pla,'most','degree',v); return v
                return was
            }
            # fade the boring**
            #  find parents of **degree >= 8
            inplacing(top,&{},&pla,d,eld,joi,regs,had{
                # amongst pla/** and pla
                $most = mostdeg(pla,plas&degree)
                !eld and return
                mostdeg(eld,most)
            })
            inplacing(top,&pla,d,eld,joi,regs,had{
                mostdeg(pla) < 8 and return
                plas&borein = 1
                d.not = 1
            })
            
            # pla <- joi misc
            inplacing(top,&pla,d,eld,joi,regs,had{
                3c&o(joi,'lit.l',&lc{
                    # find l%moren, which are closed...
                    # < openable, via multiple &tt
                    ls&moren and plas&moren = hak(ls&moren)
                    
                    # the unfixable joi%crapcap
                    ls&crapcap and plas&crapcap = 1
                })
            })
            
            
            # reg is so popular in pla** that we say when it doesnt match
            # < io expr
            inplacing(top,&pla,d,eld,joi,regs,had{
                each tc plas&regtc {
                    # already in the ***, dont need to say reg
                    ahsk(d,'hadbyall',t) and c.saidbyancestor = 1; continue
                    # high having reg in pla**
                    !inplace_ratio(pla, 0.88,pla => ahsk(pla,'sc','regtc',t)) and continue
                    # < similar for new Eref bunches?
                    ahk(d,'hadbyall',t,{})
                    c.hadbyall = 1
                }
                
                !d.hadbyall and return
                
                # an ancestor says reg***
                each tg d.hadbyall {
                    # see c.saidbyancestor above
                    ahsk(pla,'sc','regtc',t) and continue
                    # or say when we dont
                    ahk(pla,'sc','unhad_regtc',t,{})
                }
            })
            
            
            
            # pla%watersprouts (arborism)
            #  long-necked skinny-branch
            # < should avoid ** with .regs? coincidentally does for now
            inplacing(top,&pla,d{},&pla,d{
                # on the way back up
                # ! these must be into d.sc.*
                #    since d.yy() can happen before later d.y()
                #     we can still inherit from an above d.*
                #     alt, do topd.visit in reverse, once all d** are separated
                d.stack.map(&p{
                    p == d and return
                    ps&descendants ||= 0
                    ps&descendants ++
                })
                # not too many
                ds&descendants > 9 and return
                hak(pla.placed) > 2 and return
                # average amount of children (divergence) is low
                !inplace_ratio(pla, 0.67,pla => hak(pla.placed) < 2) and return
                plas&watersprout = 1
                # claims that area (of descendants)
                inplace(pla,&pla,d{
                    d.d == 1 and return
                    delete plas&watersprout
                    plas&watersprouted = 1
                })
            })
            
            # create emphasis for some regs
            #  these are the only ones said by -Difpla
            #   everything else becomes mod diffs or is invisible
            inplacing(top,&pla,d,eld,joi,regs,had{
                each i,reg had {
                    $c = ahsk(pla,'sc','regtc',reg.t)
                    if (joi == reg.matches[0] || c.hadbyall) {
                        c.emphasis = 1
                    }
                }
            })
            
           // done, visualise
            !3c&show_regs and return
            # reg+
            me&boxcap,"regions",5 (&ml{
                3c&o(3c&X,'region',&reg,{
                    $ze = me&boxcap,"reg"+reg.i_region,3 (&ml{
                        me&walls,m,'bd:2.2'
                        me&tsc,'cond-match',reg.t,'G'
                        me&boxcap,"joi" (&ml{
                            me&tsc,'joi-started',reg.starts,'6y'
                            me&tc,"->"
                            me&tsc,'joi-ended',reg.ends,'6y'
                        })
                        me&tsc,'match',hak(reg.matches)
                        me&tsc,'over','/'+hak(reg.over)
                    })
                    me&ioty,ze .map(&n{
                        ns&dis = 4
                    })
                })
            })
            # pla**
            me&boxcap,"places",1 (&ml{
                me&walls,m,'bd:2.2'
                inplacing(top,&pla,d,eld,joi,regs,had{
                    $nod = pla.anod
                    d.cap = me&boxcap,"place"+pla.i_place,1,0,d.cap (&ml{
                      // drawing
                        my&cv = 0.7
                        mc&maybeempty = 1

                        ms&ml = 1
                        me&walls,m,'bd:2.2'
                        lc&s = nod.E.t
                        ls&fs = 6

                        # folding skinny branch
                        #  only when not remodulating
                        #   this is a cheap analogue of &sfx_mirage making lines?
                        plas&watersprout and d.foldedup = 1
                        if (plas&watersprouted) {
                            ms&dis = 2
                            ms&pt = ms&pb = 0.03
                            !plas&watersprout and delete ms&ml
                        }

                      // regs etc!
                        # regs here
                        # give an overall degree
                        $degree = plas&degree
                        ms&bgh = degree > 7 ? '241'
                            : degree > 0 ? '642'
                            : '001'

                        # are visible (or not)
                        each tc plas&regtc {
                            c.saidbyancestor and continue
                            $n = me&tsc,"regs-had",t,'y'
                            if (c.emphasis) {
                                ns&fs = 17
                                # marking stuck in indent
                                me&drawleftwing,pla (&{
                                    me&tsc,"regs-emphasis",t .sc.fs = 17
                                    c.hadbyall
                                        && me&tsc,"regs-hadbyall",'***','y'
                                })
                            }
                            c.hadbyall
                                && me&tsc,"regs-hadbyall",'***','y'
                            c.degree && c.degree != degree
                                && me&tsc,'match-quality',c.degree,'6g'
                        }
                        # are against what was saidbyancestor
                        each tc plas&unhad_regtc {
                            me&boxcap,"unhad-amongst",2,2 (&ml{
                                lc&not = 1
                                ms&hue = 300
                                me&tsc,"regs-unhad",'!','y' .sc.fs = 17
                                me&tsc,"regs-unhad",t,'y'
                            })
                        }

                        $heren = hak(pla.sc) &&
                        me&boxcap,"here",2 (&ml{
                            me&walls,m,'bd:2.2'
                            ms&hue = 150
                            lc&not = 1
                            $unususc = []
                            each kv pla.sc {
                                k.endsWith('tc') and continue
                                k == 'watersprouted' and continue
                                if (k == 'degree') {
                                    v < 8 and me&tsc,k,'°'+v,'b'; unususc.push(k)
                                }
                                else
                                k == 'watersprout' and me&tsc,k,'⸙','b'
                                else
                                k == 'non' and me&tsc,k,'.','b'
                                else {
                                    unususc.push(k)
                                    k == 'toomany' and me&tsc,k,'⦄..'+v,'b'
                                    else {
                                        me&tc,cint(k,v),'g'
                                    }
                                }
                            }
                            if (!hak(unususc)) {
                                ms&usualstuff = 1
                            }
                            !plas&watersprouted and me&Ploy_tid,joi
                        })
                    })
                })
            })
        }
    
    //  pla remodulating
        me.Ploy_pla_remodulating = &acgtm,pla,{
            # for example
            $nod = pla.anod
            $r = Aof(nod.E)
            # where to put parts
            $modinto = m
            plas&degree && plas&degree < 8 and ms&mt = ms&mb = 0.1
            # may overall new|gone, instead of lots of little marks
            $no_mark_sided = 0
            map(&k{
                $c = ahsk(pla,'sc','regtc',k)
                !c and return
                if (!c.saidbyancestor) {
                    $n = me&modmark_sided,modinto,k
                    c.hadbyall and ns&bol = '0.25em dotted rgb(38, 110, 217)'
                }
                no_mark_sided = 1
            },['new','gone'])
            
           // source $n
            # i pla/#nod:remod/#n:mod o pla/with/nod//r/%M/n
            #  relativity between nod modulat
            $inti = me&intivity
            pla.with.map(&nod,{
                $rem = 3c&io(pla,'remod',nod.sph.sphere)
                rem.nod = nod
                $into = inti.side(nod.sph.sphere,rem)
                $E = nod.E
                $r = Aof(E)
                $N = me&modselect,r
                # < always ~~, may ~order about to be sorted out?
                #!heq(N,rs&M) and debugger
                $M = []
                each in N {
                    nc&not and continue
                    ns&miragia == 2 and M.push(...me&ioty,n)
                    # let E/*)%Difpla remake mirage lines
                    ns&miragia and continue
                    M.push(n)
                }
                # sometimes 1/sc/todo/0/c: says cX{~, sometimes cX~{
                #  the latter because mirmod%miragia=2 does c&sortcv
                # < why doesnt &Topping / vsortz(Rs&M) sort them
                vsortz(M)
                each in M {
                    $mod = 3c&iz(rem,'mod')
                    mod.n = n
                    # the relativity index for modulat, allows dupey %z
                    into.part(mod,{tv:[n.t,ny&cv]})
                }
            })
            
            
           // el:1|2|8
            $thenode = 0 && r.t == '1' && ry&up.t == '-hat'
            $data = {}
            $zucty = &srdl{
                # never happens, unless c&zuct outside of %miragia**
                debugger
            }
            # {el:1|2,part|parting,sided.$t=part}+
            inti.what().map(&rel,{
                # want gone,new
                hak(rel.sided) == 2 && cint(haks(rel.sided)) != 'gone:new' and debugger
                
                if (rel.el == 2) {
                    # might be the same!
                    me&modsame,pla,rel and rel.el = 8
                }
                
                each t,part rel.sided {
                    $side = part.up
                    # ie whole r/* are drawn, preferring side:new
                    rel.el == 8 && t != 'new' and continue
                    
                    $rem = side.rem
                    $nod = rem.nod
                    $E = nod.E
                    $r = Aof(E)
                    
                    $mod = part.mod
                    $n = mod.n
                    nc&not and continue
                    thenode and ahk(data,[r.t],n.t,rel)
                    
                    # init
                    #!rem.rels and rem_init(r)
                    ahk(rem,['rels'],rel)

           //   clone mod amongst
                    $figaro = null
                    if (hak(n.c,'s') && rel.el < 8) {
                        # extra container around text element
                        figaro = Cye(['figaro-'+n.t,ny&cv,{figaro:1}])
                        ac(modinto,'z',figaro)
                    }
                    # < if nc&s, make extra container around it
                    #    where &modmark_sided will be
                    $s = me&modclone,(figaro||modinto),n,{zucty}
                    if (rel.el < 8 && !no_mark_sided) {
                        # mark as new|gone
                        me&modmark_sided,(figaro||s),t
                    }
                }
            })
            
            thenode and me&fu,"Lerel",data
        }
        # for new|gone brackets around modclones
        me.modmark_sided = &acgtst{
            $n = me&tc,s,'side:'+t+':'+s.t,'y'
            $nn = ss&z.pop()
            nn != n and debugger
            ss&z.unshift(nn)
            delete nc&s
            # position:fixed
            ns&po = 3
            # display:block/position:absolute
            ss&dis == 1 and ns&po = 1
            if (sy&R) {
                ss&po = 2;             ns&po = 1; ns&dis = 1
            }
            if (sc&figaro) {
                # pos:rel,dis:inline-block / pos:abs,dis:block
                ss&po = 2; ss&dis = 2; ns&po = 1; ns&dis = 1
                ss&miw = 1
            }
            
            # border without verticals
            ns&br = 1
            ns&bo = '0.25em dashed rgb(38, 110, 217)'
            ns&hue = t == 'gone' ? 30 : -60
            ns&bol ||= 0
            ns&bor = 0
            #ns&zi = -1
            ns&wi = '100%'
            ns&he = '100%'
            ns&miw = 0.8
            ns&mih = 1
            ns&pa = 0.2
            # centering
            ns&ml = -0.2
            ns&mt = -0.4125
            !ns&po and ns&top = 0
            
            return n
        }
        # oddrow: regs start|end at a join
        me.Ploy_drawjoin_regions = &acgt{
            $joi = A&joi
            !joi.regs and return
            cint(haks(joi.regs)) == 'had' and return
            
            $m = me&Ploy_rower,'regs'
            ms&hue = 260
            
            me&Ploy_rower_i,m,'lit' (&ml{
                $regs = sex({},joi.regs,'end,start')
                each th regs {
                    me&boxcap,t,2 (&ml{
                        each i,reg h {
                            me&boxcap,"reg"+reg.i_region,2 (&ml{
                                me&walls,m,'bd:2.2'
                                me&tsc,'cond-match',reg.t,'G'
                            })
                        }
                    })
                }
            })
        }
        
    // drawing row+
        # $m:row re-opens a &boxcap column for eg /with
        me.Ploy_rower_i = &acgtmt{
            return &y{
                !me&fiu,m,t,8 and debugger
                me&boxcap,t,4,2,m (&ml{
                    y (m,l)
                })
            }
        }
        # boxcap for some kind of row, for a joi
        me.Ploy_rower = &acgtk{
            # kind may also odd|fail|fix|etc
            $modk = "mod"+(k||'joi')
            $m = A&joi[modk]
            if (!m) {
                # name it after this row
                $i = A&joi.i_join
                $name = cint('join',i,k)
                m = A&joi[modk] =
                me&boxcap,name,3 (&ml{
                    ms&type = cint('join',k)
                    # label is the first column
                    lc&s = k || i
                    ls&bri = 0.6
                    ls&dis = 4
                    k and ls&fs = 7
                    # < how to border rows
                    
                    # with...E
                    me&boxcap,'with',4 (&ml{
                        lc&not = 1
                        mc&maybeempty = 1
                        ms&fs = 7
                        ms&maw = 6
                        ms&miw = 3
                    })
                    # lit...l
                    me&boxcap,'lit',4 (&ml{
                        lc&not = 1
                        mc&maybeempty = 1
                    })
                    # jin... discernibles
                    me&boxcap,'jin',4 (&ml{
                        lc&not = 1
                        mc&maybeempty = 1
                        ms&maw = 6
                        ms&miw = 3
                    })
                })
            }
            return m
        }
        # columns 2-4 span, for larger breakdowns, eg &Ploy_fail
        me.Ploy_spannyrower = &acgtt{
            return &y{
                return me&boxcap,t,3 (&ml{
                    me&boxcap,'spanny',4 (&ml{
                        lc&not = 1
                        mc&maybeempty = 1
                        ms&tag = 'td'
                        ahk(m.sc,'attr','colspan',3)
                        
                        y (m,l)
                    })
                })
            }
        }
        
    // drawing f
        # space for marking in the indent space
        me.drawleftwing = &acgt,pla{
            return &y{
                me&boxcap,'leftwing',2 (&ml{
                    lc&not = 1
                    my&cv = 0.004
                    # < ^ is not enough most of the time?
                    # extra sort-first hack:
                    ms&floats = 'left'
                    ms&ab = 1
                    if (s&po == 2) {
                        # an m%left would be relative to that (C)
                        # < or any above, an R:Display-time look-around style
                        #   as would be figuring out our indent properly
                        #    whence you would probably use &boxlink (at shui() time)
                        # how far we are indented is had to gauge
                        #  this assumes %ml=1 per depth, with the occasional inline
                        #   and ignore depth=1 having no %ml, clearing width of m from C
                        $depth = pla ? pla.d : 5
                        ms&ml = - dec(depth * 0.67,2)
                    }
                    #else ms&left = 0
                    # just in case we end up piled up on other stuff
                    #  eg if we are put into a line...
                    ms&opa = 0.6
                    ms&hue = -80
                    ms&mw = 3
                    me&walls,m,'b:2.2h:4'
                    
                    y (m,l)
                })
            }
        }
        # name|number n:E.t, j:$i...
        # see also &Ploy_identify
        # < should become -Difmo/joi/E**?
        me.Ploy_tid = &acgtvk{
            k and v = v[k]
            !ish(v) and debugger
            $type = v.i_join ? 'j'
                : v.i_node ? 'n'
                :'?'
            $t = v.i_join ? v.i_join
                : v.i_node ? v.E.t
                : '?'
            me&tc,cint(type,t),'6G'
        }
        # not to be confused with $bit, which it maps to
        me.drawdiffbit = &acgttl{
            $name = cint(t,l.t)
            return me&boxcap,name,'5y' (&m,la{
                me&walls,m,'bd:1.1'
                ms&type = 'l'
                lac&s = 
                    l.t == 'new' ? '++' :
                    l.t == 'gone' ? '--' :
                    l.t == 'same' ? '==' : l.t
                
                $to = me&drawString,ls&string,{tsc:'y',squishindent:1}
                tos&ws = 4
                me&walls,to,'bd:2.2,bg:000'
            })
        }
        me.drawnod = &acgt,nod{
            $E = nod.E
            return me&boxcap,E.t,'1' (&ml{
                lc&not = 1
                ms&type = 'nod'
            me&boxcap,E.t,'2' (&ml{
                me&walls,m,'bd:3.3h4'
                ms&ml = (nod.d-1) * 0.6
                me&drawsym,'E'
                $sph = nod.sph
                sph.sphere == 'gone' and ms&bg = '#300'
            })
            })
        }
        me.drawsym = &acgtt{
            $sym = me&tsc,"sym",t
            $m = T.ab
            grop(sym, ms&z)
            ms&z.unshift(sym)
            pex(sym.sc,'fs:13,lh:0.8,hs:757')
            
        }
        
        me.drawbunchliner = &acgtc{
            each kv c {
                isst(v) and me&drawtextliner,{},k,v
                else me&drawnontextliner,k,v
            }
        }
        me.drawnontextliner = &acgtts{
            !isst(t) and throw "drawnontextliner!title"
            return me&boxcap,t,'5' (&ml{
                me&walls,m,'bd:1.3h4'
                # &Ploy_identify may have munged:
                me&tsc,'s',dis(s),'6y'
            })
        }
        # for a series of calls with v = {0,0,1,1,1,0}
        #  put markers between the 0,1 and 1,0, pointing at the 1
        me.drawintersplice = &acgtt{
            $first = 1
            $inside = 1
            return &v{
                if (v && !inside) {
                    # after some that dont
                    inside = 1
                    $n = me&tsc,t+'-starts',"\u21A6"
                    ns&fs = 12
                    ns&co = '7c9'
                }
                if (!v && inside) {
                    inside = 0
                    if (!first) {
                        $n = me&tsc,t+'-stops',"\u21A4"
                        ns&fs = 12
                        ns&co = '7c9'
                    }
                }
                first = 0
            }
        }
        
    // f, fail
        me.Ploy_fail = &acgttc{
            # stop l++
            3c&not = 1
            
            # nod|joi has errors
            # < create ^^%strange
            grep([A&joi,A&nod]).map(&blame,{
                $x = 3c&iz(blame,'!'+t)
                c and pex(x,c)
            })
            
            # display in modulat
            me&Ploy_spannyrower,"fail" (&ml{
                me&walls,m,'ba:3.1h6'
                #ls&dis = 3
                ls&hue = 200
                me&tc,"A:"+A.t,'6' .sc.ml = 1
                me&tsc,"error:",'!'+t,'G'
                
                
                me&boxcap,"env",5 (&ml{
                    lc&not = 1
                    $inner = &tcy{
                        c = me&Ploy_identify,c
                        me&boxcap,t,3 (&ml{
                            ls&dis = 4
                            ls&ws = 1
                            me&drawbunchliner,c
                            y and y (m,l)
                        })
                    }

                    c and inner('ar',c)
                    inner('A&',me&novelAc,A.c ,&m{ ms&hue = 33 })
                    A&bit and 3c&fail_bit = A&bit
                    inner('a&',A.sc,&m{ ms&hue = 66 })
                })
            })
        }
        
        me.novelAc = &acgtc{
            return nex({},c,'X,ip,sip')
        }

        # turn c={k:sph|nod|lin +} to idc
        me.Ploy_identify = &acgtc{
            c = ex({},c)
            each ts c {
                # leave non-objects in
                !isha(s) and continue
                $h = {}
                $looks
                map(&vk{
                    if (isob(v)) {
                        if (looks == 'bit' && k == 'mung') {
                            # know this object displays
                            h[k] = me&loosedepeel,v
                            return
                        }
                        # or leave out objects
                        return
                    }
                    $ma = k.match(/^i_(\w+)$/)
                    if (ma) {
                        h[ma[1]] = v
                        looks = ma[1]
                        return
                    }
                    # a word or so
                    h[k] = v
                },s)
                c[t] = h
            }
            return c
        }
        me.loosedepeel = &acgtc{
            return coint(armap(&vk{
                v == 1 and return k
                iske(v) || isC(v) and return cint(k,v)
                return cint(k,dis(v))
            }, c))
        }
 
 // Ply = Ness + Comp <
    =pod
      probably GOING, Ploy is much better
       tho this does know how to y&thing at -seven, etc.
        and only has one D, the other is a Ness
      < into X
      < with A
      < recovery
    =cut
    // Plymergent f
      // draw thing
        # wild repurposing the symbols of &Rthingo
        me.thingosym = &acgts{
            $sym = me&tc,s,'b'
            syms&lh = 0.5
            syms&fs = 20
            return sym
        }
        # a named string bubble, clue odd chars
        # < know where in l|E...
        me.drawtextliner = &acgtdts{
            !isst(t) and throw "drawtextliner!title"
            !isst(s) and throw "drawtextliner!text"
            $Om = T.ab
            $m = me&boxcap,t,'5' (&ml{
                me&walls,m,'bd:1.1'
                Om.y [t] = m
                
                $to = me&drawString,s,'y'
                tos&ws = 1
                me&walls,to,'bd:2.2,bg:000'
                Om.y [t+'s'] = to
            })
            return m
        }
        # < to having diff chunks floating around!
        me.textarrow = &acgtO{
            $b = O ? me&tc,O,"=>",'B' : me&tc,"=>",'B'
            by&cv = 0.0001
            bs&fs = 20
            bs&lh = 0.6
            bs&ab = 1
            bs&ml = -2
            O and grepout(Os&z,b); Os&z.unshift(b)
            return b
        }
        # passing y&thing acknowledged
        me.drawtextthing = &acgttdn{
            $oth = ny&thing
            oth && me&boxcap,t,'5' (&ml{
                me&walls,m,'bd:2.2h6'
                othy&cv != 0.1 and me&tc,cvf(othy&cv),'G'
                !me&mergent_oktothing,d,n and me&tc,"!used"
                $sum = me&textsize,oths&string
                me&thingosym,'⦄' .sc.fs = 15
                me&tc,sum,'y'
            })
        }
                
        # y&thing sanity check: into z requires zy&thing used on slope
        # < was %%oust to slope
        me.mergent_oktothing = &acgtdz,fatal{
            # it must exist in order to z
            $th = zy&thing
            if (!th) {
                !fatal and return null
                throw "tosphere!thing"
            }
            
            if (!hak(ths&use)) {
                !fatal and return 0
                throw "tosphere!use"
            }
            $slopers = d.slope.map(z => zy&ers)
            !hak(slopers) and throw "!slopers"
            if (!hak(grepout(slopers,ths&use))) {
                if (!slopers.slice(-2)[0]) {
                    # sloper no ers, perhaps because it was synthesized
                    $nu = zy&up
                    nu && nu.t != d.slope.slice(-2)[0].t and debugger
                    if (nu && ths&use.includes(nuy&C)) {
                        !fatal and me&tc,"//^//",'G'
                        return 1
                    }
                }
                !fatal and return 0
                throw "tosphere!used"
            }
            
            return 1
        }
      // close
        # if no Lines can be found
        # eg E...-inx/up|z are hidden from stringify
        me.mergent_avoids_unLinesed = &acgtdn{
            # anything goes so long as marked by layout symbol '~' above
            # < could be on the thing above, value =~ / \*$/
            !ahsk(n,'y','up','y','D','sc','~') and return
            me&drawtextnofurther,d,'layout:hid'
            # relies on returning from anywhere()
            return 1
        }
        # &Rthingo-ish complaint
        me.drawtextnofurther = &acgtdt{
            !isst(t) and throw "complain"
            me&thingosym,'⛔'
            me&tc,t,'6y'
            d.nofurther = 1
            # fade line
            $O = d.O
            $Om = d.Om
            Os&opa = 0.6
            # shrink everything inside, since indent O%ml depends on O%fs
            each in Os&z {
                ns&fs = 6
                # < make faster grounding for T.ab<-{&tc}
                #   these are attached now because they are the label or more T.ab
            }
            # (toL s/string//)
            Omy&toLs and Omy&toLs.sc.dis=0
            return 1
        }
      
    me.Plymergent = &acgtREs,Ness,Comp{
      // Ply box, all[] from anywhere(n**)
        # see ds&morenth
        # < trace ourselves through every ^^^*y&thing%string
        #    kind of like a report vortex
        #    lets go as it wanders off the -Ness/*/*
        #     seeing slope into W
        #   ind slice it for all Lines at l%moren
        #  < real as the E|exp**:n walk
        #    many **:n to navigate with Comp
        #     exp having gone, E having new
        #    $exp** to resurrect relics from,
        #     for D->modulat totality,
        #      so we can then Diff the modulats, and make good visual
        $Ply = me&boxcap,'Ply','1' (&Ply,l{
        lc&not = 1
        # clue any change inside, become Plyy&offendEd[] later
        $radiate = &vd{
            ds&changey ||= 0
            ds&changey += v
            d.up && radiate(v*0.3,d.up)
        }
        # l = Comp[upto]
        $upto = 0
        # [d+]
        $all = []
        # Ness** as long as possible
        #  y&thing are for the outsphere
        #  y&C=This/Eight** follow E** down
        #   once Ness** runs out
        # < wander into Ness**, with diff )
        $anywhere = &nd{
            d ||= {}
            # < for a set of trees
            d.n = n
            d.slope = (d.slope||[]).slice()
            d.sc = {z:[]}
            d.up and d.up.sc.z.push(d)
            all.push(d)
      
      // Ply stuff<->things!
            me&boxcap,"Ply"+n.t,'1' (&ml{
            ls&deco = 1
            lc&s = n.t
            ms&ml = 1
            $O = d.O = m
            $pl = me&tc,"place"
            plc&s = ''
            # intoable insphere, y&C from Ness**
            # in (Ness|This|exp)**//E-seven**
            #  slope begins This/here**

            $z
            $Om
            # notice outsphere features...
            me&boxcap,"Out",'g' (&ml{
                d.Om = Om = m
                me&walls,m,'bd:2.2h3'
                ms&fs = 6
                
                # gives Omy&toL(s)?
                ny&toLines
                    && me&drawtextliner,d,"toL",ny&toLines

                # < swathes of %moren may be entirely
                me&drawtextthing,'thing',d,n
                
                $D = ny&D
                D && Dy&thing && Dy&thing != ny&thing
                    && me&drawtextthing,'Dthing',d,D

                z = ny&C
                z || d.ins and d.slope.push(z||n)
                # < isn't always E?
                z and ds&E = z
                else
                d.ins and ds&E = n
                
                # < &Saturn into here!
                # at Ness..-seven the ** dries up
                if (!d.ins && !hak(ns&z)) {
                    if (!z) {
                        # we may be on a missing -seven
                        ds&goneseven = 1
                        d.nofurther = 1
                        return me&tc,"GONE",'b'
                    }
                    d.ins = d
                    ds&pi = 'seven'
                    # must =be a 
                    !z and return me&tc,"GONE",'b'
                    !hak(zs&z) and throw "deadend"
                    me&mergent_oktothing,d,z,'fatal'
                    me&tc,"yC",'G'
                }
                if (d.up && d.ins == d.up) {
                    # the RE
                    ds&pi = 'six'
                    me&walls,O,'bd:4.2h3'
                    # < which E** are selected
                    # see TheingE 2951: sets y&C
                    #  like there is up in Ness/*/*, see &EsyncThis
                    !z and me&drawtextnofurther,d,"non-main"
                }
                if (d.up && d.up.sc.pi == 'six') {
                    # the Ey&main itself
                    ds&pi = 'five'
                }
                ds&pi and me&tc,pl,"-"+ds&pi,'G'
            })
            d.nofurther and return
            
      // E<->l
            # lingering l, or nothing
            $l = null
            me&boxcap,"E",'g' (&m{
                me&walls,m,'bd:2.2h3'
            // Comp/l and E...n...Lines
              
              // l = Comp[upto]
                # eitherings, any substring of Lines
                l = Comp[upto]
                if (d.morend) {
                    $nd = d.morend
                    # n's l is not in Comp/*, last one that was:
                    $ul = nd.l
                    nd.moreni ||= 0
                    l = uls&moren [nd.moreni]
                    me&tsc,'morening',"^"
                }
                !l and d.offtape = 1; return me&tc,"off","b"
                d.l = l
                
                # last l%ope, l/* (indentitively) is folded into l%moren
                if (ls&moren) {
                    me&tc,"x"+hak(ls&moren),'6d'
                    # < &strange <-> T.ab
                    d.morend and debugger; me&tc,"inside-morend",'!','b'
                    d.morend = d
                    if (d.ins == d.up) {
                        # -six whole y&thing check
                        ds&morenth = 1
                    }
                }
                
                $skipgone = &L{
                    # L == l that may be gone!
                    L.t != 'gone' and return
                    me&tc,"Agone",'6y'
                    # wash up on the next E in iteration
                    ac(d,'goners',L)
                    ac(d,'subComp',L)
                    ac(d,'chaComp',L)
                    # pull until we uncover a same, continue as
                    l = Comp[++upto]
                    !l and return
                    l = skipgone(l) || l
                    !l and return
                    # dedupes (see this line in while(l) below)
                    l.t != 'same' and ac(d,'chaComp',l)
                    # line-splitting not near folds
                    l && ls&moren && l.t != 'same' and debugger
                    return l
                }
                l = skipgone(l) || l
                !l and d.offtape = 1; return me&tc,"skipgone-off","b"
                
                # everything we visit should be open, may %moren
                ls&ope == '1' and 'ok'
                else
                ls&ope and me&tc,dis({ope:ls&ope}),'y'
                else {
                    me&tc,'shut','y'
                }
                
              // Lines = ny&toLines or so
                # into R'The'
                $D = ny&D
                D and me&tc,"D",'G'
                $th = ny&thing
                
                $Lines = ny&toLines
                #D && Dy&toLines and me&tc,"DtoL"
                D && Dy&thing and me&tc,"Dth"
                D && Dy&thing and Lines = Dy&thing.sc.string; me&tc,"Dth",'6y'
                if (ds&morenth) {
                    # -six whole y&thing check
                    Lines = ths&string
                    !Lines and debugger
                }
                if (!Lines) {
                    Lines = th && ths&string
                    Lines and me&tc,"th",6
                }
                if (!Lines) {
                    Lines = D && Dy&toLines
                    Lines and me&tc,"DtoL",6
                }
                if (!Lines && D) {
                    $Dth = Dy&thing
                    Lines = Dth && Dths&string
                    Lines and me&tc,"Dth",6
                }
                
                !Lines && me&mergent_avoids_unLinesed,d,n and return
                # < test all of these recover
                !Lines and return me&tc,"lost-string",'b'
                !hak(ns&z) and me&tc,'/$','g'
                
              // could be easy
                # < func text lib
                # if we indent this
                $indLines = indents(ls&level,Lines)
                # and we aren't looking at folded or interesting l
                if (!d.morend && l.t == 'same'
                    # it should look like the rest of l
                    && ls&string == indLines) {
                    ds&good = me&ts,"match-quality-good","2"
                    # and we associate d (for E**) with it
                    ac(d,'subComp',l)
                    upto++
                    return
                }
                
              // or break apart Lines, gradually l
                $Lin = Lin_Lines(indLines)
                $Li = 0
                $nd = d.morend
                nd = nd != d && nd
                $ul = nd && nd.l
                while (l) {
                    
                    $aLine = Lin[Li]
                    # non-first bit
                    Li && nd and l = uls&moren [nd.moreni]
                    aLine == null and break
                    l.t != 'same' and ac(d,'chaComp',l)
                    if (ls&string.length && !hak(ls&string.split('')
                        .filter(s => s != ' ')) ) {
                        me&tc,"Aspacey",'6y'
                    }
                    skipgone(l) and continue
                    
                    ul && ul != l && ls&moren and me&tc,"(moremore)",'6y'
                    
                    $good_luck = 0
                    if (d.up && d.up.sc.recoveredup) {
                        debugger
                    }
                    if (d.up && d.up.sc.recovering_since) {
                        $string = ls&string.replace(/\n$/,'')
                        good_luck = aLine.includes(string)
                        #me&drawtextliner,d,"l::",ls&string
                        #me&drawtextliner,d,"a::",aLine+"\n"
                        #!good_luck and debugger
                    }
                    # first bit should look good
                    if (good_luck || ls&string == aLine+"\n") {
                        Li++
                        ac(d,'subComp',l)
                        if (nd) {
                            nd.moreni ++
                            # if we're in ul%moren/l, we can't be l%ope
                            #  so checks the entirety of y&thing if possible
                        }
                        elsif (ds&morenth) {
                            # check off a bunch more l in this while
                            #  already has Lines from y&thing
                            if (!th) {
                                ds&good = me&tc,"1+"
                                me&tc,"no-th",'b'
                                Li == 1 and upto++; return
                                break
                            }
                            $ul = l
                            # start using uls%moren
                            $nd = d
                            d.moreni = 0
                            # eventually seek next Comp/l
                            upto++
                        }
                        else {
                            ds&good = me&tc,"1"
                            Li == 1 and upto++; return
                            break
                        }
                    }
                    else {
                        # or at least starts with l
                        me&tc,",."+Li,'c'
                        if (!nd && !ls&string.endsWith("\n")) {
                            if (aLine.startsWith(ls&string)) {
                                ac(d,'subComp',l)
                                # sub-Line at a time
                                me&tc,"+",'6y'
                                aLine = aLine.substr(ls&string.length)
                                $waslev = ls&level
                                # go forwards, skipping goners
                                l = Comp[++upto]
                                l = skipgone(l) || l
                                $islev = ls&level
                                # level might increase onto a change
                                # < really?
                                if (waslev < islev) {
                                    $morelev = islev-waslev
                                    me&tc,"ind+="+morelev,'6y'
                                    aLine = indents(morelev,aLine,1)
                                }
                                Lin[Li] = aLine
                                continue
                            }
                        }
                        break
                    }
                }
             
              // non-easy OK
                Li and me&tc,"("+Li+")",'6y'
                if (!l) {
                    ds&good = me&ts,"match-quality-okay","7"
                    # already counted upto++ going into ul%moren (either of two ways)
                    return
                }
                if (hak(Lin) > 1) {
                    # others may then!
                    me&tc,"+more"
                }
            
            // lingering confusedly?
                $interesting = 1
                ||
                (n.t == 'maaaagic' && n.y.up.t == 'origin_X')
                ||
                (n.t == 'A' && n.y.up.t == '-Fez'
                    && n.y.up.y.up.t == 'node_hand_U')
                ||
                (n.t == 'maaaagic')
                
                if (interesting) {
                    me&drawtextliner,d,"l",ls&string
                    aLine ? me&drawtextliner,d,"a",aLine
                        : me&drawtextliner,d,"L",Lines
                }
                
                
                # maybe just the start of it
                if (Lines) {
                    me&ts,"lingering-confusedly",'??'
                    
                    if (ls&string.includes(Lines)) {
                        me&tc,"oooook@"+upto
                        return
                    }
                }
            })
      
      // stat
            # < dodgy
            $next = ds&pi == 'seven' ? zs&z : ns&z
            
            if (ds&good) {
                # mute toL!
                $Ls = Omy&toLs
                Ls and Lsc&not = 1
                me&tc,"OK"
            }
            
            if (ds&chaComp) {
                me&boxcap,"~",'g' (&m{
                    me&tt,'d' () and me&tc,"dsc"+dis(d.sc),'1G'
                    each il ds&subComp {
                        me&drawtextliner,d,l.t,ls&string
                    }
                    me&boxcap,"ExtraAfter?",1 (&{
                        # and the non-same ones
                        #  may inc the non-match after, not in %subComp
                        each il ds&chaComp {
                            grap(l,ds&subComp) and continue
                            me&drawtextliner,d,l.t,ls&string
                        }
                    })
                })
            }
            d.nofurther and return
            
      // recursion?
            $cant = t => me&thingosym,'⦄'+t .sc.fs = 15
            if (hak(next) && ds&good) {
                $not = 0
                # don't recurse unless Comp says
                #Comp[upto] != l and debugger
                $ln = Comp[upto]
                if (!d.morend && ln && l && l != ln && lns&level <= ls&level) {
                    #me&fu,"Leaving:"+slant(d.slope),{d,ln,l}
                    # may end on a single line E, so no l%moren
                    #  eg X.A is a one-liner, yet we can see n/* t,y,c,sc
                    return cant('E...')
                }
                # < should only l%moren instead of !l%ope
                !(l && ls&ope) and return cant('l')
                else
                # see ds&morenth for -six whole y&thing check
                #  doesn't involve E**, what we avoid here:
                # since E** feeds Lines one-C at a time, avoid the folds.
                #  essentially ignoring a bunch of stuff already marked as boring.
                #  they must be opened back in Diff.
                ls&moren and return cant('m')
                # and not far
                #hak(d.slope) > 5 and return me&thingosym,'⦄>'
                # el2 -six can skip unpacking all the newness
                elsif (ds&pi == 'six' && 'new' == joint(ds&subComp)) {
                    me&tc,"Looks-new"
                    # requires the rest of -six** Comp to be new
                    $rest = Comp.slice(upto)
                    $restofsix = ksaf(rest,{bow:ul => uls&level <= ls&level,may:1})
                    
                    $frontier = !grap(ul => ul.t != 'new', restofsix)
                    if (frontier) {
                        ds&want_recovery = 1
                        ds&el2six = 1
                        next = []
                        cant('el2-six**')
                    }
                    else {
                        me&tc,"el2-six**,not-all-new",'6'
                    }
                }
            }
            
            each iz next {
                !ds&good and cant("!good"); break
                $dd = ex(ex({},d),{up:d})
                anywhere(z,dd)
                # happens when E** shows un-Ret potential
                #  little to no flood control
                dd.offtape and me&tc,'off-tape'; break
                
                ds&recoveredup and me&tc,"/Recoveredup",'g'; break
            }
            
      // recovery?
            # and here, at every crux to a later depth first
            if (!ds&good || ds&want_recovery) {
                $dup = d.up
                if (dup && dups&good) {
                    # < voice the four options for choosing a goodlevel
                   // attempt recovery at first Comp%level <= that
                    $goodlevel = dup.l.sc.level
                    if (ds&good) {
                        # we may be skipping an el -six OK
                        goodlevel = d.l.sc.level
                    }
                    else {
                        # in a (==1-six\n)(~~2-six\n)(==3-six\n)
                        #  recover to the next six
                        $prevd = ksaf(dups&z,{bow:d}) [0]
                        $maybelevel = prevd && prevd.l.sc.level
                    }
                    if (maybelevel) {
                        if (maybelevel && maybelevel == goodlevel + 2) {
                            goodlevel = maybelevel
                        }
                        else {
                            maybelevel = 0
                            # < shouldn't really depend on a maybelevel
                            if (hak(ds&subComp)) {
                                # this might be a (==      )(--other)
                                # < handle everything better
                                $few = ds&subComp.slice(0,3).map(l => ls&string).join('')
                                $sublevel = me&getindent,few
                                # < not strange but just odd
                                if (sublevel > goodlevel) {
                                    goodlevel = sublevel
                                }
                                else {
                                    sublevel == goodlevel and me&tc,"subComp==goodlevel"
                                    sublevel = 0
                                }
                            }
                            else {
                                me&tc,"unsure"+dis({maybelevel,"^/<":prevd.l.sc.string})
                            }
                        }
                    }
                    
                   // aim Comp[upto], notting d recursion up to it!
                    $indup = upto
                    $max = 1000
                    $maxed = 0
                    $la2
                    $la
                    $nl
                    me&boxcap,"Recovering",1 (&ml{
                    ms&ml = 1
                    ls&ml = -1
                    
                    me&tt,'d' () and me&tc,"dsc"+dis(d.sc),'1G'
                    me&tc,"good<="+goodlevel,'6'
                    maybelevel and me&ts,'maybelevel-got-from-^/<','(same-indent)','6y'
                    sublevel and me&ts,'sublevel-got-from-%subComp-parts','(part-indent)','6y'
                    $lastline
                    $opecovered = me&tt,"covered" ()
                    while (maxed++<max) {
                        la2 = la
                        la = nl
                        indup++
                        nl = Comp[indup]
                        !nl && !ahsk(Om,'y','lingering-confu') and me&tc,'Once','G'
                        !nl and break
                        $heady = la && las&string.endsWith("  ")
                            || nls&string.startsWith("  ")
                        !heady and continue
                        
                        
                        $cover = me&boxcap,"Coveredup",1,2 (&ml{
                            me&walls,m,'b:2.2'
                            
                            $t = '+'+(indup-upto)
                            lastline = me&drawtextliner,d,t,nls&string
                            if (nls&level > goodlevel && la2) {
                                # perhaps it is wrong!
                                # < not carrying %level over empties:
                                #    (==      \n)(==    )(++somewhat  \n)
                                $may = la2s&string.endsWith("\n")
                                    && las&string.match(/^ +$/)
                                $relevel = may && me&getindent,las&string+nls&string
                                if (may && relevel != nls&level) {
                                    me&tc,"lies!lev:"+relevel
                                    nls&level = relevel
                                    # this was carried
                                    las&level = me&getindent,las&string
                                    # carry on from there
                                }
                            }
                        })
                        # close draw of covered lines
                        !opecovered and cover.c.not = 1
                        
                        if (nls&level <= goodlevel) {
                            # < move last line up to box:Recovering
                            lastlinec&not = 1
                            me&drawtextliner,d,lastline.t,nls&string
                            break
                        }
                    }
                    # < add a d.path
                    maxed >= max and ~>0 Ply recovermuch: maxed, slant(me.cby(d).map(d => d.n))
                    !nl and return
                    })
                    if (!nl) {
                        ds&el2six and return me&tc,"new-tail"
                        return ac(Ply,'strange','unrecoverable!nl')
                    }
                    $wasupto = upto
                    upto = Comp.indexOf(nl)
                    
                    # find corresponding d to skip iteration until
                    $done = 0
                    while (maxed<max) {
                        if (!done) {
                            if (dup.l && dup.l.sc.level < goodlevel) {
                                done = 1
                            }
                            else dups&recoveredup = 1
                        }
                        dup = dup.up
                        !dup and break
                        
                        # < radiate to last dups&good and break
                        if (dups&pi == 'six') {
                            # hang %changey
                            radiate(upto-wasupto,dup)
                        }
                        if (!done) {
                            if (hak(dup.slope)*2 < nls&level) {
                                dups&recovering_since = d
                            }
                        }
                    }
                    #ahk(Om,'y','lingering-confu',1)
                    #    || me&fu,"@"+n.t,{d,l,nl,n,upto,total:Comp.length,dup}
                }
                else ac(Ply,'strange','unrecoverable')
            }
            
            
            
            })
        }
        
      // aft: radiate changey %ope -> E !
        anywhere(Ness)
        
        # get -seven/-six with change inside
        reverse(all).map(&d{
            $cha = hak(ds&chaComp)
            cha and radiate(cha,d)
        })
        
        # < boxlink Diff|Ply**
        #   scopes the change could be viewed from
        # < -six should redirect %%ope, as it is REy&main
        $Es = []
        each id all {
            !ds&changey and continue
            # we only make -seven/-six/-five out to d%pi
            #  they may not reflect the Ec&pi
            #  eg RE-Fez/E-Fez are -six/-five to d
            !ds&pi and continue
            # mark Ply**
            me&textarrow,d.O
            # to visit d%E
            $E = ds&E
            !E and debugger
            ahk(Ply,['y'],'offendEd',{E,d})
            Es.push(E)
        }
        #me&nu,"Wouldvis",Es
        
        # /box:Ply
        })
        me&boxcap,'strange!',5 (&m{
            # me&walls,m,'b:3.2'
            each is Plys&strange {
                me&tc,dis(s),'B'
            }
        })
        # < move outside
        Plys&ml = -6
        return Ply
        if (0 && 'look-around-lines') {
            $mai = Comp.findIndex(l => ls&string.includes("maaaagic"))
            
            
            
            
            
            
            
            
            
            me&boxcap,'wonk','1' (&ml{
                $some = Comp.slice(mai-3,mai+3)
                each in some {
                    me&boxcap,'line','1G' (&ml{
                        lc&s = n.t
                        lc&s.length == 3 and lc&s += "!"
                        $t = me&tc,'doov','g'
                        tc&s = enj(ns&string)
                        ts&ws = 1

                    })
                }
            })
        }
    }   
      