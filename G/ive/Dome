# brack time
   =alphabet layercake
     join our decisions of how
      into an over-realm, a computed individuals unity
      so decisions that cant be made by anyone
      can be made by that mind
     wording so it applies force around a structure
      the decision being to break or not
     NervOS fibre bundles arm sleepy processes
      limbs becoming available
   
    solves:
    having to state everything, or:
    leaving cos &bready drops state between
      usually youd export the ready state somewhere,
       eg the bunch of C to compile
      such that it can pull changes,
       eg CBing with a Know**%fully turnaround
    by:
      not accepting CBing while busy doing other stuff
      simply not getting around to that &nodeein,
       and not avoiding what it was doing,
        because any confusing/unhandled e
        should usu make a node hang/dev
    
    < %supr-ish list/pile process via me&ind, slepping
       a natural migration pathway, among slopes...
       < know users of the things changing,
    
    o1:
      < ha that can think, stream news downstream (z gets read)
      < sa that can log, selection replayable, dome input slep
        to check the conditions for a decision are still so,
         without having to conduce the decision again
      < Babz for each in me&thing { # call me&thing once
      < Babz R&za -> me&za,R (single character == self)
    
    =elvis


// 1 - physics
   // sahazaja io
       // &sahajaza usu
        # i - enterer
        # < to react in a Ring,r hang way,
        #   returning/jumping somewhere to think/reapproach
        me.ha = &acgtj{
            return me&bracki,j,js&wou,...[...arguments].slice(5)
        }
        # o - reading,
        # from what is beginning,
        #  what was mid-way,
        #  what got to the end
        #   < without &bready? or just !sleep?
        # ja always now
        me.ja = &acgtj{
            return me&bracko,j,js&wou,...[...arguments].slice(5)
        }
        # sa last time
        me.sa = &acgtj{
            $z = js&wou;
            return me&bracko,j,zy&get_saz(j),...[...arguments].slice(5)
        }
        # za always >7
        #  so can take j=s, using sy&R to find last good R
        me.za = &acgtj{
            $r = jy&R
            $s = rc&s
            s && sy&R and j = sy&R
            $z = js&wou;
            return me&bracko,j,zy&get_zaz(j),...[...arguments].slice(5)
        }
        # differential
        me.da = &acgtjqc{
            c ||= {}
            isnu(c) and c = {el:c}
            c.el ||= 1
            $is = me&jaa,j,q
            $was = me&zaa,j,q
            # some rows, were none
            c.el == 1 and hak(is) && !hak(was) and return is
            else {
                # < changed number of
                # < hakd(), out of order
                # < returning new|gone|diff
            }
        }
        # and always array
        me.saa = &{ return me.sa(...arguments) || [] }
        me.zaa = &{ return me.za(...arguments) || [] }
        me.jaa = &{ return me.ja(...arguments) || [] }
        me.daa = &{ return me.da(...arguments) || [] }

        # io %wou, a feedback loop
        #   experience -> notion, notion -> etc
        me.sahazaja = &acgtj{
            jy&R and j = jy&R
            # < de-hard-code $k
            $k = 'wou';
            
            # %wou = $z/$row+, via me&ha,j,data etc
            $z = j.sc[k] ||= Cye([k,1,{}]);
            zy&R ||= j;
            zy&brack = z
            
            # sa last time
            $saz = me&ollbs,j,k
            zy&get_saz = &j{ return saz };
            
            # za always >7
            $zak = k+'_accepted';
            me&rollbs,j,zak;
            me&reaw,j,zak;
            zy&get_zaz = &j{ return j.sc[zak] };
        }
        # simpler
        me.haja = &acgtR{
            $j = R || me&R
            # < de-hard-code $k
            $k = 'wou';
            
            # %wou = $z/$row+, via me&ha,j,data etc
            $z = j.sc[k] ||= Cye([k,1,{}]);
            zy&R ||= j;
        }
        
        # commit %wou to be za next time
        # usu via Domes_7
        me.node_accept = &acgtRrs{
            rs&wou_accepted = rs&wou
        }
        
       // &hajadome/&hajasute make/access a cooptable T.sute
        # misleading names:
        #  &hajadome is how &supetime begins each sute
        #  &hajasute finds that via T.sute
        #   or improvises a similar interface
        # so they are provision, get_provision
        
        # take up h={ha,jaa...} interfaces anywhere (in the node)
        # < similar to an Xio front end
        #    the flavour of the interation, besides expr through it
        me.hajasute = &acgt{
            # may be for T.sute, ie &SuperGnome
            $h = T.sute
            if (h) {
                # can memo only while &supetime context limits its scope on T
                #  by deleting it. it can always be set up
                #  one T lasts the whole R'Peace' Ringing at the mo?
                # < they would be building + antibuilding
                T.hajasute and return T.hajasute
                T.hajasute = h
            }
            $j = me&R
            if (h) {
                # zaa,jaa meaning recycled or not
            }
            else {
                # without being for a h = &hajadome
                h = {R:j}
                h.ha = (c,s) => me&ha,j,c,{},s
                h.jaa = (c) => me&jaa,j,c
                h.zaa = (c) => me&zaa,j,c
            }
            h.zaaj = (c) => me&zaaj,h,c
            
            return h
        }
        # h={ha,zaa,jaa} for doming for such idc
        #  will then be used by &hajasute if put on T.sute
        # < s/idc/cid/
        me.hajadome = &acgtR,idc{
            $dome = idc.dome || daint(havs(idc))
            dome == null and throw "haja!dome"
            # make sure dome etc is first
            idc = ex({dome},idc)
            $h = {R,idc,dome}
            # &ha|jaa|etc are based on idc
            $local = c => ex(ex({},idc),peel(c))
            
            h.ha = (c,s) => me&ha,R,local(c),{},s
            # zaa,jaa meaning recycled or not
            #  both &jaa underneath, %%dome reentered every time
            #  jaa(c,i=1) selects either
            #   weird - usu one column mode (see &bracko)
            h.zaa =     c => grep(n => nc&recycled,       me&jaa,R,local(c) )
            h.jaa = (c,i) => grep(n => !nc&recycled || i, me&jaa,R,local(c) )
            # zaaj(c) via jaa(c,i=1) - selects either     ^
            #  see also &hajasute for maybe-sute bracking
            
            # and then we believe in %%rec as sub-doming this dome
            h.traction = () => me&rec_traction,h
            
            return h
        }
       
       // %%rec, &zaaj
        # %%rec... copy to %wou after
        #  unless %%dome brought it into now since &dome_o3
        #   for which the %%rec are dome-within-dome
        me.rec_traction = &acgth{
            #  an extra persistence.
            #  more permanent than %%dome, remain while going faulty.
            #   ie the step becomes unreachable
            #    are more plot points, goals, irregularly stated state
            #    eg check w:Try via elIntro etc
            $hasnew = {}
            h.zaa('rec') .map(&n{
                # any &*a should grop these
                nc&drop and debugger
                
                if (hasnew[ns&rec] == null) {
                    # o *%rec == n%rec
                    hasnew[ns&rec] = hak(
                        h.jaa({rec:ns&rec})
                            .filter(n => !nc&recycled)
                    )
                }
                # < is this just for showing in tests -brackio?
                if (hasnew[ns&rec]) {
                    if (nc&recycled) {
                        # is our copy, %%dome brought it into now
                        ny&R != h.R and debugger
                        # < only most probably:
                        # the h.zaa() from &hajadome
                        #   which may be inherited to h.zaa() from &hajasute
                        #  is showing us n in now that %%dome from before
                        #  so we can write on our copy of it!
                        # < h.traction() won't sane more than once
                        #   will however fix '< as long as some new gets selected'
                        #    for the rest of the day
                        nc&drop = 'rec'
                    }
                    else {
                        # neu or not
                    }
                }
                else {
                    # remain
                    if (nc&recycled) {
                        # is our copy, %%dome brought it into now
                        #  then &dome_o3 has already put $n here
                        #   and &rec_betractioned for n%%sustain.n == n etc
                        ny&R != h.R and debugger
                        # since already surviving %%rec,
                        #  it will also survive &dome_traction
                        #   as if no neu $n in %%dome
                        nc&rec_cyc = delete nc&recycled
                        # < note that we didn't get &sustain'd this time
                        return
                    }
                    else {
                        # move zaa->jaa, very late in the day
                        $z = h.ha(n.sc)
                        me&rec_betractioned,n,z,'rec7'
                    }
                }
            })
        }
        # ny&future -> z
        me.rec_betractioned = &acgtnzk{
            !k and throw "moveth!whence"
            if (zs&sustain) {
                zs&sustain != ns&sustain and debugger
                zs&sustain.n = z
            }
            # future in particular shouldn't exist (is from &rec_traction)
            #  because the future comes from the future
            #   and is only superimposed on the past, which keeps museum.
            #    giving R y&future before commit is a source of tunnel breakage
            #     when aborting what stays the future
            #     then something expects y&future to lead to a better self to use
            #      unless (rarely) using nowerR = &yfuture R c.merged=1
            ny&future = z
            z.y [k] = n
        }
        # %%rec-tractioned zaa+jaa
        #  used when jaa(c,1) gives dupes from neu+old %%rec
        # < as long as some new gets selected
        #    ie you may see the old row if your query doesnt also get the new one
        #     this would make it bad for seeing %%Such,ness,(--faulty)
        #  < X easy to detect recent additions to %%dome etc
        me.zaaj = &acgthc{
            $neu = h.jaa(c)
            # < use a grouper instead of...
            $recn = {}
            each in neu {
                ns&rec and recn[ns&rec] = 1
            }
            return [...h.zaa(c)
                .filter(n => !ns&rec || !recn[ns&rec]),
                ...neu]
        }
       
       // other access: &jaaz
        # &zaa it when it might not be entered yet
        #  or when j%sleeping
        #  used only by &Effect_o
        # oddness... Xio time to straighten?
        #  see also &supetime's ja, has similar
        # < perhaps &sa means &ja even if sleeping?
        # < try to make all from-to wake separately?
        #   Ring und Story/* sequentially?
        #  or the more complex:
        # < Dome_7 check from (j)
        #    it may still wake up or alter (noiseloop)
        #   to re-&Effected wake if ~
        #    (besides %%Eto:-eight)
        me.jaaz = &acgtjq{
            $R = Cy&R
            $N = me&jaa,j,q
            # reasons to trust this R's brackstate:
            # something
            N.length and return N
            # nothing from yourself
            R == j and return N
            # nothing, not happening (in R-time, see 'may still wake up')
            !Rc&N.includes(j) && !js&sleeping and return N
            # use the commit brack
            $N = me&zaa,j,q
            # there's a chance we dont wake up to notice a vanish
            return N
        }
   
   // bracktools
    # display brackology
    me.stepbrack = &acgtjz{
        $g = me&brackology,j,z||'wou';
        me&walls,g,'b:2.2';
        # attaching C to r without doming:
        ac(j,'M',g);
        return g
    }
    # 7ish brackstable determiniser
    #  sees future R as the same, cha=0
    #   otherwise be cha=1 for only objects changing
    # and no in-object differencing, just whats on the rows
    me.brackstabliser = &acgtr,se{
        # compute once
        sey&R == r and return
        sey&R = r;
        # takes brack
        $z = rs&wou;
        ses&z = (zs&z||[]).filter(n => !nc&drop);
        # includes nodes %current below, for &halfsettled
        $froms = sey&settlefroms;
        if (froms) {
            $N = fromss&nodes_below;
            $nb = Cye(['nodes below',1]);
            each in N {
                $nse = ny&settled;
                $la = nse && nses&current;
                !la and debugger
                # duplicatey
                nb.sc[n.t] and nb.sc[n.t+' '+i] = la
                else { nb.sc[n.t] = la }
            }
            ses&z.push(nb)
        }
        # into a progression
        ses&vers ||= [];
        $la = ses&vers.slice(-1)[0];
        if (la) {
            # hack for %%something:$R continuity
            #  sees future R as the same
            # < Display versioning?
            each ir lac&allvs {
                !(r && r.y && ry&R == r) and continue
                $nr = me&yfuture,r;
                lac&allvs[i] = nr || r
            }
        }
        $cha = me&brackstill,r,se,la;
        if (cha) {
            #delete ses&accepted_boring;
            # clone into vers[], drops se/*
            ses&vers.push(Cye(se));
        }
        ses&current = ses&vers.slice(-1)[0];
        return cha
    }
    # transbrack comparator
    # < brackology with two z's, +- 
    me.brackstill = &acgtRzb{
        $cha = 0
        zc&allks = [];
        zc&allvs = [];
        me&ioty,z .map(&n{
            nc&drop and return
            $nsc
            nsc = &nd{
            each kv n.sc {
                if (v && v.y && vy&brack) {
                    # recurse to n = ns&n
                    k != 'n' and throw "non-n brack in brack", k, n
                    d > 3 and throw "deep brack in brack"
                    nsc(v,d+1)
                    continue
                }
                $ki = zc&allks.push(k)-1;
                # < more/less important k
                !b || bc&allks[ki] != k and cha = 2
                $vi = zc&allvs.push(v)-1;
                if (!b || bc&allvs[vi] != v) {
                    isob(v) and cha ||= 1
                    else { cha = 2 }
                }
            }
            };
            nsc(n,0)
        })
        !b || bc&allks.length != zc&allks.length and cha = 2
        return cha
    }
    # za|ha[n+] compare over time
    #  things out of order is change
    me.brackstillzaha = &acgta{
        hak(a.za) != hak(a.ha) and return 1
        each in a.ha {
            $z = a.za[i]
            !heq(z.sc,n.sc) and return 1
        }
    }
  
   // nodes
        window.isnode = s => s && isC(s) && sy&path && sy&path[0]
        # as r/** wake up & want nodesing, give %wou
        me.inode = &acgtj{
            if (jy&R) {
                # < might be eg Ace to arrive into
                $meant = j;
                j = jy&R;
            }
            $z = jc&s;
            $N = me.cbyb(j,
                &r{ return rs&ball && rc&s.y.N },
                &r{ return rs&Peace == 4 });
            # Ying is not running... eg %R:+Hoosh
            # < A.nodar || throw "nonoder"
            !N and return
            zy&path = N.map(r=>rc&s);
            # make sy&up = ball up
            zy&up ||= N.reverse().slice(1)
                .filter(r => rs&ball).map(r => rc&s)[0];
            $S = zy&path[0];
            $N = Sy&N;
            !N.includes(z) and N.push(z)
            zy&R = j;
            
            # pseudo Nodes init o3
            !js&wou and me&Nodes_o3,j
            
            # Step's R that last o3'd, not sleeping
            !Sy&p and throw "Step !y&p"
            !Sy&R and throw "Step !y&R"
            #T.act and me&ha,j,{noded:T.act}
            return Sy&R
        };
        
        # see &Yingwhen for misc sleep functions
        # see Pictures climbing
        
        # should we not Doming_7 due to %sleep*
        me.node_issleeping = &acgtRs{
            =elvis &node_issleeping if %sleepung-ish
             potential to really stop mid-r:
             < avoiding any more Ring r**,
                < wants Rc&ip.contains()
               as soon as ha ...waits
                winding them past mind they cant reach,
                 recycling domes of stuff
             < alterior sleeping - when %%waits stops Ring
               does it accept r as b? suppose, to display
                r/** want winding past their whole lives if strange
                 winds to 9...Display while %sleeping?
            =elvis
            # >0 if r is not able to commit (za)
            # >1 if r is not able to display
            R = Ry&R;
            $r = sy&R;
            # before it calls &inode to set sy&R
            r = me&yfuture,r
            if (rs&sleepung) {
                # displayable after sleepywind
                ~>3 node pung: r.t
                return 1
            }
            elsif (rs&sleeping) {
                # reawakened + tunneled through (Know)
                #~>3 node sleeping: r.t
            } 
            elsif (!Rc&N.includes(r)) {
                # not awakened
                #~>3 node avoid: r.t
            }
            else {
                return 0
            }
            return 2
        }
        # node s resolve to a %Ying/(pa/th)
        #  for inter-noding, eg %%settle or %%eto
        # see also &pipath
        # < riding X, hoisting all the way up...
        #  < a/b/-c/d should revoke d's stuff on b, a
        me.tpath = &acgtR,to{
            # < drop need for R%Ying
            to ||= R;
            $jo = toy&R;
            to = joc&s;
            $path = toy&path || [to]
            path = path.slice().reverse();
            $N = path.map(s => sy&R);
            each in N {
                (n) and continue
                i *= 1
                $inner = N[i-1];
                !inner and throw "lost @"+i
                $p = innery&up;
                ps&ball && pc&s == path[i] and N[i] = p
                else {
                    throw "not looking", p, path[i]
                }
            }
            N = N.reverse()
            #    .filter(r => rs&ball)
            return N.map(r => r.t).join('/')
        };
        # < better sanity, with &Yingate_8 stutters
        me.must_newnodesamepath = &acgtsz{
            !s || s == z and return
            !isnode(s) || !isnode(z) and debugger
            joint(sy&path) != joint(zy&path) and debugger
        }
        # < order of Sy&N
        me.nodes_below = &acgts{
            $j = sy&R;
            !j || !sy&path and throw "nodenever"
            $S = sy&path[0];
            $N = Sy&N;
            return N.filter(z => zy&up == s)
        }
   
   // nodelinks
    # concept of leading rows -> sy&${k}tos|froms -> somewhere
    # the (settle|etos)_(6|7|8) exchange
    me.either_ftk = &acgtc{
        !isst(c.k) and throw "give c.k"
        !isar(c.rows) and throw "give c.rows"
        # somethings that become somethingfroms
        $k = c.k;
        k.substr(-1) == 's' and k = k.substr(0,k.length-1)
        c.tk ||= k+'tos';
        c.fk ||= k+'froms';
    }
    # rows leaving $from, grouped by $to
    #  eg sy&settletos/$h:to/$row
    me.either_6 = &acgtRrc{
        me&either_ftk,c;
        $s = rc&s;
        $fromt = me&tpath,R,r;
        # k,tk = settle,settletos | eto,etos
        $ing = s.y[c.tk] ||= Cye([fromt,1]);
        $gone = (ings&z||[]).slice();
        each in c.rows {
            $to = n.sc[c.k];
            !to and throw ""
            # %%eto=1 means to the step
            # < clone out the n to change %%eto=name->$s
            to == 1 and to = s.y.path[0]
            # select s given p/r/s
            $jo = toy&R;
            to = joc&s;

            $h = fio(ing, me&tpath,R,to );
            hy&up = ing;
            $gi = gone.indexOf(h);
            if (gi >= 0) {
                gone.splice(gi,1);
                # new bunch of rows
                hs&z = [];
            }

            hs&to = to;
            hs&from  = s;
            hs&fromt = fromt;
            ac(h,'z',n);
        }
        # revoke
        gone .map(&h{
            !fio(ing,h.t,0) and throw "notnt"
            if (hc&el != 9) {
                hc&el = 9;
                c.on_el9 and c.on_el9(h);
            }
        });
        c.each and me&ioty,ing .map(&h{ c.each(h,hs&from,hs&to) })
    }
    # Ying for something_8 takes $from->$to
    me.either_8 = &acgtRc{
        me&either_ftk,c;
        each in c.rows {
            !ns&fromt and throw "!fromt"
            $h = n.sc[c.k];
            $to = hs&to;
            $jo = toy&R;
            to = joc&s;
            # froms - for|on the to node path
            $ef = to.y[c.fk] ||= Cye([h.t,1]);
            ef.t != h.t and throw "misnodepath"
            #  /$fromt - the from node path
            $fo = fio(ef,ns&fromt);
            fo.sc[c.tk] = h;
            
            c.each and c.each(h,hs&from,hs&to,ef,fo)
        }
    }

// 2 - Y:Ying|Steps
 me.Yingmind ||= {}
 # Y:Ying - the top
 me.Yingmind.Ying = &acgt{ return [
  // Steps <- Schema
    # @1 figure out where things are at every so often
    # > misuse of 0.01 to declare functions
    # @o1 discerns itself from SC, which it doesn't
    
    # < set out unififying crawlythings
    #  eg check legitimacy of W Iing from its .5
    #  or do some update
    #   they set out, taking their parts of the wormhole
    ['Ying',0.01,&acgtRYs,SC{
        ~>3 Ying forks:
    },'ift,D'],

    # @02 when R%SC relives,
    #  ~SCy&R winds SCy&Y back to here
    ['on',0.02,&acgtRYs,SC{
        s != SC and throw "should be the one"
        sy&R = R;
        me&Ying_o2,R,s;
    },'ift,D'],

    #  mix Schema/$h/$p into Steps/$p
    # < Schema knowing export to Steps/$p
    #   or sharing as $p:step, and Steps inhales :steps
    ['Schema to Steps',0.021,&acgtRYs,SC{
        $Sch = me&fiu,SC,'Schema',7;
        Schc&compiled and return
        $N = [];
        me&ioty,Sch .map(&h{
            me&ioty,h .map(p => N.push(p))
        });
        tvsortz(N);
        # start new Steps
        #   and imports new Steps/$p
        s = Ys&Steps = me&Yong,R,SC,'Steps',{adoptees:N},'o2';
        Schc&compiled = 1;
    },'ift,D'],
  
  // Steps @02, @03, @9, &Ying_8
    # @023 Steps per R%SC
    ['Steps per R',0.023,&acgtRYs,SC{
        me&Yong,R,Ys&Steps,{},'o2';
    },'ift,D'],

    # @03 Steps per walk through Y:SC
    #   pull up a map for this Aing,
    ['Steps per walk',0.03,&acgtRYs,SC{
        me&Yong,R,Ys&Steps,{},'o3';
    },'ift,D'],

    # @6 Steps take walk through Y:Steps
    #   pull up a map for this Aing,
    ['Steps walk',0.6,&acgtRYs,SC{
        me&Yong,R,Ys&Steps,{},9;
    },'ift,D'],
    # 
    ['Steps e',0.8,&acgtRYs,SC{
        me&Ying_8,R,s;
    },'ift,D'],
 ]};

 # Y:Steps
 me.Yingmind.Steps = &acgt{ return [
      // <=o2 Steps R
        # o1 schema doming recreates SC/Y:Steps
        # per awake R%Ying%SomeSchema
        ['Steps',0.01,&acgtRYs,SC{
            s != SC and throw "s!=SC"
            $s = Rc&s
            $Steps = me&fiu,SC,'Steps',1;
            # grounded $p:steps flow into o2
            each ip Ys&adoptees {
                # < slep here
                me&fiu,Steps,p
            }
            # and any not in the schema
            each in ss&z {
                $p = me&fiu,Steps,n.t,8
                !p and me&fiu,Steps,n.t
            }
            #~>3 Steps fork:
            return Steps
        },'ift,D'],
        
        # o2 Steps/$p <-> R/$r awake
        # per any R%Ying
        ['are',0.02,&acgtRY,Steps,SC{
            $s = Rc&s;
            sy&R = R;
            Stepsy&R = R;
            
            # we can see tunnelled $r already
            $N = me&ioty,R,'ball';
            $sleeping = [];
            $awake = [];
            if (N.length) {
                # mixed with recycling
                N = arou(N,&n{ return Rc&N.includes(n) },awake);
                $tunneling = Rs&tunneling;
                !tunneling and throw "early !tun"
                # by the sleeping since we know r -> p
                sleeping = N.map(r => rc&s.y.p);
            }
            
            # this reverse + bal adjust Rs&z to flow upwards
            # links p,r,s (+n)
            Stepss&z.slice().reverse().map(&p{
                sleeping.includes(p) and return ps&sleeping = 1
                delete ps&sleeping
                
                $r = me&bal,p.t
                $s = rc&s;
                sy&up && sy&up != Rc&s and debugger
                # < what requires climbing s only up to the step?
                #sy&up = Rc&s
                
                $n = py&Schema_step
                if (n) {
                    # bal inputs to ups%ball, unless %eph
                    # < compile this on the Schema
                    ns&supr and ns&eph = 1

                    # n.sc -> r.sc
                    ex(r.sc,n.sc);
                    # n.c -> s.sc
                    ex(s.sc,n.c);
                }
                # < pc&s = s)%ball?
                py&s = s;
                sy&p = p;
                py&R = sy&R = r;
            });
            
            # goes on as each SC/Steps/$p
            SCs&steps = Yc&M = Stepss&z;
            # GOING
            Rs&Lastly = Stepss&z.slice().pop();
        },'ift,D'],
      
      // o2=> Steps attr # < see -Labe
        # o21 per awake Steps/(p,r,s) attr init
        ['attrise',0.021,&acgtRYp,SC{
            $Steps = py&up;
            $r = py&R;
            $s = rc&s;
            # not &inode:
            sy&path = [s]
            
            rs&Pavings and ss&twmt = ps&priority = 1
            rs&Travels and ss&twmt = rs&twmt_dl = 1
            
            # joins t-t
            ss&twin and me&attrise_twin,p,r,s;
            # p%%tw <- t/[t,t,t]
            ss&twmt and ah(r,'adhere','twmt',1)
            
            # < check out. effectively %twmt?
            # prefer specific tw, altering supr-isms
            # they seem to have storable ambitions
            # eg including to /W/ ways to use
            #   With/$trick/$hack
            #    + $hack = $trick trick
            #   and SCinway
            rs&tw and rs&tw = ss&tw
            #  allowing calm isolated spacewalks
            rs&gently && rs&Gracto and rs&tw = 1
        },'ift,D'],
        
        ['arrive',0.022,&acgtRYp,SC{
            $r = py&R;
            Rs&waits and return T.Z = 8
            # enough to have Rs&C, Rc&b, Ace
            me&Ring,r,{und:r,ov:0.295};
        },'ift,D'],
      
      // being 03
        # @03 each Steps/(p,r,s) wake up, have features
        #  may be different, may be time to something!
        ['being',0.03,&acgtRYp,SC{
            $r = py&R;
            $s = rc&s;
            sy&R = r;
            
            # p's current Y:Walk around Y:Steps?
            #$Ob = py&O;
            #$O = py&O = Cye([p.t,py&cv]);
            #Ob and Oc&b = Ob; delete Obc&b
            
            # $p earlier (Know-ward) and later
            me.neigh(p,&lr{ py&l = l; py&r = r })
            
            me&Steps_o3,r;
            
            # me&inode arrives jc&s into:
            sy&N ||= [];
            # < reliable ordering
            #    putting them in around their neigh/up
            # < some way to traverse j/** in dialect,
            #   using slep, avoiding %folder, !%supr,
            #   that they should be in sy&N, etc.
            #   %supr might:
            #    each step/* is sy&top, has another pool sy&N
            # %adhere-ants like %supr, %twmt me&inode
        },'ift,D'],
        
      // Steps 5 6 7
        ['seee',0.5,&acgtRYp,SC{
            $r = py&R;
            me&Ring,r,{und:r,ov:0.315};
        },'ift,D'],
        ['aseee',0.6,&acgtRYp,SC{
            $r = py&R;
            me&Ring,r,{und:r,ov:0.7};
        },'ift,D'],
        
        # and again to wake things generated into other steps
        #  ie from inside:r, out to where Ring isn't
        # < notice things like that,
        # < use wai to organise elvising it in there
        ['Steps may other',0.67,&acgtRYp,SC{
            $r = py&R;
            me&Ring,r,{und:r,ov:0.7};
        },'ift,D'],
        
        ['Trip report',0.7,&acgtRYp,SC{
            $r = py&R;
            $s = rc&s;
            me&Steps_7,R,p,r,s;
        },'ift,D'],
 ]};

// 3 - Domes time connect items
    # nodes at each end of time
    
    # Ying/step/node** all
    me.Ying_o2 = &acgtR{
        $s = Rc&s
        # Ying is the thing to bring vague Q changes
        4s&mainthing = R
        sy&brackwouology_ope == null and sy&brackwouology_ope = -1
        me&Yingate_2,R
        me&Domes_o3,R
    }
    me.Steps_o3 =
    me.Nodes_o3 = &acgtRs{
        me&Domes_o3,R
    }
    # domes, transbrack init
    me.Domes_o3 = &acgtr{
        $s = rc&s;
        me&sahazaja,r;
        me&etos_o3,r,s;
        me&settle_o3,r,s;
        me&dome_o3,r,s;
    }
    
    # $p and its nodes &Domes_7
    #  depending on !node_issleeping
    me.Steps_7 = &acgtRprs{
        $stepsleeping = me&node_issleeping,R,r;
        
        $rev = [];
        each iz sy&N {
            $j = zy&R;
            me&node_issleeping,R,j and continue
            me&Domes_7,R,p,j
            rev.unshift(z)
        }
        each iz rev {
            $j = zy&R;
            !j || j == z and debugger
            me&Domes_7_upward,R,p,j
        }
        if (stepsleeping) {
            me&Detection_7,R,p,r
            return
        }

        me&Domes_7,R,p,r;
        $g = me&Domes_7_upward,R,p,r;
        me&walls,g,'b:3.3h9';
    }
    # domes, transbrack accept
    # everyone &bready or -> conclusion
    me.Domes_7 = &acgtRpr{
        $s = rc&s;
        # %%dome replace if any new
        me&dome_7,R,p,r,s;
        me&waits_7,R,r;
        me&settle_6,R,p,r,s;
        me&settle_7,R,p,r,s;
        me&Detection_7,R,p,r,s;
        
    }
    # deeper first, depending on Sy&N (S = py&s)
    me.Domes_7_upward = &acgtRpr{
        $s = rc&s;
        # still state
        me&brackstable_7,R,p,r,s;
        me&settle_7_upward,R,p,r,s;

        me&node_accept,R,r,s;
        # < might sleepytime if brackstable
        #   && no elvising into brackology, etc...

        # %%eto|from
        me&etos_6,R,p,r,s;
        me&etos_7,R,p,r,s;
        # display
        return me&stepbrack,r;
    }

me.etoblab = 0
me.settleblab = 1

// 5 < Domes
  // %%dome - residing state
      // intro
        =pod %%dome:$t,... - a row that resurrects
         # not: another $z to seem in this one via bracko
         @o3 &zaa 'dome' -> ha, each nc&recycled=1
         @6:
           you ja your permanent-er state out of it
           eg %Ying has orders of $p waiting
           or commit log
           or %Paving sanity checking as we .5<->.1
         @7:
           any ha %%dome:$t,... replace them
            < or do some el=...
              eg delete with where clause
            < or something configured
           one ha %dome:$t - to drop it
           no ha %dome:$t* - to keep them all
            maybe for a ttl
         for &bracko and similar (&brackgroupX|&brackstill|&brackstabliser)
           nc&drop should appear gone,
           in time for other Doming_7 to not get it
        =cut
        
        # += %%dome from last time
        me.dome_o3 = &acgtrs{
            me&zaa,r,'dome' .map(&n{
                nc&drop and throw "dropsnot"
                $w = n
                nc&recycled and n = ny&up
                # shaded n.sc stay when dome recycling
                #  usu any other recycling vanishes them
                #   eg &ha,$n, &nodei to $to
                $shade = {}
                nc&shade && haks(nc&shade)
                    .map(k => shade[k] = n.sc[k])
                
                $z = me&ha,r,n,shade
                
                # stretch, through/from the same S
                zc&recycled = 1 + (wc&recycled||0)
                nc&S and zc&S = nc&S
                ns&rec and me&rec_betractioned,n,z,'reco3'
            })
        }
        # remove old one if obvious!
        me.dome_bracki = &acgtrn{
            $p = ny&up;
            p && ny&brack == py&brack && pc&recycled and pc&drop = 'i-rec'
            else {
                # < indexes enough to conclude that it's that
                # if it's entirely that, intensity could increase
            }
        }
      
      // tractioning
        # named traction
        me.dome_S = &acgtrkS{
            # everything must have been given
            $c = {el:2}
            c.having = &n{
                nc&S ||= S
                return nc&S == S
            }
            me&dome_traction,r,k,c
                .map(&n{
                    #~>4 indoc: ki(n,4.23)
                })
        }
        # commit new? dome
        me.dome_traction = &acgtrkc{
            k ||= 1;
            c ||= {};
            !isob(c) and throw "c.el:2?"
            
            $are = me&jaa,r,'dome:'+k
            c.having and are = are.filter(n => c.having(n))
            # < one S many domes? (c.having > dome:1)
            k == 1 && !c.having and throw "group by nothing"
            
            $neu = [];
            $old = [];
            are.map(&n{
                #~>4 of: ki(n,4.23)
                ns&el and 'where/what?'
                # tractioned until gone around
                $isold = nc&recycled || nc&tractioned;
                (isold ? old : neu ).push(n)
                nc&tractioned = 1
            })
            # everything must have been given
            $says_drop = c.el == 2 && "el2"
            
            # < making this block smaller fontsize
            # WEIRD drop by single %%dome
            $d = neu.filter(n => hak(n.sc) == 1);
            if (d.length) {
                d.length > 1 and throw "drop+"
                neu.length > 1 and throw "drop + replace"
                d = d[0];
                says_drop = dc&drop = 'singular'
            }
            
            # neu bits may not cause a redome on their own (el2)
            # el1 (default, implied)
            #  its surroundings are implied to have been stated also
            #  ie the set stated are complete and canonical
            # el2 just adds this thing
            #  supposed to recreate it...
            # < sticks out. sha() and cel=2other variants of everything?
            $some_new = neu.filter(&n{
                # probably el3? or el1.5
                nc&el == 2 and return 0
                # and via &ha for now
                # < raku: i el2%%things
                #    cm housing bits of text amongst ology modulat?
                !ns&el2 and return 1
                delete ns&el2
            })
            says_drop ||= some_new.length && "neu"
            says_drop && old.map(&n{
                nc&drop ||= says_drop
            })
            
            #$hmm = says_drop && old.filter(
            #    n => ns&eto && ns&dome == 'v1').length
            #hmm and ~>3 v1etore: R.t
            
            return c.having ? neu : old
        }
        # each %%dome replaces if any new
        me.dome_7 = &acgtRpr{
            uniq(me&jaa,r,'dome' .map(n => ns&dome))
                .map(k => me&dome_traction,r,k );
        }
   
  // %%eto - externalising state
        # < el:9 retracting it
        # $to += %%efrom...
        me.etos_o3 = &acgtrs{
            $ef = sy&efroms;
            !ef and return
            me&ioty,ef .map(&fo,{
                $h = fos&etos;
                # h may re-node_hoist before we 7, if from /**
                fos&using = hs&current;
                hc&el == 9 and foc&el = 9; return
                !hs&vers.includes(hs&current) and throw "vers!"
                !hs&from and throw "!from"
                hs&to != s and throw "to!"
                me&ioty,h .map(&n{
                    # each row is mixed in +%%efrom
                    n = me&ha,r,n,{},{efrom:hs&from}
                    # < looking at s & n should notice this link:
                    ny&efrom = fo;
                });
            })
        };
        # $from %%eto
        #   -> $from sy&etos
        #   -> Ying%%etos
        # < brackstill config/slep
        me.etos_6 = &acgtRprs{
            # all %%eto from this node
            $rows = me&jaa,r,'eto' .filter(&n{
                # demand %%eto=s is a node && not us
                $s = ns&eto;
                # to the step only if not us
                s == 1 and return ry&up != R
                isR(s) and throw "R fed eto"
                !(sy&path||sy&p) and throw "!node",s
                s == rc&s and return
                return 1
            })
            !rows.length && !sy&etos and return
            # loads up sy&etos
            $c = {rows,k:'eto',tk:'etos'}
            c.on_el9 = &h{
                hs&current = h
            }
            c.each = &h{
                $fromt = hs&fromt
                # brackstill version off the previous
                hs&vers ||= [];
                if (hc&el != 9) {
                    $la = hs&vers.slice(-1)[0]
                    $cha = me&brackstill,r,h,la
                    if (cha) {
                        delete hs&accepted_boring;
                        # clone into vers[], h/* replaces
                        hs&vers.push(Cye(h));
                        #~>3 newvers: h.t
                    }
                    hs&current = hs&vers.slice(-1)[0];
                }
                !(hs&from || !hs&to) and throw "!to|from"
                if (hs&accepted == hs&current) {
                    # remove here once they accept 9ing it
                    if (hc&el == 9) {
                        ~>2 GC: h.t
                        fio(hy&up,h.t,9)
                    }
                    $neu = !hs&accepted_boring
                    hs&accepted_boring = 1
                    if (neu) {
                        me.etoblab and ~>3 hoistcept: h.t, '<-', fromt
                    }
                }
                else {
                    # asking %Ying to transport
                    me&ha,R,{etos:h,s,fromt}
                    if (!cha) {
                        me.etoblab and ~>3 oldnews: h.t, '<-', fromt
                    }
                }
            }
            me&either_6,R,r,c;
        }
        # $to %%efrom marked as accepted
        #  relaxes $from sending it
        me.etos_7 = &acgtRprs{
            $ef = sy&efroms
            !ef and return
            $gone = [];
            me&ioty,ef .map(&fo,{
                $h = fos&etos
                hs&accepted = fos&using
                hc&el == 9 and gone.push(fo); return
                # something in the way it is now?
            })
            gone.map(fo => fio(ef,fo,9))
        }
        # Ying %%etos
        #   -> $to sy&efroms
        #   -> Ying%%waits:eto,wants:$to
        me.etos_8 = &acgtR{
            $rows = me&jaa,R,'etos';
            $c = {rows,k:'etos',tk:'etos',fk:'efroms'};
            c.each = &h,from,to,ef,fo{
                # $to tidies efroms, once el=9 accepted
                # send attention
                me&ha,R,{waits:'eto',wants:to}
                
                me.etoblab and ~>5 efroms hoisting: ef.t, '<-', fo.t
            }
            me&either_8,R,c;
        }
   
  // %brackstable - still state
    # puts sy&settled brack versioning, r%brackstable++
    #  sees future R as the same
    #  may include %current of nodes below
    #   for &settle's &halfsettled
    # &sort_wakers:
    #  may freeze infinite loops
    # %%settle:
    #  wanting others to &brackstable
    me.brackstable_7 = &acgtRprs{
        $se = sy&settled ||= Cye([s.t,1]);
        
        me&brackstabliser,r,se;
        
        ses&brackstable = ses&accepted == ses&current ? 1 : 0;
        ses&accepted = ses&current;
        
        # how many times this node Domes_7 without brack changing
        $was = me&ollbs,r,'brackstable' || 0;
        ses&brackstable and rs&brackstable = 1 + was
    }
   
  // %%settle - still state
   // beginning
    # $from sees a version of each &settled,$to
    me.settle_o3 = &acgtrs{
        $tos = sy&settletos;
        !tos and return
        me&ioty,tos .map(&h{
            hs&current and hs&using = hs&current
            hs&from != s and throw "from!=s"
        })
    }
    # %settle emits|completes
    me.settle_6 = &acgtRprs{
        # all %%settle:$to
        # nothing in the row matters,
        #  only the from-to direction,
        #   orders Ying wake towards settle
        $rows = me&jaa,r,'settle';
        !rows.length && !sy&settletos and return
        $c = {rows,k:'settle'};
        c.each = &h{
            # asking %Ying to transport
            me&ha,R,{settles:h,s,fromt:hs&fromt}
        }
        me&either_6,R,r,c;
    }
    # resolve &settle at a nodes 7
    # gathering them to do all at once in reverse
    me.settle_7 = &acgtRprs{
        me&settle_71_halfsettle_down,R,p,r,s;
    }
    # and depth first:
    me.settle_7_upward = &acgtRprs{
        me&settle_72_settled_up,R,p,r,s;
        me&settle_77_settletos_accepted,R,p,r,s;
    }
    # the settled to - having froms/**
    #  push s/* a froms with %halfsettle_for
    #   causing brackstabilising there
    me.settle_71_halfsettle_down = &acgtRprs{
        $froms = sy&settlefroms;
        if (froms) {
            $N = fromss&nodes_below = me&nodes_below,s;
            !me&ioty,froms .length and return
            each in N {
                $nf = ny&settlefroms ||= Cye([me&tpath,R,n ,1])
                ac(nf,'halfsettle_for',s)
            }
        }
    }
   
   // middle &Doming_7
    # the $from<-$to
    me.settle_72_settled_up = &acgtRprs{
        
        $froms = sy&settlefroms;
        !froms and return
        # $to:r checks itself, makes version
        #~>3 settle_7 from: r.t
        # everyone gets a sy&settled from &brackstable_7
        $se = sy&settled ||= Cye([s.t,1]);
        !(se && sey&R == r) and throw "brack version"
        sey&settlefroms = froms;
        $washalf = ses&halfsettled;
        ses&halfsettled = 0;
        ses&settled = 0;
        
        $want = &sf{
            me&wants,R,'settle',s,{for:f}
        }

        if (!rs&isbready) {
            # generates %%waits, will come back
            me.settleblab and ~>4 set7 isntbready: r.t
            return
        }
        if (!ses&brackstable) {
            want(s,'onemore')
            me.settleblab and ~>4 set7 onemore: r.t
            return
        }

        ses&halfsettled = 1;

        # nodes below are at least &halfsettled
        # when we are them:
        each in fromss&halfsettle_for {
            # when we become &halfsettled
            washalf and break
            me.settleblab and ~>4 set7 half aboving: n.t, '<-', s.t
            want(n,'nodesabove')
            # < $s/$n awake at the same time is ok
            # < that could be $n%onlyish (not $n/** again)
        }
        # < ^v mutex?
        $non = me&settle_halfsettle_down,s;
        if (non.length) {
            me.settleblab and ~>4 set7 half below: ki(non,4.23)
            non.map(n => want(n,'nodesbelow'))
            return;
        }

        ses&settled = 1;
        # ses&current -> hs&current, then they hs&accepted
        # < hc&el=9
        me&ioty,froms .map(&fo,{
            $h = fos&settletos;
            !hs&from and throw "nofrom"
            hs&current = ses&current;
            if (hs&current != hs&accepted || ses&bump) {
                me.settleblab and ~>4 set7 awaits: h.t, hs&from.t
                want(hs&from,'settled')
            }
        })
        delete ses&bump
    }
   
   // ends
    # checks $to/* (nodes below) are %halfsettled, returning non
    #  n may not immediately inform $to of losing it
    #   eg if tunneled into, no s Doming_7
    #    $from would think s still &settled,
    #     until $to:s wakes for:nodesabove
    me.settle_halfsettle_down = &acgts{
        $froms = sy&settlefroms;
        !froms and return []
        $N = fromss&nodes_below;
        !N and throw "missing &settle_71_halfsettle_down"
        $non = [];
        each in N {
            # check if ready
            $nse = ny&settled
            nse && nses&halfsettled and continue
            non.push(n)
        }
        return non
    }
    # ack $from<-$to
    me.settle_77_settletos_accepted = &acgtRprs{
        if (sy&settletos) {
            # $from:r accepts version of $to
            # < wanting to have seen the &settle,$to again
            #    or chase the dome that didnt do it
            $tos = sy&settletos;
            !tos and return
            me&ioty,tos .map(&h{
                #~>3 settle_7 accepts: hs&to.t, '<-', hs&from.t
                # $to sets current when settled (ish)
                #  which we started using, and now:
                hs&using and hs&accepted = hs&using
            })
        }
    }
    # Ying takes %%settles $from->$to
    me.settle_8 = &acgtR{
        $Y = Rs&Ying;
        $set = Ys&settles ||= Cye(['settles',1]);
        
        $rows = me&jaa,R,'settles';
        $c = {rows,k:'settles'};
        c.each = &h,from,to,ef{
            # all tos and froms
            # < no independent list of them is needed?
            #   since they always progress the settle when awake
            #   see %%settle <-> %%waits
            !(hs&to && hs&from) and throw "%%settles!s"
            #ac(set,'tos',hs&to);
            #ac(set,'froms',hs&from);
            
            if (hs&accepted && hs&current == hs&accepted) {
                $neu = !hs&accepted_boring
                hs&accepted_boring = 1
                if (neu) {
                    me.settleblab and ~>7 settled: to.t, '<-', from.t
                }
                return
            }
            
            # attend $to, probably
            me&ha,R,{waits:'settle',wants:to,for:'to'}
        }
        me&either_8,R,c;
    }
   
// 6 < frontends

  // &sustain causal effigy
    =sustain
       watch thing go true|changey
       tests: see Try@5
       phil
         $s|$c
          you may find lesser s|c
          <<< format can apply to them like ~$v
          usu ~$s dis-remembers $a, as does ~$c (except $v)
           they both ~> g.grouping
            except for s.*=ref, see RiceNonText
          perhaps grouping relaxes
           nearest ~~$s may have stuff to reuse
            eg a modulat to morph gently into the new purpose
            eg swapping into its position in a list
             < unclear how to do this now, not near doing it...
               &rec_traction more than once a Doming?
               rearrange wou%X.../z? (is mixed with others)
           ~~ might be a state machine
            allowing|expecting transfers|borrow of etc
             eg @Pro wants o W|lv from C
           see arrive, resolve $n
          the ~$changer|~~$samer #code/spec
           are changing|not
           ~~ is the perl smart match operator
           ~ shows oscillation, change impulsing
         ~$v
          < diff any value? watch for rate of change?
          < some format to decide whats interesting about it?
          < and -The to them:
           < Aline: the theory of selecting in|out from a set
              essentially drawing another s|c split
               after the one into less|more stable
               into an idc-ish $grouping (&bracko expr) to want to resume
                this could be per %%sute, %%supe, %%dome, %%sustain...
                they could all present shortcuts to the wanting visitor
         
         c.* incidentals
          <<< could mostly be:
          less grouping (after $k)
           loosens what could end up on n%*
           of $a that may have had it differently before
           n%* may go away since 'you may find lesser  s|c'
            # < do something meaningful about no more n%seeing
          as in not part of g.grouping
           until they may be needed to resolve a multitude?
            needs to be rowing &sustain
             widely, I:sustain compiles for-one I:i:sustain
             to be able to gather the information to resolve $n
           or we just demand your $s+$k(:$v)? should remember
          so
          we could say:
            s is most specifying
             what-for you are sustaining
              what btw you are sustaining is $a
               from an $n in the past
            c is looser
             except for that first $k
             see c.* incidentals
            
            and of any s|c
             c is usu quieter
              culture for the immediacy
             
            and of any c|s
             that if it is [AC].c|sc
              c is usu quieter all around
              c change could be deeply effective or not matter
            
            and of things that look vaguely s|c
             eg &axsimilate,ax,{n,x}
             eg &tc,'blah','6'
         
         
         what to n%*...
          the serialisable portion of it all
           anything beyond &sustain s+c?
            would be illegal to alter n%* without reindex
          supposing they could init with eg no Glance_i,
           but still function as the Glance they remember
          < digital readout of all %%sustains over time
            lots of coming|going findable from a.c|sc <-> s|c
            # more+more further
            < try top make the first ER.sc the Ec&pi it starts from
              (there is also Dc&pi it finishes with)
            < -Effect could &yio resurrect to new nodes
               each format would have c.* pick for whence
     
         # exploration
         < params could imply the format and more:
            &sustain $Item=$gat %%rhy=3
             the $v=$gat $k=Item
             %%rhy: - (c.|n%)rhy - loop occasional el2
            &sustain $Item=$gat %%rhy=3
            &sustain per'foot':$Item=$gat
             format=per with how|what
             sustains every foot of the guitars coming in ++$gat
              somehow, from stuff the per'foot' pulls in
            < I.per: to SQL sort|group|aggregate
              for io and everyone else
            Babz able to construct q.* about how these are
             knowing that for all|some scq, or via I.sustain
         
       fun
        &sustain s c q?
         i them
         %%rec=keyword(:$v)? (etc)
          causes this row to vanish if any same %%rec is reinput
           without also reinputting this via &sustain
           see RiceRun / they would have to %%rec separately
           < more, eg %%rec=keyword:pk:suchlike:etc
            # this is not expr:Cid
            format could o s|c.*, see Aline
          < gc a next time? &da,'sustain',9 ?
            see &rec_traction
            see # < note that we didn't get &sustain'd this time
          
         args
          s=idc
           more identity, ends up in a.*
            < format may allow some ~~ here
              and still remember $a
           non-text s.* is ignored, not in n%*
          c={Keyword:$v,...}
           the more stable identity
            < + mixing ...
           Keyword would never turn into another Keyword
            (and still remember $a)
            < perhaps borrow, see ~~ might be a state machine
           usu: ~$v -> el2
            re-originating $a
            $wasa may sink (drop in doming)
            < handle now? it may still resolve
          q
           time-format controls
           usu about ~$v policy
            eg q=2 keeps latest true v
            eg q=3 hakd(v,memv) -> el2 (new $a)
         
         remember by
          grouping = %%sustain,...s,rec,...c # lies:
           not non-text s.* (idc)
           not $v itself, to allow ~
           < perhaps not the rest of c.* after $k?
             see c.* incidentals
          arrive each if many
           by skipping wasny&future
            which it sets when entering $n
          
         ~$v
          decides el2, re-originating $a
          based on the $v format
           < could be anything
             usu looking at everything in $v=hash**
             but not the hash objects themselves
             or CODEs, etc
          similar to:
           using another $a as:
            $s
             its textual a.* becomes your identity
            $v
             will be inherited onto a.a=$v
              but not a.* = v.*
               see &axsimilates
             ~ as usual: see &sustain / if (ish(v))
           
         say sus:KeyWord, in expr:Cid
          eg sus:RiceDay
          eg sus:RiceDay:3
           3 is not $v but $day, part of &sustain s: the grouper
            https://youtu.be/6QImCMjW-PM
           assumes the grouper scheme is for all sus:RiceDay*
            same as eg %%rec=keyword:pk:suchlike:etc
            Xq may require k:v, in:
             < semipeel: using ; to join, instead of ,
               to embed peelable hashes into peelable Lines gv
         
         $v is monitored -> a.el
          < format for doing so
          usually true
           if false:
            initially: el10
             (no $n|remember)
            after true: el9
             once $n, thence el10
            after true if q=2: el1
             lets $v stop coming in
          change
           may el1|3|2 (ascending importance)
          usu
           el2 if $v!=$wasv
            re-originating $a
            your a.processes drop away like a forgotten dream
            < unwind them... see borrow
          
         a.el basically
          return a={idc,n,el:1|2|9|10}
           < el3 for ~ within some limit|diff|geo|Aline
          a.el<=8 is success
          a.el>=9 is not a sustained a
          
        $n = %%sustain...
         rolls a bit?
         would have to know what to put there in &sustain
        $a = %%sustain
         < a.done(...)
         
         < # < note that we didn't get &sustain'd this time
         
         < a.el=2 if given v != a.v
           how to ask for meanings of el:1,2,3,4...
            they affect grouping|separating the identity
           $v policy
            # numbers adjusted to coincide with q=2
            q=1:
             usu $v = already caching result
             so we may just wake up a process when el:2 or so
             eg %Diff%Comp or elIntro .gs: $v != $wasv
             eg such a C, will separate if osc decides it ~
            q=2:
             caching last true $v forever?
            q=3:
             we hakd(v,memv)
             < with memv part of that, cloning from the v
               we now look at wasv, which may be the same hash
             then:
              el2 if important ~
               definitely change to see
              el3 unimportant
               not meaningfully changing
                eg @elIntro could notice when we just typed comments
               still wakes yon &sustrain t
                unlikely to redo much further?
              el1 if no ~
               only backstage noise, eg:
               < ignore CODE and similar noise
                 $v might be another $a
               < dont wake yon &sustrain t?
                 can we redraw without waking? etc etc.
                  perhaps if a &supetime happens within it could
                   logic would join around the simplicity of the call
                    like @Gnome 8
             eg giving the grouper (t,of,species) to &sus tain s
              and the state-deciders (dige,ver) to $v
               so you can have the old v.* when they have changed
                putting the dige etc in the grouper would reset your (sus:) individual
             < isC(v) should q=3.1:
            q=3.1:
             heq() for v.* and v.*.* (or more)
             ignores v.* object change if v.*.* same
              this sympathies the recreate all parents strategy to ~ perc
               which could also keep the same C if you always check C.*
                for ~ within.
               then X:I can sit there bubbling away...
                you dive into anything that looks different
            q=4: may other()
             to do eg grep & brackstill, compute geometry, etc
             eg %Diff%Comp (==[)(++0 newfirst)(?+:1)(== wasfirst)
              the ++ being in an array ->
               all the i++ being tracked by low-im
             < or is 4 just 3 with the resurrecty of 2
               ie not losing a.writings
             the above qua ideation would have to be specified
              perhaps just saying 4 to the &sustrain $t y
              
           q
            may a.Xq... about $v, etc
             on any of its invocations of &sustain
           
         < may be used to build up some osc-think
            where &supetime is heading
             ie handlers for data+opportunity
              with sequences, A time
        
        
       o them
         &osus and &suso
          as in read sus, or sus read
           the latter sounds like it does more logic
            but not as much logic|authority as a proper &sustain
          we have three levels of self, other (&suso), alien (&osus)
           # tangent
           what if the universe was intelligent and we could teach it tricks?
            growing dimensions on the facts of life
        &osus
         o them, no logic
          basically &jaa returning (many?) a like &sustain does
         aka &sustaining
         < could probably be:
        <<<
        &suso
         o them, some logic
         < canonical otheration|observation of a, without giving $v
            perhaps for some perspective
        &suss
         o them all!
         < draw them, may be in a sute
           and germinate, a layer on &sustrain
         < @Gnome/&RunStep doesnt use this, but could
         < sort, history, reset, etc
            history based on wou? clone a** for?
         < notice pluralities per $grouping
        sus, suss in the dictionary
         suss INFORMALBRITISH
           verb
            realize or grasp (something).
            "he's sussed it" # good
           noun
            knowledge or awareness of a specified kind.
            "his lack of business suss" # strange
           adjective
            shrewd and wary.
            "he is too suss a character to fall into that trap" # odd
         sus INFORMAL
           adjective
            1.
            giving the impression that something is questionable or dishonest; suspicious.
             # good grasp of what these are trying to do
            "it's a little sus that he seems to know exactly how to play this game"
             # derriding competence
           *moire odious pamblem*
           (in biblical references) Susanna (in the Apocrypha).
         
    =cut
    # watch the thing, $v, until true|changey
    #  eg a = &sustain {} {latest_elQuip:e}
    #   remembers the latest a.v=e that was true, or est this one
    #  you may nc&drop them via a.done() or doming
    self.issus = a => ish(a) && a.done && a.pur && a
    me.sustain = &acgtscq{
       // remembering
        $h = me&hajasute
        s = peel(s)
        c = peel(c)
        num(q) and q = {num:q}
        if (q && q.num) {
            # the overall &sustain protocol! 1 is implied.
            q.num == 2 and q.resurrecty = 1
            else
            q.num == 3 and q.hakdy = 1
            else {
                throw "q.num?",q
            }
        }
        else q = peel(q)
        hak(q,'origin') && !issus(q.origin) and throw "q.origin!sus"
        !ish(s) || !ish(c) and throw "s,c"
        # keyword first
        $k = haks(c)[0]
        $v = c[k]
        # schemes given
        # this call
        $g = {s,c,q,k,v}
        
        # how to remember it
        me&sustain_grouping,g
        # remembering them
        me&sustain_remember,g,h
        # interpretation
        $a = me&sustain_vortex,g
        
       // $n
        if (g.el < 9 || g.entery) {
            # enter %sustain=a,...
            g.grouping.sustain = g.a = a ||= {}
            # a += c.*!$k > s.*
            # < how much of c.* to take... til q?
            ex(a,g.idc)
            
            # < Ay a
            #wasa and a.b = wasa

            # keep permit until done
            #~>7 entery:  el, g.rec, dis(g.idc)
            g.n = h.ha(g.grouping,c)
            
            # arrival claims wasn, see &sustain_remember
            $wasn = g.wasn
            wasn and wasny&future = g.n
        }
        # < eventually, its effect is noted on it over time
        #   by others (in sute) doing re-rec on ov++
        # < q might resolve $n c+s over idc
        $n = g.n || g.remember

        # < GONER, a is by now?
        !a and debugger
        a ||= ns&sustain
        !a and throw "!a"

        # know first time etc
        a.el = g.el
        (n) and a.n = n
        if (a.el <3) {
            # latest true value
            $v = n.sc[k]
            # if it wasn't something becoming a
            !g.housey and a.v = v
        }

       // < done()
        # we don't always &sustain what is sustained
        #  ie %%rec lets it glide along
        #   eg each %%RunStep is started only once by &sustain
        #    by a free-er will event, doesn't keep occurring
        #    then is fairly &sustain-indifferent
        #  so:
        # a.pur() is now-only, while you &sustain your something
        #  after a while it points to old R etc
        # a.done() avoids that problem by updating a.n
        
        # < gs.done('loaded','^')
        #   drops the &sustain leading to this as well
        # < a.done(s,T,e | t,expr), depending on async|not
        
        # on failure|enduring to complete it
        #  < pur after $k+$index? see &hajasute
        #    the pur changing lets loopier
        # < modulate marker of where this emerged
        #   to boxlink to the pur diag
        a.pur = say => h.ha(dex({pur:'sustain:'+g.rec},{say}))
        # revoke
        a.done = &{
            
            # a.n updates, see %%rec... copy to %%wou after
            $n = a.n
            !n and return
            nc&drop = 'done'
            # unless of course it's being sustained by another sustain
            # as in elIntro...RunStep
        }

        return a
    }
   // &sustain f
    # inherit identity from a|c
    #  eg another &sustain or &diffPs
    # < ongoing design. if a, we might have a.idc or so...
    #   wants non-text too? might have an A-ish inherit-if
    me.sustain_get_idcish = &acgta{
        return nex({},tex({},a),'el')
    }
    # how to remember it
    me.sustain_grouping = &acgtg{
        # how to dome it
        #  usu the first c.$k
        # see uses %%rec=keyword or keyword:$v
        $rec = g.k
        if (g.q.k) {
            # < name this param better
            g.v == null and throw "null pk"
            rec = cint(rec,g.v)
        }
        
        # how to identify it
        # all s.* and most c.* except c.$k
        #  what to group by, become a.*
        $idc = {}
        if (hak(g.s)) {
            ex(idc, me&sustain_get_idcish,g.s )
        }
        idc = nex(idc,g.c,[g.k])
        
        $tiel = {sustain:1}
        T.sute and tiel.rec = rec
        # use dome="rec:$rec" if !T.sute
        else tiel.dome = "rec:"+rec
        $grouping = ex(tiel,idc)
        
        ex(g,{grouping,tiel,idc,rec})
    }
    # arrive one of &zaa g.grouping
    me.sustain_remember = &acgtgh{
        # many at grouping
        # < call this a cohort? what about the subcohorts?
        $N = h.zaa(g.grouping)
        # ny&future is used in &rec_betractioned
        #  note h.zaa isn't &zaaj,
        #   and for h = &hajadome sees recycleds, see &dome_o3
        #  < may not be atomic if not %%dome
        #    the call from &dome_o3 particularly,
        #     yet not likely to have any effect
        # arrive one by one
        each in N {
            $a = ns&sustain
            # not exactly arriving:
            a.n == n and 'has been sustained, maybe'
            # arrived already
            ny&future and continue
            # arrive here
            g.remember = n
            break
        }
        !g.remember and return
        
        $wasn = g.wasn = g.remember
        g.wasv = wasn.sc [g.k]
        g.wasa = wasns&sustain
    }
    # interpretation of $v -> what $a =
    me.sustain_vortex = &acgtg{
        $v = g.v
        $q = g.q
        # overall state of a
        #  becomes el2 (if still el1) if a!=wasa
        $el = 1
        # what sustaining %%sustain:a is all about
        if (v) {
            # true
            if (ish(v)) {
                # may receive: v=gs={...} from some id scraper
                #  simple hash diff with wasv, may remake a in v's image
                #   < see mem
                g.housey = 1
                # may follow: v=a=&sustain
                #  < sync idc section to a.*
                #    or all textual v.*
                #     or to s.*? (before remember)
                #     ~~ &sustain,sus:Before,{After:1}, ie s=a
                $vsus = issus(v)
                # may be from q.origin instead of a|gs
                #  eg car send(gs) would v=gs and origin=sus:$car_i
                #   the v.* being just the stuff the innard passed out
                #  eg car send(sus:Dep) and origin=sus:Deps_i
                #   ie each Deps_i row may posit sus:Dep, to wait|act for a Dep
                #    and something above waits for all of sus:Deps to complete
                $fromsus = q.origin || vsus && v
                
                
                # how was it
                if (g.remember) {
                    $wasa = g.wasa
                    # wasa.n.sc.$k=v
                    $wasv = g.wasv
                    
                    # sanity in consistent type type feed
                    !ish(wasv) and throw "wasv!ish"
                    vsus && !issus(wasv) and throw "wasv!sus"
                    # < sharing $a between multiple cars?
                    # < needs to take a.b=wasa into account (on el2)
                    #q.origin && q.origin != wasa.a and ~>3 replant sus: k
                    
                    # compare v with:
                    # gs (random c)
                    $was = !vsus ? wasv
                        # prefer a.v (when a.a=q.origin)
                        : hak(wasa,'v') ? wasa.v
                        # or a.a = v
                        : wasa.a
                    
                    $same = v == was
                    # sameness via hakd() if q=3 (hakdy)
                    #   hash eq, mem was/* not in was incase v=was mutating
                    # < el3? then el2 can "really mean it"
                    #  < periodic extra hard shunts, randomly via Aip
                    #    cover everything every minute
                    if (!same && q.hakdy) {
                        $koff = hakd(v,was)
                        !hak(koff) and same = 1
                        else {
                            # perhaps it aint el2-serious
                            $idcish = !issus(was) ? was
                                : me&sustain_get_idcish,was
                            same = !grap(k => hak(was,k),koff)
                        }
                    }
                    if (!same) {
                        # new a. old one is via a.b (or g.wasa in here)
                        # < .drop() it now? may hook cleanup etc, as might ...
                        $a = {}
                        A.h and ~>7 originate: el, g.rec, dis(g.idc), dis(koff)
                    }
                    else {
                        # perhaps changey inside
                        $a = g.wasa
                        # spool the hash
                        # < mixing in ongoingly?
                        #   retracting what we mixed before if it leaves,
                        #    but not if it changed since we put it...
                        #   how you want $a to roll...
                        # < revoke etc see hash eq, mem
                        # < how much of it?
                        #    not its idc? got by n%* in a.*
                        ex(a,v)
                    }
                }
                else {
                    # is new!
                    $a = {}
                }
                
                if (a != g.wasa) {
                    # originating, for housey v
                    # < see sync idc
                    1 || !vsus and ex(a,v)
                    # < similar is g.idc (textual s)
                    #    should come before a.a|v
                    a.a = q.origin || v
                    # the !housey a.v=v later, via n%$k
                    q.origin and a.v = v
                }
            }
            else {
                # a value!
                if (v != g.wasv) {
                    $a = {}
                }
                else {
                    # el1
                    $a = g.wasa
                }
                # < ~ indifferent suchness, ac&voff
                # the !housey a.v=v later, via n%$k
            }
        }
        else {
            # false
            if (g.remember) {
                # going false
                if (q.resurrecty) {
                    # el1
                    $a = g.wasa
                    g.resurrected = 1
                    # see # latest true value
                    # < is c ours? and s... peel() should always clone hash
                    g.c[g.k] = a.v
                }
                else {
                    $wastrue = g.wasa.el != 9
                    $el = wastrue ? 9 : 10
                    # bracki the el:9 once?
                    g.entery = wastrue
                    $a = {}
                }
            }
            else {
                # not yet, pseudo a, no n
                $el = 10
                $a = {}
            }
        }
        if (a != g.wasa) {
            # originating
            el == 1 and el = 2
        }
        else {
            # sustaining
            fatal.ish(a)
        }
        g.el = el
        g.a = a
        return a
    }
   // &suss, &suso, $osus
    # less to more selfy
    
    # o %%sustain,$t
    # indifferently observe, returning $a+
    me.osus =
    me.sustaining = &acgtcs{
        $h = me&hajasute
        c = ex({sustain:1},pex(c,s))
        return h.zaaj(c) .map(n => ns&sustain)
    }
    
    # grasp, show in a table
    # < your &rowing adaptor
    # < controls etc for a.ov (rewind?), done()
    # < visuals, portals to Fe etc
    me.suss = &acgtsc{
        $h = me&hajasute
        s = peel(s)
        c = peel(c)
        # from %%sustain,yadda
        $iN = h.zaaj(pex('sustain',s))
        # sort by RunStep
        $sortby = c.sortby || haks(s)[0]
        $N = me&sortial,iN,sortby,'sort,flat'
        return N
    }
    
    # meaningfully observe $a+
    #  by selecting them, args like the aboves
    #  or by having $a+ already as s or c
    #   so s or c are free to be instructions
    #   instructions before|after the $a in arguments is nice
    #    could mean carry this out before|after self notices whats up
    #     two kinds of othering, eg T.wake or not
    #      before being stuff to do now, usu wont wake them
    #       eg their done()
    #      the after being more Effect|nodei
    #       although Effect may be mergible with some outer being
    #        eg &eCsc alters styles on the html without oscing it out again
    #  could be used by &sustain itself
    #   for centralising all the sustain|originate logic
    me.suso = &acgtsc{
    }
    
   // &sustrain gangs them
    =sustrain
      watch things go
       < capture the many to|froms per row
       < know when to stop along tos[]
      
      &sustrain ($train={ (i:N,)? ($t:$recv)+ })
       recv identifies a $car
        with hash about format etc
        and|or a callback that will send() us self for $t
      
      eg see elIntro
        &sustrain ({
            i: me&eis,'elIntro' ,
            elIntro: &yea{
                $gs = extract_identity(e)
                y (gs)
            },
        })
            here we iterate &eis (the step before it)
             having $e item on $a row
            y (...) rows the next step
           # so
            < .i/* are fed to every other?
              perhaps there is an _i per to
               which itself is rowing many actual %%sustain
            .elIntro finishes by defining itself, but could go on...
        then later, more
      lots
      of undecideds|refactoring
        the many
         A train
          ie many
         /car
          ie act|limb|time
         individually reachable
        
        the send() interface, $car/[io]
         send (gs) complete that self
          -> Thisact
         then just before feeding it to the Nextact:
          -> Nextact_i
         <<<
         each $car could sus itself and more
          all sorts of computer time could be divided from about here
           eg stitching up the rowing to group common sproutlings
           having output channels that know where theyre going
         so we have:
          ~:ii: two times of input
          ~:io: flow through the car
          ~:oi: flow between the many
            while they are paused or so
          ~:oo: flow from car-car
            in osc lang, between C** inside different J
             not the D|K** representations leaving it
             see each $car could sus itself and more 
        
        so we get 
         
        the many c&el
         el9|10 when done|off
          homology between: done is the end, off is the start
         el1|2 when on|changey
          el2 should push downstream
         <<<
         el3 when really changey
          should def push downstream
         el4 while waiting on sub-process (not this train)
         el5 while pushing to others (this train)
          they (others):
           receive susmail about el5 to them
           can tell el5 on anything they might 
         el6 when others receiving that
          set by the other?
         el7 when we are done getting answers
          scrolling the results should push el6 at the others,
           which means get more answers
        
         
         
        < model the whole elIntro process as one &sustrain
          usu later rows (of %%sustain) keep happening after i disconnect
          earlier steps el6 when completely on, waiting for return
           see also $v policy
          
         < multiple &sustrain share rows (all &sustain underneath)
           why not. othering in place
            or noticing this compute requires some self|&sustrain
             how to wake between node or within nodes
              a $sute may happen multiple times
               aiming|incidentally at different sub-processes each time
            # tangent
            even commit to %%wou
             such that r++ and wou++ have wrinkles
              wrinkle:
               versions of this between versions of that
                ie what you iron out in git-bisect
               may have more versions of r (if sleeping)
               may have more versions of wou (if othering)
    =cut
    # twostep &sustain!
    # < which came from where, timing for everything
    #    splosive X timescape
    me.sustrain = &acgt{
       // ta/$car/[io]/$a
        $h = me&hajasute
        $intime = 1

        return &train,{
            # many cars + an i
            $tos = haks(train)
            # < no i, substract first $car from other 
            tos.shift() != 'i' and throw "give input i=N|&{N}"
            # < cm hilight bug: {tr...} not green
            $ta = {train}
            each it tos {
                $car = ta[t] ||= {t}
                $recv = train[t]
                isfu(recv) and car.middle = recv
                else {
                    debugger
                    car.recv = recv
                }
            }
            # < these two are not that similar
            # ta/$t/i/$a=&sustain Glace_i
            # ie $car <- $s car:$ear?
            # < per to-sustain (usu one), depending on indent of $train?
            $tai = &car,s,ear{
                # < should we re-&sustain $a from another &sustain?
                #   we want another $a to spread the change
                $a = ish(s) && s
                # < might want more idc
                #   eg paginating through the act, or permasay
                $c = hashkv(car.t+'_i',s)
                # < are q.origin=a and v=a the same?
                $q = {num:3}
                a and q.origin = a
                T.sustabug == t and debugger
                a = me&sustain,{},c,q
                # dupey accumulator
                me&X_z,car,'i',a
            }
            # ta/$t/o/$a=&sustain Glace
            $tao = &car,a{
                me&X_z,car,'o',a
                return a
            }
            
            
       // i *
            # ta/$t/o/$a=&sustain
            $la
            #ta.Glance and debugger
            each it tos {
                $car = ta[t]
                # < many time++ around? recv.i?
                car.i and debugger
                if (0 == i) {
                    # i origin, may be empty
                    fuN(train.i).map(s => tai(car,s))
                }
                elsif (la) {
                    # ~:oi: clones sus:Laststep -> sus:Nextstep_i
                    $osus = me&osus,la.t
                    osus.map(a => tai(car,a,la))
                    # < osus <=> la.o might be empty, wind down from?
                }
                # can happen if train.i = []
                car.i ||= []
                # and when done drains the pipes
                !hak(car.i) and 'reap?'
                car.i.map(&a{
                    # < not always a.v, will always a.n.sc.$k
                    $v = a.v
                    # < what this interface should be
                    #   it has already defined $t, the key to put $v at
                    # &sustain args with c.$t=$v and c separated
                    $M = []
                    $send = &svcq{
                        !intime and throw "oot"
                        # s:idc, can be $gs, becomes v if alone
                        hak(arguments) == 1 and v = s
                        # %%sustain:a + non-idc
                        c = ex(hashkv(t,v), c||{})

                        q ||= {}
                        q.origin = a
                        q.num ||= 3
                        
                        # note: '$a =' here causes q.origin = undef above
                        a = me&sustain,s,c,q
                        M.push(a)
                        tao(car,a)
                        return a
                    }
                    send.ta = ta
                    #!v and debugger
                    v ||= a
                    # they send(gs)
                    car.middle (send,v,a)
                })
                # car.o traction? may be empty
                car.o ||= []
                la = car
            }
            # dome over - no async &sustain
            intime = 0
        }
    }

  // &Effect, their -Effect receives faster than %%eto
   // < doc
    # < tidy, test...
    =Effect
    
       i &Effect,from,to,t,c
        from - node
        to - node(..$E)?
        t - name of the cause, eg t='togcon' for qua='ope'
        c - first key is qua, sc.$gk to be aggregated
        
         e gets an -Effects @1
          z+c put into it, like nodey&efroms
           including distance to node from pi
         to has a timeframe to compute -Effects @6
          %%waits for it unless node is this-timed, not yet &Effected
          < robusticise that (Dome_7 checkup)
          < able to have an 'otherable outcome'

       o &Effected,to,c
        as above - receiving to as self
         eg -eight wants state of %ope, etc
        < other can receive ~ for it,
          if it has set up some thing to do,
           -pipe, %ein, A?, see 'othering wanted by Story'
        
        
      Used by Story to:
       shrink minor eights, with &togcon,
       $eight wants to use -eight to avoid -eight:
        < E:acheck: L%checking and !%%Checkable
        E:Ignored for %%Ignor*
        < E:shy until interesting:
         the $Test becomes interactive
          an e:click in any Dome should be noticed
         or wobbly - Failing
         or wandering off the end
         maybe until it becomes %%Checkable
          for maximum time to incubate style
        so
         a receptive Plot mode for going weird
         could be another system of:
       &Effect the acheck|Ignored|shy etc to -eight
       they resolve over the -eight%ope default
        and &togcon takes precedence if !null,
         deciding -eight%ope, through the same process
        so
         %ope=0 hides stuff
          eCsc dis:0 $seven+$four/Kn
           < noDisplay $seven
         %ope=1 shows stuff
          < may need to visit $eight to Display $seven
          < can occur by E:Failing $Test
           then E:shy $eight diminish (enlightening)
            we can adjust the %Effect...$qua without selfing?
             if permitted (self not using it somehow)
             since the brackindexing only knows having $qua?

       < those E:* &Effect-ings
       < -four %%step when shut?
       < -four clicking open, separating from -eight &Effected-ness
       < see 'otherable outcome',
         know when to visit $eight

       &Effected othering wanted by Story to:
         $Test has state of %wobbly,
           from $Eigh or whatever notices etc
          but isnt &Effected by it,
         $eight however,
          is, using it to &Effect more %ope (E:shy)
           ie it relays there when changed, etc
            as if $Test &Effect $eight,
        < so,
         how to get it to those self/others that are &Effected
         it relays %wobbly to senders of %ope, who use it
          depending on how it changes,
           and how they set up their &Effected endpoint
           eg %wobbly only affects $eight we havent passed,
            ie domes that contain the errors
           yet, that seems like leaking the time domain from Plot
          so maybe %wobbly is given directly to the $eight involved...
    =cut
   // &Effect in
    # < aq.nodes for aq.node_i
    # resurrectey spooler
    me.spoolR = &acgtEkRn{
        isC(E) and E = E.y
        $X = E[k] ||= {A:R}
        
        # find latest commit R
        $v
        $log = reverse(X.Rs||[])
        while (!v) {
            $r = log.shift()
            !r and break
            # that got finished
            if (ry&cv >= 0.9) {
                v = me&X_s,X,r,0,'R'
            }
            else {
                ~>5 spoolR popdead: r.t
                X.Rs.pop()
                X.R.pop()
            }
        }
        hak(log) <3 and 'keep some'
        else {
            #~>5 spoolR shiftold: r.t
            X.Rs.shift()
            X.R.shift()
        }
        $za = v ? v.z : []
        
        # see what this R has been up to
        $x = me&X_s,X,R,0,'R'
        x.z ||= []
        x.z.push(n)
        
        return {v,x,za,ha:x.z}
    }
    # < is node awake?
    # and Doming brack
    me.node_ispresent = &acgts{
        $j = sy&R
        # < is connected to &uptonode R
        #    Rc&N compare across R//E boundary (wants R&ip)
        return jy&cv >= 0.2 && jy&cv <= 0.7
    }
    
    # nearly an %%eto, maybe its own &either_
    # from: takes state to where it matters
    me.Effect = &acgtsetcq{
        !isst(t) || !c and throw "give from,to,t,c"
        # from as self: Ringing and awake
        $j = Cy&R
        $z = jc&s
        z != s and throw "from!Ringing"
        # from a node (< pi)
        $from = s
        !sy&path and throw "from!node"
        $fnode = s
        $fpath = me&tpath,fnode
        $fpith = ''
        
        # to a node, or any pi beyond it
        $to = e
        # gets -Effects @1 (~ toy&efroms)
        #  on to, other to j (from's)
        $E = me&piEffect,j,to
        
        # i E/fpath:node/fpith/t
        $Et = me&Effect_i,E,fpath,fnode,fpith,t
        $Ep = Ety&up
        # have we everything from this node yet?
        #  see resolve $n
        # j Effects[] -> e
        # 
        # < &brackstill repeatedly as the list of Effects fills up
        
        # leaving a &wants to &not when complete is fine
        # < &brackstill parts so far, against copy from &Effected
        # c qualia mix in, shade
        $n = me&ha,j,{Effect:t,Eto:to},c,q
        
        # adding n%%Effect,... to a list that za-ha per R
        $la = me&spoolR,Ep.c,'Rave',R,n
        
        $cha = me&brackstillzaha,la
        $want = la.x.want
        $chat = cha ? "~" : "=="
        #~>5 spoolRave: hak(la.za), chat, hak(la.ha)
        if (!cha) {
            if (want) {
                wantc&drop = 1
                delete la.x.want
            }
            # done, until maybe extra
        }
        else {
            # is change
            # < or periodic fuller wake
            $toR = me&uptoR,to
            # the Effected R is waking
            $waking = jc&N.includes(toR)
            $unEffected = !(Ey&R && jc&N.includes(Ey&R))
            if (waking && unEffected) {
                # awaits &Effected
                # < more certainty about whether it can still happen
                #   Ep remembers all &Effected calls? assume then again?
                # < can probably be woken from anywhere not already woke?
            }
            else {
                # < not noising the brack here (direct to R:Ying)
                # < waits_8 noticing if it did wake (just not yet)
                !isC(toRc&s) and debugger
                if (!want) {
                    la.x.want = me&wants,j,'Effect',toRc&s
                }
            }
        }
        # < compute now if already &Effected
        #    diff -> wake e
        #     unless it's otherable (%ope=0 -> dis:0)
        'ya'
    }
   // -Effect io
    # < io space
    # at both ends of the deal
    me.piEffect = &acgtRsc{
        c ||= {}
        
        # E rolls from under the previous s-eight
        $trip = {t:'Effect'}
        $re = me&pisurrect,R,s,trip
        
        # so we can reuse it
        # < el:4 defies el:2 above to be el:3?
        #   then &Api could handle the -surrect
        c.el ||= 3
        $E = me&Api,s,'Effect',c
        re(E)
        Ec&tpith = trip.tpith
        
        return E
    }
    # E/fpath:node/fpith/t
    me.Effect_i = &acgtE,fpath,fnode,fpith,t{
        $Ef = me&fiu,E,fpath
        me&must_newnodesamepath,Efc&node,fnode
        Efc&node = fnode
        # < from pi, would put onto:
        $Ep = me&fiu,Ef,fpith
        # remark, eg 'acheck'
        $Et = me&fiu,Ep,t
        return Et
    }
    # %Effect:$t,... rows from the above
    me.Effect_o = &acgtE{
        # the -eight
        $e = Ey&up
        $M = []
        me&ioty,E .map(&Ef,{
            $from = Efc&node
            $fj = fromy&R
            # we have senders with remarks
            $fempty = 1
            me&ioty,Ef .map(&Ep,{
                $empty = 1
                # E/fpath:s/fpith:E (Ep) targeted brackstill group
                $pistill = []
                me&ioty,Ep .map(&Et,{
                    # the node must still be sending it
                    $N = me&jaaz,fromy&R,{Effect:Et.t,Eto:1}
                    # %%Eto is eg s-seven//E-seven, which replaces
                    #  but re-finds its Effect
                    N = N.filter(n => E == ahsk(n,'sc','Eto','y','Effect'))
                    # < the node might el=2 (replace)
                    # those y&Effects may have same tpith, differ in fpath
                    #  ie tpith=-Fez, yet fpath says y&up=suchathing-six
                    #  < slope|pile short name for E**, say if not y&main
                    if (!N.length) {
                        # or is de-applied
                        return me&fiu,Ep,Et,9
                    }
                    empty = 0
                    M.push(...N)
                    pistill.push(...N)
                    # < &brackstill on Ep? Ef? sortably?
                    
                })
                empty and me&fiu,Ef,Ep,9
                else { fempty = 0 }
            })
            fempty and me&fiu,E,Ef,9
        })
        return M
    }
    
   // &Effected out
    # to: user wants qualia computed !
    me.Effected = &acgtec{
        # e  the s** or E** to receive on
        $se = me&uptonode,e
        $J = sey&R
        # someone Ringing and awake
        #  might be -Fez (jc&s = data)
        #  eg &Piing may -Effected //E to configure (eg ope:0)
        #   in this case we are other to the E, but know what it is
        $j = Cy&R
        # < R'The' doing -Effected
        js&Pier and debugger
        # might be the self
        $R = ey&R
        !R and throw "to!node"
        $self = R == j
        # see &node_ispresent
        
        # gets -Effects @1 (~ toy&efroms)
        #  on to, self to j (unless other)
        $E = me&piEffect,j,e
        $M = me&Effect_o,E
        c.M = M
        
        self and Ey&R = R
        !M.length and return
        
        c = peel(c)
        if (c.go) {
            me&nu,'-Effect',E
            $Ms = M.map(m => m.sc)
            me&nu,'Ms',Ms
            me&nu,'Je',{se,e}
        }
        
        # all modes take many values of gk=ope
        #  and eg mode=num makes lav=most-wanted-%ope
        c.gk ||= haks(c)[0]
        c.mode ||= 'num'
        $lav = me.Effectsum[c.mode](A,C,G,T,c,M)
        c.v = lav
        
        if (me&node_ispresent,J) {
            # copies to %%Effected on the destination...
            me&ha,J,{Effectsum:1},c
            each in M {
                # < able to be from //E
                $Efrom = ny&R.c.s
                !isnode(Efrom) and debugger
                $ed = ex({Effected:ns&Effect,Efrom},n.sc)
                delete ed.Effect
                me&ha,J,ed
            }
        }
        
        # <
        if (self) {
            # -Effect visiting
        }
        else {
            $trip = {}
            $to = e
            $tnode = me&uptonode,to,trip
            $tpath = me&tpath,tnode
            $tpith = me&pipath,to,trip
            # other, using qualia from this somewhere else
            #  is this nodeo|da?
            # setup forwarding address for z:
            #  such that Eigh &Effect Test %%wobbly
            #   does eight &Effected Test %%wobbly
            #     based on the one that already exists
            #    which visits eight to:
            #    eight &Effect -eight %%ope
            #     then &Effected -eight %%ope
            # any of that might be doable as other
            #   if it wasn't for me&ha,j,{Effect...
            #  or avoidable
        }
        # probably a third way,
        #  gauging update for an &Effect
        
        return lav
    }
   
   // &Effectsum reckon 
    me.Effectsum ||= {}
    # < .uniqe also, returns like a leaderboard. ie .num returning many
    # return all qua given
    me.Effectsum.uniq = &acgtcM{
        $k = c.gk
        !k and throw "!gk"
        $N = []
        each in M {
            # v is the posited qua for lav
            $v = n.sc[k]
            v == null and continue
            N.push(v)
        }
        return uniq(N)
    }
    me.Effectsum.num = &acgtcM{
        $qua = c.gk
        !qua and throw "Effectsum.num: !c.gk"
        $lav = null
        $votes = {}
        each in M {
            # v is the posited qua for lav
            $v = n.sc[qua]
            v == null and continue
            !num(v) and throw "Effectsum!num"
            $N = votes[v] ||= []
            N.push(n)
            
            ns&dom and lav = v
        }
        if (lav == null) {
            # if no %%dom-inant state (&togcon adjustment)
            $lalength = 0
            each vN votes {
                # favour more votes
                N.length < lalength and continue
                # or more positive votes
                N.length == lalength && v < lav and continue
                lav = v
                lavlength = N.length
            }
        }
        return lav * 1
    }
    me.Effectsum.includes = &acgtcM{
        $s = c.s
        !s and throw "Effectsum.includes: !c.s"
        $N = M.map(n => n.sc[c.gk])
        return N.includes(s)
    }
  
  // < &nodei|o|e - makes %%eto..., going somewhere
      // nodeio-doc 
       =elvis
       focused on:
       &nodeo - reading %%ein C with Q, immediate return
         maybe there are handlers
         an inter-node o backend
       &nodei - transports via %%eto, wanders off
       < conversely:
       &nodeo might turn into:
        i %%e:hunter who will bring back the goods
       &nodei might merely:
        find %ein serving async, immediate return
       
       &nodee,to,t,a,q
        is &nodei $to %%e:t,...q
        expecting %%efrom:to,e:t,...a
         supposing $to:
          &nodeein,t,&from,q{produce %%a-ish}
           which &nodei back to $from
           including %%e
       basically,
        $from %%stuff -> $to, esp if diff
        comes back to $from once &settle,
         or sooner if $to %%answer -> $from
       usu. &nodei,
        moving intention around
        ie,
        gets delivered, revoked
         attend when different, by way of:
       
       brackstilling
        has %%stuff changed?
        if still:
         &nodee can same answer same question
          immediate return potential
        if diff:
         the $to must attend,
          returning to $from once &settle
           or sooner if $to &nodei back to $from
          all %Ying managed
        helps:
         receivers of %%efrom,...
          eg CBing (value contest/news)
          accept versions of it when ready
          see 'check CBing &nodei is as it was'
          could -%%e%done or +%%rebase if diff
           if &nodeein +%done it when done
           or %%rebase = prescribed differencing,
            is applied, via a big-deal filter, eg:
              a %Compiling in its push-phase,
               can decide to redo, because CBing, already
               depending on the algorithm (||= C percolation)
                to be able to tune inputs near the end of their workload
                including just after it,
                 if the answer is invalidated
                is nice reflexive terrain
       
       eg.
        $from = a %Compiling sequencing operations:
         makes Know%fully and selects %%Live
          $Live = &nodee $to %%Live %%e:fully
           and e:fully is ein there, subplot:
            an anyone-elected %acty=3
            must produce %%Live,
         
         $from %%waits for a response?
          or %%fail if e%edone and !%%Live
         
         $to avoid doming their 'main thing'
           eg CBing
          until all %%e%done
           would new CBing before $from receives %%Live,
           so $from receives also the new CBing,
            bound to the %%Live used for thinging
       
       =elvis
      
      // &nodei
        # moving intention around
        #  row = c(identifying marks) + o(other stuff)
        #  so c finds the rolling %%eto,
        #   %%e may resurrect if %%dige
        # < require %%dome? as T.Mw?
        me.nodei = &acgtj,to,c,shade,mix{
            
            # < bracko C.t == t
            $js = jc&s
            to == 1 and to = jsy&path[0]
            $jo = toy&R;
            to = joc&s;
            # c can be a row, pipelined
            $s = isC(c) && c
            s and c = s.sc
            else
            isst(c) and c = G&peel,c
            c = ex({},c)
            s and haks(sc&shade).map(k => delete c[k])
            isst(shade) and shade = G&peel,shade
            isst(mix) and mix = G&peel,mix
            mix = ex({eto:to},mix||{})
            # %%eto:to,e:C:question,...details
            $q = ex(ex({},c),mix)
            shade and ex(q,shade)
            
            # good details resurrect the same %%e,
            q.dige && q.e and q.e = 1
            $sending = me&ja,j,q;
            
            if (sending) {
                sending.length > 1 and throw "cant tell %%eto apart"
                $n = sending[0];
                c.e && !ns&e and throw "bug"
                if (ns&e) {
                    !c.e and throw "bug"
                    $e = c.e;
                    # < !e%done when slightly changing
                    c.e = ey&resurrected = ns&e
                }
                # re-enter $n for instant &dome_bracki replace
                # < pipeline !growing as it stays still, y&up?
                heq(c,n.sc) and c = n
                q.e && s and throw "mix.e & reenter s unless ny&up=s?"
            }
            # < %Ying relays progress via %%eto?
            #    maybe if we %%uniq this it would return the recycled one
            #   or just via e, how else?
            # must drop s%eto|efrom inside &ha
            #  to let it know its origin
            s and c = s; mix.nodeial = 1
            $n = me&ha,j,c,shade,mix;
            
            return n
        };
      
      // &nodeo
        # S o $remote/#$Q using|returning %%tw,...
        # < persistent query, knowing io it pipes into,
        me.nodeo = &acgtj,to,Q,qe{
            
            $qs = isst(Q) ? {tw:Q}
                : isC(Q) ? ex({tw:Q.t},Q.c)
                : Q
            qe ||= {}
            isst(qe) and qe = G&peel,qe
            $jo = toy&R;
            if (jos&Pavings) {
                qs.of == 'wjs' and qs.of = 'w'
            }
            to = joc&s;
            $N = me&za,jo,qs;
            if (!N) {
                $N = []
                if (qe.el == 1) {
                    # will create it
                    N = [Cye(["nodeo:el:1",1,{},qe])]
                }
                else {
                    # permission is nodei'd in (by now)
                    N = me&jaa,j,'may:input,s';
                    # once an other sees that we:
                    me&ha,j,'may:input,s';
                }
                # we have Qish to tw
                # < input s, clone if sy&path not ours
                # < &may -> %%may,answerlike,question
                #   might look different when (un)answered
                #    eg. %%waits, %%has (done so), %%is (doing) 
                #    and mode stay on, do once, etc
                #   here it will do once and stop being called:
                # me&may,j,'input','s',{tw:Q.t,waits:'not-found'},qe
                N.map(&n{
                    ~>3 CREATE: ki(n.sc,4.23)
                    # < use %Pavings%ein to input
                    if (jos&Pavings || jos&Paving) {
                        if (qs.of) {
                            # look for an of island (even if of=W)
                            $of = me&ioty,to,'Pavings'
                                .filter(of => ofs&Paving == qs.of) [0];
                            of ||= me&fiu,to,qs.of;
                            ofs&Paving = qs.of;
                            ofs&Pavings = 1;
                        }
                        else {
                            # $to/$W direct
                            of = to
                        }
                        $t = me&fiu,of,qs.tw;
                        # info
                        me&ha,j,{waits:'input',wants:to}
                        # listen to to
                        me&settle,j,to
                        # < pointers at not yet nodes
                        toy&p and jos&numberclicked = 1;
                    }
                    else {
                        debugger;
                        #me&fiu,
                    }
                });
                !N.length and me&tsc,'nodeo:'+qs.tw+':el9','non';
                # for %%waits:input first
                return []
            }
            if (N.legnth > 1) {
                # in the web you would want many answers,
                #  perhaps candidates get see s** to rank/sync
                me&tsc,'unc';
                me&waits,'unclear'
            }
            return N
        };
      
      // &nodee
        # %%e:action, expects reply re the same %%e
        # see &nodei re c+o
        me.nodee = &acgt,j,to,t,a,c,o{
            
            $jo = toy&R;
            to = joc&s;
            c.e = t;
            # %%eto:to,e:C:question,...details
            $n = me&nodei,j,to,c,o;
            # reuses e if %%dige 
            $e = ns&e;
            !isC(e) and throw "nodei!%%eto,e"
            # answer could be:
            # %%efrom somewhere answering %%e
            $replying = me&ja,j,{e,efrom:1};
            # anything( somehow)? answering %%e
            # < except $n or its recycling, which may lurk
            #    unless nodei 'slepish let'
            $an = hak(a) ? me&ja,j,ex({e},a) : n;
            
            if (es&done) {
                !an and me&ha,j,{fail:'done',e}
                else {
                    if (hak(a) == 1) {
                        # eg returning %%Live sent back
                        an.length > 1 and throw "many rows"
                        return an[0].sc[haks(a)[0]]
                    }
                    # rows returning from this %%e
                    return an
                }
            }
            else {
                # waits?
                # %%eto hoisting should gently hurry up etc
            }
        }
      
      // < &nodein
        # %%e:handler, sync response
        #  %Ying will otherwise attend $to
        me.nodeein = &acgt,j,t,cb{
            # for e:t into j
            # cb = &from,q{produce %%a-ish}
        }
      
      // nodeio-scussion # further into %Compiling 
       =elvis
       # Know etc means a Know/** node
       # and that &nodei somewhere revisits somewhere
       Know builds tw, &settle
       Know have clients for CBing
        Ghost &nodeo Know their thing,
        Ghost &nodei Know their downstreamness,
         Ghost%dige if not as Know%dige implies
       Know !Ghost, 
        %%may create some Travel/$t c&W=Looking of it,
         to start doing something
       Know CBing per downstream,
        &nodei Ghost %%cha,
         which Ghost &nodei Travel %%cha
       and in reverse: Know <- Ghost <- Travels
       
       Travel/$W,
         receives CBing &nodei %%cha,
          - decides to update itself,
          - gets the inputs ready,
          - runs the thing,
          - tractions a bunch of $n/$u etc
            artifacts to save
             by way of a %Search that accepts writes itself,
              then presenting a tree of things to:
             n all G&t it put, push to That/**
              a downstream Know, non-CBing
              < via another %twin
             u all G&t it used, to Know/**
            push must:
             check CBing &nodei is as it was,
               so a %%rebase might emerge to Travel/$W
                in/near &nodei brackstill
               which our work (bunch of %%e:push) hangs off
              ie know Qs&parent on push,
              different:
               $n - %%rebase strangeness,
                 our downstream changed without us
               $n+$u - Travel/$W again, must know current
                 eg $W loading/saving itself
               $u - new input since Travel/$W
                 eg %dige can CBing again after we push
            if push:
              push all $n, That/**%%e:push,n (->%Paving->G&t)
              note all $u, Know/**%%e:pulled,u (%dige = that used)
               disimplying Ghost/*/**%dige must be expressed
                  semi-syncd Ghost mappings should be resolved after Travel/$W
                   until everything is aligned with Know/**,
                   might end up chasing loops,
                    diff the Travel of several $W in time
               
            $n/$u sets for %twin/$W/* may be canonical or not
             when its not invoking all the G&t the $W gets up to
               
            ideally all those G&t + W:KnowThee%Ying itself
             are in an Over%Search
              branching things for KnowThee
              to be merged with the Uber%Search above that,
               saving each thing,
                can sorta undo if interrupted,
                 from memory or Uber git reset
               < getting the new tree of changed things ready,
                 then commit just changing a link
             
            then!
            back to:
            CBing &nodei as before, since the %dige is out
            which might be real fast since the gear
             is all ready to pass another %Live through
      
       =elvis
      
      // nodeio-Yingu-scussion # sort activity
       =elvis
       underneath &nodei:
        $from &nodei $to %%stuff
         put into $from%%eto:to,stuff
        %Ying hoists %%eto,stuff
         &brackstill-ing %%stuff
          attending $to
       # < Yingterms:
       #  < need tests for all this. compiles tests <-> docs
         then (once $to &settle or sooner or later)
          attending $from
         sooner if:
          %%e - &nodee suggests a round trip:
           e%done or the question solved means return
           $from exacting %%eto:to,e <-> %%efrom:to,e
          $to &nodei $from, related or not, attends $from
           as in returning a row to find the question in
           < should it merge with the from?
         later if:
          %%e - !e%done etc, the above in reverse
          !&settle,
           see 'not accepting CBing while busy'
        
        if %%eto,dome=questions,
         persists them, as usual
          you periodically refreshing %%dome
         if %%dome, could anyway, see %%dome ttl
         
         hoisting progress could appear on it,
          eg $to accepted, then &settle
          the hoisting-out could be a Y,
           involved for $from dome init,
            and $to delivery, or anything
       
       ecoursing:
        where the e takes us/our stuff
        eg c&el makes adjustments on some $to ground,
         probably the same %%dome as the $from
         or to a corresponding idea:
        $to %%efrom,dome=questioned
         to wakey the $dome part of $to,
          like routes
        re %Slope:
         they plumb somewhere else,
          that $from can detect the state of
           follow our affect through the machine
           eg wanting to watch Babz %Compiling
            to bring meta back to the ghost
            ie cursoring details transient in the process itself,
             rather than even biggering the result
         $e might:
          encode and wander the network meanwhile
           coming back to pick up that $e again,
            contracting some %Search to keep a way in:
             matching a rebooted %%eto
              by brackstill == that $e that left
       
       =elvis
   
  // &bready - if no %%waits
    =elvis
     &waits,... -> R%waits
     &bready and return # implements a waitsology
      R%waits -> %%waits
      %%wants:$n%%waits -> %%waits:wants,...
      %%waits -> pause|shy $R
       and inners, unless $n%%waits,
         or %%waits:wants them,
         fuzzy line? who is waiting for who
         top down if same cv?
       might be a recognisable solution
       might be retry loop,
       do others first (moreso if %%waits:wants)
    =elvis
    me.bready = &acgtR{
        # got to via %%wants:R below
        !Rs&wou and throw "notbegun"
        # R%waits -> %%waits
        each in Rs&waits {
            me&ja,R,{waits:n} and continue
            $h = me&ha,R,{waits:n}
            hy&waits = n
            ny&waits = h
        }
        # %%wants:$n && n%%waits -> %%waits:wants,wants:$n
        #  $n may be a non-node R
        me&jaa,R,'wants' .map(&n{
            $z = ns&wants;
            ns&waits || !isC(z) and return
            # once
            nc&breadied and return
            nc&breadied = 1
            # could be p/r/s
            $j = zy&R;
            $q = {waits:'wants'};
            # R:Pave passes through as %%wants
            isR(z) && zs&ball and z = jc&s;
            !z || !zy&R and debugger;
            # decide if %%wants should %%waits
            if (!js&wou) {
                q.notanode = 1
                js&waits and me&ha,R,n,{},q
            }
            else {
                # < unpossiblate infinite recursion
                #   with me&ind bit on the T?
                me&bready,j and me&ha,R,n,{},q
            }
        })

        # < %%waits -> pause|shy $R
        # avoiding the rest of the activity
        return me&ja,R,'waits'
    };
        
  // &settle
    =elvis
     &settle,z and return # waitsology for z to seem ready
     
     &settle sets/checks a node that is:
      relative to this node, which wants it,
      &node_issleeping, not able to unsettle this time
      < not pending elvising:
        as in %%wants:n,acty:1,settled,
         unless %%acty has transmit
      &halfsettled @7:
        &bready,
        &brackstable: ja == za
      and:
       nodes below are at least &halfsettled
        eg: Settled/Unsettled/Chaos
         where Chaos is not &brackstable etc but Unsettled is
       < should be able to climb bunch of index then a node,
         'nodes below' meaning the next layer of nodes beyond!
    =elvis
    me.settle = &acgtRr{
        R = Ry&R;
        isar(r) and return r.filter(n => me&settle,R,n ).length
        
        if (!isR(r) && isC(r) && !ry&R) {
            $to = r
            # node that never was, should turn up if we visit sy&up
            $ru = toy&up;
            !(ru && ruy&R) and throw "settle,R,s not connected enough"
            me&wants,R,"newnode",ru
            # and come back here, as if we had settled it
            #  turns out we can set up sy&settle* before visitation:
            !me&ja,R,{settle:to} and me&ha,R,{settle:to}
            return 1
        }
        r = ry&R;
        $from = Rc&s;
        $to = rc&s;
        # log it, via &settle_6|8 + Ying to transport
        !me&ja,R,{settle:to} and me&ha,R,{settle:to}
        # < that and this still working if sleeping
        $comeback = &t{
            me&ha,R,{waits:'settle',wants:to,for:'settled-'+t}
        }
        # is figured at Doming_7, once est.
        $se = toy&settled;
        $settled = se && ses&settled;
        
        !settled and comeback('not')
        else
        # check these two loose-able aspects
        # not happening now:
        !(me&node_issleeping,R,r || Rc&N != rc&N) and comeback('!awake')
        else
        me&settle_halfsettle_down,to .length and comeback('!down')
        else {
            return 0
        }
        return 'not settled'
    }
    # settle all previous siblings
    # for 3 &settle 2,1, for lack of:
    # < settle deeply, 3 &settle 2 &settle 1
    me.settle_prev = &acgtR{
        $N = me&ioty,Ry&up,'ball';
        $ri = N.indexOf(R);
        ri < 0 and throw "upz%ball"
        $prev = N.slice(0,ri);
        !prev.length and return

        me&settle,R,prev and return 1
        Rs&settled = prev;
        Rs&brackstable_aware = 1;
    }
    
  // < &acting, &acty, &wants
    # a heading for some %Part of it
    # < swallowing brack
    #  < knowing T.act here and when ha
    # acty:8 meaning dialectical,
    # acty:1 would be openey,
    #   buttons for the first layers of mind atop
    # they are cv-ish, yet individual doables...
    #   %%may:ha,openey:1,acty:1 - advertise route
    # then just increase %%acty to wander in to things
    #  eg when depending on something being awake
    #  eg acty=5 might be enough to know expected Wup affects
    me.acting = &acgtRty{
        R ||= me&R
        !t and t = T.act.t; me&reaw,R,t
        y == null and y = 1
        y and me&inode,R
        $go = me&rolltog,R,{may:t,tsc:'l',acty:8};
        if (go) {
            R.sc['go'+t] = 1
            $x = me&Jx,R
            $s = Rc&s
            $ot = t.match(/^-?(.+)/)[1]
            $named = s.y [ot]
            if (named) {
                # othering as %ball for verbosity
                # < know when -eight is sprawling open,
                #   to stop at -seven if it doesn't $go
                $name = 'sy&'+ot
                x.ro(name,{}) and me&bal,name,named,'eph'
                else { me&nu,name,named }
            }
            me&nu,'s',s
        }
        return go
    };
    # $from &wants,'msg'||c,$to -> %%waits:$msg,wants:$to
    # < $from -> $later? test the effects
    me.wants = &acgtRtsc{
        !isst(t) and throw "ct"
        c ||= {}
        isst(c) and c = G&peel,c
        c.waits = t
        c.wants = s
        me&ha,R,c
    }
  
  // &quiet_waker*
    # management nodes wake up when all is quiet
    me.quiet_waker = &acgtR{
        Rs&quiet_waker = 1
        me&reaw,R,'quiet_waker'
        $Y = me.cbu(R,'Ying').sc.Ying
        $s = Rc&s
        Ys&quiet_wakers = [s]
        #ac(Y,'quiet_wakers',s)
        # may be having one
        $is = delete sy&quiet_wake
        is and Rs&quiet_now = 1
        is and Rs&is_quiet = 1
        return is
    }
    # to see if eg Gump is quiet_now from Gump...Gome
    #  Gome may be tunneled on its own (false)
    #   or being %wakeful from Gump%quiet_now (true)
    me.is_quiet_now = &acgts{
        # to the latest R, possibly tunneled-through?
        $r = me&yfuture,s
        return rs&is_quiet
    }
    # do something when nothing
    # < not before a slow wakers[], for async
    #    may finish waiting early
    me.quiet_wakers = &acgtR{
        $Y = Rs&Ying
        $D = Rs&Det;
        $would = Ys&quiet_wakers;
        grepout(would,s => sy&invalide)
        !would and return []
        $wakers = []
        $quiet_recently = &s{
            return me&wokerecently,R,s,5,{quiet:1} .length
        }
        # quiet,wake when not recently
        #  or if next page == Plot%wants_upto, must self to act
        $y = Ys&quiet_wakers_too_recently
        if (would.filter(s => !quiet_recently(s)).length
            || y && y (R)) {
            would.map(&s{
                # < Yinge terms:
                # is consumed:
                sy&quiet_wake ||= 1
                wakers.push(s);
            })
        }
        else {
            ~>5 quiet_recently: joint(would,'+')
            me&bracki,R,D,{quiet_recently:1}
        }
        return wakers
    }
  
// 8 < round
 // %%waits 7 - visit other nodes
    # r%%waits,wants=z,... -> R &waits_8
    #  from &settle, &bready, or you
    me.waits_7 = &acgtRr{
        $s = rc&s
        # &bready finalises and returns the %%waits
        $waits = me&bready,r || []
        waits .map(&n{
            # %%waits = R%waits/$D
            $D = ns&waits
            D = isC(D) && D
            $q = {via:s}
            
            D && sex(q,D.sc,'say,sooner,momentarily,later')
            if (!ns&wants) {
                # usu from just &waits
                #  lets explicit %%wants happen first
                q.wants = s
                q.momentarily = 'nowants'
            }
            
            $z = ns&wants || q.wants
            if (ns&notanode) {
                q.sooner = 'notanode'
                ~>3 notanode: s.t, z.t
            }
            else
            isR(z) and ~>3 wantsR: s.t, z.t
            
            # -> Ying waits_8
            $h = me&ha,R,n,{},q
            D and Dy&waits8 = h
            ny&waits8 = h
            hy&waits = n
            
        })
        !waits.length and rs&isbready = 1
    }
 // &Ying_8
        # Ying done, orgs comeback
        #  R%Ying Domes_o3 but not _7
        #   except to have za commit
        me.Ying_8 = &acgtRs{
            me&node_accept,R,R,s;
            
            # across Ying
            me&etos_8,R;
            me&settle_8,R;
            # Ying around
            me&waits_8,R;
            
            # < Yingu may stepbrack Ying itself
            #me&node_issleeping,R,R and return
            #me&stepbrack,R;
        };
    
// &waits_8 - regroup around
   // &waits_8
    =couldbe
     Ying waits_8   wakers order re &settle
      dribbling awareness in waves to Ying
     
     a $to-before-$from separator,
      as long as theyre both in $wakers[]
      !&settle $to doesnt block $from, see 'waitsology'
     
     a lifo of $froms awaiting &settle
     
     something to do when !wakers
     
     < study errors
     
     < packs ($to,$c:term?)+ for Ying, pass nuance per $to
     
     one day:
     < &settled, or just &settle with no $to
       true if $from is waiting for any $to
       would cause an extra 'onemore' (after %brackstable)
        to experience being %settled
     
     < guarantee the eventuality,
        check every Y%settles %from?
       to catch up lost|tangled impulse:
       $from|$to generate 8%%waits:settle,wants:each other,
        $from 
         &settle_6 - wants $to to &settle
        $to
         &settle_7 - checks for &settle
          pushing &halfsettled to children
          versioning %wou for:
        $from
         &settle_7 - accept $to &settled
       can get distracted with settle-stacking, unless lifo?
     
     < loop detect !sooner && !later
        go for least conflicted, earliest in Sy&N
     < instant Yingu innard, style of collapse into time
     < partition into several single-minded Yings,
       for atomicity,
    =elvis
    me.waits_8 = &acgtR{
        $Y = Rs&Ying;
        $set = Ys&settles;
        
        # < brack all this, esp about tpath
        # getting more later:
        $sooner = [];
        $wakers = [];
        $momentarily = [];
        $later = [];
        $stashed = ['laters','momentarilys']
        each ik stashed {
            $M = Y.sc[k]
            each iN M {
                # may have happened anyhow
                N and grepout(N,n => me&Detectioned,R,n )
            }
            M and grepout(M,N => !N.length)
        }
        $freeze = [];
        
   //     !%%wants|!node
        $ignore = [];
        $tpaths = {};
        $tpath_s = [];
        $tpath_ = [];
        $tpath = &s{
            $si = tpath_s.indexOf(s)
            si >= 0 and return tpath_[si]
            $tp = me&tpath,R,s
            tpaths[tp] ||= s
            $si = tpath_s.push(s)-1;
            return tpath_[si] = tp
        }
        $saywaits = &n{
            $tp = joint(haks(n.sc))+" "
            $s = ns&wants
            $sr = s && me&tpath,s || "!%wants"
            $viar = ns&via && me&tpath,ns&via
            viar = viar && viar != sr
                ? " (via "+viar+")" : ''
            $why = ns&waits
            why = isC(why) ? why.t : why
            
            return sr+viar+": "+why
        }
        me&jaa,R,{waits:1} .filter(&n{
            $s = ns&wants
            # !
            if (ns&say) {
                $tp = saywaits(n)
                ~>4 says: ns&say, tp
            }
            
            # usu from just &waits!
            #  lets explicit %%wants happen first
            ns&momentarily and momentarily.push(s); return
            # usu just R we should tunnel
            # eg R%Paving/r%Pave, happens to only tunnel to R
            # < ns&via probably -> later
            ns&sooner and sooner.push(s); return
            # almost a quiet_waker...
            ns&later and later.push(s); return
            # < others may have %Q waiting for %ready
            #   this could later an entire set of wakers for 300ms
            
            $j = sy&R;
            !j and debugger
            # no %%wants=R (j==s)
            !j || jc&s != s and debugger;
            
            $tp = tpath(s)
            $z = tpaths[tp];
            if (z && s) {
                z == s and "s dup %%wants,..."
                else {
                    if (sy&R && zy&R && zy&R != sy&R) {
                        ~>5 tpath res: tp
                        zy&R == me&yfuture,sy&R and return
                        me&yfuture,sy&R != me&yfuture,zy&R and debugger
                        ignore.push(z);
                        tpaths[tp] = s
                    }
                    else {
                        zy&up == sy&up and throw "s dup same up (tv|tw?)"
                        throw "tpath confu"
                    }
                }
            }
            
            return 1
        })
   
   //     %%wants:node
        .map(&n{
            
            $s = ns&wants;
            $j = sy&R;
            !j || jc&s != s and debugger;
            
            $tos = sy&settletos;
            if (tos) {
                # waiting for these
                $arewakers = me&ioty,tos .filter(n => tpaths[n.t]);
                if (arewakers.length) {
                    #~>5 waitfor: tpath(s)
                    later.push(s);
                    return
                }
            }
            
            if (js&brackstable > 6) {
                if (me&wokerecently,R,s > 3) {
                    ~>4 freeze: tpath(s)
                    freeze.push(s)
                    return
                    # < try to release laters to around it?
                }
            }
            
            !wakers.includes(s) and wakers.push(s)
        });
        
   //   # sooner or laters
        # < then submit to another round of ^ (Jx doming)
        # the arrays going to &log must be readonly
        
        # sooners take precedence over any wakers
        $rem = ''
        if (sooner.length) {
            momentarily.push(...wakers)
            wakers = sooner
            rem = "sooner"
            hak(momentarily) and rem = "<-sooner"
            hak(momentarily) and me&log,R,'sooner',{wakers,momentarily}
        }
        if (!wakers.length) {
            wakers = momentarily.slice()
            # < shouldnt happen?
            hak(wakers) and rem = "()momentarily"
            momentarily = []
        }
        if (!wakers.length) {
            wakers = (Ys&momentarilys||[]).pop() || []
            hak(wakers) and rem = "<-momentarily"
        }
        
        # laters give precedence to any wakers
        !wakers.length and wakers = later; later = []
        if (!wakers.length) {
            wakers = (Ys&laters||[]).pop() || [];
            hak(wakers) and rem = "<-later"
            hak(wakers) and me&log,R,'later',{wakers}
        }
        wakers = uniq(wakers)
        
   //   are concluded
        if (wakers.length) {
            $via = {}
            $vias = {}
            uniq(wakers) .map(&s{
                $got = me&jaa,R,{waits:1,wants:s} .map(&n{
                    #+isR(s) and ~>7 GoR: s.t
                    isR(s) and return
                    $t = me&tpath,s;
                    vias[t] = s
                    via[t] ||= [];
                    via[t].push(saywaits(n))
                });
                if (!got.length) {
                    # < can't find any via later[] etc
                    #~>7 unk: s.t
                }
            })
            each tm via {
                $s = vias[t]
                $V = me&jaa,R,{wants:s,say:1} [0]
                !V and break
                # < assumes only one
                $say = Vs&say || ''
                ~>7 8r: t, say
                each it m {
                    ~>7 <-: t
                    me&log,R,'later',{waker:s,say,saywaits:t}
                }
            }
            
        }
        
        # for later
        later.length and ac(Y,'laters',later)
        momentarily.length and ac(Y,'momentarilys',momentarily)
        # they may happen before planned
        each is wakers {
            ['laters','momentarilys'].map(&k{
                $wake = Y.sc[k]
                !wake and return
                wake = wake.filter(z => z != s)
                !wake.length and delete Y.sc[k]
            })
        }
   
   // and finally ish
        !wakers.length and wakers.push(... me&quiet_wakers,R )
        !wakers.length and ~>4 .:
        
        me&Yingate_8,R,{wakers}
        
        !wakers.length and return

        # Ying and each node has %terms,
        #  they must accept the wave is done
        wakers = wakers.map(&n{
            return {wake:n,terms:{anode:1}}
        });
        me&Yinge,R,{wakers,terms:{bunch:1}};
    }
   
   // &Yinge - &waits_8 gives:
    me.Yinge = &acgtRc{
        4s&stopeforasecond and return ~>5 stopeforasecond drop:
        4s&stopeforasecond and return ~>5 Twce drop:
        $elvising = &{
            # since delay, Ying may have reset at Peace:8
            #  and only be as far as Gens (about to +self)
            # < J would simpler.
            $dodge = {}
            $Xt = &nt{
                $X = nc&X
                $oX = X && X.x && X.x[t]
                oX && oX.z and return oX.z[0]
            }
            $jr = me&yfuture,me.cbu(R,'JRom')
            $jp = me&yfuture,jry&up
            jr = Xt(jp,jr.t)
            $ge = Xt(jr,R.t)
            !(ge && ges&Gens) and dodge.nogen = 1
            $gen = me.cbu(R,'Gens')
            ge && me&yfuture,gen != me&yfuture,ge and dodge.Xfuture = 1
            
            $r = ge && me&ioty,ge,['Ying'] [0]
            !r and dodge.Early = 1
            else
            rc&s != Rc&s and dodge.Yingdiff = 1
            else
            r != me&yfuture,R and dodge.rfute = 1
            
            4s&gonemainthing_s == Rc&s and dodge.gones = 1
            
            $ks = G&depeel,dodge
            hak(dodge) and console.log("dodge:"+ks)
            hak(dodge) and return ~>6 DodgeYinge: R.t, ks
            
            # giving N[{wake:r,terms}]
            me&elpack,R,"Yingvoids",'reYn',c.wakers
        };
        # limit to one feedback loop
        $Co = me&rollbsc,R,'Corresp';
        $yeah = me&sccb,Co,'Yingvoids',elvising;
        # avoids usual timing of Elvoids:
        # < should ec&when exactly
        $del = !4s&slowedown ? 22 : 3000;
        G&yl,del,yeah;
    }
    # make e:$t pack with e:$k for N inside
    me.elpack = &acgtRtkNc{
        c ||= {}
        # visits those r**
        $wakers = N.map(&r{
            $c = {}
            !isC(r) && isC(r.wake) and c = r; r = c.wake
            r = ry&R;
            !isR(r) and throw "notR"
            c.wake = me&yfuture,r;
            c.ret = 1;
            return me&elvis,R,k,c
        });
        # on a single trip to %Ying
        # pack: es&z are e, simultaneously
        c.pack = R;
        return me&elvis,R,t,c,wakers
    }
  
   // < conclusion *Ying_8 -> waits_8)
       =pod todo
        < # Yingterms
        %%dome 
         < and other %%tricks
        &settle, meaning a wants b to be settled,
          quickly decided, else comeback
        < catching that %Pave elvis async already @315
           coming back to complete bunches at a time
        < io making sense of eg %%tw, %ein,
          but probably not &settle, too micro to wait
           blocking reads only for Pinnings: S o Thing
        < upper levels of %acty or R/r tugging lower
          %Paving would become acty=2,
           meaning something acty=1 (%%openey) succeeded
          and produce a %%Live (Qc&s)
        < %Paving basically top-down &settle,
           and some kind of r%acty=R%acty-1 tugging spread
          runs out of %acty=1->%openey far enough in
          so $p/* should &settle,
            but $p/*/*/* neednt be %openey (or settled?)
          > becoming %Paving_good|in all the way down|up
          might be up to r:Know to %%wants:r/*,acty:1,settled,
       
       // mostly
         most behaviour decisions wait for &settle
          waiting for confidence
          eg selecting nodes eg S o ... or &nodeo

         most behaviour reflexes wait for &bready
          just needing a bit of resolution
          eg begin reaction as txn on brack
            as in %%may,... -> ...,%may, sorta
        
         and they form loops!
         
       // Yingterms - see nodeio-Yingu-scussion
        messaging / nodes / time
        find loops, pause/debug/trace
       
        %Yingu
        < display for Ying, out of time
        R%Ying @296 - repeatedly
         may be planned, e with %term
         or random e (click)
        
        arrange for next Ying to come back with
         %terms - arrival protocol
          eg visit only $to, not $to/**
           for any %%eto upwards
          otherwise figured by elvis %tunneling
        
        by sorting waves of wakers
        < p%priority or nodes refd by another waker first
        < deeper nodes first, all siblings at once
          supposing their reason to be is compatible,
           avoid re-%%waits when theres %%eto to deliver
        
        from now and before
        < undropped e when sccb throttles
        < come back in at least a little while
        
        noticing when we might
        < interrupt busy system
         < to refine eg &etos_6 &brackstill
        < give up on
         < &brackstill %%waits
          < until what it %%wants re-&settle
         < sheer change (lack of) in motion,
           if all %Zif-able, spotting increases etc.
        < go randomly visiting ($p/10s?)
          where further time plots emerge
       =elvis
  
// 9 wakes
 
