# brack time
   =alphabet layercake
     join our decisions of how
      into an over-realm, a computed individuals unity
      so decisions that cant be made by anyone
      can be made by that mind
     wording so it applies force around a structure
      the decision being to break or not
     NervOS fibre bundles arm sleepy processes
      limbs becoming available
   
    solves:
    having to state everything, or:
    leaving cos &bready drops state between
      usually youd export the ready state somewhere,
       eg the bunch of C to compile
      such that it can pull changes,
       eg CBing with a Know**%fully turnaround
    by:
      not accepting CBing while busy doing other stuff
      simply not getting around to that &nodeein,
       and not avoiding what it was doing,
        because any confusing/unhandled e
        should usu make a node hang/dev
    
    < %supr-ish list/pile process via me&ind, slepping
       a natural migration pathway, among slopes...
       < know users of the things changing,
    
    o1:
      < ha that can think, stream news downstream (z gets read)
      < sa that can log, selection replayable, dome input slep
        to check the conditions for a decision are still so,
         without having to conduce the decision again
      < Babz for each in me&thing { # call me&thing once
      < Babz R&za -> me&za,R (single character == self)
    
    =elvis


// 1 - physics
   // sahazaja io
       // &sahajaza usu
        # i - enterer
        # < to react in a Ring,r hang way,
        #   returning/jumping somewhere to think/reapproach
        me.ha = &acgtj{
            return me&bracki,j,js&wou,...[...arguments].slice(5)
        }
        # o - reading,
        # from what is beginning,
        #  what was mid-way,
        #  what got to the end
        #   < without &bready? or just !sleep?
        # ja always now
        me.ja = &acgtj{
            return me&bracko,j,js&wou,...[...arguments].slice(5)
        }
        # sa last time
        me.sa = &acgtj{
            $z = js&wou;
            return me&bracko,j,zy&get_saz(j),...[...arguments].slice(5)
        }
        # za always >7
        #  so can take j=s, using sy&R to find last good R
        me.za = &acgtj{
            $r = jy&R
            $s = rc&s
            s && sy&R and j = sy&R
            $z = js&wou;
            return me&bracko,j,zy&get_zaz(j),...[...arguments].slice(5)
        }
        # differential
        me.da = &acgtjqc{
            c ||= {}
            isnu(c) and c = {el:c}
            c.el ||= 1
            $is = me&jaa,j,q
            $was = me&zaa,j,q
            # some rows, were none
            c.el == 1 and hak(is) && !hak(was) and return is
            else {
                # < changed number of
                # < hakd(), out of order
                # < returning new|gone|diff
            }
        }
        # and always array
        me.saa = &{ return me.sa(...arguments) || [] }
        me.zaa = &{ return me.za(...arguments) || [] }
        me.jaa = &{ return me.ja(...arguments) || [] }
        me.daa = &{ return me.da(...arguments) || [] }

        # io %wou, a feedback loop
        #   experience -> notion, notion -> etc
        me.sahazaja = &acgtj{
            jy&R and j = jy&R
            # < de-hard-code $k
            $k = 'wou';
            
            # %wou = $z/$row+, via me&ha,j,data etc
            $z = j.sc[k] ||= Cye([k,1,{}]);
            zy&R ||= j;
            
            # sa last time
            $saz = me&ollbs,j,k
            zy&get_saz = &j{ return saz };
            
            # za always >7
            $zak = k+'_accepted';
            me&rollbs,j,zak;
            me&reaw,j,zak;
            zy&get_zaz = &j{ return j.sc[zak] };
        }
        # simpler
        me.haja = &acgtR{
            $j = R || me&R
            # < de-hard-code $k
            $k = 'wou';
            
            # %wou = $z/$row+, via me&ha,j,data etc
            $z = j.sc[k] ||= Cye([k,1,{}]);
            zy&R ||= j;
        }
        
        # commit %wou to be za next time
        # usu via Domes_7
        me.node_accept = &acgtRrs{
            rs&wou_accepted = rs&wou
        }
        
       // &hajasute, proto &saa, &jaaz
        # return h={ha,jaa,etc}, possing through T.sute &Supe*
        # < similar to an Xio front end
        #    the flavour of the interation, besides expr through it
        me.hajasute = &acgt{
            $h = T.sute
            $j = me&R
            if (h) {
                # has:
            }
            else {
                h = {}
                h.ha = (c,s) => me&ha,j,c,{},s
                h.jaa = (c) => me&jaa,j,c
                h.zaa = (c) => me&zaa,j,c
            }
            # %%rec-tractioned zaa+jaa
            #  used when jaa(c,1) gives dupes from neu+old %%rec
            # < as long as some new gets selected
            #  < X easy to detect recent additions to %%dome etc
            h.saa = &c{
                $neu = h.jaa(c)
                # < use a grouper instead of...
                $recn = {}
                each in neu {
                    ns&rec and recn[ns&rec] = 1
                }
                return [...h.zaa(c)
                    .filter(n => !ns&rec || !recn[ns&rec]),
                    ...neu]
            }
            return h
        }
        # &zaa it when it might not be entered yet
        #  or when j%sleeping
        #  used only by &Effect_o
        # oddness... Xio time to straighten?
        #  see also &supetime's ja, has similar
        # < perhaps &sa means &ja even if sleeping?
        # < try to make all from-to wake separately?
        #   Ring und Story/* sequentially?
        #  or the more complex:
        # < Dome_7 check from (j)
        #    it may still wake up or alter (noiseloop)
        #   to re-&Effected wake if ~
        #    (besides %%Eto:-eight)
        me.jaaz = &acgtjq{
            $R = Cy&R
            $N = me&jaa,j,q
            # reasons to trust this R's brackstate:
            # something
            N.length and return N
            # nothing from yourself
            R == j and return N
            # nothing, not happening (in R-time, see 'may still wake up')
            !Rc&N.includes(j) && !js&sleeping and return N
            # use the commit brack
            $N = me&zaa,j,q
            # there's a chance we dont wake up to notice a vanish
            return N
        }
   
   // bracktools
    # display brackology
    me.stepbrack = &acgtjz{
        $g = me&brackology,j,z||'wou';
        me&walls,g,'b:2.2';
        # attaching C to r without doming:
        ac(j,'M',g);
        return g
    }
    # 7ish brackstable determiniser
    #  sees future R as the same, cha=0
    #   otherwise be cha=1 for only objects changing
    # and no in-object differencing, just whats on the rows
    me.brackstabliser = &acgtr,se{
        # compute once
        sey&R == r and return
        sey&R = r;
        # takes brack
        $z = rs&wou;
        ses&z = (zs&z||[]).filter(n => !nc&drop);
        # includes nodes %current below, for &halfsettled
        $froms = sey&settlefroms;
        if (froms) {
            $N = fromss&nodes_below;
            $nb = Cye(['nodes below',1]);
            each in N {
                $nse = ny&settled;
                $la = nse && nses&current;
                !la and debugger
                # duplicatey
                nb.sc[n.t] and nb.sc[n.t+' '+i] = la
                else { nb.sc[n.t] = la }
            }
            ses&z.push(nb)
        }
        # into a progression
        ses&vers ||= [];
        $la = ses&vers.slice(-1)[0];
        if (la) {
            # hack for %%something:$R continuity
            #  sees future R as the same
            # < Display versioning?
            each ir lac&allvs {
                !(r && r.y && ry&R == r) and continue
                $nr = me&yfuture,r;
                lac&allvs[i] = nr || r
            }
        }
        $cha = me&brackstill,r,se,la;
        if (cha) {
            #delete ses&accepted_boring;
            # clone into vers[], drops se/*
            ses&vers.push(Cye(se));
        }
        ses&current = ses&vers.slice(-1)[0];
        return cha
    }
    # transbrack comparator
    # < brackology with two z's, +- 
    me.brackstill = &acgtRzb{
        $cha = 0
        zc&allks = [];
        zc&allvs = [];
        me&ioty,z .map(&n{
            nc&drop and return
            $nsc
            nsc = &nd{
            each kv n.sc {
                if (v && v.y && vy&brack) {
                    # recurse to n = ns&n
                    k != 'n' and throw "non-n brack in brack", k, n
                    d > 3 and throw "deep brack in brack"
                    nsc(v,d+1)
                    continue
                }
                $ki = zc&allks.push(k)-1;
                # < more/less important k
                !b || bc&allks[ki] != k and cha = 2
                $vi = zc&allvs.push(v)-1;
                if (!b || bc&allvs[vi] != v) {
                    isob(v) and cha ||= 1
                    else { cha = 2 }
                }
            }
            };
            nsc(n,0)
        })
        !b || bc&allks.length != zc&allks.length and cha = 2
        return cha
    }
    # za|ha[n+] compare over time
    #  things out of order is change
    me.brackstillzaha = &acgta{
        hak(a.za) != hak(a.ha) and return 1
        each in a.ha {
            $z = a.za[i]
            !heq(z.sc,n.sc) and return 1
        }
    }
  
   // nodes
        window.isnode = s => s && isC(s) && sy&path && sy&path[0]
        # as r/** wake up & want nodesing, give %wou
        me.inode = &acgtj{
            if (jy&R) {
                # < might be eg Ace to arrive into
                $meant = j;
                j = jy&R;
            }
            $z = jc&s;
            $N = me.cbyb(j,
                &r{ return rs&ball && rc&s.y.N },
                &r{ return rs&Peace == 4 });
            # Ying is not running... eg %R:+Hoosh
            # < A.nodar || throw "nonoder"
            !N and return
            zy&path = N.map(r=>rc&s);
            # make sy&up = ball up
            zy&up ||= N.reverse().slice(1)
                .filter(r => rs&ball).map(r => rc&s)[0];
            $S = zy&path[0];
            $N = Sy&N;
            !N.includes(z) and N.push(z)
            zy&R = j;
            
            # pseudo Nodes init o3
            !js&wou and me&Nodes_o3,j
            
            # Step's R that last o3'd, not sleeping
            !Sy&p and throw "Step !y&p"
            !Sy&R and throw "Step !y&R"
            #T.act and me&ha,j,{noded:T.act}
            return Sy&R
        };
        
        # see &Yingwhen for misc sleep functions
        # see Pictures climbing
        
        # should we not Doming_7 due to %sleep*
        me.node_issleeping = &acgtRs{
            =elvis &node_issleeping if %sleepung-ish
             potential to really stop mid-r:
             < avoiding any more Ring r**,
                < wants Rc&ip.contains()
               as soon as ha ...waits
                winding them past mind they cant reach,
                 recycling domes of stuff
             < alterior sleeping - when %%waits stops Ring
               does it accept r as b? suppose, to display
                r/** want winding past their whole lives if strange
                 winds to 9...Display while %sleeping?
            =elvis
            # >0 if r is not able to commit (za)
            # >1 if r is not able to display
            R = Ry&R;
            $r = sy&R;
            # before it calls &inode to set sy&R
            r = me&yfuture,r
            if (rs&sleepung) {
                # displayable after sleepywind
                ~>3 node pung: r.t
                return 1
            }
            elsif (rs&sleeping) {
                # reawakened + tunneled through (Know)
                #~>3 node sleeping: r.t
            } 
            elsif (!Rc&N.includes(r)) {
                # not awakened
                #~>3 node avoid: r.t
            }
            else {
                return 0
            }
            return 2
        }
        # node s resolve to a %Ying/(pa/th)
        #  for inter-noding, eg %%settle or %%eto
        # see also &pipath
        # < riding X, hoisting all the way up...
        #  < a/b/-c/d should revoke d's stuff on b, a
        me.tpath = &acgtR,to{
            # < drop need for R%Ying
            to ||= R;
            $jo = toy&R;
            to = joc&s;
            $path = toy&path || [to]
            path = path.slice().reverse();
            $N = path.map(s => sy&R);
            each in N {
                (n) and continue
                i *= 1
                $inner = N[i-1];
                !inner and throw "lost @"+i
                $p = innery&up;
                ps&ball && pc&s == path[i] and N[i] = p
                else {
                    throw "not looking", p, path[i]
                }
            }
            N = N.reverse()
            #    .filter(r => rs&ball)
            return N.map(r => r.t).join('/')
        };
        # < better sanity, with &Yingate_8 stutters
        me.must_newnodesamepath = &acgtsz{
            !s || s == z and return
            !isnode(s) || !isnode(z) and debugger
            joint(sy&path) != joint(zy&path) and debugger
        }
        # < order of Sy&N
        me.nodes_below = &acgts{
            $j = sy&R;
            !j || !sy&path and throw "nodenever"
            $S = sy&path[0];
            $N = Sy&N;
            return N.filter(z => zy&up == s)
        }
   
   // nodelinks
    # concept of leading rows -> sy&${k}tos|froms -> somewhere
    # the (settle|etos)_(6|7|8) exchange
    me.either_ftk = &acgtc{
        !isst(c.k) and throw "give c.k"
        !isar(c.rows) and throw "give c.rows"
        # somethings that become somethingfroms
        $k = c.k;
        k.substr(-1) == 's' and k = k.substr(0,k.length-1)
        c.tk ||= k+'tos';
        c.fk ||= k+'froms';
    }
    # rows leaving $from, grouped by $to
    #  eg sy&settletos/$h:to/$row
    me.either_6 = &acgtRrc{
        me&either_ftk,c;
        $s = rc&s;
        $fromt = me&tpath,R,r;
        # k,tk = settle,settletos | eto,etos
        $ing = s.y[c.tk] ||= Cye([fromt,1]);
        $gone = (ings&z||[]).slice();
        each in c.rows {
            $to = n.sc[c.k];
            !to and throw ""
            # %%eto=1 means to the step
            # < clone out the n to change %%eto=name->$s
            to == 1 and to = s.y.path[0]
            # select s given p/r/s
            $jo = toy&R;
            to = joc&s;

            $h = fio(ing, me&tpath,R,to );
            hy&up = ing;
            $gi = gone.indexOf(h);
            if (gi >= 0) {
                gone.splice(gi,1);
                # new bunch of rows
                hs&z = [];
            }

            hs&to = to;
            hs&from  = s;
            hs&fromt = fromt;
            ac(h,'z',n);
        }
        # revoke
        gone .map(&h{
            !fio(ing,h.t,0) and throw "notnt"
            if (hc&el != 9) {
                hc&el = 9;
                c.on_el9 and c.on_el9(h);
            }
        });
        c.each and me&ioty,ing .map(&h{ c.each(h,hs&from,hs&to) })
    }
    # Ying for something_8 takes $from->$to
    me.either_8 = &acgtRc{
        me&either_ftk,c;
        each in c.rows {
            !ns&fromt and throw "!fromt"
            $h = n.sc[c.k];
            $to = hs&to;
            $jo = toy&R;
            to = joc&s;
            # froms - for|on the to node path
            $ef = to.y[c.fk] ||= Cye([h.t,1]);
            ef.t != h.t and throw "misnodepath"
            #  /$fromt - the from node path
            $fo = fio(ef,ns&fromt);
            fo.sc[c.tk] = h;
            
            c.each and c.each(h,hs&from,hs&to,ef,fo)
        }
    }

// 2 - Y:Ying|Steps
 me.Yingmind ||= {}
 # Y:Ying - the top
 me.Yingmind.Ying = &acgt{ return [
  // Steps <- Schema
    # @1 figure out where things are at every so often
    # > misuse of 0.01 to declare functions
    # @o1 discerns itself from SC, which it doesn't
    
    # < set out unififying crawlythings
    #  eg check legitimacy of W Iing from its .5
    #  or do some update
    #   they set out, taking their parts of the wormhole
    ['Ying',0.01,&acgtRYs,SC{
        ~>3 Ying forks:
    },'ift,D'],

    # @02 when R%SC relives,
    #  ~SCy&R winds SCy&Y back to here
    ['on',0.02,&acgtRYs,SC{
        s != SC and throw "should be the one"
        sy&R = R;
        me&Ying_o2,R,s;
    },'ift,D'],

    #  mix Schema/$h/$p into Steps/$p
    # < Schema knowing export to Steps/$p
    #   or sharing as $p:step, and Steps inhales :steps
    ['Schema to Steps',0.021,&acgtRYs,SC{
        $Sch = me&fiu,SC,'Schema',7;
        Schc&compiled and return
        $N = [];
        me&ioty,Sch .map(&h{
            me&ioty,h .map(p => N.push(p))
        });
        tvsortz(N);
        # start new Steps
        #   and imports new Steps/$p
        s = Ys&Steps = me&Yong,R,SC,'Steps',{adoptees:N},'o2';
        Schc&compiled = 1;
    },'ift,D'],
  
  // Steps @02, @03, @9, &Ying_8
    # @023 Steps per R%SC
    ['Steps per R',0.023,&acgtRYs,SC{
        me&Yong,R,Ys&Steps,{},'o2';
    },'ift,D'],

    # @03 Steps per walk through Y:SC
    #   pull up a map for this Aing,
    ['Steps per walk',0.03,&acgtRYs,SC{
        me&Yong,R,Ys&Steps,{},'o3';
    },'ift,D'],

    # @6 Steps take walk through Y:Steps
    #   pull up a map for this Aing,
    ['Steps walk',0.6,&acgtRYs,SC{
        me&Yong,R,Ys&Steps,{},9;
    },'ift,D'],
    # 
    ['Steps e',0.8,&acgtRYs,SC{
        me&Ying_8,R,s;
    },'ift,D'],
 ]};

 # Y:Steps
 me.Yingmind.Steps = &acgt{ return [
      // <=o2 Steps R
        # o1 schema doming recreates SC/Y:Steps
        # per awake R%Ying%SomeSchema
        ['Steps',0.01,&acgtRYs,SC{
            s != SC and throw "s!=SC"
            $s = Rc&s
            $Steps = me&fiu,SC,'Steps',1;
            # grounded $p:steps flow into o2
            each ip Ys&adoptees {
                # < slep here
                me&fiu,Steps,p
            }
            # and any not in the schema
            each in ss&z {
                $p = me&fiu,Steps,n.t,8
                !p and me&fiu,Steps,n.t
            }
            #~>3 Steps fork:
            return Steps
        },'ift,D'],
        
        # o2 Steps/$p <-> R/$r awake
        # per any R%Ying
        ['are',0.02,&acgtRY,Steps,SC{
            $s = Rc&s;
            sy&R = R;
            Stepsy&R = R;
            
            # we can see tunnelled $r already
            $N = me&ioty,R,'ball';
            $sleeping = [];
            $awake = [];
            if (N.length) {
                # mixed with recycling
                N = arou(N,&n{ return Rc&N.includes(n) },awake);
                $tunneling = Rs&tunneling;
                !tunneling and throw "early !tun"
                # by the sleeping since we know r -> p
                sleeping = N.map(r => rc&s.y.p);
            }
            
            # this reverse + bal adjust Rs&z to flow upwards
            # links p,r,s (+n)
            Stepss&z.slice().reverse().map(&p{
                sleeping.includes(p) and return ps&sleeping = 1
                delete ps&sleeping
                
                $r = me&bal,p.t
                $s = rc&s;
                sy&up && sy&up != Rc&s and debugger
                # < what requires climbing s only up to the step?
                #sy&up = Rc&s
                
                $n = py&Schema_step
                if (n) {
                    # bal inputs to ups%ball, unless %eph
                    # < compile this on the Schema
                    ns&supr and ns&eph = 1

                    # n.sc -> r.sc
                    ex(r.sc,n.sc);
                    # n.c -> s.sc
                    ex(s.sc,n.c);
                }
                # < pc&s = s)%ball?
                py&s = s;
                sy&p = p;
                py&R = sy&R = r;
            });
            
            # goes on as each SC/Steps/$p
            SCs&steps = Yc&M = Stepss&z;
            # GOING
            Rs&Lastly = Stepss&z.slice().pop();
        },'ift,D'],
      
      // o2=> Steps attr # < see -Labe
        # o21 per awake Steps/(p,r,s) attr init
        ['attrise',0.021,&acgtRYp,SC{
            $Steps = py&up;
            $r = py&R;
            $s = rc&s;
            # not &inode:
            sy&path = [s]
            
            rs&Pavings and ss&twmt = ps&priority = 1
            rs&Travels and ss&twmt = rs&twmt_dl = 1
            
            # joins t-t
            ss&twin and me&attrise_twin,p,r,s;
            # p%%tw <- t/[t,t,t]
            ss&twmt and ah(r,'adhere','twmt',1)
            
            # < check out. effectively %twmt?
            # prefer specific tw, altering supr-isms
            # they seem to have storable ambitions
            # eg including to /W/ ways to use
            #   With/$trick/$hack
            #    + $hack = $trick trick
            #   and SCinway
            rs&tw and rs&tw = ss&tw
            #  allowing calm isolated spacewalks
            rs&gently && rs&Gracto and rs&tw = 1
        },'ift,D'],
        
        ['arrive',0.022,&acgtRYp,SC{
            $r = py&R;
            Rs&waits and return T.Z = 8
            # enough to have Rs&C, Rc&b, Ace
            me&Ring,r,{und:r,ov:0.295};
        },'ift,D'],
      
      // being 03
        # @03 each Steps/(p,r,s) wake up, have features
        #  may be different, may be time to something!
        ['being',0.03,&acgtRYp,SC{
            $r = py&R;
            $s = rc&s;
            sy&R = r;
            
            # p's current Y:Walk around Y:Steps?
            #$Ob = py&O;
            #$O = py&O = Cye([p.t,py&cv]);
            #Ob and Oc&b = Ob; delete Obc&b
            
            # $p earlier (Know-ward) and later
            me.neigh(p,&lr{ py&l = l; py&r = r })
            
            me&Steps_o3,r;
            
            # me&inode arrives jc&s into:
            sy&N ||= [];
            # < reliable ordering
            #    putting them in around their neigh/up
            # < some way to traverse j/** in dialect,
            #   using slep, avoiding %folder, !%supr,
            #   that they should be in sy&N, etc.
            #   %supr might:
            #    each step/* is sy&top, has another pool sy&N
            # %adhere-ants like %supr, %twmt me&inode
        },'ift,D'],
        
      // Steps 5 6 7
        ['seee',0.5,&acgtRYp,SC{
            $r = py&R;
            me&Ring,r,{und:r,ov:0.315};
        },'ift,D'],
        ['aseee',0.6,&acgtRYp,SC{
            $r = py&R;
            me&Ring,r,{und:r,ov:0.7};
        },'ift,D'],
        
        # and again to wake things generated into other steps
        #  ie from inside:r, out to where Ring isn't
        # < notice things like that,
        # < use wai to organise elvising it in there
        ['Steps may other',0.67,&acgtRYp,SC{
            $r = py&R;
            me&Ring,r,{und:r,ov:0.7};
        },'ift,D'],
        
        ['Trip report',0.7,&acgtRYp,SC{
            $r = py&R;
            $s = rc&s;
            me&Steps_7,R,p,r,s;
        },'ift,D'],
 ]};

// 3 - Domes time connect items
    # nodes at each end of time
    
    # Ying/step/node** all
    me.Ying_o2 = &acgtR{
        $s = Rc&s
        # Ying is the thing to bring vague Q changes
        4s&mainthing = R
        sy&brackwouology_ope == null and sy&brackwouology_ope = -1
        me&Yingate_2,R
        me&Domes_o3,R
    }
    me.Steps_o3 =
    me.Nodes_o3 = &acgtRs{
        me&Domes_o3,R
    }
    # domes, transbrack init
    me.Domes_o3 = &acgtr{
        $s = rc&s;
        me&sahazaja,r;
        me&etos_o3,r,s;
        me&settle_o3,r,s;
        me&dome_o3,r,s;
    }
    
    # $p and its nodes &Domes_7
    #  depending on !node_issleeping
    me.Steps_7 = &acgtRprs{
        $stepsleeping = me&node_issleeping,R,r;
        
        $rev = [];
        each iz sy&N {
            $j = zy&R;
            me&node_issleeping,R,j and continue
            me&Domes_7,R,p,j
            rev.unshift(z)
        }
        each iz rev {
            $j = zy&R;
            !j || j == z and debugger
            me&Domes_7_upward,R,p,j
        }
        if (stepsleeping) {
            me&Detection_7,R,p,r
            return
        }

        me&Domes_7,R,p,r;
        $g = me&Domes_7_upward,R,p,r;
        me&walls,g,'b:3.3h9';
    }
    # domes, transbrack accept
    # everyone &bready or -> conclusion
    me.Domes_7 = &acgtRpr{
        $s = rc&s;
        # %%dome replace if any new
        me&dome_7,R,p,r,s;
        me&waits_7,R,r;
        me&settle_6,R,p,r,s;
        me&settle_7,R,p,r,s;
        me&Detection_7,R,p,r,s;
        
    }
    # deeper first, depending on Sy&N (S = py&s)
    me.Domes_7_upward = &acgtRpr{
        $s = rc&s;
        # still state
        me&brackstable_7,R,p,r,s;
        me&settle_7_upward,R,p,r,s;

        me&node_accept,R,r,s;
        # < might sleepytime if brackstable
        #   && no elvising into brackology, etc...

        # %%eto|from
        me&etos_6,R,p,r,s;
        me&etos_7,R,p,r,s;
        # display
        return me&stepbrack,r;
    }

me.etoblab = 0
me.settleblab = 1

// 5 < Domes
  // %%dome - residing state
      // intro
        =pod %%dome:$t,... - a row that resurrects
         # not: another $z to seem in this one via bracko
         @o3 &zaa 'dome' -> ha, each nc&recycled=1
         @6:
           you ja your permanent-er state out of it
           eg %Ying has orders of $p waiting
           or commit log
           or %Paving sanity checking as we .5<->.1
         @7:
           any ha %%dome:$t,... replace them
            < or do some el=...
              eg delete with where clause
            < or something configured
           one ha %dome:$t - to drop it
           no ha %dome:$t* - to keep them all
            maybe for a ttl
         for &bracko and similar (&brackgroupX|&brackstill|&brackstabliser)
           nc&drop should appear gone,
           in time for other Doming_7 to not get it
        =cut
        
        # += %%dome from last time
        me.dome_o3 = &acgtrs{
            me&zaa,r,'dome' .map(&n{
                nc&drop and throw "dropsnot"
                $w = n;
                nc&recycled and n = ny&up
                # shaded n.sc stay when dome recycling
                #  usu any other recycling (&ha,$n) vanishes them
                $shade = {}
                nc&shade && haks(nc&shade)
                    .map(k => shade[k] = n.sc[k])
                
                $O = me&ha,r,n,shade;
                
                # stretch, through/from the same S
                Oc&recycled = 1 + (wc&recycled||0)
                wc&S and Oc&S = wc&S
                
            })
        }
        # remove old one if obvious!
        me.dome_bracki = &acgtrn{
            $p = ny&up;
            p && ny&brack == py&brack && pc&recycled and pc&drop = 'i-rec'
            else {
                # < indexes enough to conclude that it's that
                # if it's entirely that, intensity could increase
            }
        }
      
      // tractioning
        # named traction
        me.dome_S = &acgtrkS{
            # everything must have been given
            $c = {el:2}
            c.having = &n{
                nc&S ||= S
                return nc&S == S
            }
            me&dome_traction,r,k,c
                .map(&n{
                    #~>4 indoc: ki(n,4.23)
                })
        }
        # commit new? dome
        me.dome_traction = &acgtrkc{
            k ||= 1;
            c ||= {};
            !isob(c) and throw "c.el:2?"
            
            $are = me&jaa,r,'dome:'+k
            c.having and are = are.filter(n => c.having(n))
            # < one S many domes? (c.having > dome:1)
            k == 1 && !c.having and throw "group by nothing"
            
            $neu = [];
            $old = [];
            are.map(&n{
                #~>4 of: ki(n,4.23)
                ns&el and 'where/what?'
                # tractioned until gone around
                $isold = nc&recycled || nc&tractioned;
                (isold ? old : neu ).push(n)
                nc&tractioned = 1
            })
            # everything must have been given
            $says_drop = c.el == 2 && "el2"
            
            # < making this block smaller fontsize
            # WEIRD drop by single %%dome
            $d = neu.filter(n => hak(n.sc) == 1);
            if (d.length) {
                d.length > 1 and throw "drop+"
                neu.length > 1 and throw "drop + replace"
                d = d[0];
                says_drop = dc&drop = 'singular'
            }
            
            # el1 (default, implied)
            #  its surroundings are implied to have been stated also
            #  ie the set stated are complete and canonical
            # el2 just adds this thing
            #  supposed to recreate it...
            #  perhaps el6 is the just-add thing?
            #   finds like el3, forks a thing
            # < sticks out. sha() and cel=2other variants of everything?
            $some_new = neu.filter(&n{
                !ns&el2 and return 1
                delete ns&el2
            })
            says_drop ||= some_new.length && "neu"
            says_drop and old.map(n => nc&drop = says_drop)
            
            #$hmm = says_drop && old.filter(
            #    n => ns&eto && ns&dome == 'v1').length
            #hmm and ~>3 v1etore: R.t
            
            return c.having ? neu : old
        }
        # each %%dome replaces if any new
        me.dome_7 = &acgtRprs{
            uniq(me&jaa,r,'dome' .map(n => ns&dome))
                .map(k => me&dome_traction,r,k );
        }
   
  // %%eto - externalising state
        # < el:9 retracting it
        # $to += %%efrom...
        me.etos_o3 = &acgtrs{
            $ef = sy&efroms;
            !ef and return
            me&ioty,ef .map(&fo,{
                $h = fos&etos;
                # h may re-node_hoist before we 7, if from /**
                fos&using = hs&current;
                hc&el == 9 and foc&el = 9; return
                !hs&vers.includes(hs&current) and throw "vers!"
                !hs&from and throw "!from"
                hs&to != s and throw "to!"
                me&ioty,h .map(&n{
                    # each row is mixed in +%%efrom
                    n = me&ha,r,n,{},{efrom:hs&from}
                    # < looking at s & n should notice this link:
                    ny&efrom = fo;
                });
            })
        };
        # $from %%eto
        #   -> $from sy&etos
        #   -> Ying%%etos
        # < brackstill config/slep
        me.etos_6 = &acgtRprs{
            # all %%eto from this node
            $rows = me&jaa,r,'eto' .filter(&n{
                # demand %%eto=s is a node && not us
                $s = ns&eto;
                # to the step only if not us
                s == 1 and return ry&up != R
                isR(s) and throw "R fed eto"
                !(sy&path||sy&p) and throw "!node",s
                s == rc&s and return
                return 1
            })
            !rows.length && !sy&etos and return
            # loads up sy&etos
            $c = {rows,k:'eto',tk:'etos'}
            c.on_el9 = &h{
                hs&current = h
            }
            c.each = &h{
                $fromt = hs&fromt
                # brackstill version off the previous
                hs&vers ||= [];
                if (hc&el != 9) {
                    $la = hs&vers.slice(-1)[0]
                    $cha = me&brackstill,r,h,la
                    if (cha) {
                        delete hs&accepted_boring;
                        # clone into vers[], h/* replaces
                        hs&vers.push(Cye(h));
                        #~>3 newvers: h.t
                    }
                    hs&current = hs&vers.slice(-1)[0];
                }
                !(hs&from || !hs&to) and throw "!to|from"
                if (hs&accepted == hs&current) {
                    # remove here once they accept 9ing it
                    if (hc&el == 9) {
                        ~>2 GC: h.t
                        fio(hy&up,h.t,9)
                    }
                    $neu = !hs&accepted_boring
                    hs&accepted_boring = 1
                    if (neu) {
                        me.etoblab and ~>3 hoistcept: h.t, '<-', fromt
                    }
                }
                else {
                    # asking %Ying to transport
                    me&ha,R,{etos:h,s,fromt}
                    if (!cha) {
                        me.etoblab and ~>3 oldnews: h.t, '<-', fromt
                    }
                }
            }
            me&either_6,R,r,c;
        }
        # $to %%efrom marked as accepted
        #  relaxes $from sending it
        me.etos_7 = &acgtRprs{
            $ef = sy&efroms
            !ef and return
            $gone = [];
            me&ioty,ef .map(&fo,{
                $h = fos&etos
                hs&accepted = fos&using
                hc&el == 9 and gone.push(fo); return
                # something in the way it is now?
            })
            gone.map(fo => fio(ef,fo,9))
        }
        # Ying %%etos
        #   -> $to sy&efroms
        #   -> Ying%%waits:eto,wants:$to
        me.etos_8 = &acgtR{
            $rows = me&jaa,R,'etos';
            $c = {rows,k:'etos',tk:'etos',fk:'efroms'};
            c.each = &h,from,to,ef,fo{
                # $to tidies efroms, once el=9 accepted
                # send attention
                me&ha,R,{waits:'eto',wants:to}
                
                me.etoblab and ~>5 efroms hoisting: ef.t, '<-', fo.t
            }
            me&either_8,R,c;
        }
   
  // %brackstable - still state
    # puts sy&settled brack versioning, r%brackstable++
    #  sees future R as the same
    #  may include %current of nodes below
    #   for &settle's &halfsettled
    # &sort_wakers:
    #  may freeze infinite loops
    # %%settle:
    #  wanting others to &brackstable
    me.brackstable_7 = &acgtRprs{
        $se = sy&settled ||= Cye([s.t,1]);
        
        me&brackstabliser,r,se;
        
        ses&brackstable = ses&accepted == ses&current ? 1 : 0;
        ses&accepted = ses&current;
        
        # how many times this node Domes_7 without brack changing
        $was = me&ollbs,r,'brackstable' || 0;
        ses&brackstable and rs&brackstable = 1 + was
    }
   
  // %%settle - still state
   // beginning
    # $from sees a version of each &settled,$to
    me.settle_o3 = &acgtrs{
        $tos = sy&settletos;
        !tos and return
        me&ioty,tos .map(&h{
            hs&current and hs&using = hs&current
            hs&from != s and throw "from!=s"
        })
    }
    # %settle emits|completes
    me.settle_6 = &acgtRprs{
        # all %%settle:$to
        # nothing in the row matters,
        #  only the from-to direction,
        #   orders Ying wake towards settle
        $rows = me&jaa,r,'settle';
        !rows.length && !sy&settletos and return
        $c = {rows,k:'settle'};
        c.each = &h{
            # asking %Ying to transport
            me&ha,R,{settles:h,s,fromt:hs&fromt}
        }
        me&either_6,R,r,c;
    }
    # resolve &settle at a nodes 7
    # gathering them to do all at once in reverse
    me.settle_7 = &acgtRprs{
        me&settle_71_halfsettle_down,R,p,r,s;
    }
    # and depth first:
    me.settle_7_upward = &acgtRprs{
        me&settle_72_settled_up,R,p,r,s;
        me&settle_77_settletos_accepted,R,p,r,s;
    }
    # the settled to - having froms/**
    #  push s/* a froms with %halfsettle_for
    #   causing brackstabilising there
    me.settle_71_halfsettle_down = &acgtRprs{
        $froms = sy&settlefroms;
        if (froms) {
            $N = fromss&nodes_below = me&nodes_below,s;
            !me&ioty,froms .length and return
            each in N {
                $nf = ny&settlefroms ||= Cye([me&tpath,R,n ,1])
                ac(nf,'halfsettle_for',s)
            }
        }
    }
   
   // middle &Doming_7
    # the $from<-$to
    me.settle_72_settled_up = &acgtRprs{
        
        $froms = sy&settlefroms;
        !froms and return
        # $to:r checks itself, makes version
        #~>3 settle_7 from: r.t
        # everyone gets a sy&settled from &brackstable_7
        $se = sy&settled ||= Cye([s.t,1]);
        !(se && sey&R == r) and throw "brack version"
        sey&settlefroms = froms;
        $washalf = ses&halfsettled;
        ses&halfsettled = 0;
        ses&settled = 0;
        
        $want = &sf{
            me&wants,R,'settle',s,{for:f}
        }

        if (!rs&isbready) {
            # generates %%waits, will come back
            me.settleblab and ~>4 set7 isntbready: r.t
            return
        }
        if (!ses&brackstable) {
            want(s,'onemore')
            me.settleblab and ~>4 set7 onemore: r.t
            return
        }

        ses&halfsettled = 1;

        # nodes below are at least &halfsettled
        # when we are them:
        each in fromss&halfsettle_for {
            # when we become &halfsettled
            washalf and break
            me.settleblab and ~>4 set7 half aboving: n.t, '<-', s.t
            want(n,'nodesabove')
            # < $s/$n awake at the same time is ok
            # < that could be $n%onlyish (not $n/** again)
        }
        # < ^v mutex?
        $non = me&settle_halfsettle_down,s;
        if (non.length) {
            me.settleblab and ~>4 set7 half below: ki(non,4.23)
            non.map(n => want(n,'nodesbelow'))
            return;
        }

        ses&settled = 1;
        # ses&current -> hs&current, then they hs&accepted
        # < hc&el=9
        me&ioty,froms .map(&fo,{
            $h = fos&settletos;
            !hs&from and throw "nofrom"
            hs&current = ses&current;
            if (hs&current != hs&accepted || ses&bump) {
                me.settleblab and ~>4 set7 awaits: h.t, hs&from.t
                want(hs&from,'settled')
            }
        })
        delete ses&bump
    }
   
   // ends
    # checks $to/* (nodes below) are %halfsettled, returning non
    #  n may not immediately inform $to of losing it
    #   eg if tunneled into, no s Doming_7
    #    $from would think s still &settled,
    #     until $to:s wakes for:nodesabove
    me.settle_halfsettle_down = &acgts{
        $froms = sy&settlefroms;
        !froms and return []
        $N = fromss&nodes_below;
        !N and throw "missing &settle_71_halfsettle_down"
        $non = [];
        each in N {
            # check if ready
            $nse = ny&settled
            nse && nses&halfsettled and continue
            non.push(n)
        }
        return non
    }
    # ack $from<-$to
    me.settle_77_settletos_accepted = &acgtRprs{
        if (sy&settletos) {
            # $from:r accepts version of $to
            # < wanting to have seen the &settle,$to again
            #    or chase the dome that didnt do it
            $tos = sy&settletos;
            !tos and return
            me&ioty,tos .map(&h{
                #~>3 settle_7 accepts: hs&to.t, '<-', hs&from.t
                # $to sets current when settled (ish)
                #  which we started using, and now:
                hs&using and hs&accepted = hs&using
            })
        }
    }
    # Ying takes %%settles $from->$to
    me.settle_8 = &acgtR{
        $Y = Rs&Ying;
        $set = Ys&settles ||= Cye(['settles',1]);
        
        $rows = me&jaa,R,'settles';
        $c = {rows,k:'settles'};
        c.each = &h,from,to,ef{
            # all tos and froms
            # < no independent list of them is needed?
            #   since they always progress the settle when awake
            #   see %%settle <-> %%waits
            !(hs&to && hs&from) and throw "%%settles!s"
            #ac(set,'tos',hs&to);
            #ac(set,'froms',hs&from);
            
            if (hs&accepted && hs&current == hs&accepted) {
                $neu = !hs&accepted_boring
                hs&accepted_boring = 1
                if (neu) {
                    me.settleblab and ~>7 settled: to.t, '<-', from.t
                }
                return
            }
            
            # attend $to, probably
            me&ha,R,{waits:'settle',wants:to,for:'to'}
        }
        me&either_8,R,c;
    }
   
// 6 < frontends
  
  // &Effect, their -Effect receives faster than %%eto
   // < doc
    # < tidy, test...
    =Effect
    
       i &Effect,from,to,t,c
        from - node
        to - node(..$E)?
        t - name of the cause, eg t='togcon' for qua='ope'
        c - first key is qua, sc.$gk to be aggregated
        
         e gets an -Effects @1
          z+c put into it, like nodey&efroms
           including distance to node from pi
         to has a timeframe to compute -Effects @6
          %%waits for it unless node is this-timed, not yet &Effected
          < robusticise that (Dome_7 checkup)
          < able to have an 'otherable outcome'

       o &Effected,to,c
        as above - receiving to as self
         eg -eight wants state of %ope, etc
        < other can receive ~ for it,
          if it has set up some thing to do,
           -pipe, %ein, A?, see 'othering wanted by Story'
        
        
      Used by Story to:
       shrink minor eights, with &togcon,
       $eight wants to use -eight to avoid -eight:
        < E:acheck: L%checking and !%%Checkable
        E:Ignored for %%Ignor*
        < E:shy until interesting:
         the $Test becomes interactive
          an e:click in any Dome should be noticed
         or wobbly - Failing
         or wandering off the end
         maybe until it becomes %%Checkable
          for maximum time to incubate style
        so
         a receptive Plot mode for going weird
         could be another system of:
       &Effect the acheck|Ignored|shy etc to -eight
       they resolve over the -eight%ope default
        and &togcon takes precedence if !null,
         deciding -eight%ope, through the same process
        so
         %ope=0 hides stuff
          eCsc dis:0 $seven+$four/Kn
           < noDisplay $seven
         %ope=1 shows stuff
          < may need to visit $eight to Display $seven
          < can occur by E:Failing $Test
           then E:shy $eight diminish (enlightening)
            we can adjust the %Effect...$qua without selfing?
             if permitted (self not using it somehow)
             since the brackindexing only knows having $qua?

       < those E:* &Effect-ings
       < -four %%step when shut?
       < -four clicking open, separating from -eight &Effected-ness
       < see 'otherable outcome',
         know when to visit $eight

       &Effected othering wanted by Story to:
         $Test has state of %wobbly,
           from $Eigh or whatever notices etc
          but isnt &Effected by it,
         $eight however,
          is, using it to &Effect more %ope (E:shy)
           ie it relays there when changed, etc
            as if $Test &Effect $eight,
        < so,
         how to get it to those self/others that are &Effected
         it relays %wobbly to senders of %ope, who use it
          depending on how it changes,
           and how they set up their &Effected endpoint
           eg %wobbly only affects $eight we havent passed,
            ie domes that contain the errors
           yet, that seems like leaking the time domain from Plot
          so maybe %wobbly is given directly to the $eight involved...
    =cut
   // &Effect in
    # < aq.nodes for aq.node_i
    # resurrectey spooler
    me.spoolR = &acgtEkRn{
        isC(E) and E = E.y
        $X = E[k] ||= {A:R}
        
        # find latest commit R
        $v
        $log = reverse(X.Rs||[])
        while (!v) {
            $r = log.shift()
            !r and break
            # that got finished
            if (ry&cv >= 0.9) {
                v = me&X_s,X,r,0,'R'
            }
            else {
                ~>5 spoolR popdead: r.t
                X.Rs.pop()
                X.R.pop()
            }
        }
        hak(log) <3 and 'keep some'
        else {
            #~>5 spoolR shiftold: r.t
            X.Rs.shift()
            X.R.shift()
        }
        $za = v ? v.z : []
        
        # see what this R has been up to
        $x = me&X_s,X,R,0,'R'
        x.z ||= []
        x.z.push(n)
        
        return {v,x,za,ha:x.z}
    }
    # < is node awake?
    # and Doming brack
    me.node_ispresent = &acgts{
        $j = sy&R
        # < is connected to &uptonode R
        #    Rc&N compare across R//E boundary (wants R&ip)
        return jy&cv >= 0.2 && jy&cv <= 0.7
    }
    
    # nearly an %%eto, maybe its own &either_
    # from: takes state to where it matters
    me.Effect = &acgtsetcq{
        !isst(t) || !c and throw "give from,to,t,c"
        # from as self: Ringing and awake
        $j = Cy&R
        $z = jc&s
        z != s and throw "from!Ringing"
        # from a node (< pi)
        $from = s
        !sy&path and throw "from!node"
        $fnode = s
        $fpath = me&tpath,fnode
        $fpith = ''
        
        # to a node, or any pi beyond it
        $to = e
        # gets -Effects @1 (~ toy&efroms)
        #  on to, other to j (from's)
        $E = me&piEffect,j,to
        
        # i E/fpath:node/fpith/t
        $Et = me&Effect_i,E,fpath,fnode,fpith,t
        $Ep = Ety&up
        # have we everything from this node yet?
        #  see resolve $n
        # j Effects[] -> e
        # 
        # < &brackstill repeatedly as the list of Effects fills up
        
        # leaving a &wants to &not when complete is fine
        # < &brackstill parts so far, against copy from &Effected
        # c qualia mix in, shade
        $n = me&ha,j,{Effect:t,Eto:to},c,q
        
        # adding n%%Effect,... to a list that za-ha per R
        $la = me&spoolR,Ep.c,'Rave',R,n
        
        $cha = me&brackstillzaha,la
        $want = la.x.want
        $chat = cha ? "~" : "=="
        #~>5 spoolRave: hak(la.za), chat, hak(la.ha)
        if (!cha) {
            if (want) {
                wantc&drop = 1
                delete la.x.want
            }
            # done, until maybe extra
        }
        else {
            # is change
            # < or periodic fuller wake
            $toR = me&uptoR,to
            # the Effected R is waking
            $waking = jc&N.includes(toR)
            $unEffected = !(Ey&R && jc&N.includes(Ey&R))
            if (waking && unEffected) {
                # awaits &Effected
                # < more certainty about whether it can still happen
                #   Ep remembers all &Effected calls? assume then again?
                # < can probably be woken from anywhere not already woke?
            }
            else {
                # < not noising the brack here (direct to R:Ying)
                # < waits_8 noticing if it did wake (just not yet)
                !isC(toRc&s) and debugger
                if (!want) {
                    la.x.want = me&wants,j,'Effect',toRc&s
                }
            }
        }
        # < compute now if already &Effected
        #    diff -> wake e
        #     unless it's otherable (%ope=0 -> dis:0)
        'ya'
    }
   // -Effect io
    # < io space
    # at both ends of the deal
    me.piEffect = &acgtRsc{
        c ||= {}
        
        # E rolls from under the previous s-eight
        $trip = {t:'Effect'}
        $re = me&pisurrect,R,s,trip
        
        # so we can reuse it
        # < el:4 defies el:2 above to be el:3?
        #   then &Api could handle the -surrect
        c.el ||= 3
        $E = me&Api,s,'Effect',c
        re(E)
        Ec&tpith = trip.tpith
        
        return E
     }
     # E/fpath:node/fpith/t
     me.Effect_i = &acgtE,fpath,fnode,fpith,t{
        $Ef = me&fiu,E,fpath
        me&must_newnodesamepath,Efc&node,fnode
        Efc&node = fnode
        # < from pi, would put onto:
        $Ep = me&fiu,Ef,fpith
        # remark, eg 'acheck'
        $Et = me&fiu,Ep,t
        return Et
     }
     # %Effect:$t,... rows from the above
     me.Effect_o = &acgtE{
        # the -eight
        $e = Ey&up
        $M = []
        me&ioty,E .map(&Ef,{
            $from = Efc&node
            $fj = fromy&R
            # we have senders with remarks
            $fempty = 1
            me&ioty,Ef .map(&Ep,{
                $empty = 1
                # E/fpath:s/fpith:E (Ep) targeted brackstill group
                $pistill = []
                me&ioty,Ep .map(&Et,{
                    # the node must still be sending it
                    $N = me&jaaz,fromy&R,{Effect:Et.t,Eto:1}
                    # %%Eto is eg s-seven//E-seven, which replaces
                    #  but re-finds its Effect
                    N = N.filter(n => E == ahsk(n,'sc','Eto','y','Effect'))
                    # < the node might el=2 (replace)
                    # those y&Effects may have same tpith, differ in fpath
                    #  ie tpith=-Fez, yet fpath says y&up=suchathing-six
                    #  < slope|pile short name for E**, say if not y&main
                    if (!N.length) {
                        # or is de-applied
                        return me&fiu,Ep,Et,9
                    }
                    empty = 0
                    M.push(...N)
                    pistill.push(...N)
                    # < &brackstill on Ep? Ef? sortably?
                    
                })
                empty and me&fiu,Ef,Ep,9
                else { fempty = 0 }
            })
            fempty and me&fiu,E,Ef,9
        })
        return M
    }
    
   // &Effected out
    # to: user wants qualia computed !
    me.Effected = &acgtec{
        # e  the s** or E** to receive on
        $se = me&uptonode,e
        $J = sey&R
        # someone Ringing and awake
        #  might be -Fez (jc&s = data)
        #  eg &Piing may -Effected //E to configure (eg ope:0)
        #   in this case we are other to the E, but know what it is
        $j = Cy&R
        # < R'The' doing -Effected
        js&Pier and debugger
        # might be the self
        $R = ey&R
        !R and throw "to!node"
        $self = R == j
        # see &node_ispresent
        
        # gets -Effects @1 (~ toy&efroms)
        #  on to, self to j (unless other)
        $E = me&piEffect,j,e
        $M = me&Effect_o,E
        c.M = M
        
        self and Ey&R = R
        !M.length and return
        
        c = peel(c)
        if (c.go) {
            me&nu,'-Effect',E
            $Ms = M.map(m => m.sc)
            me&nu,'Ms',Ms
            me&nu,'Je',{se,e}
        }
        
        # all modes take many values of gk=ope
        #  and eg mode=num makes lav=most-wanted-%ope
        c.gk ||= haks(c)[0]
        c.mode ||= 'num'
        $lav = me.Effectsum[c.mode](A,C,G,T,c,M)
        c.v = lav
        
        if (me&node_ispresent,J) {
            # copies to %%Effected on the destination...
            me&ha,J,{Effectsum:1},c
            each in M {
                # < able to be from //E
                $Efrom = ny&R.c.s
                !isnode(Efrom) and debugger
                $ed = ex({Effected:ns&Effect,Efrom},n.sc)
                delete ed.Effect
                me&ha,J,ed
            }
        }
        
        # <
        if (self) {
            # -Effect visiting
        }
        else {
            $trip = {}
            $to = e
            $tnode = me&uptonode,to,trip
            $tpath = me&tpath,tnode
            $tpith = me&pipath,to,trip
            # other, using qualia from this somewhere else
            #  is this nodeo|da?
            # setup forwarding address for z:
            #  such that Eigh &Effect Test %%wobbly
            #   does eight &Effected Test %%wobbly
            #     based on the one that already exists
            #    which visits eight to:
            #    eight &Effect -eight %%ope
            #     then &Effected -eight %%ope
            # any of that might be doable as other
            #   if it wasn't for me&ha,j,{Effect...
            #  or avoidable
        }
        # probably a third way,
        #  gauging update for an &Effect
        
        return lav
    }
   
   // &Effectsum reckon 
    me.Effectsum ||= {}
    me.Effectsum.num = &acgtcM{
        $qua = c.gk
        !qua and throw "Effectsum.num: !c.gk"
        $lav = null
        $votes = {}
        each in M {
            # v is the posited qua for lav
            $v = n.sc[qua]
            v == null and continue
            !num(v) and throw "Effectsum!num"
            $N = votes[v] ||= []
            N.push(n)
            ns&dom and lav = v
        }
        if (lav == null) {
            # if no %%dom-inant state (&togcon adjustment)
            $lalength = 0
            each vN votes {
                # favour more votes
                N.length < lalength and continue
                # or more positive votes
                N.length == lalength && v < lav and continue
                lav = v
                lavlength = N.length
            }
        }
        return lav * 1
    }
    me.Effectsum.includes = &acgtcM{
        $s = c.s
        !s and throw "Effectsum.includes: !c.s"
        $N = M.map(n => n.sc[c.gk])
        return N.includes(s)
    }
  
  // < &nodei|o|e - makes %%eto..., going somewhere
      // nodeio-doc 
       =elvis
       focused on:
       &nodeo - reading %%ein C with Q, immediate return
         maybe there are handlers
         an inter-node o backend
       &nodei - transports via %%eto, wanders off
       < conversely:
       &nodeo might turn into:
        i %%e:hunter who will bring back the goods
       &nodei might merely:
        find %ein serving async, immediate return
       
       &nodee,to,t,a,q
        is &nodei $to %%e:t,...q
        expecting %%efrom:to,e:t,...a
         supposing $to:
          &nodeein,t,&from,q{produce %%a-ish}
           which &nodei back to $from
           including %%e
       basically,
        $from %%stuff -> $to, esp if diff
        comes back to $from once &settle,
         or sooner if $to %%answer -> $from
       usu. &nodei,
        moving intention around
        ie,
        gets delivered, revoked
         attend when different, by way of:
       
       brackstilling
        has %%stuff changed?
        if still:
         &nodee can same answer same question
          immediate return potential
        if diff:
         the $to must attend,
          returning to $from once &settle
           or sooner if $to &nodei back to $from
          all %Ying managed
        helps:
         receivers of %%efrom,...
          eg CBing (value contest/news)
          accept versions of it when ready
          see 'check CBing &nodei is as it was'
          could -%%e%done or +%%rebase if diff
           if &nodeein +%done it when done
           or %%rebase = prescribed differencing,
            is applied, via a big-deal filter, eg:
              a %Compiling in its push-phase,
               can decide to redo, because CBing, already
               depending on the algorithm (||= C percolation)
                to be able to tune inputs near the end of their workload
                including just after it,
                 if the answer is invalidated
                is nice reflexive terrain
       
       eg.
        $from = a %Compiling sequencing operations:
         makes Know%fully and selects %%Live
          $Live = &nodee $to %%Live %%e:fully
           and e:fully is ein there, subplot:
            an anyone-elected %acty=3
            must produce %%Live,
         
         $from %%waits for a response?
          or %%fail if e%edone and !%%Live
         
         $to avoid doming their 'main thing'
           eg CBing
          until all %%e%done
           would new CBing before $from receives %%Live,
           so $from receives also the new CBing,
            bound to the %%Live used for thinging
       
       =elvis
      
      // &nodei
        # moving intention around
        #  row = c(identifying marks) + o(other stuff)
        #  so c finds the rolling %%eto,
        #   %%e may resurrect if %%dige
        # < require %%dome? as T.Mw?
        me.nodei = &acgtj,to,c,shade,mix{
            
            # < bracko C.t == t
            $js = jc&s
            to == 1 and to = jsy&path[0]
            $jo = toy&R;
            to = joc&s;
            # c can be a row, pipelined
            $s = isC(c) && c
            s and c = s.sc
            else
            isst(c) and c = G&peel,c
            c = ex({},c)
            s and haks(sc&shade).map(k => delete c[k])
            isst(shade) and shade = G&peel,shade
            isst(mix) and mix = G&peel,mix
            mix = ex({eto:to},mix||{})
            # %%eto:to,e:C:question,...details
            $q = ex(ex({},c),mix)
            shade and ex(q,shade)
            
            # good details resurrect the same %%e,
            q.dige && q.e and q.e = 1
            $sending = me&ja,j,q;
            
            if (sending) {
                sending.length > 1 and throw "cant tell %%eto apart"
                $n = sending[0];
                c.e && !ns&e and throw "bug"
                if (ns&e) {
                    !c.e and throw "bug"
                    $e = c.e;
                    # < !e%done when slightly changing
                    c.e = ey&resurrected = ns&e
                }
                # re-enter $n for instant &dome_bracki replace
                # < pipeline !growing as it stays still, y&up?
                heq(c,n.sc) and c = n
                q.e && s and throw "mix.e & reenter s unless ny&up=s?"
            }
            # < %Ying relays progress via %%eto?
            #    maybe if we %%uniq this it would return the recycled one
            #   or just via e, how else?
            # must drop s%eto|efrom inside &ha
            #  to let it know its origin
            s and c = s; mix.nodeial = 1
            $n = me&ha,j,c,shade,mix;
            
            return n
        };
      
      // &nodeo
        # S o $remote/#$Q using|returning %%tw,...
        # < persistent query, knowing io it pipes into,
        me.nodeo = &acgtj,to,Q,qe{
            
            $qs = isst(Q) ? {tw:Q}
                : isC(Q) ? ex({tw:Q.t},Q.c)
                : Q
            qe ||= {}
            isst(qe) and qe = G&peel,qe
            $jo = toy&R;
            if (jos&Pavings) {
                qs.of == 'wjs' and qs.of = 'w'
            }
            to = joc&s;
            $N = me&za,jo,qs;
            if (!N) {
                $N = []
                if (qe.el == 1) {
                    # will create it
                    N = [Cye(["nodeo:el:1",1,{},qe])]
                }
                else {
                    # permission is nodei'd in (by now)
                    N = me&jaa,j,'may:input,s';
                    # once an other sees that we:
                    me&ha,j,'may:input,s';
                }
                # we have Qish to tw
                # < input s, clone if sy&path not ours
                # < &may -> %%may,answerlike,question
                #   might look different when (un)answered
                #    eg. %%waits, %%has (done so), %%is (doing) 
                #    and mode stay on, do once, etc
                #   here it will do once and stop being called:
                # me&may,j,'input','s',{tw:Q.t,waits:'not-found'},qe
                N.map(&n{
                    ~>3 CREATE: ki(n.sc,4.23)
                    # < use %Pavings%ein to input
                    if (jos&Pavings || jos&Paving) {
                        if (qs.of) {
                            # look for an of island (even if of=W)
                            $of = me&ioty,to,'Pavings'
                                .filter(of => ofs&Paving == qs.of) [0];
                            of ||= me&fiu,to,qs.of;
                            ofs&Paving = qs.of;
                            ofs&Pavings = 1;
                        }
                        else {
                            # $to/$W direct
                            of = to
                        }
                        $t = me&fiu,of,qs.tw;
                        # info
                        me&ha,j,{waits:'input',wants:to}
                        # listen to to
                        me&settle,j,to
                        # < pointers at not yet nodes
                        toy&p and jos&numberclicked = 1;
                    }
                    else {
                        debugger;
                        #me&fiu,
                    }
                });
                !N.length and me&tsc,'nodeo:'+qs.tw+':el9','non';
                # for %%waits:input first
                return []
            }
            if (N.legnth > 1) {
                # in the web you would want many answers,
                #  perhaps candidates get see s** to rank/sync
                me&tsc,'unc';
                me&waits,'unclear'
            }
            return N
        };
      
      // &nodee
        # %%e:action, expects reply re the same %%e
        # see &nodei re c+o
        me.nodee = &acgt,j,to,t,a,c,o{
            
            $jo = toy&R;
            to = joc&s;
            c.e = t;
            # %%eto:to,e:C:question,...details
            $n = me&nodei,j,to,c,o;
            # reuses e if %%dige 
            $e = ns&e;
            !isC(e) and throw "nodei!%%eto,e"
            # answer could be:
            # %%efrom somewhere answering %%e
            $replying = me&ja,j,{e,efrom:1};
            # anything( somehow)? answering %%e
            # < except $n or its recycling, which may lurk
            #    unless nodei 'slepish let'
            $an = hak(a) ? me&ja,j,ex({e},a) : n;
            
            if (es&done) {
                !an and me&ha,j,{fail:'done',e}
                else {
                    if (hak(a) == 1) {
                        # eg returning %%Live sent back
                        an.length > 1 and throw "many rows"
                        return an[0].sc[haks(a)[0]]
                    }
                    # rows returning from this %%e
                    return an
                }
            }
            else {
                # waits?
                # %%eto hoisting should gently hurry up etc
            }
        }
      
      // < &nodein
        # %%e:handler, sync response
        #  %Ying will otherwise attend $to
        me.nodeein = &acgt,j,t,cb{
            # for e:t into j
            # cb = &from,q{produce %%a-ish}
        }
      
      // nodeio-scussion # further into %Compiling 
       =elvis
       # Know etc means a Know/** node
       # and that &nodei somewhere revisits somewhere
       Know builds tw, &settle
       Know have clients for CBing
        Ghost &nodeo Know their thing,
        Ghost &nodei Know their downstreamness,
         Ghost%dige if not as Know%dige implies
       Know !Ghost, 
        %%may create some Travel/$t c&W=Looking of it,
         to start doing something
       Know CBing per downstream,
        &nodei Ghost %%cha,
         which Ghost &nodei Travel %%cha
       and in reverse: Know <- Ghost <- Travels
       
       Travel/$W,
         receives CBing &nodei %%cha,
          - decides to update itself,
          - gets the inputs ready,
          - runs the thing,
          - tractions a bunch of $n/$u etc
            artifacts to save
             by way of a %Search that accepts writes itself,
              then presenting a tree of things to:
             n all G&t it put, push to That/**
              a downstream Know, non-CBing
              < via another %twin
             u all G&t it used, to Know/**
            push must:
             check CBing &nodei is as it was,
               so a %%rebase might emerge to Travel/$W
                in/near &nodei brackstill
               which our work (bunch of %%e:push) hangs off
              ie know Qs&parent on push,
              different:
               $n - %%rebase strangeness,
                 our downstream changed without us
               $n+$u - Travel/$W again, must know current
                 eg $W loading/saving itself
               $u - new input since Travel/$W
                 eg %dige can CBing again after we push
            if push:
              push all $n, That/**%%e:push,n (->%Paving->G&t)
              note all $u, Know/**%%e:pulled,u (%dige = that used)
               disimplying Ghost/*/**%dige must be expressed
                  semi-syncd Ghost mappings should be resolved after Travel/$W
                   until everything is aligned with Know/**,
                   might end up chasing loops,
                    diff the Travel of several $W in time
               
            $n/$u sets for %twin/$W/* may be canonical or not
             when its not invoking all the G&t the $W gets up to
               
            ideally all those G&t + W:KnowThee%Ying itself
             are in an Over%Search
              branching things for KnowThee
              to be merged with the Uber%Search above that,
               saving each thing,
                can sorta undo if interrupted,
                 from memory or Uber git reset
               < getting the new tree of changed things ready,
                 then commit just changing a link
             
            then!
            back to:
            CBing &nodei as before, since the %dige is out
            which might be real fast since the gear
             is all ready to pass another %Live through
      
       =elvis
      
      // nodeio-Yingu-scussion # sort activity
       =elvis
       underneath &nodei:
        $from &nodei $to %%stuff
         put into $from%%eto:to,stuff
        %Ying hoists %%eto,stuff
         &brackstill-ing %%stuff
          attending $to
       # < Yingterms:
       #  < need tests for all this. compiles tests <-> docs
         then (once $to &settle or sooner or later)
          attending $from
         sooner if:
          %%e - &nodee suggests a round trip:
           e%done or the question solved means return
           $from exacting %%eto:to,e <-> %%efrom:to,e
          $to &nodei $from, related or not, attends $from
           as in returning a row to find the question in
           < should it merge with the from?
         later if:
          %%e - !e%done etc, the above in reverse
          !&settle,
           see 'not accepting CBing while busy'
        
        if %%eto,dome=questions,
         persists them, as usual
          you periodically refreshing %%dome
         if %%dome, could anyway, see %%dome ttl
         
         hoisting progress could appear on it,
          eg $to accepted, then &settle
          the hoisting-out could be a Y,
           involved for $from dome init,
            and $to delivery, or anything
       
       ecoursing:
        where the e takes us/our stuff
        eg c&el makes adjustments on some $to ground,
         probably the same %%dome as the $from
         or to a corresponding idea:
        $to %%efrom,dome=questioned
         to wakey the $dome part of $to,
          like routes
        re %Slope:
         they plumb somewhere else,
          that $from can detect the state of
           follow our affect through the machine
           eg wanting to watch Babz %Compiling
            to bring meta back to the ghost
            ie cursoring details transient in the process itself,
             rather than even biggering the result
         $e might:
          encode and wander the network meanwhile
           coming back to pick up that $e again,
            contracting some %Search to keep a way in:
             matching a rebooted %%eto
              by brackstill == that $e that left
       
       =elvis
   
  // &bready - if no %%waits
    =elvis
     &waits,... -> R%waits
     &bready and return # implements a waitsology
      R%waits -> %%waits
      %%wants:$n%%waits -> %%waits:wants,...
      %%waits -> pause|shy $R
       and inners, unless $n%%waits,
         or %%waits:wants them,
         fuzzy line? who is waiting for who
         top down if same cv?
       might be a recognisable solution
       might be retry loop,
       do others first (moreso if %%waits:wants)
    =elvis
    me.bready = &acgtR{
        # got to via %%wants:R below
        !Rs&wou and throw "notbegun"
        # R%waits -> %%waits
        each in Rs&waits {
            me&ja,R,{waits:n} and continue
            $h = me&ha,R,{waits:n}
            hy&waits = n
            ny&waits = h
        }
        # %%wants:$n && n%%waits -> %%waits:wants,wants:$n
        #  $n may be a non-node R
        me&jaa,R,'wants' .map(&n{
            $z = ns&wants;
            ns&waits || !isC(z) and return
            # once
            nc&breadied and return
            nc&breadied = 1
            # could be p/r/s
            $j = zy&R;
            $q = {waits:'wants'};
            # R:Pave passes through as %%wants
            isR(z) && zs&ball and z = jc&s;
            !z || !zy&R and debugger;
            # decide if %%wants should %%waits
            if (!js&wou) {
                q.notanode = 1
                js&waits and me&ha,R,n,{},q
            }
            else {
                # < unpossiblate infinite recursion
                #   with me&ind bit on the T?
                me&bready,j and me&ha,R,n,{},q
            }
        })

        # < %%waits -> pause|shy $R
        # avoiding the rest of the activity
        return me&ja,R,'waits'
    };
        
  // &settle
    =elvis
     &settle,z and return # waitsology for z to seem ready
     
     &settle sets/checks a node that is:
      relative to this node, which wants it,
      &node_issleeping, not able to unsettle this time
      < not pending elvising:
        as in %%wants:n,acty:1,settled,
         unless %%acty has transmit
      &halfsettled @7:
        &bready,
        &brackstable: ja == za
      and:
       nodes below are at least &halfsettled
        eg: Settled/Unsettled/Chaos
         where Chaos is not &brackstable etc but Unsettled is
       < should be able to climb bunch of index then a node,
         'nodes below' meaning the next layer of nodes beyond!
    =elvis
    me.settle = &acgtRr{
        R = Ry&R;
        isar(r) and return r.filter(n => me&settle,R,n ).length
        
        if (!isR(r) && isC(r) && !ry&R) {
            $to = r
            # node that never was, should turn up if we visit sy&up
            $ru = toy&up;
            !(ru && ruy&R) and throw "settle,R,s not connected enough"
            me&wants,R,"newnode",ru
            # and come back here, as if we had settled it
            #  turns out we can set up sy&settle* before visitation:
            !me&ja,R,{settle:to} and me&ha,R,{settle:to}
            return 1
        }
        r = ry&R;
        $from = Rc&s;
        $to = rc&s;
        # log it, via &settle_6|8 + Ying to transport
        !me&ja,R,{settle:to} and me&ha,R,{settle:to}
        # < that and this still working if sleeping
        $comeback = &t{
            me&ha,R,{waits:'settle',wants:to,for:'settled-'+t}
        }
        # is figured at Doming_7, once est.
        $se = toy&settled;
        $settled = se && ses&settled;
        
        !settled and comeback('not')
        else
        # check these two loose-able aspects:
        !me&node_issleeping,R,r and comeback('!sleeping')
        else
        me&settle_halfsettle_down,to .length and comeback('!down')
        else {
            return 0
        }
        return 'not settled'
    }
    # settle all previous siblings
    # for 3 &settle 2,1, for lack of:
    # < settle deeply, 3 &settle 2 &settle 1
    me.settle_prev = &acgtR{
        $N = me&ioty,Ry&up,'ball';
        $ri = N.indexOf(R);
        ri < 0 and throw "upz%ball"
        $prev = N.slice(0,ri);
        !prev.length and return

        me&settle,R,prev and return 1
        Rs&settled = prev;
        Rs&brackstable_aware = 1;
    }
    
  // < &acting, &acty, &wants
    # a heading for some %Part of it
    # < swallowing brack
    #  < knowing T.act here and when ha
    # acty:8 meaning dialectical,
    # acty:1 would be openey,
    #   buttons for the first layers of mind atop
    # they are cv-ish, yet individual doables...
    #   %%may:ha,openey:1,acty:1 - advertise route
    # then just increase %%acty to wander in to things
    #  eg when depending on something being awake
    #  eg acty=5 might be enough to know expected Wup affects
    me.acting = &acgtRty{
        R ||= me&R
        !t and t = T.act.t; me&reaw,R,t
        y == null and y = 1
        y and me&inode,R
        $go = me&rolltog,R,{may:t,tsc:'l',acty:8};
        if (go) {
            R.sc['go'+t] = 1
            $x = me&Jx,R
            $s = Rc&s
            $ot = t.match(/^-?(.+)/)[1]
            $named = s.y [ot]
            if (named) {
                # othering as %ball for verbosity
                # < know when -eight is sprawling open,
                #   to stop at -seven if it doesn't $go
                $name = 'sy&'+ot
                x.ro(name,{}) and me&bal,name,named,'eph'
                else { me&nu,name,named }
            }
            me&nu,'s',s
        }
        return go
    };
    # $from &wants,'msg'||c,$to -> %%waits:$msg,wants:$to
    # < $from -> $later? test the effects
    me.wants = &acgtRtsc{
        !isst(t) and throw "ct"
        c ||= {}
        isst(c) and c = G&peel,c
        c.waits = t
        c.wants = s
        me&ha,R,c
    }
  
  // &quiet_waker*
    # management nodes wake up when all is quiet
    me.quiet_waker = &acgtR{
        Rs&quiet_waker = 1
        me&reaw,R,'quiet_waker'
        $Y = me.cbu(R,'Ying').sc.Ying
        $s = Rc&s
        Ys&quiet_wakers = [s]
        #ac(Y,'quiet_wakers',s)
        # may be having one
        $is = delete sy&quiet_wake
        is and Rs&quiet_now = 1
        is and Rs&is_quiet = 1
        return is
    }
    # to see if eg Gump is quiet_now from Gump...Gome
    #  Gome may be tunneled on its own (false)
    #   or being %wakeful from Gump%quiet_now (true)
    me.is_quiet_now = &acgts{
        # to the latest R, possibly tunneled-through?
        $r = me&yfuture,s
        return rs&is_quiet
    }
    # do something when nothing
    # < not before a slow wakers[], for async
    #    may finish waiting early
    me.quiet_wakers = &acgtR{
        $Y = Rs&Ying
        $D = Rs&Det;
        $would = Ys&quiet_wakers;
        grepout(would,s => sy&invalide)
        !would and return []
        $wakers = []
        $quiet_recently = &s{
            return me&wokerecently,R,s,5,{quiet:1} .length
        }
        # quiet,wake when not recently
        #  or if next page == Plot%wants_upto, must self to act
        $y = Ys&quiet_wakers_too_recently
        if (would.filter(s => !quiet_recently(s)).length
            || y && y (R)) {
            would.map(&s{
                # < Yinge terms:
                # is consumed:
                sy&quiet_wake ||= 1
                wakers.push(s);
            })
        }
        else {
            ~>5 quiet_recently: joint(would,'+')
            me&bracki,R,D,{quiet_recently:1}
        }
        return wakers
    }
  
// 8 < round
 // %%waits 7 - visit other nodes
    # r%%waits,wants=z,... -> R &waits_8
    #  from &settle, &bready, or you
    me.waits_7 = &acgtRr{
        $s = rc&s
        # &bready finalises and returns the %%waits
        $waits = me&bready,r || []
        waits .map(&n{
            # %%waits = R%waits/$D
            $D = ns&waits
            D = isC(D) && D
            $q = {via:s}
            
            D && sex(q,D.sc,'say,sooner,momentarily,later')
            if (!ns&wants) {
                # usu from just &waits
                #  lets explicit %%wants happen first
                q.wants = s
                q.momentarily = 'nowants'
            }
            
            $z = ns&wants || q.wants
            if (ns&notanode) {
                q.sooner = 'notanode'
                ~>3 notanode: s.t, z.t
            }
            else
            isR(z) and ~>3 wantsR: s.t, z.t
            
            # -> Ying waits_8
            $h = me&ha,R,n,{},q
            D and Dy&waits8 = h
            ny&waits8 = h
            hy&waits = n
            
        })
        !waits.length and rs&isbready = 1
    }
 // &Ying_8
        # Ying done, orgs comeback
        #  R%Ying Domes_o3 but not _7
        #   except to have za commit
        me.Ying_8 = &acgtRs{
            me&node_accept,R,R,s;
            
            # across Ying
            me&etos_8,R;
            me&settle_8,R;
            # Ying around
            me&waits_8,R;
            
            # < Yingu may stepbrack Ying itself
            #me&node_issleeping,R,R and return
            #me&stepbrack,R;
        };
    
// &waits_8 - regroup around
   // &waits_8
    =couldbe
     Ying waits_8   wakers order re &settle
      dribbling awareness in waves to Ying
     
     a $to-before-$from separator,
      as long as theyre both in $wakers[]
      !&settle $to doesnt block $from, see 'waitsology'
     
     a lifo of $froms awaiting &settle
     
     something to do when !wakers
     
     < study errors
     
     < packs ($to,$c:term?)+ for Ying, pass nuance per $to
     
     one day:
     < &settled, or just &settle with no $to
       true if $from is waiting for any $to
       would cause an extra 'onemore' (after %brackstable)
        to experience being %settled
     
     < guarantee the eventuality,
        check every Y%settles %from?
       to catch up lost|tangled impulse:
       $from|$to generate 8%%waits:settle,wants:each other,
        $from 
         &settle_6 - wants $to to &settle
        $to
         &settle_7 - checks for &settle
          pushing &halfsettled to children
          versioning %wou for:
        $from
         &settle_7 - accept $to &settled
       can get distracted with settle-stacking, unless lifo?
     
     < loop detect !sooner && !later
        go for least conflicted, earliest in Sy&N
     < instant Yingu innard, style of collapse into time
     < partition into several single-minded Yings,
       for atomicity,
    =elvis
    me.waits_8 = &acgtR{
        $Y = Rs&Ying;
        $set = Ys&settles;
        
        # < brack all this, esp about tpath
        # getting more later:
        $sooner = [];
        $wakers = [];
        $momentarily = [];
        $later = [];
        $stashed = ['laters','momentarilys']
        each ik stashed {
            $M = Y.sc[k]
            each iN M {
                # may have happened anyhow
                N and grepout(N,n => me&Detectioned,R,n )
            }
            M and grepout(M,N => !N.length)
        }
        $freeze = [];
        
   //     !%%wants|!node
        $ignore = [];
        $tpaths = {};
        $tpath_s = [];
        $tpath_ = [];
        $tpath = &s{
            $si = tpath_s.indexOf(s)
            si >= 0 and return tpath_[si]
            $tp = me&tpath,R,s
            tpaths[tp] ||= s
            $si = tpath_s.push(s)-1;
            return tpath_[si] = tp
        }
        $saywaits = &n{
            $tp = joint(haks(n.sc))+" "
            $s = ns&wants
            $sr = s && me&tpath,s || "!%wants"
            $viar = ns&via && me&tpath,ns&via
            viar = viar && viar != sr
                ? " (via "+viar+")" : ''
            $why = ns&waits
            why = isC(why) ? why.t : why
            
            return sr+viar+": "+why
        }
        me&jaa,R,{waits:1} .filter(&n{
            $s = ns&wants
            # !
            if (ns&say) {
                $tp = saywaits(n)
                ~>4 says: ns&say, tp
            }
            
            # usu from just &waits!
            #  lets explicit %%wants happen first
            ns&momentarily and momentarily.push(s); return
            # usu just R we should tunnel
            # eg R%Paving/r%Pave, happens to only tunnel to R
            # < ns&via probably -> later
            ns&sooner and sooner.push(s); return
            # almost a quiet_waker...
            ns&later and later.push(s); return
            # < others may have %Q waiting for %ready
            #   this could later an entire set of wakers for 300ms
            
            $j = sy&R;
            !j and debugger
            # no %%wants=R (j==s)
            !j || jc&s != s and debugger;
            
            $tp = tpath(s)
            $z = tpaths[tp];
            if (z && s) {
                z == s and "s dup %%wants,..."
                else {
                    if (sy&R && zy&R && zy&R != sy&R) {
                        ~>5 tpath res: tp
                        zy&R == me&yfuture,sy&R and return
                        me&yfuture,sy&R != me&yfuture,zy&R and debugger
                        ignore.push(z);
                        tpaths[tp] = s
                    }
                    else {
                        zy&up == sy&up and throw "s dup same up (tv|tw?)"
                        throw "tpath confu"
                    }
                }
            }
            
            return 1
        })
   
   //     %%wants:node
        
        .map(&n{
            
            $s = ns&wants;
            $j = sy&R;
            !j || jc&s != s and debugger;
            
            $tos = sy&settletos;
            if (tos) {
                # waiting for these
                $arewakers = me&ioty,tos .filter(n => tpaths[n.t]);
                if (arewakers.length) {
                    #~>5 waitfor: tpath(s)
                    later.push(s);
                    return
                }
            }
            
            if (js&brackstable > 6) {
                if (me&wokerecently,R,s > 3) {
                    ~>4 freeze: tpath(s)
                    freeze.push(s)
                    return
                    # < try to release laters to around it?
                }
            }
            
            !wakers.includes(s) and wakers.push(s)
        });
        
   //   # sooner or laters
        # < then submit to another round of ^ (Jx doming)
        # the arrays going to &log must be readonly
        
        # sooners take precedence over any wakers
        $rem = ''
        if (sooner.length) {
            momentarily.push(...wakers)
            wakers = sooner
            rem = "sooner"
            hak(momentarily) and rem = "<-sooner"
            hak(momentarily) and me&log,R,'sooner',{wakers,momentarily}
        }
        if (!wakers.length) {
            wakers = momentarily.slice()
            # < shouldnt happen?
            hak(wakers) and rem = "()momentarily"
            momentarily = []
        }
        if (!wakers.length) {
            wakers = (Ys&momentarilys||[]).pop() || []
            hak(wakers) and rem = "<-momentarily"
        }
        
        # laters give precedence to any wakers
        !wakers.length and wakers = later; later = []
        if (!wakers.length) {
            wakers = (Ys&laters||[]).pop() || [];
            hak(wakers) and rem = "<-later"
            hak(wakers) and me&log,R,'later',{wakers}
        }
        wakers = uniq(wakers)
        
   //   are concluded
        if (wakers.length) {
            $via = {}
            $vias = {}
            uniq(wakers) .map(&s{
                $got = me&jaa,R,{waits:1,wants:s} .map(&n{
                    #+isR(s) and ~>7 GoR: s.t
                    isR(s) and return
                    $t = me&tpath,s;
                    vias[t] = s
                    via[t] ||= [];
                    via[t].push(saywaits(n))
                });
                if (!got.length) {
                    # < can't find any via later[] etc
                    #~>7 unk: s.t
                }
            })
            each tm via {
                $s = vias[t]
                $V = me&jaa,R,{wants:s,say:1} [0]
                !V and break
                # < assumes only one
                $say = Vs&say || ''
                ~>7 8r: t, say
                each it m {
                    ~>7 <-: t
                    me&log,R,'later',{waker:s,say,saywaits:t}
                }
            }
            
        }
        
        # for later
        later.length and ac(Y,'laters',later)
        momentarily.length and ac(Y,'momentarilys',momentarily)
        # they may happen before planned
        each is wakers {
            ['laters','momentarilys'].map(&k{
                $wake = Y.sc[k]
                !wake and return
                wake = wake.filter(z => z != s)
                !wake.length and delete Y.sc[k]
            })
        }
   
   // and finally ish
        !wakers.length and wakers.push(... me&quiet_wakers,R )
        !wakers.length and ~>4 .:
        
        me&Yingate_8,R,{wakers}
        
        !wakers.length and return

        # Ying and each node has %terms,
        #  they must accept the wave is done
        wakers = wakers.map(&n{
            return {wake:n,terms:{anode:1}}
        });
        me&Yinge,R,{wakers,terms:{bunch:1}};
    }
   
   // &Yinge - &waits_8 gives:
    me.Yinge = &acgtRc{
        me&rollbs,R,'Iinint',0;
        $starting = Rs&Iinint++ < 128
        
        $elvising = &{
            # since delay, Ying may have reset at Peace:8
            #  and only be as far as Gens (about to +self)
            # < J would simpler.
            $dodge = {}
            $Xt = &nt{
                $X = nc&X
                $oX = X && X.x && X.x[t]
                oX && oX.z and return oX.z[0]
            }
            $jr = me&yfuture,me.cbu(R,'JRom')
            $jp = me&yfuture,jry&up
            jr = Xt(jp,jr.t)
            $ge = Xt(jr,R.t)
            !(ge && ges&Gens) and dodge.nogen = 1
            $gen = me.cbu(R,'Gens')
            ge && me&yfuture,gen != me&yfuture,ge and dodge.Xfuture = 1
            
            $r = ge && me&ioty,ge,['Ying'] [0]
            !r and dodge.Early = 1
            else
            rc&s != Rc&s and dodge.Yingdiff = 1
            else
            r != me&yfuture,R and dodge.rfute = 1
            
            4s&gonemainthing_s == Rc&s and dodge.gones = 1
            
            $ks = G&depeel,dodge
            hak(dodge) and console.log("dodge:"+ks)
            hak(dodge) and return ~>6 DodgeYinge: R.t, ks
            
            # giving N[{wake:r,terms}]
            me&elpack,R,"Yingvoids",'reYn',c.wakers
        };
        # avoids usual timing of Elvoids:
        # < should ec&when exactly
        $del = starting ? 22 : 3000;
        # limit to one feedback loop
        $Co = me&rollbsc,R,'Corresp';
        $yeah = me&sccb,Co,'Yingvoids',elvising;
        G&yl,del,yeah;
    }
    # make e:$t pack with e:$k for N inside
    me.elpack = &acgtRtkNc{
        c ||= {}
        # visits those r**
        $wakers = N.map(&r{
            $c = {}
            !isC(r) && isC(r.wake) and c = r; r = c.wake
            r = ry&R;
            !isR(r) and throw "notR"
            c.wake = me&yfuture,r;
            c.ret = 1;
            return me&elvis,R,k,c
        });
        # on a single trip to %Ying
        # pack: es&z are e, simultaneously
        c.pack = R;
        return me&elvis,R,t,c,wakers
    }
  
   // < conclusion *Ying_8 -> waits_8)
       =pod todo
        < # Yingterms
        %%dome 
         < and other %%tricks
        &settle, meaning a wants b to be settled,
          quickly decided, else comeback
        < catching that %Pave elvis async already @315
           coming back to complete bunches at a time
        < io making sense of eg %%tw, %ein,
          but probably not &settle, too micro to wait
           blocking reads only for Pinnings: S o Thing
        < upper levels of %acty or R/r tugging lower
          %Paving would become acty=2,
           meaning something acty=1 (%%openey) succeeded
          and produce a %%Live (Qc&s)
        < %Paving basically top-down &settle,
           and some kind of r%acty=R%acty-1 tugging spread
          runs out of %acty=1->%openey far enough in
          so $p/* should &settle,
            but $p/*/*/* neednt be %openey (or settled?)
          > becoming %Paving_good|in all the way down|up
          might be up to r:Know to %%wants:r/*,acty:1,settled,
       
       // mostly
         most behaviour decisions wait for &settle
          waiting for confidence
          eg selecting nodes eg S o ... or &nodeo

         most behaviour reflexes wait for &bready
          just needing a bit of resolution
          eg begin reaction as txn on brack
            as in %%may,... -> ...,%may, sorta
        
         and they form loops!
         
       // Yingterms - see nodeio-Yingu-scussion
        messaging / nodes / time
        find loops, pause/debug/trace
       
        %Yingu
        < display for Ying, out of time
        R%Ying @296 - repeatedly
         may be planned, e with %term
         or random e (click)
        
        arrange for next Ying to come back with
         %terms - arrival protocol
          eg visit only $to, not $to/**
           for any %%eto upwards
          otherwise figured by elvis %tunneling
        
        by sorting waves of wakers
        < p%priority or nodes refd by another waker first
        < deeper nodes first, all siblings at once
          supposing their reason to be is compatible,
           avoid re-%%waits when theres %%eto to deliver
        
        from now and before
        < undropped e when sccb throttles
        < come back in at least a little while
        
        noticing when we might
        < interrupt busy system
         < to refine eg &etos_6 &brackstill
        < give up on
         < &brackstill %%waits
          < until what it %%wants re-&settle
         < sheer change (lack of) in motion,
           if all %Zif-able, spotting increases etc.
        < go randomly visiting ($p/10s?)
          where further time plots emerge
       =elvis
  
// 9 wakes
 
