# go there for ..!?!
# having to contribute
   // X
    // for Brackio
        # index n by n%*
        #  X/k/ref(s) enumerate columns and their values
        # ongoingly to index N-news into X
        me.brackX = &acgtNX{
            X ||= {}
            X.z ||= []
            each in N {
                X.z.push(n)
                each kv n.sc {
                    # the keys
                    $kx = me&X_t,X,k,n,'k'
                    # have their values via unique id
                    me&X_s,kx,v,n,'ref'
                }
            }
            return X
        }
    // &X_t|s|refer for Nodar
      =write or read (autovivificatorialy)
        X/$someindex ||= x += /$n
       leading to x, another|inside X via $someindex
       x doesnt know what indexes it is in
        &Xsomp etc make ax = {someindex=value,x,n...}
        joins|varies by x.z/r aka x/$n or just /$n,
         the members being added to x locatable space
       < X_n, X_z for duplicating|not X.z?
      =cut 
        
        # the X/$t += r
        # r could be Y, s (C), X|x, anything
        # in &RbitXarrive it is R, &brackX it is a row
        me.X_t = &acgtXtrk{
            k ||= 't'
            X[k] ||= {}
            $x = X[k][t] ||= {};
            x.up = X
            x.z ||= [];
            r && x.z.push(r)
            return x
        }
        # the X/uniq($s) += r
        me.X_s = &acgtXsr,kf{
            kf ||= 's'
            return me&X_refer,X,s,r,kf
        }
        me.X_refer = &acgtXsr,kf,kfs{
            !kf and throw "named"
            kfs ||= kf+'s'
            # by id of the value
            $fs = X[kfs] ||= [];
            $vi = fs.indexOf(s);
            vi < 0 and vi = fs.push(s)-1
            $f = X[kf] ||= [];
            $x = f[vi] ||= {};
            x.up = X
            x.z ||= [];
            r && x.z.push(r);
            return x
        }
    // on data
        # groups [C+] by their %$k
        # [%K:2,%K:1,%K:2,%oth] ->
        #  [[%K:2,%K2],[%K:1],[%oth]]
        # < order mirrors eg Know..$K
        me.sortial = &acgtNyc{
            $X = {}
            c ||= {}
            isst(c) and c = peel(c)
            isst(y) and $k = y; y = j => j.sc[k]
            N.map(j => me&X_s,X,y(j),j )
            X.ss ||= []
            $order = c.sort ? X.ss.slice().sort()
                .map(s => X.ss.indexOf(s))
                :
                haks(X.s)
            $M = order.map(i => X.s [i] .z)
            c.flat and M = flatten(M)
            return M
        }
        window.flatten = &M{
            $N = []
            each il M {
                !l and continue
                !isar(l) and throw "flatten!ar:"+ki(l,2)
                N.push(...l)
            }
            return N
        }
 
  // 0.columns @Gump tables
    # x%columns%pk <- %%layout
    me.columns = &acgtRc{
        $s = Rc&s
        # < via &Jx
        #$x = me&Jx,R
        #x.t = 'acolumning'
        $x = Cye(['acoluming',1])
       // <- %%layout spec
        xs&columns = []
        $toname = &n{ return isC(n) ? n.t : ""+n }
        xs&groups = []
        # order doesn't matter to bracko
        me&jaa,R,'layout,outside,p,inside' .map(&ni{
            1 < i and throw "many joins"
            $spec = haks(n.sc)
            $left = spec.indexOf('outside') < spec.indexOf('inside')
            if (left) {
                xs&pk and throw "many left"
                xs&pk = ns&inside
                xs&groups.push(ns&inside)
                xs&columns.push(ns&outside,ns&p,ns&inside)
            }
            else {
                xs&columns.slice(-1)[0] != ns&inside and throw "not joined %%inside"
                xs&columns.push(ns&p,ns&outside)
            }
        }).length
        ||
            me&jaa,R,'layout,mostly' .map(&ni{
                xs&pk ||= ns&mostly
                xs&groups.push(ns&mostly)
                xs&columns.push(ns&mostly)
            }) .length
            && me&jaa,R,'layout,also' .map(&ni{
                xs&columns.push(ns&also)
            })
        
        $g = xs&g = me&opeolo,R,'sprains'
        gs&dis = 4
        # column header
        $gr = gy&can('w')
        grs&bri = 1.4
        grs&deco = 1
        $se = gry&can('c')
        xs&columns .map(&n{
            $se = gry&can('c')
            $name = toname(n)
            ah(x,'columnt',name,n)
            xs&groups.includes(n)
                && ah(x,'grouptse',name,se)
            ah(x,'headingtse',name,se)
            $lc = sey&can('i',name)
        })
        
       // -> y&arow(h,c) starts drawing
        
        # h:byT starts drawing
        # < able to pass columning x between J|R%rowgroup
        #   to split sprains into R per $t (row.join)
        xs&rows = 0
        xy&arow = &hc{
            isst(c) and c = {inish:peel(c)}
            c ||= {}
            $i = xs&rows++
            $was = xs&row
            $row = {}
           // detect row.present columns
            # inish are h%$gk to match as a column
            row.present = sex({},h.sc,c.inish)
            # coli:value of matched $gk
            row.joiniv = {}
            each kv row.present {
                $vi = xs&columns.indexOf(k)
                if (vi >= 0) {
                    # column named $gk
                }
                else {
                    # a node for its step's column
                    !isnode(v) and continue
                    vi = xs&columns.indexOf(vy&path[0])
                }
                vi < 0 and continue
                $n = xs&columns[vi]
                if (xs&groups.includes(n)) {
                    # in the group-by
                    row.join ||= v
                    row.joiniv[vi] = v
                }
                else {
                    # when it %pk|groups|joins in the middle,
                    #  the first columnable thing is left or not of it
                    #   helps to have %%direction symbols
                    $joincoli = xs&columns.indexOf(xs&groups[0])
                    joincoli < 0 and debugger
                    row.left ||= (vi < joincoli ? 1 : 2)
                }
            }
            row.left == 2 and delete row.left
            
           // row.label, row.joining columns
            $t = row.join
            $indexing = []
            each iS xs&groups {
                i = xs&columns.indexOf(S)
                $v = row.joiniv[i]
                indexing.push(v ? toname(v) : "?")
            }
            indexing = joint(indexing,'+')
            !indexing and debugger
            row.label = "h:"+indexing+" "+i
            
            # usu Travel/$t joins
            #  has row.te cell
            row.joining = {}
            each iS xs&groups {
                i = xs&columns.indexOf(S)
                $v = row.joiniv[i]
                $vo = was && was.joiniv[i]
                # a break avoids joining later columns anyway
                v == null || vo != v and break
                $te = row.joining[i] = was.col[i]
                row.te ||= te
            }
            # now, (loop above &arow might have already)
            #  row-span cells of row.joining-ness
            #   also space for large-ish items, spacer row
            was and xy&arowgrouped(row)
           
           // draw row
            
            $g = xs&g
            $gr = row.gr = gy&can('w')
            $se = gry&can('c')
            $lc = sey&can('i','+')
            
            row.col = xs&columns.map(&Si{
                if (xs&groups.includes(S)) {
                    # Travel..$t
                    $te = row.joining[i]
                    if (!te) {
                        te = gry&can('o')
                        row.te ||= te
                        tec&rows = [h]
                        me&walls,te,'b:1.4h6'
                        row.made_te = 1
                    }
                    else {
                        # < Km Kn supposed|used to know!
                        tec&rows.push(h)
                    }
                    xy&terowspan(te)
                    $se = te
                }
                else {
                    $se = gry&can('c')
                }
                sey&step = S
                sey&coli = i
                return se
            })
           
           // is
            # ^v est. row
            xs&row = row
            hy&arow and throw "many arow per h"
            hy&arow = row
            # + shows  source rows
            $te = row.te
            !te and debugger
            lcs&ope and ac(te,'srcbyT',h)
            
            return gr
        }
        
       // y&inSteps(z), y&stepcol(p), y&cean(t,...), y&usun(z)
        # try to find a Travel..$t etc to hang off
        # < for all column
        xy&inSteps = &sqN{
            N ||= xs&columns
            !q and $returnq = q = {}
            $sc = isC(s) ? s.sc : s
            each kv sc {
                # ignore eg %%lost:Travel
                N.includes(v) and continue
                !isnode(v) and continue
                $S = vy&path[0]
                $vi = N.indexOf(S)
                vi < 0 and continue
                # thing is in a step that is a column
                # notes first thing that is so
                q.step = S
                q.column = vi
                q.gk = k
                return returnq || v
            }
            returnq and return returnq
        }
        # once arow, you may find row.col.$coli=$se for p
        xy&stepcol = &p,row{
            row ||= xs&row
            $se = row.col.filter(se => sey&step == p)[0]
            !se and debugger
            return se
        }
        xy&cean = &t{
            $args = [...arguments].slice(1)
            $se = xy&stepcol(t)
            !se and debugger
            !hak(args) and return se
            return sey&can(...args)
        }
        # node gets label
        # se - which column modulat to put in
        xy&usun = &z,se{
            if (isnode(z)) {
                $label = z.t
                !isnode(z) and throw "unnode"
                se ||= xy&stepcol(zy&path[0])
                # < interesting, posited as not yet?
                #   eg may el2 Travel..$t based on a To..$a (%%lost)
                #    or Know..$K (%%lonely)
                sey&step && sey&step != zy&path[0] 
                    && me&mtsc,se,"wrongleft?"+xs&row.left,"","y"
                
                # pathy label K columns, the outsides
                # < know better
                $col = xs&row.col
                if (se == col[0] || se == col.slice(-1)[0]) {
                    label = joint(zy&path.slice(1),'/')
                }
            }
            else {
                !se and throw "usun!node!se"
                !isst(z) && !num(z) and throw "usun!st|num"
                $label = z
            }
            $lc = sey&can('i',label)
            return lc
        }
       
       // -> y&arowed() etc finishes drawing
        xy&terowspan = &te,{
            $rows = hak(tec&rows) + hak(tec&nonrows)
            me&span,te,rows
        }
        xy&arowed = &{
            $row = xs&row
            each iv row.joiniv {
                # for new joinings
                row.joining[i] and continue
                $te = row.col[i]
                if (v || !me&ioty,te .length) {
                    # empty te/* ||= '?'
                    $ro = tey&can('w')

                    $rc = !v ? roy&can('i',"?")
                        # print it like a node, like h%%K,z except:
                        #  with the above te/* ||=
                        #  without comp. same .t as neighbour (K>v)
                        : xy&usun(v,ro)
                }
            }
        }
        # may have another row to group onto
        xy&arowgrouped = &row,{
            $was = xs&row
            # coli/nonrows to make joining[i<coli] span
            $spanning = {}
            # coli/te that join
            $joining = {}
            each iv was.joiniv {
                if (row) {
                    # we are the next, joinable row
                    $te = row.joining[i]
                    te and joining[i] = te
                    te && tec&finished and debugger; continue
                    # te can accumulate interestings until finished
                    te and continue
                }
                $te = was.col[i]
                tec&finished and continue
                tec&finished = 1
                # they collect details
                $plusrows = &ts{
                    $spans = spanning[i] ||= []
                    $ol = xy&plusrows(t,s)
                    spans.push(ol)
                    return ol
                }
                each tN tes&brackaft {
                    plusrows(t,N)
                }
                $N = tes&srcbyT
                if (N) {
                    plusrows('n', xy&nward(N))
                        .sc.hue -= 50

                    plusrows('byT',N)

                    plusrows('u', xy&uward(N))
                        .sc.hue += 50
                }
            }
            if (hak(joining)) {
                # joining columns span large item rows
                # < the plusrows()'s colspan doesn't expect
                #   this rowspan moving it over
                each coli,l spanning {
                    each i,te joining {
                        coli > i and continue
                        $nonrows = tec&nonrows ||= []
                        nonrows.push(...l)
                        xy&terowspan(te)
                    }
                }
            }
            else {
                # insert a spacer row when nothing in common
                # < wanting to row.gr%mb=1, means nothing when tabley?
                $g = xs&g
                $gr = xs&rowspacer = gy&can('w')
                grc&s = ' '
                grs&fs = 4
            }
        }
       
       // y&nward, &plusrows etc detail
        # done a group of rows,
        #  nearby unfoldments and footnotes
        xy&uward = &s{
            $N = isar(s) ? s : [s]
            $M = []
            N.map(n => M.push(... me&jaa,R,{n} ))
            return M
        }
        xy&nward = &s{
            $N = isar(s) ? s : [s]
            return uniq(N.map(u => us&n).filter(n=>n))
        }
        # table-spanning row for extra group of (brack) rows
        xy&plusrows = &kN{
            isC(N) and N = [N]
            $g = xs&g
            $gr = gy&can('w')
            $se = gry&can('c')
            $rc = sey&can('i',k)
            rcs&dis = 5
            me&span,se,xs&columns.length+1,1
            
            $ol = xy&brackcell(k,N)
            ac(se,'z',ol)
            
            return ol
        }
        # extra group of brack rows
        xy&brackcell = &kN{
            $D = Cye(['+'+k,1])
            Ds&z = N
            # < dupe C confusol
            $label = xs&row.label
            $br = me&pibrackology,R,D,{D,ology:{label}}
            $ol = bry&ology
            ol.t = label+k
            
            # make the Kms wrap, not dis:inline-block
            # < when the line we're on is fresh
            me&ioty,ol .map(t => delete ts&dis)
            # with no label inside the brack cell
            oly&label.sc.dis = 0
            
            return ol
        }
        
        return x
    }
    me.span = &acgtnid{
        ns&tag = 'td'
        $way = (d == 'row' || !d) ? 'row' : 'col'
        ah(n,'attr',way+'span',i)
    }
  
 // &Sa
 
  // < &Sa %%stuff and ^^%Piing
    me.Sa = &acgtc{
        return &s{
            $g = me&Sarg,'chaseout',s,c
            g.fail and me&Sargfailhandle,g
            return hak(g,'return') ? g.return : g.N
        }
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
      
    me.UseCase = &{
            
            # 
            $r = me.cbu(R,'Piing')
            me&ha,r,{Superdef:1},{},c
            
            me&ja,r,'got_active'
    }
  
  // &Sarg io proto
      
      // &Sarg
        # k per pseudo-implementation
        #  &Sarg within sarg get
        me.Sarg = &acgtkscq{
            isar(c) and c = {arg:c}
            q ||= {}
            
            $p = c.p = me&parserify,s
            # remove and multilining, indents, trailing space
            while (p.p(/\n/," ") //# ...things\ni...
                || p.p(/  +/," ")
                || p.p(/^\s+|\s+$/)) {}
            $plumb = p.p(/^(.+) (?=[io] )/) && p.1
            p.p(/^(i|o) /) and c.gee = p.1
            c.expr = p.s
            c.N ||= []
            c.sargk = k
            me&mearg,'Sarg_'+k,[p,s,c,q]
            # you get the deepest c, .c|fc=inputs
            plumb and c = me&Sarg,k,plumb,{c},q
            if (!c.c || plumb) {
                # outer|&Shx-call-terminating &Sarg
                # < does everyone get this?
                if (!c.fail && p.s.length) {
                    # notice leftovers, should all parse
                    me&Sargfail,c,{t:'expr++',part:p.s}
                }
                c.fail and me&Sargfailhandle,c
                hak(c,'return') and return c.return
            }
            # failh
            return c
        }
      
      // common
        me.parserify = &acgts{
            $p = {}
            p.s = s
            p.p = &r{
                r = new RegExp(r)
                m = p.m = p.s.match(r)||[];
                delete p.1
                delete p.2
                delete p.3
                !hak(m) and return
                p.whole = m.shift();
                p.1 = m[0]
                p.2 = m[1]
                p.3 = m[2]
                # what to put where r matched
                $placements = [...arguments].slice(1)
                $place = ""
                each is placements {
                    # place a capture, numbered from 1
                    isnu(s) and place += m[s-1]||''
                    else place += s
                }
                p.s = p.s.replace(r,place)
                return 1
            }
            # apply a pattern
            p.a = &regex,y{
                $times = 30
                while (p.p(regex)) {
                    y (...p.m)
                    !times-- and throw "looping"
                    !times and debugger
                }
            }
            return p
        }
        self.hassignar = &sc{
            !isar(s) and throw "!array"
            # String.match() returns a mostly-array
            s.flat and s = s.flat()
            !isar(c) and c = c.split(',')
            $h = {}
            each in s {
                $k = c.shift()
                !k and throw "toomany"
                n == null and continue
                h[k] = n
            }
            return h
        }
        # a(/match/,&{...}) etc
        me.paullistify = &acgtpscq{
            $a = &{ 
                # stop matching once unsure
                c.fail and return
                return p.a(...arguments)
            }
            # a type checker
            p.ist = &tsl{
                $ok = me&mearg,c.sargk+'_is'+t,[s]
                ok and return 0
                me&Sargfail,c,{t:(l||'')+'!'+t,s}
                return 1
            }
            # bind from arg[]
            p.ull = &type,{
                !c.arg.length and debugger
                $s = c.arg.shift()
                # < to enter zeroes, fail from here? 
                type && p.ist(type,s) and return
                return s
            }
            if (c.c) {
                me&Sargplumbed,c,c.c
                c.N = c.c.N.slice()
            }
            return a
        }
      
      // &Sargfail|plumbed
        # c.fail += problem
        me.Sargfail = &acgtcq{
            $n = {c}
            ex(n,q)
            # the last matched expr
            # < we may be after that part already
            n.expr = c.p.whole
            c.fail ||= []
            c.fail.push(n)
        }
        # inheriting between i ... o ...
        me.Sargplumbed = &acgtcf{
            # args left after o ... become for i ...
            # < visual order params: lex whole
            c.arg = f.arg
            f.arg = []
            # fail follow into later plumbings
            each in f.fail {
                c.fail ||= []
                !c.fail.includes(n) and c.fail.push(n)
            }
        }
        # after &Sarg, draw errors, may tell &Super*
        me.Sargfailhandle = &acgtc{
            $h = T.sute
            h and h.ha('pur:iofail')
            
            
            $ox = me&boxcap,'iofail','1B',2
            me&walls,T.ab,'b:1.1h5'
            each in c.fail {
                # "o someexpr"
                me&boxcap,n.c.expr,'1b' (&{
                    # part that failed
                    me&tsc,"fail-expr-matched",n.expr,'y'
                    me&tsc,"fail-say",n.t,'q'
                    # < objects -> Thy, for introspection...
                    #   looking at eg s=-Nine
                    #   the T.ab^^ may also have leads
                    me&tsc,"faildata",dis(nex({},n,'c,expr,t')),'G'
                })
            }
            #me&zu,"Fail:",c
            ox()
        }
  
      // ioisms &rayplace, q etc
        # adds s={k:v} to all rows, or creates one
        me.arkray = &acgtgscq{
            !hak(g.N) and g.N = [ me&axsimilate,s ]
            else {
                me&rayplace,g,s,c,q (&ascqM{
                    M.push(me&axsimilate,a,s )
                })
            }
        }
        # replaces g.N, generating scq, sets up q.param
        #  see &rowplace for a slightly &ind variation
        me.rayplace = &acgtgscq{
            return &y{
                
                $per_scq = &ascqM{
                    # binds q.param from a.$param
                    if (q.param) {
                        !hak(a,q.param) and debugger
                        $v = a [q.param]
                        s [q.param] = v
                    }
                    # you push same+new ax to M
                    y (a,s,c,q,M)
                }
                $per_a = &a{
                    $M = []
                    $arg = [s,c,q].map(s => ex({},s||{}))
                    per_scq(a,...arg,M)
                    # < geneology mania
                    return M
                }
                
                $more = []
                g.N.map(a => more.push(... per_a(a)))
                g.N = more
                # you may not be &Shx_io
                !q and return
                # later parts dont also get our q.param
                # < compulsively add layers to s.*, partitions
                #   wants !c.long &Xsim etc...
                #    basically wanting ax+ over vx
                delete q.param
            }
        }
        # q clones at the part through io leg
        #  so the q-leg has a density at far end
        # < rename other leg meaning x... or so (qis)
        #   same thing, other impedance
        me.qsimilate = &acgtqp{
            q = ex({},q)
            p and ex(q,p)
            return q
        }
        
      // ioisms ax
        # clone rowing between &Sarg
        me.axsimilates = &acgtcg{
            # < stash c.N somewhere. osc page.
            c.N = g.N.slice()
                .map(ax => me&axsimilate,ax )
            ahk(c,['ax_from'],g)
        }
        # clone an ax
        me.axsimilate = &acgtab{
            $ax = ex({},a)
            $arkx = ax.arkx = ex({},ax.arkx||{})
            if (b) {
                # may mix in b over any of it
                ex(ax,b)
                ex(arkx,b.arkx||{})
                ex(ax,{arkx})
            }
            # fi&AoQ sets ax.N to join /believe/
            ax.N and ax.N = ax.N.slice()
            return ax
        }
        # sanity check when joining rowings
        #  c + g should share /$n, see &Shx_arkbind
        me.axcompatible = &acgtcg{
            $thesen = c.N.map(ax => ax.n)
            $thosen = g.N.map(ax => ax.n)
            # thesen not there
            $undefn = thesen.filter(n => !thosen.includes(n))
            hak(undefn) and debugger
            # thosen not here
            $othern = thosen.filter(n => !thesen.includes(n))
            hak(othern) and debugger
            return thosen
        }
        
  
  
  // 'Sarn' i slope
        # @Thy/-This/#@Fine-Labine/@-Lab#@n%ThyLab/c&s=@n
        #  the @n, @Fine arrive in &Saturn
        # make g.path for &Saturn to fill out
        me.Sarg_Sarn = &acgtpscq{
            $a = me&paullistify,p,s,c,q
            # columns for c.N
            c.path ||= []
            $pat = &pa,{
                pa = ex({i:hak(c.path)},pa)
                c.path.push(pa)
                return pa
            }
            # < compile this in Yingmind? 
            $name = '(\\w+)'
            $pi = '(?:-(\\w+))'
            # {gaze,pi+name} for /@-Lab
            $piname = '(?:-('+name+'))'
            $namepi = '(?:'+piname+'|'+name+'|'+pi+'|'+name+pi+')'
            $scpeel= '(?:%(\\w+))'
            # for #@n {spaceref}
            $spaceref = '(?:#@'+name+')'
            $wander = '(\\*\\*)'
            $etc = wander+'?'+spaceref+'?'+scpeel+'?'
            # !
            $naming = '(#)?([\\$@])?'+namepi+etc
            $subframesetref = 'c\&s=@(\\w+)'
            $chasing = '(?:'+subframesetref+'|'+wander+')'+scpeel+'?'
            $end = '(?:(?=$|\\/)| )'
            a('^\\/?(?:'+naming+'|'+chasing+')'+end, &{
                $a = hassignar(p.m,'spaceref,gaze,pi,name,name,pi,name,pi'
                    +',wander,spaceref,scpeel,csref,wander,scpeel')
                # yua
                a.gaze && a.gaze != '@' and throw "@refs only"
                if (a.spaceref == '#') {
                    !isst(a.name) and debugger
                    # delete to not name this column that, tries pi
                    a.spaceref = delete a.name
                }
                a.pi and a.name ||= a.pi
                # the /c&s=... is not a node
                a.csref and a.subframe = 1
                
                pat(a)
            })
            
            # declaration time
            each ia c.path {
                if (i == 0) {
                    !a.gaze and throw "first should name itself"
                    a.slick = 1
                    # < export as a name to &Jx, &Superdefs...
                }
                if (i == 1) {
                    if (a.pi && a.pi == 'This') {
                        a.slick = 1
                        $R = me&R
                        $E = Rs&E
                        !Ec&uber and throw "E!c&uber/-This"
                        # duality, has:
                        $This = me&Pii,'-This'
                        $The = me&Pii,'-The'
                        Thes&tow = 1
                    }
                }
                
            }
        }
  //  'Saturn' o slope
       // itself
        # i @z <-+@mix @n||=@inst
        #     i &locate_Sarn@2 &being_inst $s** $sc={} $mix={}
        # o <- %%inst
        me.Sarg_Saturn = &acgtpscq{
            $a = me&paullistify,p,s,c,q
            $g = c
            if (g.c && !hak(g.N)) {
                # plumbed from nothing
                #  should do everything with no rows
                #   ie just consume expr
                # everyone must handle doing nothing
                #g.gee == 'i' and return g.empty = 1
                # < o ... o ... may get further when legs empty
                g.gee == 'o' and debugger
                # in i...(i...)o...%%inst with no %%inst
                #  compulse row @2 but not @3
                g.empty = 1
            }
            a(/^&(\w+)(?:@(\d+))? /, &func,cv{
                cv ||= 3
                ahk(g,'func',cv,func,1)
            })
            
       // brackio
            # o <- %%inst
            g.gee == 'o' &&
            a(/(<- )?(?:%%(\S+))$/, &etohere,expr{
                hak(g.N) and throw "N before jaa"
                expr = peel(expr)
                # < wait for $s to arrive in the i ...
                #   so we might also 'i @z <- %%inst,@variety/'
                $R = me&R
                etohere and expr.eto = Rc&s
                $N = me&jaa,R,expr
                $k = haks(expr)[0]
                # a.inst=%%inst,...
                g.N = N.map(n => me&axsimilate,hashkv(k,n) )
            })
            
            $ref = '(?:@(\\w+))'
            # < what += %%brack,comp:@osit,ion++
            $what = '(|'+ref+'|'+ref+'\\|\\|='+ref+')'
            # i @z <-+@mix @n||=@inst
            g.gee == 'i' &&
            a('^'+ref+"? ?<-(?:\\+"+ref+")? ?"+what+"$",&{
                $w = hassignar(p.m,
                    'eto,mix,nothing,n,ndef,or')
                $R = me&R
                me&rayplace,g,{},c,q (&ascqM{
                    # to
                    if (w.eto) {
                        s.eto = me&tark,a,w.eto,'easy'
                        if (!s.eto) {
                            # lack of the target drops this row
                            # < shading expr by types of this, oking
                            return
                        }
                    }
                    s.eto ||= a.z
                    s.eto ||= theone(havs(a).filter(n => isnode(n)))
                    !s.eto and throw "eto unclear"
                    # may not have visited, eg more %%inst -> $s/$z
                    # < better diag here... is an expected type fail
                    $z = s.eto
                    !zy&R and return me&waits,'fwd:inst'
                    # what
                    !w.nothing and s.n = a.n
                    else
                    w.n and s.n = me&tark,a,w.n
                    elsif (w.ndef) {
                        s.n = me&tark,a,w.ndef,'easy'
                        s.n ||= w.ndef && me&tark,a,w.or
                    }
                    !s.n and throw "n unclear"
                    # what else to merge in as it becomes a brackrow
                    # < any &nodei c.*
                    s.mix = w.mix ? a[w.mix] : {}
                    !s.mix and throw "<-+mix unclear"
                    # < eg mix being an multitude to be expanded at some point
                
                    # R:here, z:to, %%inst, shade, mix{inst+=1}
                    $n = me&nodei,R,s.eto,s.n,{},s.mix
                    
                    M.push(me&axsimilate,a,{n} )
                })
            })
            
       // $s**, etc 
            # i $s** $sc={} $mix={} 
            # we are presented with a bunch of things to input to
            # may compulse a row from empty
            a(/\/?([\$])?(\w+)(=\{([^\}]*)\})?(\*\*)?( )?/,
                    &gaze,ark,set,set_expr,wander{
                # < support
                !gaze and debugger
                if (set) {
                    # $sc={} just to have in rowing, not an arg
                    $s = {}
                    set_expr and debugger
                }
                # it probably expresses something about Rc&s, E, etc
                else {
                    $s = p.ull('C')
                }
                
                me&arkray,c,hashkv(ark,s),{},q
                
                # hash (mix or sc) should separate when rows split
                !isC(s) and ahk(g,'arkex',ark,1)
                
                q = me&qsimilate,q,{ark}
                
                gaze != '$' and throw "params only"
            })
            c.fail and return
            # func@2 for compulse (regardless of any %%inst)
            #  eg locate on Sarn.path, is about node
            #   and scpeel, is more scheme than act (%%inst)
            me&gfunc,g,q,2
            
       
       // being + %%inst # 
            # still compulse, til here:
            # non-compulsed rows only
            #  we may not be empty, but only have eg $sc,
            #   low level side-hustles like realising who you are
            g.empty and return
            # < all &Sarg s/c/g/
            $g = c
            # may split more rows
            # < wanting an &axsimilate that knows g+q...
            g.split = &ac{
                $q = g.thisq
                !q and throw "split rows during &rayplace"
                $M = q.Max
                !M and throw "split!q.Max"
                $ax = me&axsimilate,a,c
                each kv g.arkex {
                    $v = ax[k]
                    !v and continue
                    isar(v) and ax[k] = v.slice()
                    else ax[k] = ex({},v)
                }
                M.push(ax)
                return ax
            }
            # space func
            me&gfunc,g,q,3
            
            c.show = c.N
        }
        # &Saturn func hooks
        me.gfunc = &acgtgq,cv{
            cv < 1 and throw "takes whole number cv"
            $h = ahsk(g,'func',cv)
            each func,i h {
                me&rayplace,g,{},{},q (&ascqM{
                    q.Max = M
                    g.thisq = q
                    $ax = me&axsimilate,a
                    me&mearg,'Sargfunc_'+func,[g,ax,q]
                    # defaults to keeping this row
                    !q.not and M.push(ax)
                    # < q.Mw?
                    delete g.thisq
                })
            }
        }
       // realisers
        # realise where we may be receiving %%inst
        # do here compulse: regardless of having %%inst rows
        # < as another o leg, see &Saturn, parallel to o <- %%inst
        #   saves us from running for each %%inst row if there are any...
        #    i 1 o 0 o 1, perhaps the i 1 can have the o 1 row
        #     for compulse, even if it goes empty through o 0
        #      which is really saying do not @3 it, not reality
        me.Sargfunc_locate_Sarn = &acgtgaq{
            $ax = a
            # scpeel on a node, happens regardless of 
            $Sarn = q.est.Sarn
            $path = ax.path = Sarn.path
            $pathi = ax.pathi = q.est.Sarn_dist
            pathi *= 1
            $here = ax.here = path[pathi]
            !here and throw "off the path"
            # < deal an -Eight
            if (!here.slick) {
                # The|This non-thing
                ax.madeup = 1
            }
            # 
            $next = path[pathi+1]
            if (next) {
                ax.next = next
                !next.subframe and ax.nextinst = pathi+1
            }
            
            $sc = ax.sc
            !sc and throw "!sc"
            if (here.scpeel) {
                ex(sc,peel(here.scpeel))
            }
            
            if (here.gaze == '@') {
                ax.Name = here.name
            }
            elsif (isst(here.name)) {
                # < keep non-gaze names locally, eg -Eight to its /**
                #    so eg @Gnome's @This (@Run/@This) > @Thy/@This,
                #     even to @Thy/@This/-Eight/...
                ax.name = here.name
            }
        }
        # do here per %%inst rows
        # < tractogram the vying for $t-value from various branches of logic
        #    ~ sc_collection, etc
        # < path has tread, where an arm of thing pushes conf to later path
        #    eg %%listen_node can want to be -n
        #     this might make types more composable
        me.Sargfunc_being_inst = &acgtgaq{
            $ax = a
            $path = ax.path
            $inst = ax.inst
            !inst and throw "!%%inst!"
            $s = ax.s
            !s and throw "!somewhere!"
            $R = sy&R
            !R and throw "inst s!R"
            me&R != R and throw "inst !theR"
            $here = ax.here
            !here and throw "!pathbit"
            $next = ax.next
            # outputs
            $sc = ax.sc
            $mix = ax.mix
            !sc and throw "!sc"
            !mix and throw "!mix"
            # sets values of creation
            # < keep renamed history
            #  < when eg derive from $n again, save back to @Lab
       // in &being_inst
            if (ax.nextinst) {
                # message to /$z
                # becomes the identifying brack key, == pathi
                #  the @n ||= @inst selects the brack row we plumbed from o
                mix.inst = ax.nextinst
                if (next.slick) {
                    $t = next.name
                }
                else {
                    if (next.pi == 'Eight') {
                        $n = insts&listen_node
                        !n and throw "listen_node"
                        $t = 'n:'+n
                    }
                    elsif (next.pi == 'seven') {
                        $t = 'now'
                    }
                    elsif (next.wander) {
                        if (insts&listen_node) {
                            $t = 'firstaspect'
                        }
                        elsif (insts&heard) {
                            $t = insts&heard
                        }
                        else {
                            throw "unknown wanderment"
                        }
                        # < would be an interactive-grade -n resolver
                        #   that picks out aspects, ie R%stractia
                        #    to compile back into @Labi/-nodei/-row
                    }
                    if (next.spaceref == 'Fine') {
                        # < in &Gomex|&Superargs|%Names
                        # happens to mean this
                        # ie ...Lab can only be from @Fine
                        $orig = me.cbu(inst)
                        $j = origy&R
                        !js&TheFine and debugger
                        $z = jc&s
                        $t = z.t
                    }
                    elsif (next.spaceref) {
                        # the @Name is from %Names
                        $k = next.spaceref
                        $v = me&tark,a,k,{n:inst}
                        $t = v.t
                    }
                }
                # can build /#$t:z
                # < this :z meaning ark=z, syntax is near:
                #    A:Fine form, in doc notation: ark=A, its .t=Fine
                #    peel-like arg parsing, still in 'n ...' for .c
                #     eg $ba:somevar,fo=string
                #     which in io should be ba=$somevar,fo=string
                if (isst(t)) {
                    ax.wwlo = {s,t}
                    $z = me&fiu,s,t
                    ax.z = z
                    next.pi and zc&pi = next.pi
                }
                else {
                    me&tc,"inst!t",'6y'
                }
                
                if (here.pi == 'Eight') {
                    if (insts&listen_node) {
                        # fork the %%inst from here going to z
                        me&jaa,R,'heard' .map(&n{
                            $a = g.split(ax,{n})
                        })
                    }
                }
            }
            else {
                if (here.wander) {
                    if (insts&listen_node) {
                        # look it up
                        sc&pi = 'n'
                        sc&s = insts&listen_node
                        ax.final = 'wasn'
                        # then notify them of being listened
                        sc.listen_node_n = 1
                    }
                    elsif (insts&heard) {
                        # look at its ...
                        sc&pi = insts&piable || 'Fez'
                        sc&s = insts&s
                        ax.final = 'wass'
                    }
                    else {
                        throw "unknown wandering"
                    }
                }
                else {
                    ax.final = '???'
                }
            }
            !next and return
            if (next.subframe) {
                # < and all the next subframes? frame = an %%inst ->
                if (next.csref) {
                    sc&s = me&tark,a,next.csref,{n:inst}
                }
            }
        }
        
       // f, types!
        # get value for a/$ark
        # < @Name for|from &Gomex!
        me.tark = &acgtakc{
            # arkc clues, ie a.n%$k
            # < basically another a+ with looser roles (hash=role:thing)
            #   looming around this one's process
            c = peel(c)
            $n = c.n
            # is it %%inst,$k (eg n.sc.n for k=n)
            (n) && hak(n.sc,k) and $v = n.sc[k]
            else
            # is it an ark
            hak(a,k) and $v = a[k]
            else {
                !c.easy and throw "!ark",k,a
            }
            # usu just needs to be known
            c.fatal && v == null and throw "ark!v",k,a
            return v
        }
       
        # things (and A)
        me.Saturn_isC = &acgtn{
            return isC(n)
        }
        me.Saturn_isob = &acgts{
            return isob(s)
        }
  
  // 'Shx' use, &node_sort
    
    # a larger workflow, not using &Shx at all
    
    # strung together in reverse by eg &brackstract
    # < &cvdeal persist Ry&cvdeal_i
    
   // spec
    =pod
      makes such expressions of a Km!
      Xio proto research:
       eat k/*/refs
        < fast &Shx io compiling that, currently with &Xs[io]mp
       some -> /$node
       rows without any $node** eg %%awoke
         &brackX i X/$n (X.z) ~~ wous&z
         
       < some climb y&R|up to a node (eg $E)
       say only @Gome, but not only @Lab
         due to not being unique amongst ^^x/@Lab
       those nodes pile up
       < Xq|xq knowing the X/(node|nearnode)/$suchness/$ref
          is a subselect of /ref
      
      trivia
       - curiously the &Xsim c.wild doesnt need to know c.array
          because &Xsomp after it notices and resolves 'refs'
          &Xsimp however needs c.array=1, guess by isob() and etc
          < xq would know this
          < gleaned at compilation from an io expr somwhere
       - in comments: see # note:
    =cut
    =todo
      %ntype=Y|S|n for Ying/Step/node**
       say when it changes: eg '...n:GotSomewhere'
        eg 'S:More' - implies %ntype=n for /*
       %ntype=n implied for %Name, eg '...@Gnome'
      %t_reused for s.t above: '⇖' arrow
       
      &brackoddities
       oddity that ref==$node: '⇐' arrow
        < %%wake=$node should resolve in a future gate
         < who wants it
         < Ying_8 later etc also
       is per $node, so Y.nonode is not here
       < ⇐
       (x2)
        how many eg %%node... rows are for it
         even if none contain oddities
      <<<
        making pile of many -gate
         eg time selection
         the datasystem (&brackstract) being Tooled...
          which is sprouted via and next to a -Bat for it?
           the %Yingupile and %Yingulog
       
       some s describes expression:
        %%step|node
         expectation of it being %ntype=S|n
          < as a &Sargfail?
         defines the main /$node if multiple per row
          eg a main node may %%want=othern
           so draw the othern, kind of %implicated, to box-link to it
        may have neither,
         brackology saying (=otherkey)
       various thingoish interactivity to .hand
         want to interact with @Gome/@Thy The-ness
          its exporting a protocol for customising Yingu**
           to pile like such a toc
      
      sleeping modulat?
       %Yingupile wants to visit some of them,
        brackstill %%Superstat per $node, pile per $step?
        &Csse %bri=1.6 things visiting now
      
      > more name perfection:
       if unique, based on X-hoisty s.t
        would be nice to make minimal elvis path
          
          Know...Fish, if no other Know/**Fish
           suppose this is a name hoisting, R%X thing
            say Know/w/Fish if W/Fish also exists
             and Know/*/Fish (x2) if both
           picking the most expressive %glossing_nodes
       
           @Lab may mean only the really currently active @Lab,
            can be undistinguished from an older @Lab in scrollback
            @Lab++ (or so) when new? it is el:2-ish
             and similar This++ when time moves there?
            &Csse shade older ones?
            
          for @Eight:'n:Thyer/ulog'...origin_X
           then over time, @Eight/suchtime/origin_X
            that re-mention of @Eight makes a smaller expr of it
             and @seven is implied (being in @Eight/*)
              ie only use local %Name if it helps
            could even be as lum as a dot,
             Abodo positioning bordered box-link, ala metro map
          
          > @Plot has a @C
           implies any of the current -Ness/@Eight/@seven
            which amongst themselves may include @Eight/@seven
             as per unique names
           should box-link them, or version?
            so we dont have to redraw older definitions as such
            &Csse shade older ones?
         that these expr get invalidated over time,
          eg when a more-active @Lab arrives
          
      < @node_sort noticing when /* (all) are selected
        could be @Lab* if all labs
     
     generalising the $identity <-> *
        the ... that can also squish the git log
         test failing after merges of them should open them,
          bisect to where the fails begin

    =cut
   // top
    me.brackstract = &acgtX{
        $R = me&R
        Rs&origin_X = X
        $del = me&modelta
        # find /$node amongst sentences
        $Y = Rs&bract_kref_Y = me&bract_kref,X
        # /$node climb until all connected
        $D = Rs&nodes_climb_D = me&nodes_climb,Y
        # /pile(/$node(/flavour...)?)+ tree
        $H = Rs&node_sort_H = me&node_sort,D,Y
        # /pile(/$node(/hand))+ interactive tree
        $U = Rs&node_hand_U = me&node_hand,H
        # /$node/$k/$ref out of the ordinary
        $L = Rs&node_brackoddities_L = me&node_brackoddities,U,Y
        del()
        
        # modulat it here
        $m = me&boxcap,'nodelists',"1b" (&ml{
            lc&not = 1
            me&brackstract_out,'H',H,L,Y
            me&brackstract_out,'U',U,L,Y
        })
        
        del()
        return m
    }
    # print meaning, formed into /$node** structure
    # < nodes already got step|node expr join figured,
    #    extra brack expr may be hung upon them
    me.brackstract_out = &acgttHLY{
        $R = me&R
        !H and me&tc,"NoH"; return
        $m = me&boxcap,t,"4b" (&ml{
            ls&fs = 22
            ms&hue = t == 'U' ? 47 : 255
            me&walls,m,'bd:3.1'
            ms&lh = 0.7
            
            # rows without any $node** up top
            me&nonode_stractoddities,m,l,Y

            $pile = &ux,c{
                c ||= {}

                each in ux.nodes {
                    $x = ux.node[i]
                    $fla = x.flavour || {}
                    me&boxcap,"ntypeology",'1b' (&ml{
                        !c.noml and ms&ml = 0.6
                        
                        me&node_stractid,x,n,m,l,fla
                        
                        me&node_stractoddities,x,n,m,l,fla,L,Y
                        
                        $next = fla.gloss ? &x{
                            # m + /* are table-cells, so ... next
                            delete ms&ml
                            me&boxcap,"inside",'04b' (&ml{
                                lc&not = 1
                                pile(x,{noml:1})
                            })
                        } : pile
                        next(x)
                    })
                }
            }
            pile(H.pile.1,{noml:1})
        })
        R.sc['brackstract_'+t+'_W'] = m
        return m
    }
    # < %Ctitle in the wild
    me.node_stractid = &acgtxnml,fla{
        if (fla.glossed_nodes) {
            lc&not = 1
            $who = '/'+joint(fla.glossed_nodes,'/')+'/'
            $gloss = me&tsc,who,'…','6b'
            glosss&dis = 4
            !fla.gloss and debugger
        }
        fla.gloss and !fla.glossed_nodes and debugger
        else {
            $name = fla.Name || fla.name
            if (name) {
                name = me&tc,'@'+name,'g'
                fla.name and names&fs = 7
            }
            fla.ntype and lc&s = fla.ntype
            else lc&s = "?:"
            fla.ntype_implied and lc&not = 1

            $t = me&tc,n.t,'y'

            if (fla.t_reused) {
                $dist = me.cby(x,x => x == fla.t_reused, x=>x.up)
                dist = hak(dist.filter(
                    x => ahsk(x,'flavour','glossed_nodes')))
                ts&title = "t_reused: x^"+dist+": "+n.t
                # < box-link
                tc&s = '⇖'
                ts&bri = 1.6
            }
            elsif (fla.t_mute) {
                tc&not = 1
                !name and debugger
                names&title = namec&s+":"+n.t
            }
            fla.implicated and ts&opa = 0.5
        }
        $nec = fla.necessary
    }
    # o /@k/@ref
    me.stractKns = &acgtxn{
        # may $n(ode) if in the pile
        each k,kx x.k {
            me&boxcap,k,'02b' (&ml{
                # Kn style
                me&walls,m,'bd:1.4'
                ms&bgh = 581
                ms&fs = 6
                delete ls&pa
                ly&cv = 0.02

                $co = me&tc,":",'g'
                coy&cv = 0.03
                $vo
                each i,refx kx.ref {
                    $ref = kx.refs[i]
                    if (ref == n && n) {
                        $li = me&tsc,'same-as-node','⇐'
                        lis&bri = 1.6
                        lis&fs = 13
                        # before $l(abel), back to what the $m is on (a $node)
                        liy&cv = 0.004
                        mc&sortcv = 1
                    }
                    else
                    ref != '1' and vo = me&stract_drawref,m,ref
                    hak(refx.z) > 1 and me&tc,"x"+hak(refx.z),'6g'
                }
                !vo and coc&not = 1
            })
        }
    }
    # display C etc in space=2
    me.stract_drawref = &acgtmv{
        mc&sortcv = 1
        $lc = me&slabeline,v
        $vo = me&tc,lc.t,'y'
        voy&cv = 0.12
        lc.C &&
            fio(m,['sym',112,{s:lc.sym},
            'label,fs:13,lh:0.8,hs:757']);
        #me&tc,dis(ref),'y'
        return vo
    }
   // L brack oddities
    # big reduction!
    # < check k=step|node agrees with %ntype
    #    or drop %ntype_implied and oddity
    me.node_brackoddities = &acgtUY{
        $R = me&R
        $Si = me&Simqis_st
        $L = {A:R}
        # collect odd bracks
        each i,refx Y.ref {
            $ref = Y.refs[i]
            each kx refx.k {
                # sans stuff implied by U** expression
                # < check U...x for %ntype=S|n for %%step|node
                k == 'step' || k == 'node' and continue
                each i,row x.z {
                    $rx = Si(L,{row})
                    $kref_z = rx.kref_z ||= []
                    kref_z.push({k,ref})
                }
            }
        }
        # per node
        # < per node+, eg %%node,wants
        #  < Ying_8 brings pertinent rows <- %%node,... 
        each ix Y.node {
            $n = Y.nodes[i]
            each i,row x.z {
                !(L.rows||[]).includes(row) and continue
                $rx = Si(L,{row})
                $nx = Si(L,{node:n})
                # < use &brackX here
                each ia rx.kref_z {
                    $kx = Si(nx,{k:a.k})
                    $refx = Si(kx,{ref:a.ref},{array:1,n:row})
                }
            }
        }
        return L
    }
    # output
    # < brackology oddities
    me.node_stractoddities = &acgtxnml,fla,L,Y{
        # < (Y|L)...$node might be wired from this H...$node = x
        #    just need -Fez-anx to %%toomuch it (x.y.Y|L?)
        $nx = fi&Xsimp,L,{node:n},{el:8,array:1}
        # also, if it has multiple rows
        $Yx = fi&Xsimp,Y,{node:n},{el:8,array:1}
        $many = Yx && hak(Yx.z) || 1
        many == 1 and many = 0
        !nx && !many and return
        
        me&boxcap,"ungroupedrows",'05b' (&ml{
            # Km style
            me&walls,m,'bd:1.4'
            lc&not = 1
            if (many) {
                # more rows than usual
                me&tc,"x"+many,'6g'
                # no interesting keys
                !nx and return
            }
            me&stractKns,nx,n
        })
    }
    # rows without any $node** up top
    me.nonode_stractoddities = &acgtmlY{
        Y.nonode and me&stractKns,Y.nonode
    }
   // U hand out nice
    # i &condensed /$node** o /$node**
    =pod
     &nodes_iter
      can d.nox depending on &node_skippable @1
      < io: more of a d** to take many waves of sense at it
        making the x before it is attached?
         relies on nothing being there yet,
          is a crazy hook into Xsim...
          but basically allows x** multipath|converginess
         or might merge, the floating x contrib
      < io: making %thing refer to v.flavour.thing
         # assumed in the annotation below
        we then o (v|d)/flavour:sc, so we can then o v%Name etc
         this meaning both v + d may contain .flavour,
          i default to v, unless eg i d%glossed_nodes=$N
     
     &node_hand
     '...' grouping continuous %implicated
        sanity: they shouldnt have any brackrows
        < the following io expr somehow take:
          the first * to mean things with %implicated
          non-first * to mean anything
          everything else to mean !%implicated,
        include an %implicated if:
         only one deep
          o uv/*/v
          can still be ... if squeezed for space
         multiple nodes diverge from it:
          o */*{2,}!%Name
          but not when eg imp'@Labine' has /@Lab x2
         < name (t andor Name) is ambiguous amongst x^$node**
          o ux(/**#t#Name)/*/x
          just a quick rendition of this... try Rc&X**?
          < adjust test data... make w:TryPiWarmer?
     
     TryPiWarmer@Gome/imp(TheF/TryPiWarmer)/TryPiWarmer@Fine
        ie lots of different objects all named TryPiWarmer are around
       says @Fine⇖, since they share .t
       < with a box-link between the ⇖ and @Gome
         even though @Gome doesnt say the .t reused
       < even for TryPiWarming-SubNineOne, say ⇖-SubNineOne
     
     < @Run being for (^%client) @Gnome, some kind of box-link
    =cut
    me.node_hand = &acgtH{
        $R = me&R
        $U = {A:R}
        $N = []
        
        me&nodes_iter,U,H ({
            1: &unvyd{
                $skip = me&node_skippable,u,n,v,d
                skip and d.nox = skip
            },
            3: &xunvyd{
                if (x) {
                    me&merge_flavours,x,v,d
                    N.push(d)
                }
                each iz v.nodes {
                    y (z)
                    z.t == 'Magic' and x.maaaagic = 1
                }
            },
        })
        reverse(N).map(&d{
            $x = d.x
            $v = d.v
            $n = d.n
            me&node_t_reused,x,v,d,n
            me&node_t_mute,x,v,d,n
            me&node_ntype_implied,x,v,d,n
        })
        return U
    }
   // U %t_*. %ntype*
    me.node_ntype_implied = &acgtxvdn{
        $ntype = ahsk(x,'flavour','ntype')
        $implied = &{ ahk(x,'flavour','ntype_implied',1) }
        # ...@Gnome etc are usu n:
        if (ntype == 'n' &&
            (ahsk(x,'flavour','Name')
            || ahsk(x,'flavour','name')) ) {
            return implied()
        }
        
        $ud = me.cbu(d.up,d => !d.nox && !ahsk(d,'flavour','gloss'))
        $ux = ud && ud.x
        !ux and return
        $utype = ahsk(ux,'flavour','ntype')
        $ntype = ahsk(x,'flavour','ntype')
        # continuity
        utype == ntype and return implied()
        # S/n
        utype == 'S' && ntype == 'n' and return implied()
    }
    # may shorten to @Gnome if no others about...
    me.node_t_mute = &acgtxvdn{
        $Name = ahsk(x,'flavour','Name')
        if (Name == null) {
            # eg '@This This'
            ahsk(x,'flavour','name') == n.t
                && ahk(x,'flavour','t_mute','name-same')
            return
        }
        $ok = 1
        $far = 2
        $s = n
        while (ok && s && far-- > 0) {
            # o $n^^/#Name==n.Name
            # < should be checking Name that percolates,
            #   or we dive into each p/* we didn't come up from
            $p = me&node_upwards,s
            $N = me&node_downwards,p
            each in N {
                n == s and continue
                me&node_get_Names,n .map(&a{
                    a.local and return
                    a.t == Name and ok = 0
                })
                !ok and break
            }
            s = p
            !ok and break
        }
        !ok and return
        ahk(x,'flavour','t_mute','Name-fame')
    }
    # ⇖ to previous thing with .t (even if they %t_mute)
    me.node_t_reused = &acgtxvdn{
        $far = 7
        while (far-- > 0) {
            # unlike %t_mute: climbds d, they must be displayed
            $p = d.up
            !p and break
            if (!p.nox && p.n.t == n.t) {
                ahk(x,'flavour','t_reused',p.x)
                break
            }
            d = p
        }
    }
    me.merge_flavours = &acgtxvd{
        each kV v.flavour {
            ahk(x,'flavour',k,V)
        }
        each kV d.flavour {
            ahsk(x,'flavour',k) and debugger
            ahk(x,'flavour',k,V)
        }
    }
   // U %gloss
    # U... may d.nox the non-last %imp, etc
    me.node_skippable = &acgtunvd{
        
        # the innermost %imp/%imp+ speaks for them all
        $nec2 = 0
        if (hak(v.glossable_nodes) > 1) {
            $N = v.glossable_nodes
            # stash on d to apply to x.flav...
            ahk(d,'flavour','glossed_nodes',N.slice())
            nec2 = 1
        }
        $fla = v.flavour || {}
        !fla.implicated and return
        $nec = fla.necessary
        $skip = !(nec||nec2) && '!nec'
        if (!skip) {
            $w = hak(nec) && nec[0]
            # < not if many H/$node
            w == 'one-imp' && d.d == 1 and skip = "root"
            # overrule $necessary='many-kids'
            #  see "but not when eg imp'@Labine' has /@Lab x2"
            if (w == 'many-kids' && !havs(v.node)
                .some(x => !ahsk(x,'flavour','Name'))) {
                grepout(fla.necessary,'many-kids')
            }
        }
        # when %imp is necessary just to say ...
        $nec = fla.necessary
        !hak(nec) and delete fla.necessary
        if (!skip && (hak(nec)||nec2)) {
            !hak(nec) and ahk(d,'flavour','gloss',1)
        }
        return skip
    }
   // H - node sort, flavour
    # i H (-lev/$node)**
    me.node_sort = &acgtDY{
        $R = me&R
        $H = {A:R}
        # < all of $D wants no /$n-ness
        $Si = me&Simqis_st
        # < o D/@node for ( | o
        # i H/pile(/@node)+ o D/node_tips:node/upfrom/@node
        me&nodes_iter,H,D (&xunvyd{
            # H...u/$node:n = x <- v from D...$node = v
            
            # notice things about it
            me&node_has_flavour,H,D,Y,x,n,d
            
            # d.x.flavour.implicated become d.implication
            me&implicated_implication,d
            
            $N = ahsk(v,'upfrom',1,'nodes')
            me&node_sort_pickout,n,N
                .map(z => y (z))
        })
        return H
    }
    # H x%implicated** become x.glossable_nodes, -> U &node_skippable
    me.implicated_implication = &acgtd{
        $x = d.x
        $ud = d.up
        $u = ud && ud.x
        # a '...' being formed
        $glossing = u && u.glossing_nodes
        if (ahsk(x,'flavour','implicated')) {
            # and continuing
            glossing ||= []
            x.glossing_nodes = [...glossing,d.n]
        }
        elsif (glossing) {
            # and terminates glossing -> glossable
            $was = u.glossable_nodes
            u.glossable_nodes = glossing
            if (was) {
                # non-first child of %imp
                was != glossing and debugger
                ahk(u,['flavour'],'necessary','many-kids')
            }
            hak(glossing) == 1 and ahk(u,['flavour'],'necessary','one-imp')
        }
    }
    # sprinkles H x.flavour.* with expr clues !
    # this could be a freestanding X:Fl/$node/$flavour
    me.node_has_flavour = &acgtHDYxnd{
        $flav = &{ ahk(x,'flavour',...arguments) }
        
        # added since Y
        !Y.nodes.includes(n) and flav('implicated',1)
        
        me&node_get_Names,n .map(&a{
            a.s != n and flav('remark','Names-other',1)
            else {
                $k = a.local ? "name" : "Name"
                flav(k,a.t)
            }
        })
        
        # %ntype=Y|S|n|E
        # < E**
        $ntype = d.d == 1 ? 'Y'
            : d.d == 2 ? 'S'
            : 'n'
        if (ntype == 'Y') {
            $r = ny&R
            # where &node_upwards ends
            !rs&Ying and debugger
        }
        if (ntype == 'S') {
            # < steps always sy&N?
        }
        flav('ntype',ntype)
    }
   // D - elabourasta
    # s**^^^
    # i D /$node/$upfrom:node /$node_tip     o Y/$node
    #  filling in This...(Something,Someact)/Somewhen
    #  from a couple of Somewhen
    me.nodes_climb = &acgtX{
        $R = me&R
        $D = {A:R}
        # < all of $D wants no /$n-ness
        $Si = me&Simqis_st
        # group by $node, not /node/$n:row_with_node
        # < o $Y/node/ { # maybe?!
        $originodes = X.nodes
        originodes.map(s => Si(D,{node:s}))
        # N plays out: subset of /$node that are still climbing
        # < deloop
        me&rowplace,{tries:9,N:originodes} (&NM{
            #  all the way to Ying, even if converged on one parent
            #  it doesn't know it's climbing above all originodes
            #   for all that limb knows it could be between them
            #   < prioritise deeper nodes? with sy&path.length
            #N.length <= 1 and return
            each is N {
                $nx = Si(D,{node:s})
                $ps = me&node_upwards,s
                if (!ps) {
                    # no more
                    Si(D,{node_tip:s})
                }
                else {
                    $ux = Si(D,{node:ps})
                    Si(ux,{upfrom:1,node:s})
                    Si(nx,{downfrom:1,node:ps})
                    # may have climbed above there already,
                    #  may be pushing many ps from many $ps/*
                    !ux.downfrom and M.push(ps)
                }
            }
        })
        return D
    }
   // Y - separate by /$node
    # &brackX's X/$k/$ref -> Y/(node,nearnode,...)*,ref/$k
    #  with notes on &Shx semantics
    me.bract_kref = &acgtXsc{
        $R = me&R
        $Y = {A:R}
        
        # faster with &Xs[io]mp
        # o $X/k/ref {
        $nodalrows = []
        fi&Xsomp,X,{k:1,ref:1} .map(&a{
            $n = a.n
            # i $Y/@ref/@k
            $x = fi&Xsimp,Y,{ref:a.ref},{n,array:1}
            fi&Xsimp,x,{k:a.k},{n}
            if (isnode(a.ref)) {
                # i $Y/$node
                fi&Xsimp,Y,{node:a.ref},{n,array:1}
                !nodalrows.includes(n) and nodalrows.push(n)
            }
            elsif (isC(a.ref)) {
                # < climb, want y&R before long
            }
        })
        $nonode = X.z.filter(n => !nodalrows.includes(n))
        # i $Y/nonode/@k/@ref?
        hak(nonode) and Y.nonode = me&brackX,nonode
        
        return Y
        
        # < compile io:
        
        $S = me&Simqis_Shx
        #S("i $D/astract $Y",D,Y)
        # note: word (/ref) is a type of spacer,
        #  used as o it globs everything (like &jaa c.thing=1)
        # < the ark-using spacer, eg /#why binds a.why
        #    derives a word-only spacer from a ref?
        #     there may be an indexed name for it?
        #    in Cio instead of Xio, it makes C.t+y&cv copies
        S("o $X/k/ref {",X) (&an{
            # note: ark can be anywhere
            #  in iterating Sarg**
            #  reversing out, should find the latest:
            # < more robust lookup. when parts are mysteries, fail
            #$st = S("i $D/stract",D)
            # allows later use of that arkx:
            #$th = S("i stract/...$s",s)
            
            # rowing switches X cursors: ax.x = X:Y
            #  they pile up arkx.{X,k,ref,Y}
            # < construct as a surface tension and slopology from Sarg etc
            #   perhaps the toplevel tends to o $X and i $Y
            S('i $Y {',Y) (&a{
                # finds ark=ref in the above
                #  following its c.array clue ax.ref_i, see arrefs
                # < used like this should demand ref defined?
                # < wasnt this going to be a lot more @ref?
                $ref = S("i /ref/k")
                ref.N.length != 1 and throw "for one ref"
                # < may already have it, from another -log/$n mention

                if (0) {
                    $val = Cye(["DOge",3])
                    $fleet = 3
                    $ve = S('i /$val/$fleet',val,fleet)




                    # < check out i + c.wild
                    #$vi = S('i $Y/val/fleet')
                    #   val is ark_from the ve, which also merges ax.fleet
                    #    which is then ark_reused
                    # < disambiguate with $val=1
                    #    when you can't use a bare word as such anymore



                    $vo = S('o /val/fleet',Y)
                    T.oncily ||= 1
                    T.oncily++ < 2 and me&nu,"ref-find",{Sarg:T.Sarg,a,ve:vo}
                }

                isnode(a.ref) and S('i /$node',a.ref)
                elsif (isC(a.ref)) {
                    # < climb, want y&R before long
                }
            })
            
        })
        return Y
    }
   
   // common nodal
    # n/* canonical order, /*)%eph-indifferent
    me.node_downwards = &acgtn{
        $nr = ny&R
        if (nr && (nrs&ball || nrs&bell)) {
            $order = (nrs&z||[]) .filter(&r{
                # < how to backreference in javascript regex
                #   and io expr continuous one of either ball|bell
                return nrs&ball && rs&ball
                    || nrs&bell && rs&bell
            }) .map(r => rc&s)
        }
        else {
            $order = ns&z.slice()
        }
        return order
    }
    # n^
    me.node_upwards = &acgtn{
        $r = ny&R
        # ends on A.4
        r && rs&Ying and return
        $ps = ny&up
        if (!ps && ny&R) {
            # R** where n** fails (eg pr%eph)
            $r = ny&R
            $pr = ry&up
            # < up from E**
            prs&Pier and debugger
            !prs&ball and debugger
            $ps = prc&s
        }
        $pr = psy&R
        return ps
    }
    # [{t,s,local?}*] for n)%Name/*
    me.node_get_Names = &acgtn{
        $N = []
        $nr = ny&R
        $Na = nr && nrs&Names
        !Na and return N
        
        each ts Nas&tw {
            $a = {t,s}
            ahsk(Na,'sc','tlocal',t) and a.local = 1
            N.push(a)
        }
        return N
    }
    # order N by n/*
    # < after eg resolve $n projects a certainty of who is to be who
    me.node_sort_pickout = &acgtnN{
        !hak(N) and return []
        $M = []
        each iz ns&z {
            # may be a subset
            N.includes(z) and M.push(z)
        }
        if (hak(M) != hak(N)) {
            # superset or over n/*)%eph boundary (not n/* but n//R/*/c&s)
            # build a more complete picture via R** for the latter
            #  which will always be in order etc?
            # see %eph, &supsphere
            $order = me&node_downwards,n
            # M[0] = [z-beforeany*]
            # M[orderi+1] = [z-had,z-new*]
            $M = []
            $Mi = 0
            each iz N {
                $oi = order.indexOf(z)
                # news go after the last one located ie lv el=8,el2
                #  or top posting if before any located
                Mi = oi < 0 ? Mi : oi + 1
                $MN = M[Mi] ||= []
                MN.push(z)
            }
            # join inners
            return flatten(M)
        }
        return M
    }
   // common X
    # < io mode: from $D, wants no /$n-ness
    # < io might be able to use '^' for the previous x, instead of v:
    # &xunyv{ ... } for i D/pile(/$node)+ o X(/pile)?(/$node)+
    me.nodes_iter = &acgtXD{
        $Si = me&Simqis_st
        return &y{
            # < o D:uv/($node_tip|$pile:uv/$node|$node):v
            #   the latter :uv taking precedence
            #   oposite to growing rows per :uv defined (sql unnest())
            #    or shrinking them if @uv ends up aggregated
            $uv = D
            $N = D.node_tips
            if (!N) {
                N = ahsk(D,'pile',1,'nodes')
                # where to find /$node moves into /$pile
                N and uv = D.pile.1
            }
            N ||= D.nodes
            !N and throw "nodes_iter!/$node"
            
            isfu(y) and y = {3:y}
            
            $allv = []
            $anode = &unvd{
                d ||= {d:1}
                ex(d,{u,n,v})
                $more = &z{
                    # given each $n/$z
                    anode((d.x || u), z, v, {up:d,d:d.d+1})
                }
                # 0: o D...?/$node
                $uv = v.nodes ? v : D
                $v = d.v = Si(uv,{node:n})
                !v and debugger
                # looping?
                allv.includes(v) and debugger
                allv.push(v)
                
                y.1 && y.1 (u,n,v,more,d)
                d.nox and 'u...n shortcut'
                # i .../@node
                else d.x = Si(u,{node:n})
                
                y.3 && y.3 (d.x,u,n,v,more,d)
            }
            each in N {
                $pile = Si(X,{pile:1})
                anode(pile,n,uv)
            }
            
        }
    }
    # variation on &rayplace
    # < X about recursing upward, sets of M+ visited
    me.rowplace = &acgtc{
        c.tries ||= 99
        $steam = c.tries
        $N = c.N
        return &y{
            while (--steam) {
                !hak(N) and break
                $M = []
                y (N,M)
                N = uniq(M)
            }
            !steam and debugger
        }
    }
    # fast, /$n-optional i $D/$node
    # < compiling small io to small functions !!
    me.Simqis_st = &acgt{
        return &Dsc{
            $x = D
            c ||= {}
            c.n ||= 0
            each kv s {
                # r=0 for no /$n
                x = isob(v)||c.array ? me&X_s,x,v,c.n,k
                    : me&X_t,x,v,c.n,k
            }
            return x
        }
    }
    me.Simqis_Shx = &acgt{
        return &{
            $args = [...arguments]
            return me&Shx,args.shift(),args
        }
    }
  
  // 'Shx' N/ax                   
       // itself, itselves, iterate
        # sound of contorting topologies
        #  it says, hey there's all this stuff in here
        me.Shx = &acgtscq{
            return me&Sarg,'Shx',s,c,q
        }
        me.Sarg_Shx = &acgtpscq{
            $a = me&paullistify,p,s,c,q
            # begin with somethings
            if (!c.c) {
                if (T.ax) {
                    # &Shx inside &Shx iterating
                    $ax = T.ax
                    p.ist('ax',ax) and return
                    # < c.N []= suggestive {n,x}
                    c.N = [ me&axsimilate,ax ]
                }
            }
            # o ... { # returns iterator
            a(/ \{$/, &{
                c.return = &y{
                    c.fail and return
                    $N = c.N
                    each ia N {
                        # < groups
                        # < &Tap taking a callback to try {}
                        $Tap = me&Tap,{ax:a,Sarg:c}
                        # find arks only from current iteration
                        c.z = []
                        y(a,a.n)
                        Tap()
                    }
                }
            })
       
       // arrive at &Sarg expr, find ground
            # i ... $Y # sets /$n:Y
            # < gazely. pulls rows from id, eg @group/cohe
            #    Sarg ark=group containing an Sarg ark=cohe
            #     the cohe rows used
            a(/ \$(\w+)$/, &ark,{
                $n = c.arg.pop()
                p.ist('n',n) and return
                ahk(c,'tn',ark,n)
                c.N = [ me&axsimilate,{n} ]
            })
            
            if (c.c) {
                # &Sarg sub-expr receiving nothing
                !hak(c.N) and return c
            }
            else {
                # nothing yet, await c.X + expr, openly
                !hak(c.N) and c.N = [ me&axsimilate,{} ]
            }
            
            # i $D/... # for X=D
            a(/^\$(\w+)/, &ark,{
                # < D may be C. it should Ds&X or so
                $X = p.ull('X')
                !X and return
                # < should be in N/a.D, ie an ark
                ahk(c,'given_X',ark,X)
                each ia c.N {
                    a.x = a.arkx[ark] = X
                }
            })
            # i stract/... # rowing nearby ax.stract
            a(/^(\w+)/, &ark,{
                # the last to define eg i $D/stract
                $og = me&Shx_arkfind,c,ark
                !og and return me&Sargfail,c,{t:'!@'+ark}
                me&axsimilates,c,og
                c.X and debugger
            })
            
            # appear to others in the enclosing iterator
            T.Sarg and ac(T.Sarg,'z',c)
            c.fail and return
          
       // guts
            # i .../some # i /$some=1/$n
            # < should be in N/a.some, ie an ark
            #   also $D/...sea should look for a.sea
            a(/\/([\$@])?(\w+)/, &{
                $gaze = p.1
                $ark = p.2
                q = me&qsimilate,q,{ark}
                
                $s = {}
                if (gaze == '$') {
                    $v = p.ull()
                    s [ark] = v
                }
                else {
                    # may be a column in this|nearby rowings
                    $found = me&Shx_arkmaybe,c,q
                    # @things must be found
                    # < may be empty - needs arkology outside c.N
                    !found && gaze == '@' and throw "404@"+ark
                    # word=1
                    !found and s [ark] = 1
                }
                
                me&Shx_io,c,s,{},q
                # we then go from there (the N/ax.x)
                delete c.X
            })
            # o /...$s # &Xsimp s.* c.long
            a(/^\/\.\.\.\$(\w+)/, &{
                $ark = p.1
                q = me&qsimilate,q,{ark}
                
                $s = p.ull('somehash')
                !s and return
                
                me&Shx_io,c,s,{},q
                delete c.X
                ahk(c,'tsack',p.1,s)
            })
        }
        
       // &Shx_io # to &Xsim
        # adapt to &Xsomp or &Xsimp
        me.Shx_io = &acgtgscq{
            # s, c copy to each &Xs[io]mp call
            !g.gee and throw "Shx!i|o"
            !hak(g.N) and debugger
            me&rayplace,g,s,c,q (&ascqM{
                # < departure point selectivity
                $X = g.X || a.x
                !X and return me&Sargfail,g,{t:'!X',a}
                # we are per /$n
                # < who|how selectivity
                $n = a.n
                # determine c.array or not
                me&Shx_determine_c_array,g,a,X,s,c,q
                if (g.gee == 'i') {
                    (n) and c.n = n
                    $x = fi&Xsimp,X,s,c,q
                    # DIY ax return without &Xsomp
                    $ax = me&axsimilate,a,{x}
                    # < lowerable debug awarenesses:
                    #    ax.DB_scq = {s,c,q}
                    (n) and ax.n = n
                    if (q.ark) {
                        # < other s.* too?
                        hak(s) != 1 and debugger
                        $v = s [q.ark]
                        if (hak(ax,q.ark)) {
                            # < usu replacey? upgrade to brack history?
                            $same = ax[q.ark] == v
                            # doing q.param causes same ark being replaced,
                            #  with the new arkx
                            !same and debugger
                        }
                        # value itself
                        ax [q.ark] = v
                        # < ${ark}_i too? see arrefs
                        # the x beyond
                        ahk(ax,'arkx',q.ark,x)
                    }
                    M.push(ax)
                }
                else {
                    (n) and q.n = n
                    fi&Xsomp,X,s,c,q .map(&ax,{
                        $ax = me&axsimilate,a,ax
                        # a = ax, has a.arkx etc for this one expr-part
                        # < merge with over-a
                        (n) && ax.n != n and debugger
                        M.push(ax)
                    })
                }
            })
        }
        # &Xsim c.array or not guess
        #  which we don't always know just looking around X.**
        # see arrefs
        me.Shx_determine_c_array = &acgtgaXscq{
            if (q.param) {
                # from rowing, eg a.ref,ref_i, see arrefs
                !hak(a,q.param) and debugger
                hak(a,q.param+'_i') and return c.array = 1
            }
            # or looking at the s.* for being objects or not
            #  since it is for all Xsimp at once
            #  should look at the many ax we have,
            #   many args may have bound,
            $any = {}
            each kv s {
                v != 1 and any.nonglob = 1
                isob(v) and any.ob = 1
                else        any.nonob = 1
            }
            $unclear = any.ob && any.nonob
            unclear and throw "c.array?"
            any.ob and c.array = 1
            else {
                # looking at what's there
                $k = haks(s)[0]
                $ref = X[k+'s']
                ref and c.array = 1
            }
        }
       
       // &Shx_ark*
        # look up and join nearby results
        me.Shx_arkmaybe = &acgtcq{
            $ark = q.ark
            if (c.N.some(ax => hak(ax,ark))) {
                # rowing has this ark, bind to s:
                q.param = ark
                ahk(c,['ark_reused'],ark,1)
                return c
            }
            else {
                $og = T.Sarg && me&Shx_arkfind,c,ark
                if (og) {
                    # a nearby ax.$ark
                    # the entire ax.* is joined to ours
                    ahk(c,['ark_from'],ark,og)
                    me&Shx_arkbind,c,og,q,ark
                    return og
                }
                else {
                    # not found, might imply word
                    return 0
                }
            }
        }
        # find without binding (as q.param)
        me.Shx_arkfind = &acgtc,ark{
            !ark and throw "!ark"
            # must be iterating a Sarg that has the others!
            $g = T.Sarg
            !g and throw "not iterating a Sarg"
            # first, try the iterating Sarg
            $search = [g]
            # looking for arkx
            # < finding more than the last hop of &Xsim
            #   which is usually one.
            $hasit = &f{
                !hak(f.N) || f.fail and return
                $ax = f.N[0]
                !ax.arkx || !hak(ax.arkx,ark) and return
                return 1
            }
            # then its most recent children
            # < only going back one iteration?
            g.z and search.push(... reverse(g.z))
            $og
            each if search {
                f == c and continue
                hasit(f) and og = f; break
            }
            return og
        }
        # join nearby results, set q.param for the ark to bind to s
        # < many in s, an expr (sub-part) set of lexicals..
        me.Shx_arkbind = &acgtcgq,ark{
            # sanity check the /$n match
            me&axcompatible,c,g
            $N = g.N.slice()
            $seen = []
            me&rayplace,c (&ascqM{
                # rows of c /$n should be minimal
                seen.includes(a.n) and debugger
                seen.push(a.n)
                # g /$n may creates a row by instances of someark
                $binds = grepout(N,ax => ax.n == a.n)
                binds.map(&b{
                    # whole point is to bring this one
                    !hak(b,ark) and debugger
                    # merge, prefer a's .x|n|*, .arkx.*
                    $ax = me&axsimilate,b,a
                    # should have a value
                    !hak(ax,ark) and debugger
                    # and the b...x the value index leads to
                    !ax.arkx[ark] and debugger
                    # which is about to replace with some a...x
                    #  so soft label as source x
                    ax.arkx[ark+'_o'] = ax.arkx[ark]
                    M.push(ax)
                })
            })
            # we now have N/ax.$ark
            # binds ax.$ark into s.$ark, per &rayplace
            q.param = ark
        }
       
       // types
        # {...}, what the s in scq usually is
        me.Shx_issomehash = &acgts{
            return isob(s) && !isC(s) && hak(s)
        }
        # rows coming out of X traversal
        #  c.N=[ax+]
        #    < should have one or more of
        #   ax.x - where to climb from
        #    < use c.X if set
        #   ax.n - who to climb for
        #    usu require /$n at both ends to find $n's stuff
        #     or not: anyone's stuff matters more than who $n is, etc
        #  see 'for /$n=Y', bootstrapping c.N from param
        me.Shx_isax = &acgta{
            return me&Shx_isX,a.x && me&Shx_isn,a.n
        }
        # identities of things in X traversal
        # C joinery distributed
        me.Shx_isn = &acgtn{
            # $n=C usually, sometimes X|x
            return isC(n) || me&Shx_isX,n
        }
        # the islands
        me.Shx_isX = &acgtX{
            return isob(X) && !isC(X)
                && (isC(X.A)
                    || isob(X.up) && !isC(X.up))
                    # < and somewhere up there is X.A
                    #   that is in good time
        }
        
  // 'chaseout' N/s
        # Sarg with &boxcap error diag
        me.Sharg = &acgtscq{
            return me&Sarg,'chaseout',s,c,q
        }
        # only used once so far:
        # o &wants //R** if %strange o $s//E/*
        me.Sarg_chaseout = &acgtpscq{
            $a = me&paullistify,p,s,c,q
            # begin with somethings
            a(/^\$s/, &{
                $s = c.arg.shift()
                c.N = isar(s) ? s.slice() : [s]
            })
            # go somewhere
            a(/^\/\/(\w+)/, &{
                c.N = c.N.map(&s{
                    # s//E == s//R//E
                    $r = sy&R
                    !r and return me&Sargfail,c,{t:'!%R',s}
                    $ark = p.m[0]
                    ark == 'R' and return r
                    $E = r.sc[ark]
                    !E and return me&Sargfail,c,{t:'!%'+ark,s:r}
                    return E
                }) .filter(s=>s)
            })
            
            a(/^\/\*/, &{
                # < this is /?* rather than /*
                #   it adds r + r/*
                $more = []
                c.N.map(&E{
                    # E/* add (no sense of columns)
                    more.push(E, ... me&ioty,E )
                })
                c.N = more
            })
            a(/^&(\w+)(?: (.+))?$/, &{
                # space func
                $func = p.m[0]
                $plumb = p.m[1]
                # we can take N from c, c.c, c.fc (plumb here)
                $f = c
                if (plumb) {
                    # eg filter by %strange
                    f = me&Sarg,'chaseout',plumb,{c}
                    # out of a total bunch that might &wants
                    f.M = c.N
                    # return from &Sarg the filtered
                    c.N = f.N
                    # our upstream c.c 
                    # our space func result c.fc
                    c.fc = f
                    me&Sargplumbed,c,f
                }
                me&mearg,'Sargfunc_'+func,[f]
            })
            a(/^\*\*/, &{
                # everything under there, using list of R
                $more = []
                uniq(c.N.map(r => rc&N[0])).map(&r{
                    # checks each r is on tape, !rc&not
                    more.push(... rc&N
                        .filter(r => me&Risreal,r ) )
                })
                c.N = more
            })
            # < hang as the specific complaint (%strange)
            #   with the //R** inside the if
            #   knocking out rows of E** above
            #   so &wants gets E+ and R+ specifics
            a(/^ if %(\w+)/, &{
                $gk = p.m[0]
                c.N = c.N.filter(s => s.sc[gk])
            })
        }
      // &wants etc
        me.Sargfunc_wants = &acgtc{
            $h = T.sute
            $pur = (t,c) => h.ha('pur:'+t,c)
            if (c.M) {
                # as a space func,
                #  we can differentiate two steps
                # we should have recv something to check
                !hak(c.M) and pur('none')
            }
            if (hak(c.N)) {
                $last_expr = c.p.whole
                each ir c.N {
                    $s = rc&s
                    $j = me.cbu(r,'Piing')
                    $tpath = joint(me.cby(rs&E,js&E),'/')
                    pur('wants:'+last_expr,{tpath,pre:jc&s,targ:s})
                }
                # where to go to redo
                pur('some',{em:joint(c.N)})
            }
        }
 
// < &togcon via %Te
 
 // doc
  =todo
  < pointers may mung to sensible syntax
     so they can be squished together...
    may not need to for %togcon.$pt.$ok,
     is structured enough.
     about that:
  Nine/$t/($seven|four):expr/...
   $expr are expected of|beyond -eight/** usuality
    direction for their expression
   eg drilling into certain -ology
   can be done once -eight is got, idle
    then Story can reset with them.
   < leave (save Te%togcon)
   < turn up (load Te%togcon) as they:
    < -eight**, a while after a Page++
       similar to 'once -eight', 
    < Ying@8, while running, state will be precise
      This needs to know in advance
   < mung $pt + $ok for tidier $Nine/$t/$expr:
     various $expr projects (eg %togcon)
      want to save under a $p, which they may share
      so they might share room in $expr%*/** space,
       if compatible. eg, %togcon+%pointe:
        can use the same index, the endpoint has room:
         okc&s=ope, oks&e:pointe/says things there
          or %pointe would okc&s,
           %togcon would oky&cv
         # terrain: mergible A mind, split complicated
  =todo
  =spec
    mostly:
      $t/$expr%togcon:2/$ok # $expr implies $pt
     verbosely:
      $t/$expr%togcon/$pt/$ok # on|for an $expr,
      $t/$expr:togcon@8/$pt/$ok # on its own $expr
       and okc&s = $ope
        or is it oky&cv transposing $ope? modes:
         + 1,2,3,4[1-4],5[11-55],6[111-666]...,
         and the inverse, down from 1:
         - 09,08,07,06[9-3],05[99-33],04[999-333]
        subnetty numbers:
         quickly slowing down into precision
         are in order for ages
         until:
        looping back with further dp:
         + 45[11-44],56[111-555],67[1111-6666]...,
        %togcon for ope wouldnt handle that,
         something iterating a vast C* shall be:
          navigating via that cv dealing mode
           confused or finished when gappy|vanishy trail
            resorting to cv index:
             would tally each subnet, per dp
           or Cy&next, or start of next subnet, etc
            know where the next chunk is
             eg TripScaler, looks for next level few things to try
        # of geometric intention
        # we might have any shaped room+sequencing in mind
        # perhaps space wraps around like that
        # so it can also represent time,
        #  eg 1,2,3,41,4185 <- happens now,42
        #   belongs to the third wave of 4*
        #  so it might not wash away whence:
        #   eg 3(el:2),42(el:8) - keeps 1,2,42 (and 4185)
        #    vanishes 41, having come back to 42 > 41
        #     through a higher timeframe: 3
        #      being re-authoritative: 3(el:2)
        #      or not (keeping 41): 3(el:8)
        #       until 3(el:2),43 later,
        #        or not if its 3,431 - keeps 41
        #         as in not climbing into 43 from 41,
        #         just seeing a part of it
        # or whatever x+y things
        # all those parameters are up for ...
        #  eg how many dp to increase when,
        #   stretching to map noise out,
        #   fractionating, darting (edgible simil)
        #    are around in -group*,
        #     the io.ind() row compressor, etc
        # rhythm -> structure
        #  to crystalise language
        # geoio constructo fun
        
       $expr for some -eight**
        via -expr parsing @8 means %togcon:1
        $pt restricts it to $p-four
     
    it can name '-four':
      $t/$expr:'-four'%togcon:2/$ok
       $expr targets -four (some $eight**c&pi|.t)
       %togcon:2 meaning $expr/** is a %togcon index,
        starting beyond $pt, guessed for $expr to be:
         the main pointering thing inside -four, ie:
       expanding to:
      $t/$expr:'-four'%togcon:1/$pt:'beginning-four-brackology-ology<-gate'/$ok
       for applying the meaning
       the main $pt for $expr now stated inside it,
        so we can serve &togcon for %togcon=$expr/*/*
     
      how to paint the path
       as ending in a portrait
     $pt may:
       be a loose pointer
        eg '-four', as above
        eg q/-four*-grouptri/
        would be explicit enough to start a -grouptri,
         as discovered to be a -group* thing
          and put in with that lot while -four
     $ok may:
       also loose pointer
        eg q/e*Lingo/ 
         matching $ok='e,r,on,gate_r_Lingo'
         each $ok tried, expected
          see 'test data would clue surprise unfurlments'
       which could compress to /^e.*Lingo$/ (knowing all $ok)
        to be as ambiguous as possible,
         since the -eight that -four goes into is expected
       include ok%pt, to move into that %togcon/$pt/$ok
         doesnt make sense for %togcon.$pt.$ok
        a way to include a freak in a pile of others
        # probably for a different puzzle
      when
       .$ok - have some kind of data here
        ie the $ope, or compatible projects'' stuff joint()ed somehow
       /$ok - have anything on that C
       
    movable meaning zones:
     so $t/$expr
     and %togcon/$pt/$ok
      or $expr%togcon:2/$ok
      or $t%togcon/$expr/$ok
     (gets $pt from $expr)
        
     can be placed so $t/... needs differentiate:
     
     can entirely sc jampack %togcon={...}
       Lines peel deeply? splits chunk of yaml if large
     or exude into C-space:
      $t%togcon.$pt.$ok=ope
        room in $t%*/**
      $t%togcon /$expr       /$ok=ope  or:
      $t    /$expr%togcon:2  /$ok=ope  or:
      $t    /$expr%togcon2.$ok=ope     or even:
      $t    /$expr%togcon.$pt.$ok=ope
      $t    /$expr%togcon/$pt/$ok=ope
        are variously jammed, sizo determines best?
        get $pt for $expr, etc
         have to state all $pt (the last two ^)
          if not the one $pt for $expr
     even going as far as
      $t/$expr:togcon@8/$pt/$ok
       # named after the index it is (becomes $expr%togcon)
      $t/$expr:something%togcon:2/$ok
       since they could be anything,
       apply to all|certain other possible $expr that can %togcon
     or being minimal, loosely exudey:
      $t%togcon2.$ok=ope/$expr
        know %togcon2 is %togcon:2,
         starting ahead of its first column (many $expr)
        so $pt/$ok for all $expr,
        eg turn up the volume knob on certain things
      $t%togcon2.$ok=ope
        so $pt/$ok for any possible $expr
        eg turn up the volume knob on everything
     
    $expr is treated -expr
        could bind to one (maybe more) possible $expr,
         a place to hang details for all those $expr,
          ie $pt/$ok for all $expr
           $ok probably ignored by another $pt it is shared to,
            if those -whatevers are wildly different
           or:
            finds the same thing
             immersed in a different web
           it might have a number of %matches to expect,
            or the test data would clue surprise unfurlments
           then decide when to:
         sometimes be specific which styles apply to what
          subnet of the tree to start inheriting $x from
          < can css do .thermal ^^^(!hot|cooled) { cool }?
        ...
        could be supplemental,
         refer to any $expr, maybe anything,
          check some other dimension of sense across them
          etc.
        could be anything
          hoping to resolve in this Story
       arbitrary name and content, implied normal:
        given expr.t
         ~'-four': bind to c&pi == 'four'
         ~'togcon': make expr%togcon=1
           named for the index it carries
            maybe thats what @8 means?
           that it is Cified (scanned) %togcon
            to be put back together
  =spec
 
 // togcon
    # temperate -ology clusters
    #  R%Te %togcon.$pt serves .$ok for $p**
    # < generalise from label only
    # for within elvising on s-pi,
    #  where its ^^^.t must be uniq
    
    # get R%Te %togcon, maybe
    me.get_togcon = &acgtR,softly{
        $te = me&theTe,R,softly
        !te and return
        # < Te save: meaning collapse, empty hash scrub
        #   eg $ok:0 is as it inherits
        !softly and tes&togcon ||= {}
        $toge = tes&togcon
        return toge
    }
    # Xo or sometimes Xi the ope of a pt/ok
    # climber at %togcon.$pt, serves many .$ok
    me.togcon_open = &acgt,toge,q,{
        $pt = qc&pt
        return &q,ope{
            qc&pt != pt and debugger
            $ok = qc&ok
            if (ope != null) {
                toge[pt] ||= {}
                toge[pt][ok] = ope
            }
            return toge[pt] && toge[pt][ok]
        }
    }
    # wrap the above for each (nearet) R^^^%togcon.$pt
    #  serves many inheritable .$ok
    me.togcon_inheritily_open = &acgtRq,{
        $pt = qc&pt
        !pt and throw "!pt"
        $N = []
        me&inheritily,R (&rz{
            # creates %togcon for R,
            #  just looks at others
            $wander = r == R ? 0 : 1
            $toge = me&get_togcon,r,wander
            !toge && r == R and throw "!toge"

            if (toge && (toge[pt] || !wander)) {
                # where R will save $pt
                #  or other R^^^%togcon.$pt instance
                $open = me&togcon_open,toge,q
                N.push({r,q,open})
            }
            else {
                # has never heard of $p-ology
                if (q.depth == 1 && rs&Peace == 4) {
                    # made it to 4 for the $p-ology
                    # init Ying-wide defaults
                    $toge = me&get_togcon,r
                    $open = me&togcon_open,toge,q
                    # the $p/itself -1?
                    #open(q,-1)
                    # < do the:
                    #sy&brackwouology_ope == null
                    #  and sy&brackwouology_ope = -1
                }
            }
        })
        return &q,ope{
            each in N {
                $r = n.r
                $is = n.open(q,ope)
                if (is != null) {
                    rs&Teoptic = 1
                    r != R and q.inherited = r
                    return is
                }
                ope != null and debugger
            }
        }
    }
    # the $p ($pt-er) starts inheritable y&togcon,
    #  called by $p**y&label (itself first)
    # per -log:
    #  $p = $g-ology
    #  c.for[ok='itself'](q) sets q.is = Effected
    me.togcon = &acgtRpc{
        c ||= {}
        #$C = Rs&C
        $z = Rc&s
        !zy&R and throw "leave a node"
        !p and throw "give top modulat"
        
        # for $g from &vlabinto, &opelabel
        #  make g/n, the label, attach click handler
        # < generalise
        py&togcon = &gq{
            return me&togcon_solve,R,p,c,g,q
        }
    }
    # instance of $pt/$ok !
    me.togcon_solve = &acgtRpcgq{
        # for continuous this togcon, set in -eight
        q.path = me.cby(g,s => sy&togcon == gy&togcon ? 0 : -2)
        #!q.path.includes(Rc&s) and debugger
        q.depth = hak(q.path)
        # R/(p) name (the -ology)
        $alsop = q.path[0]
        p != alsop and debugger
        $pt = q.part = p.t
        # R/p/(**) name, inside p
        $insidep = q.path.slice(1)
        $ok = q.name = hak(insidep) ? joint(insidep,"_")
            : 'itself'
        
        # the $p-ology
        #q.depth == 1 and q.tsc ||= 'y'

        # tooltip
        #  pointer is forgetting that it is 'label'
        !q.may and throw "may join"
        q.may = q.may+"_"+q.name
        # #$p-ology/#$bits
        q.c = {}
        qc&pt = pt
        qc&ok = ok

        # auto ope depth:!
        $shall = q.depth <3 ? 1 : null
        $ope = q.shall = shall

        # on the label:
        $n = q.n = me&mtsc,g,q.may,q.s,q.tsc
        nc&s = q.s

        if (q.depth == 1) {
            # the first $n will be $p for the others
            # R%Te %togcon.$pt, saves+serves .$ok for $p**,
            #  we may inherit .$ok also
            $open = ny&open = me&togcon_inheritily_open,R,q
        }
        else {
            $open = py&open || py&label.y.open
        }

        # look up this q, with its $ok
        q.is = open(q)
        # consider q.is for this ok
        #  may adjust it depending on anything (&Effected)
        $y = c.for && c.for[ok]
        y && y (q)
        q.is != null and ope = q.is*1

        # -1..2 adjustable!
        me.nto(R,n,&sTe{
            $add = e.t.startsWith('C') ? -1 : 1
            # may start from an ope we inherit
            $is = defor(open(q),ope,0)
            $was = is
            is += add
            is > 2 and is = 2
            is < -1 and is = -1
            ~>3 Togssssssss: was,'->',is, q.name
            open(q,is)
        })

        ns&fs = 9+((ope||0.5)*2)
        ope < 1 and ns&bri = 0.5
        ns&ope = ope
        # not nothing, not default open
        $interest = ope != null && ope != shall
        interest and ~>6 Toge: q.depth, ope, pt, ok

        return n
    }
    
    # return R%Te, storable pointer cloudlayer
    me.theTe = &acgtR,softly{
        return Rs&Te && Rs&Te.c && Rs&Te || !softly && me&introqua,R
    }
    # climb til Peace==4, y() if rc&s
    me.inheritily = &acgtR{
        return &y{
            me.cbu(R,&r{
                $z = rc&s
                if (z) {
                    $re = y (r,z)
                    re != null and return re
                }
                rs&Peace == 4 and return 1
            })
        }
    }
   
 
// jobs
    // &twlic, &twlim - tw matchup
        # expand twlim to &l,z,c,either.t{} everything
        #  will c.surprise|wanted
        me.twlic = &acgtNL{
            return &y{
                $M = []
                # returns list of y returns
                $ya = &lzc{
                    c ||= {}
                    c.t ||= l && l.t || z.t
                    $t = delete c.t
                    !z and c.wanted = 1
                    !l and c.surprise = 1
                    M.push(y(l,z,c,t))
                }
                $seek = me&twlim,L (&lc{ ya(l,null,c,l.t) })
                
                # N[got] match into the expected stream
                N.map(&t{
                    $z = isR(t) && ts&ball ? tc&s : t
                    $l = seek(z)
                    ya(l,z)
                })
                seek()
                
                return M
            }
        }
        # consume expectations: L/*
        # by t one at a time in order
        #  returns L/l per found thing,
        #   or calls y(l,c) with c.missing|trailing
        me.twlim = &acgtL{
            $have = L ? me&ioty,L : []
            return &y{
                $for_missing = y || &{}
                # each had s:
                $some = 0
                return &s{
                    if (s) {
                        some = 1
                        # a name to find
                        $l = L && me&fiu,L,s,8
                        if (l) {
                            $li = have.indexOf(l)
                            # unfound L/* before l are now missing
                            # ! splice(in,length), slice(in,out)
                            #    [0,1,2,3].slice(0,2) = [0,1]
                            #                   (1,2) = [1]
                            #   [0,1,2,3].splice(0,2) = [0,1]/[2,3]
                            #                   (1,2) = [1,2]/[0,3]
                            li > 0 && have.splice(0,li)
                                .map(l => for_missing(l,{missing:1}))
                            $thel = have.shift()
                            thel != l and debugger
                        }
                    }
                    else {
                        # finish
                        $c = {}
                        some and c.trailing = 1
                        have.map(l => for_missing(l,ex({},c)))
                    }
                    return l
                }
            }
        }
