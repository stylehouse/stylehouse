# pile movie!!!!
# < brackolosim: draw 
# < Yingu pile scollto
me.Sch_Travel = &acgt{ return [
    =pod todo
    cm.getModeAt(pos
     < each step should Ring 2-9, try/catch

     nearly home
     &nodeo not found sends attention there:
      extra %twin &settle host makes it go,
      obscuring the probably still open:
       Travel%%tw making gets forgot:
       < %%eto dont land there reliably, is it:
        < coinciding &Yinge not lost
     < come back to %MayGansp,
     to:
     < &sleepic so %MayGansp may &settle all %%thing
     < sip: get node** %%thing to %%ok|%%wantpush,Q,s+
     < push remainders, til all %%ok

     for coming back to %MayGansp
     < using %acty levels to move readiness around?
       they must &settle at each one,
       transmitting to neighbours
        was an inspiration for nodei
     < &elnodes must visit any $p/$n we add,
        to make sure it gives %twmt
       Rsync not enough?

     and back to this,
     < Know..s%Paving must be set up in the remotes
        or Ghost..s can be trusted to &nodei them?
     < Ghost..s grows/shrinks and downloads s.sc
      < goners may gc Know..s if !ja,Ghost,{host:Know,s}
      < keepers may drop sc evident in Know..s
      < other Ghost..s may acquire sc, above in reverse

     ^ loosely around:
     < n must push to That..s
     < u must be as Know..s, or Ghost..s may acquire sc
    =cut
    
// Yingu - every frame Jstat
  
  // %Yingu
    # compulse Yingu
    ['Abodo+Ying','82',&acgtRs{
        # any time Yingu isn't really there
        $Yingu = theone( me&ioty,R,'','Yingu' )
        if (!Rc&N.includes(Yingu)) {
            # make it happen anyway
            n Yingu  R %Abodis,Yingu,Peace:1
        }
    },'ift,D,sleeping'],
    # n Yingu  R %Abodis,Yingu,Peace:1
    ['Abodis+Yingu','7',&acgtRs{
        #~>3 Yingu: Rs&sleeping&&"Sleeping"||""
    },'ift,D,sleeping'],
    ['Abodis+Yingu','7',&acgtRs{
        
        me&reaw,R,'Abodis,Yingu';
        # modern browsers nest fixed|absolute
        me&moveDisplayto,R,document.body
        s&width = 14;
        s&fs = 15.51
        s&over = 1
        
        #n Yingito  R %Tool
        
        # < glow the pile of all? nodes from Outlog wake etc
        #   1-2 line display hoist?
        #   their times!!
        # -log entries (-gate?)
        me&baleg,"Yingulog"
        # -pile wriggles
        me&baleg,"Yingupile"
        
  // Abodis+Yingu
        me&rollbs,R,'seekto'
        # who we art
        $f = Rs&Abodis
        $dish = &{ahk(f,...arguments) };
        
        # Loc/** to %seekto
        dish('o','Codon_click',&fTs{
            $D = Cye([s.t,1]);
            f.hatch('step_point',D)
            # < Codon version puts point on trail
            ~>2 Seek: ki(D,2)
        });
        # from %Abodis f.22 when R%seekto:D
        dish('o','step_point',&fTD{
            $v = f.M.filter(n => D.t==n.t)[0];
            !v and ~>2 seek!found: D.t
            !v and return

            $at = f.at;
            $on = f.on;
            
            $scroll = on.scrollTop + vs&top
            on.scrollTop = dec(scroll)
            ~>7 sunk: ki(D,2)
            delete Rs&seekto;
        });
    },'ift,D'],
    
  // < %Yingulog -gate visits
   // %Yingulog
    ['ball+Yingulog','2901',&acgtRs{
        #Rs&Piing = 1
    },'ift,D'],
    ['ball+Yingulog','294',&acgtRs{
        #me&ha,R,"Degreesa"
    },'ift,D'],
    # After Ying_8
    ['ball+Yingulog','85',&acgtRs{
        $x = me&Yingu_Jx
        $Outlog = xs&Outlog
        Rs&onlyish = 1
        Rs&rowish = 0
        me&tc,"zeeega"
        
        $la = Outlog.slice(-5)
        each il la {
            $k = Outlog.indexOf(l);
            !num(lc&i) and throw '-log!c&i'
            # not %ball due to l/*:rows we eat
            #n $k  $s:l %R,Yingoutlog
            $r = me&Ret,R,{t:k,s:l,aYingulog:1}
            
            $N = me&bracko,R,l,{step:1},1
            hak(uniq(N)) > 2 and rs&interesting = 1
        }
        !r and return
        rs&lastone = 1
    },'ift,D'],
    ['aYingulog','85',&acgtRs{
        me&reaw,R,'aYingulog,lastone,interesting'
        Rs&interesting and Rs&lastone = 1
        !me&ollbs,R,'lastone' && me&sleepic,R and return
        s&dis = 1
        me&walls,C,'b:1.1h5'
        $X = ss&X
        !X && !hak(ss&z) and return me&tc,"empty"
        # o Outlog/-log%X
        !X.k and throw "!wou"
        !X.A and throw "!X.A"
        Rs&interesting and 4s&interestoYing = s
        
        me&boxcap,R.t,'b' (&{
            # whole olosim
            me&walls,T.ab,'b:1.1h2'
            
            # <<<
            # these two ^ usually matching all of:
            #  anything else we can y&up to a node
            #   otherwise add it in
            # wants to use rowing to do so
            #  then join to nodelist to sort
            #   which breaks down into s/* orders
            #   and R/* order (may be superset of s/*)
            
            # < node-like, other k
            #   node-near, y&up or so
            #me&brackstract,ss&X,{isa:'node'}
            #me&brackstract,ss&X,{rel:'up'}
            
            # per Km expression island, can be conjoined
            me&boxcap,'allkeys','b' (&l{
                ly&label.sc.dis = 0
                ls&fs = 6
                
                $ks = {}
                me&ioty,s .map(n => haks(n.sc).map(k => ks[k] = 1))
                me&tc,joint(haks(ks),',')
            })
        })
    },'ift,D'],
    ['ball+Yingulog','86',&acgtRs{
        $r = me&ioty,R,'interesting' .pop()
        !r and return
        rs&lastone = 1
    },'ift,D'],
  
  
  // < %Yingupile node list
    ['ball+Yingupile','85',&acgtRs{
        
        # standard node toc, Ying** reachable
        $YingR = me.cbu(R,'Ying')
        $f = me&Rsc,R,'^^Abodis'
        me&boxcap,"4/*/*:",'5b' (&m{
            my&label.c.not = 1
            me&ioty,YingR .map(&r{
                !rs&ball and return
                $s = rc&s
                me&boxcap,"S:",'1b' (&m{
                    #ms&ml = 0.6
                    me&ty,s.t (&sTe{
                        ~>5 workfor: s.t
                        f.fengi(T,'Codon_click',s);
                        T.wake = 'not';
                    })
                    #me&tsc,"nsc",""+dis(n.sc),6
                })
            })
        })
    },'ift,D'],
    
  // @Thyer/@ThyerYing - in time!!!
    ['Thyer','2969',&acgtRs{
        $x = me&Jx
        $Ying = xs&Ying
        # < bright and early
        me&ioty,Ying .map(&n{
            ny&cv ||= 0.1
            me&fiu,Ying,n
        })
        me&haveextranodes,R,s,x
    },'ift,D'],
    ['Thyer','66',&acgtRs{
        me&baleg,'ThyerYing'
        me&baleg,'ThyerinterestoYing'
    },'ift,D'],
    ['ThyerinterestoYing','55',&acgtRs{
        $x = me&Jx
        $s = 4s&interestoYing
        !s || !ss&X and return me&tc,"awaits"
        me&brackstract,ss&X
        # < ns&wake are for the future
        $nonode = ss&z.filter(n => !ns&step && !ns&node)
        me&nu,"non",nonode[0]
    },'ift,D'],
    
    # main thing: $gate -> &brackstract
    ['ThyerYing','55',&acgtRs{
        $x = me&Jx
        
        $Intro = 0 && xs&Introtivity
        Intro and me&nodei,R,Intro,{Introtiv:1,t:'Travel'}
        Intro and me&nodei,R,Intro,{Introtiv:1,t:'The'}
        Intro and me&nodei,R,Intro,{Introtiv:1,t:'Index'}
        
        # < Tool for zooming into Ying-gate
        #$s = 4s&interestoYing
        $s = me&mock_Thyergate,R
        !s || !ss&X and return me&tc,"awaits"
        ss&X.A != R and debugger
        # X by &bracki (ish), make &Shx_isX
        # < the &Shx p.ist('X') check is too silent
        me&brackstract,ss&X
        
        # data hose, see &Piing_inst / &Saturn %%listen_node
        Rs&listen_node_listened = 1
    },'ift,D'],
    # those other particles 
    &{
    # mock nodes** to mock -gate
    me.haveextranodes = &acgtRsx{
        $Ying = xs&Ying
        # as per W:Thy
        $More = me&fiu,Ying,'More',7
        # using &Pii for path name input, not making %Piing
        me&Pii,More,'Firstly/The'
        me&Pii,More,'Firstly/Magic'
        me&Pii,More,'Secondly'
        me&Pii,More,'Finally'
    }
    # mock -gate
    me.mock_Thyergate = &acgtR{
        $x = me&Jx
        $Ying = xs&Ying
        $wou = Cye(["Thyinggate",1])
        wouy&R = R
        $ha = s => me&bracki,R,wou,s
        
        # < no node...
        ha({awoke:"tothings"})
        
        # of mock nodes
        $More = me&fiu,Ying,'More',7
        ha({node:me&Pii,More,'Finally' ,erstly:2})
        ha({step:More})
        ha({node:me&Pii,More,'Firstly/The' })
        $Magics = {node:me&Pii,More,'Firstly/Magic' }
        #ex(Magics,{comes:'at',the:'dawn',also:More})
        Magics.alswo = Cye(["Grit",2])
        ha(Magics)
        ha({node:me&Pii,More,'Firstly/Secondly' })
        ha({step:More})
        ha({wake:me&fiu,Ying,'Less',7 })
        
        # @This, @Nine
        me&jaa,R,'listened' .map(&n{
            # @This
            $to = ns&replyto
            ha({node:to})
            # @Gome
            $tor = toy&R
            $SC = me.cbu(tor,'client')
            $cl = SCs&client
            ha({node:cl})
            # the old E-nine is there
            $active = me&jaa,cly&R,'active',1 .filter(n => isnode(n))
            # @Fine, @Lab
            active .map(node => ha({node,active:1}))
            
        })
        return wou
    }
    },
    # mock nodes
    ['Moreism','291',&acgtRs{
        me&bin
        me&acting
        sc&noencode = 1
    },'ift,D'],
    ['Moreism','296',&acgtRs{
        me&ha,R,{Some:23}
    },'ift,D'],
    
  // Yingu f
    &{
    # a namespace?
    me.Yingu_Jx = &acgt{
        $R = me&R
        $x = me&Jx,R
        
        # the Y:Peace slope (RNA)
        #  Y.1 = R:Yingu, Yc&sip etc
        $Y = me&Rsc,R,'^^Ace'
        # Y.4.1 = R:Thy
        $RYing = Y.4[1];
        $Outlog = RYings&Outlog
        !Outlog and debugger
        # R:Thy%Ying=C
        #  perma A, has /Schema,Steps
        $CYing = RYings&Ying;
        # which is C to Y:Ying:
        $YYing = CYingy&Y
        
        # give xs&Outlog etc
        $arg = {Y,RYing,CYing,YYing,Outlog}
        each kv arg {
            x.sc[k] && x.sc[k] != v and debugger; me&tc,"Jx!!"+k,'B'
            else {
                x.sc[k] = v
            }
        }
        #me&nu,'Yingu_Jx',x.sc
        return x
    }
    },
    
// Detection - whats going on
  &{
  // &Yingate_2|8: %OutLog += $D-gate
    # Ying happens
    me.Yingate_2 = &acgtRc{
        me&reaw,R,'Outlog';
        $D = me&Outlog,R,'gate'
        Rs&Det = D;
        # &t signals
        me&YingelQup_2,R
    }
    # Ying/** happens
    # < take extra pictures 
    # < become RbitXarrive
    # < further tunneling, counts as landing the pointer in R
    #    all its limbs want to ok this before acting,
    #     unless they are separated by chunks of
    #     Story to see before the next steps
    me.Detection_2 = &acgtRpr{
    }
    # count as an awake step|node
    #  (step may be asleep if tunneling to nodes )
    # < extend/solve Dtunneling above
    me.Detection_7 = &acgtRpr{
        $D = Rs&Det;
        $c = {}
        rs&Det and c.Det = rs&Det
        
        $k = ry&up == R ? "step" : "node"
        $s = rc&s
        !s and throw "nos"
        c[k] = s
        
        me&bracki,R,D,c
    }
    # waits_8 noticing later[] etc woke this time
    me.Detectioned = &acgtRs{
        !Rs&Ying and throw "asYing"
        !isnode(s) and throw "!node"
        $D = Rs&Det
        $r = sy&R
        $k = ry&up == R ? "step" : "node"
        $c = {}
        c[k] = s
        return me&bracko,R,D,c
    }
    # receive what Ying wants to do
    me.Yingate_8 = &acgtRc{
        $D = delete Rs&Det
        Dc&be_time = Gtime()
        me&Dwakers,R,D,c
        me&Dtunneling,R,D
    }
  
  // &log -> %Outlog/$D
    # D -log
    me.log = &acgtRtsc{
        $D = me&Outlog,R,'log'
        Dc&s = t
        $sc = {}
        t and sc.says = t
        s and ex(sc,s)
        isnode(Rc&s) and sc.node ||= Rc&s
        hak(sc) and me&bracki,R,D,sc
        c and ex(D.c,c)
        return D
    }
    # accessor
    me.theOutlog = &acgtR{
        $Ying = me.cbu(R,'Ying')
        return me&rollbs,Ying,'Outlog',[]
    }
    # add a $D 
    me.Outlog = &acgtRtsc{
        $Outlog = me&theOutlog,R
        $D = Cye([t,1])
        Outlog.push(D)
        D.t += '-'+(Dc&i = Outlog.length)
        Dc&pi = t
        Dc&fe_time = Gtime()
        # knows Ying and the -gate its in
        $Ying = me.cbu(R,'Ying')
        $Det = Yings&Det
        Det and Dy&inside = Det
        Dy&Ying = Ying
        Ying != R and Dy&R = R
        return D
    }
  
  // &Gstaci|o|_reset
    # like the B-stack, Gc&stac.$t=[$s+]
    me.Gstaci = &acgtts{
        !isst(t) || !isC(s) and throw "!Gstac"
        ah(G,['c'],'stac',t,s)
        return &{
            # takes (all of) this s back out
            $stact = ahsk(G,'c','stac',t)
            $got = grepout(stact,s)
            !hak(got) and debugger
        }
    }
    # [$s+] for $t, eg the $s-seven accumulating a $t='-log'
    me.Gstaco = &acgtt{
        return (ahsk(G,'c','stac',t) || []).slice()
    }
    # prepare to be reset on catch
    me.Gstac_reset = &acgt{
        $stac = {}
        each tN Gc&stac {
            stac[t] = N.slice()
        }
        $done = 0
        return &{
            done++ and return
            $aborts = {}
            each tM Gc&stac {
                # put as it was
                $N = Gc&stac[t] = stac[t] || []
                # those that weren't
                grepout(M,N)
                hak(M) and aborts[t] = M
            }
            each tis aborts {
                me&yyt,s,'onabort'
            }}
            return aborts
        }
    }
    
  // &Dwakers, &wokerecently
    # detects looping wakers
    me.wokerecently = &acgtRsdq{
        $Outlog = me&theOutlog,R
        q = ex({}||q, {wake:s||1})
        return Outlog.slice((d||10) * -1)
            .filter(D => me&bracko,R,D,q )
    }
    # log wakers for the above
    me.Dwakers = &acgtRDc{
        # %%wake - for the next round
        # multiply by Ying rows wanting it
        # < vie for %terms or have to spread out processes
        # < group by %%wake in the refactored &waits_8
        #    ignore those in %%dome:later,
        #     el:9 when n input again with(out| different) %%dome
        #   then they would y&up their source
        $quiet = []
        c.wakers.map(&s{
            $l = me&jaa,R,{wants:s} .map(n => {Yingrow:n})
            !l[0] and l = [{}]
            $c = {}
            sy&quiet_wake and c.quiet = 1
            c.wake = s
            l.map(q => me&bracki,R,D,c,{},q ) 
        })
        quiet.length && c.wakers.length == quiet.length and throw "all!q"
    }
  
  // &Dtunneling
    # < merge in &Yingwhen, early sense e, how to %onlyish
    #  < how to gradually work when fed A leashes
    me.Yingtunneling = &acgt{
    }
    # there's no way in without tunneling
    #  could be found before it happens (!tunnelout yet)
    # $e = ^^%tunneling, and maybe ey&up
    #  which would es&divawz = [e+] if tunnel diverges
    me.Dtunneling = &acgtRD{
        $poin = me.cby(R) .filter(r => rs&tunneling) .reverse()
        D ||= Cye(["Dtunneling",1])
        each ir poin {
            rs&tunneling == e and continue
            $e = rs&tunneling
            $c = {}
            # < -pi-ish on the one e, to many row per %%e
            r != R and c.r = r
            me&Delvis,R,D,e,c
        }
        # ^ climbs e:divawz, goes y&up-only to:
        # top e may /* about R
        $one
        e && ec&pack && me&ioty,e .map(&e{
            $r = ec&wake;
            r && rc&s == Rc&s and one = e
        })
        return one || e
    }
    me.Delvis = &acgtRDeq{
        $c = {e}
        q and ex(c,q)
        es&tunnelout and c.on = es&tunnelout
        # e:Qup|elQups update generally or:
        #  e/*.c ={ wake=aJRom, Intere=Qupe.c{Q,R=G&t-er} }
        each iQ ec&Qz {
            me&bracki,R,D,{Q}
        }
        me&bracki,R,D,c
    }
    
    },
  
  
// about Qup
    &{
    # log but dont e:elQups !!!!!!!!!!!
    me.YingelQup_2 = &acgtR{
        4s&noQup = &e{
            # GONER?
            ~>4 4%noQup: e.t
            4s&lastnoQup = e
        }
        4s&noelQups = &e{
            ~>4 4%noelQups: e.t
            # limit to stuff included within Ying**, eg in R%Paving
            $beyond = hak(ec&Qz.filter(n => ny&R.t != 'Pearch'))
            1 || beyond and 4s&lastnoelQups = e
            $Tr = 4s&Travels
            if (Tr) {
                Tr = me&yfuture,Tr
                me&elvis,R,"doelQups",{wake:Tr}
            }
            $D = me&log,R,'no-e:'+e.t
            me&Delvis,R,D,e
        }
    }
    # catch e that wake:Ying
    me.Yingwhen_e = &acgtRe{
         if (e.t == 'elQups') {
             $D = me&log,R,'e:elQups',{e}
             me&Dtunneling,R,D
             debugger;
             return 1
         }
    }
    me.PaveelQup_5 = &acgtRs{
        $Q = Rs&Q
        $was = me&jaa,R,'isready',1 [0]
        $also = me&ja,R,'isready',0
        also != was and throw "wasi"
        $is = Qs&ready ? 1 : 0
        !(was == null || was != is) and return
        me&ha,R,{isready:is,dome:'isready'}
        me&log,R,'Q~'+is,{Q,node:s}
    }
    },
    ['noGump+Paving',0.55,&acgtRs{
        me&PaveelQup_5,R,s
    },'ift,D'],   
// @Introtivity A tool hovers
   # to feed the outside in (&t notify) !
   #  breaks once Fingo reset (e -> v1 spring from somewhere?)
   #  notice everything, a -seven
   #  has things its doing (warm &t cache)
   #  then may point paths into J
   # is a &Supe accumulatable spot
   # each &supetime is a Dome, have X!
   # ja %%climb may say things
    ['Introtivity',0.39,&acgtRs{
        me&reaw,R,'Introtivity'
        $x = me&Jx,R
        s&bg = 312
        # < wants to accept anything from anywhere
        #4s&Athing and me&nu,'A',4s&Athing
        #4s&Bthing and me&nu,'B',4s&Bthing
        #Rs&wakeful = 1
        
        # subscribe:
        4s&Travels = s
            # & enable:
            $Cating = me&ja,R,'Intro,Cat'
            Cating ||= xs&Ying.t == 'Thy'
            Cating ||= x.ro("Intro?",{})
            !Cating and delete 4s&lastnoelQups; return
        # for changes in:
        $e = 4s&lastnoelQups
        !e and return
        me&IntroelQups,R,s,e
    },'ift,D'],
    &{
    me.IntroelQups = &acgtRse{
        ec&looki ||= 0
        ec&looki ++
        ~>5 Intro........:
        $what = me&rollbs,R,'tdige',{}
        #me&nu,"e-thing",e
        each iQ ec&Qz {
            me&nu,"Q-thing",Q
            $P = Qs&P
            $se = 
            n t 76  %dib
            n of 1 $s:Qc&of %c:G
            me&walls,se,'b:2.2h5';
            me&tc,se,Q.t,'b'
            me&tc,se,Ps&dige,'6y'
            Qs&dige && Qs&dige != Ps&dige and me&tc,se,",Q#"+Qs&dige,'6y'
            
            # < if Cat, check into @Aearch for its version?!!
            what[Q.t] == Ps&dige and return ~>3 goated: Q.t
            ec&goated and return ~>3 goated: Q.t
            
            $avoid = &t{ me&tc,se,t,'y' .sc.ma=0.5 }
            
            # $r = who re-requests &t pre-waking!!
            $r = Qy&R
            r.t == 'Pearch' and avoid("@Pearch")
            # $z = who to wake
            if (rs&Pave) {
                # Know...K/R%Pave
                $z = ry&up
            }
            elsif (rc&Cat) {
                # %SummerCat/%Jrunto/...a %Doming Yingbal
                # <!? we switch r away from who did the &t?
                $z = r = me.cbu(r,'Jrunto')
            }
            elsif (r.t == "Pearch" || rs&Peace == 9) {
                # the weld keeps warm!
                !Qc&of.startsWith('w') and avoid("of?"); continue
                $z = me&jaa,R,{Introtiv:1,t:Q.t}
                    .map(n => ns&efrom)
                !hak(z) and avoid("!sub"); continue
            }
            else {
                r.t == 'Wayout' and return ~>5 skipWayout: Q.t
                rs&Peace == 9 and return ~>5 skipNiner: Q.t
                !me.cbu(r,'Ying') and return ~>5 aboveYing?: joint(me.cby(r))
                debugger
                return
            }
            
            !z and debugger
            $wasz = z
            !isar(z) and z = [zc&s]
            # < pack many ec&wake
            hak(z) > 1 and debugger
            $z = z[0]
            
            # we can send it here!!!!!!!!!!!!!
            $tp = me&tpath,z
            me&tc,se,"->"+tp
            $sendit = &{
                ~>4 Qwake: tp
                what[Q.t] = Ps&dige
                ec&goated = 1
                me&elvis,R,'elIntro',{wake:zy&R,e:Q}
            }
            # one sendit() only
            what[Q.t] == Ps&dige and ~>3 already: Q.t
            else {
                # first, do the &t,r,Q out of time
                # < !? isn't it already
                0 and me&Outoftime_t,R,r,e,Q,sendit
                else sendit()
            }
            
            0 and me&diffPs,R,Q,P,s,se
        }
        #4s&lastnoQup and me&nu,'4s&lastnoQup',4s&lastnoQup
        #4s&lastnoelQups and me&nu,'4s&lastnoelQups',4s&lastnoelQups
    }
    me.Outoftime_t = &acgtRreQ,sendit{
        ac(e,'wantup',n)
        !es&gotup && es&gotup.includes(Q) and return
        ~>5 wantup: Q.t
        # just this, then wake:z
        #  would have %Paving call &t, go async
        #  bothering Gump with empty then something again
        # < not nodei between steps until all ready?
        Qs&Want_Check = 1
        Qc&ready_instead = &{
            !Qs&dige and return ~>5 digeless-ready: Q.t
            #what[Q.t] == ns&dige and return ~>3 goatied: Q.t
            delete Qc&ready_instead
            ~>5 goatready: Q.t

            sendit()
        }
        T.asyncQs = [];
        me&t,r,Q
        delete T.asyncQs
        ac(e,'gotup',Q)
    }
    # diff code changes as they come in!
    # < rather bad diffsplay
    me.diffPs = &acgtRQPs,se{
        # not extractable from <script src...>
        # from the first of the 2 requests to /wjs/
        $str = Ps&string
        if (Pc&of == 'wjs') {
            $Live = Pc&s
            Live and str = Livec&s
        }
        $io = &i{ return (i=='i'?ah:ahsk)(s,'y','diffPs',...[...arguments].slice(1)) }
        str == null and return
        io('o','nows') == str and 'same'
        else {
            io('i','wass',io('o','nows'))
            io('i','nows',str)
        }
        $las = io('o','wass')
        !las and return me&tc,"first!"
        
        $red = {a:str,b:las,nofirstline:1}
        me&reducefromtheedges,red
        $Pis = Cye(['i',1,{},{string:red.a}])
        $las = Cye(['l',1,{},{string:red.b}])
        me&diffany,R,Pis,las,{se}
    }
    me.reducefromtheedges = &acgtc{
        if (c.nofirstline) {
            $nonfirstline = &s{
                return s.replace(/^.+?\n/,'')
            }
            c.a = nonfirstline(c.a)
            c.b = nonfirstline(c.b)
        }
        $a = c.a.split("\n")
        $b = c.b.split("\n")
        
        $trimsame = &ab{
            while (a[0] == b[0]) {
                a.shift(); b.shift()
                # keep some context leading up to it
                #  supposedly the first line of each indent going out
                #  not very chunks
                a.length < 100 and return
            }
        }
        # reverse first, so we have context leading up to it
        a.reverse()
        b.reverse()
        trimsame(a,b)
        a.reverse()
        b.reverse()
        trimsame(a,b)
        c.a = a.join("\n")+"\n"
        c.b = b.join("\n")+"\n"
    }
    },
    
 

// Story ext
 // %Nodar views
  // doc
        =experiencing a:
        
        self,other are building,styling modes
        
        self nodes -> O <- meddling other
        
        many users other(&{...}) to iter O**
         may slep|steer around iteration semi-auto
          may only visit the top few C
         or
         may be from nodes iterating that we other
          each knowing the O it is
          < gonerism for partly awake O/*, what they emit
            when are things el:9|sleeping
            weird area. see Rc&X + %eph
         what they emit, as users, for O etc,
          may bring other users around,
           eg self must instantiate an O others want to be
          may be streaming somewhere
           eg brack rows upwards
           to fill indexes (merge branches), think on O
           similar to the slep landscape joinup and %%eto:1 hoisting
           getting extra %%O as the row leaves
        
        anyway,
        here, self visits Ying/*/* into O=Rc&s,
         which starts R/**%Nodaring we can tunnel/sleep
         as a kind of R%Nodar self tour
          usu there is a similar canonical other tour
          eg %Abodis others regularly to keep watch for ~self,
           as well as apply styles
         re-visiting parts of the self is elvised|tunneled from users:
        
        other
         visits anything as anything else,
          supposing self is complete (eg Display attached)
          so we can work some other process into it:
         knowing the self + others at O,
          a chance to slep and elvis any of them
          eg new/gone/diff 4/* can be noticed by any othering near it
         other may:
          bring inputs to slep themselves (see -balcurve)
          find selfs that should be because $s..$z
           stretching self beyond its starting shape,
            may have dim O between $s..$z, if never iterated (!node)
          include etc in the R:Nodar self tour
          
         self gc:
           when self wants to O/-O,
            other the effect of being gently phased out first
           %eph may $s/!$z, need to look in sy&R X-path to gc
         
         eg
           a node happening, wanting sy&Org
           making its language there happen
           eg blinking lights, looking %ope, incrementing time
         eg
           to express another thing through it
           showing several -seven in -balcurve/-seven/-n
            would be given to Nodar by the %Plot
            -n+ each knowing an O to style
           specifics|activity amplified across a bell curve,
            the intensity smoothly fading
            so the middle seems to burn open
           -balcurve would slep, like another self
            who in turn is othering its parameters
             which may self from some html controls
             and how they might interslep
            depending on the -balcurve resolving via other,
             may need different attention
              depending on its futurism
              eg being a %J native to another %J
             winding Y:pi cv-ov gaps should do (when !%J)
         
         so,
         may elvis for selfing if slep clued from other
         may stretch self further than Ying/*/* if pushed in
         R/**%Nodaring, we can tunnel/sleep
            whose selfs would hang around,
            able to style just by othering:
        sleping:
         either mode can notice change in things
         when near something else that is iterating
        
        so,
        < &ind moves in via &ind_twz
         < can slep last self as other with that,
          < or more if configured on Y:Dome
          
        =cut
   
  // selfs
    ['Nodar',0.299,&acgtRs{
        
        me&reaw,R,'Nodar'
        $x = me&Jx,R
        # these, we can tunnel/sleep
        Rs&Nodaring = 1;
        Rs&nofurtherDisplay = 1
        
        # < cloning spacers: i $s y- o xs&Ying/#*/#*
        # giving O=s makes this %ball the other
        $c = {beyond:0,within:3}
        $Org = me&indot,xs&Ying,s,c;
        
        # < ingoing refs -> X**,
        #   merges awake|not O.X
        $X = sy&X = {}
        # climbing
        # < Stepy&N having possibly connected things
        Rs&selfs = Org.self(&rOd{
            ~>4 selfs: d.ind, r.t, O.t
            me&X_t,X,r.t,O
            me&X_s,X,r,O
            Os&dopth = d.d;
            Os&coun ||= 0
            Os&coun ++
            return O
        });
        
        s&hue = 66;
        ss&couni ||= 0
        ss&couni ++
        each in ss&z {
            #me&bal,'n:'+i,n,'Yingate,eph,tightly'
            #$r = me&Ret,R,{t:"n:"+i,s:n,Yingate:1}
        }
    },'ift,D'],
  
  // others
  
   // to nodepile%ball
    ['Nodaring',0.299,&acgtRs{
        ah(R,'inheritscif','ball','Nodaring',2)
        Rs&Nodaring < 2 and return
        #me&tsc,"Nod",'','y'
        
        if (s.t == 'Ligno') {
            Rc&b && !Rs&tunneling and return Rs&sleeping = 1
        }
        
        (Rs&boost||0) < 1 and return
        me&nu,s
    },'ift,D'],
    
   // nodepile given -seven+
 
 // signals
  # L (visits|stays) (Plot|eight)y&Point
  # L%Nine <- %%Having,eight+
  // Plot%%Nine<->L%Nine init
    # Plot wants %%Nine to give to L
    # < de-mysteriate beginning (Ying in %SummerCat?)
    ['The',0.46,&acgtRs{
        $x = me&Jx,R
        $Plot = xs&Plot
        me&za,Plot,'Nine' ||
            # keep trying The..Nine
            me&wants,R,'Theing',ss&z[0]
    },'ift,D'],
    
    # Nine -> Plot%%Nine
    ['TheNine',0.44,&acgtRs{
        $x = me&Jx,R
        $Plot = xs&Plot
        me&nodei,R,Plot,{Nine:s}
    },'ift,D'],
    
    # Plot%%Nine just to bind the first L%Nine
    #  thence inherited, until a different Stori
    ['Plot',0.36,&acgtRs{
        $L = sy&Point
        if (L && !Ls&Nine) {
            Ly&l and throw "nonfirstL!%Nine"
            $Nine = me&ja,R,'Nine',0
            Nine and Ls&Nine = Nine
            # now L can async enough to:
            #  This/eight find L, send Nine, send %%Having,eight
            #  later L inherit oL%Nine, if not new Stori
        }
    },'ift,D'],
  
  // L%Nine <- %%Having,eight,L     &L_Streaming
    &{
    # L finds its This/eight +y&Point=L
    # any time we can read Stream[Page_in..out]
    me.L_Streaming = &acgtRLD{
        !Ly&initialis and debugger
        $N = Ds&z.slice(Lc&Page_in-1,Lc&Page_out)
        $was = Ls&Dome
        if (was) {
            heq(was,N) and return
            hak(N) < hak(was) and Ls&Domeshrinks = 1
            N[0] != was[0] and Ls&Domestart = 'diff'
            N[hak(was)-1] != was[hak(was)-1] and Ls&Domeend = 'diff'
        }
        Ls&Dome = N
        # claim each This/$eight for L
        each in N {
            $was = ny&Point
            was && was != L and debugger
            ny&Point = L
        }
    }
    },
    # L%Nine <- %%Having,eight(y&Point=$L)
    # < an &Accepting mode for these three,
    #   controlling and resulting some A
    ['theThis',0.297,&acgtRs{
        $D = Rs&Storystream
        $lastPoint = 0
        $last = Ds&z.length-1
        each in Ds&z {
            if (i == last) {
                !hak( me&ioty,n ) and continue
            }
            $q = {Having:1,eight:n}
            $L = ny&Point
            # may be before OPoint (L_Streaming finds n)
            #  or after the last L has Page_out
            !L and q.wander = lastPoint ? "off" : "in"
            L ||= lastPoint
            !L and break
            lastPoint = L
            
            # may be before Plot%%Nine -> first Ls&Nine
            !Ls&Nine and break
            q.L = L
            me&nodei,R,Ls&Nine,q
        }
    },'ift,D'],
  
  // The<->Plot %%Checkable    &Plot_Pageturn_Checkable
    &{
    # Plot%%Checkable,L <- This/* subset L%Dome completed !
    # as r:This othering a Page++!
    # < merge all Page_*... %Domes = D/*:eight{where},
    #   tell from eight if it's still streaming?
    #   or wait til there's a Page after it, as in:
    me.Plot_Pageturn_Checkable = &acgtRsrD{
        $dome = {dome:'pageturn'}
        $Plot = R
        # go through L+ considering new %Page
        each iL ss&z {
            # < Plot/L could exist before init
            !Ly&initialis and debugger
            # ignore Fuguery except L%Fugued itself
            Ls&Fugue || Ls&Fuguing and continue
            
            !Lc&Page_in || !Lc&Page_out and throw "L!&OPoint"
            $q = {Checkable:1,L}
            if (!Ls&ok && !me&ja,r,q) {
                ss&Page >= Lc&Page_in and me&L_Streaming,r,L,D
                ss&Page <= Lc&Page_out and break
                # L's pages now complete
                me&log,R,'Checkable',{L,Page_out:Lc&Page_out}
                ~>5 +Checkable: L.t
            }
            # %%Checkable -> Plot->/Point -> Nine
            # < ideally %%eto=L will work already
            if (me&jaa,r,ex(q,dome) .length > 1 ) {
                ~>5 multi This Checkable: L.t
                debugger
                continue
            }
            me&nodei,r,Plot,q,dome
        }
        
        # also through D/* considering y&Point=L or not
        # < twlic mode for this
        $D = rs&Storystream
        !D and throw "Storystream"
        $Lless = []
        #!G.afll and debugger
        me&ioty,D .map(&n{
            !ny&R and return
            $L = ny&Point
            !L and Lless.push(n)
            else {
                Lless.length and ~>4 LlessIgnored: joint(Lless), L.t
                Ls&ignore and me&nodei,r,n,{Ignored:Ls&ignore},dome
                Lless.map(n => me&nodei,r,n,'Ignored',dome )
                Lless = []
            }
        })
        
        # < allow it to empty?
        me&dome_traction,r,dome.dome,{el:2}
    }
    },
    # Plot %%Checkable,L -> /Point:L
    #  via here to ensure selfed before eto:L
    # < forwarding %%L here to /L can be faster if selfed?
    ['Plot',0.36,&acgtRs{
        me&jaa,R,'L,efrom'
            .map(n => me&nodei,R,ns&L,n )
    },'ift,D'],
    
    # L %%Checkable,L -> L%Nine
    #  when L%Dome completed
    ['Point',0.38,&acgtRs{
        $L = s
        # Point gets %%Checkable 
        $Ch = me&jaa,R,'Checkable,L,efrom'
            .filter(n=>!ns&Eigh)
        hak(Ch) > 1 and debugger
        Ch.map(&n{
            ns&L != L and throw "Confus"
            !Ls&Nine and return me&wants,R,"getNine"
            
            me&Point_nonCheckable,R,L,n and return
            
            me&nodei,R,Ls&Nine,n
        })
    },'ift,D'],
  
  // Nine<->Eigh->eight %%Checkable
    &{
    # < detecting limbs of %%Checkable pipe with eg %%expect
    # < retracting %%Checkable (from L?)
    #   fading out Eigh|-eight
    
    # < qualities on a jaa and what it wants todo
    # for %%Checkable,L +Eigh, +eight, +ready,ok
    #  pick which stage|form of this message to read
    #  tally them, etc
    me.brackstream = &acgtRs{
    }
    },
    # L%Nine %%Checkable,L -> /Eigh
    #  each L%Dome.$eight have become Eigh%got,
    #   so eighty&Eigh and Eighy&eight
    ['TheNine',0.45,&acgtRs{
        # upto is a length
        $x = me&Jx,R;
        # all results here
        me&jaa,R,'Checkable,L' .map(&n{
            # the ones arriving, not leaving
            !ns&efrom and debugger; return
            # not from /Eigh, sends vitals to keep Nine aware
            ns&Eigh and return
            # < ^ forward them once all Eigh%%ready
            #   should mirror the eight<->Eigh got via L%Dome:
            
            # L has Eigh+ to get to
            $L = ns&L
            !hak(Ls&Dome) and debugger
            $ready = 1
            $ok = 1
            $Eighed = Ls&Dome.map(&eight,{
                $Eigh = eighty&Eigh
                r = Eigh && Eighy&R
                !r and return ready=ok=0
                !me&za,r,'ready' and ready = 0
                !me&za,r,'ok' and ok = 0
                return Eigh
            }).filter(s=>s)
            !hak(Eighed) and return me&log,R,'NineCheckable-noDomes',{L}
            
            # %%Checkable -> Eigh
            # < include %%Eigh already?
            Eighed.map(&Eigh,{
                !Eigh and debugger
                me&nodei,R,Eigh,n
            })
            
            # all Eigh%%ready
            !ready and return
            
            # L <- %%Checkable,...,ready,ok <- Eigh
            # < return it from -eight instead of %Fin?
            me&jaa,R,{L,Checkable:1,Eigh:1,eight:1} .map(&n{
                me&nodei,R,L,n
            })
        })
    },'ift,D'],
    # Eigh %%Checkable,+expect=Nine/$t -> This/$eight
    #  $eight Yingates+Fin:
    #   half happens without it,
    #   -> Eigh%%Fin:$eight,dige checks it ...
    ['TheEigh',0.35,&acgtRs{
        
        $x = me&Jx,R
        $Nine = Ry&up.c.s
        $t = Rs&exp
        $eight = Rs&got
        !eight and return
        # each L%Dome.$eight have become Eigh%got,
        #  so eighty&Eigh and Eighy&eight
        # eight:z now knows Eigh
        eighty&Eigh = s
        sy&eight = eight
        $L = sy&Point = eighty&Point
        
        me&Eigh_nonCheckable,R,L and return
        
        $r = eighty&R
        $Ch = me&jaa,R,'Checkable,efrom'
        hak(grepout(Ch,n => ns&Eigh)) and debugger
        hak(Ch) > 1 and debugger
        
        # can be manually
        !hak(Ch) && x.ro("check",{}) and Ch[0] = 'Checkable'
        if (!L) {
            $l = me&neaz,R,-1
            l and l = lc&s
            $oL = l && ly&Point
            if (oL) {
                # previous one was found
                # < type in t%L=L.t
                #    or 
                if (x.ro("+")) {
                    me&fiu,Nine,[s.t,1,{},{L:'further'}]
                }
                # < or stretch l%Pages
            }
        }
        # disregard actual
        
        Ch.map(n => me&nodei,R,eight,n,{},{expect:t} )
    },'ift,D'],
    # Eigh%%ready -> Nine
    ['TheEigh',0.37,&acgtRs{
        $x = me&Jx,R;
        # then once got storable (via &acceptable)
        # ! Eigh wants:gotready is very important...
        #   stops Nine pushing while we are pushing to it
        #   at some critical moment?
        me&da,R,'ready'
            && me&wants,R,'gotready',Ry&up.c.s
        # %%Checkable...+Eigh,eight,ready,ok back to Nine
        #  once all %%ready then they pipe all %%ok over to %%L
        me&jaa,R,{Checkable:1,eto:s} .map(&n{
            $q = {}
            # add on:
            q.Eigh = s
            q.eight = sy&eight
            q.ready = me&ja,R,'ready',0
            q.ok = me&ja,R,'ok',0 
            me&nodei,R,ns&efrom,n,{},q
        })
    },'ift,D'],
  
 // Plot/Point tie most thing together
    ['Plot',0.298,&acgtRs{
        
        # < TEST see &OPoint Plot 298 init too early
        #me&bewind,R,Ry&up.sc.z and return
        # < all this in one:
        me&reaw,R,'Plot'
        $S = me&inode,R
        $go = me&acting,R,'Plot'
        ah(R,'inheritscif','ball','Point',1)
        
        # for This
        me&Plot_Pageness,R,s
        
        # init something to do
        !hak(ss&z) && me&Plot_Default,R,s
    },'ift,D'],
    
    # This %%Checkable,L -> Plot/Point:L 
    # comes here to say:
    #  ok:
    #    then do some act with-into the next plot point
    #  not:
    #    become Story/** hacking session, resume?
    ['Point',0.34,&acgtRL{
        me&reaw,R,'Point'
        me&inode,R
        Ls&ok && me&sleepic,R and return
        me&OPoint,R,L
    },'ift,D'],
    ['Point',0.37,&acgtRL{
        $go = me&acting,R,'Point'
        # L%ok from  %%Checkable,Eigh
        $Eighs = me&Point_Eighs,R,L
        Ls&ok and s&bgh = '041'
        # act onwards
        Eighs and me&Point_then,R,L
        # L%* shown
        me&Point_ology,R,L
    },'ift,D'],
    
    ['Plot',0.38,&acgtRL{
        # and finally
        !Ls&alldone and return
        me&ha,R,'alldone'
        me&da,R,'alldone' and me&log,R,'Plot-Done'
        me&tsc,"Done",0,'G'
    },'ift,D'],
 
 &{
 // Plot gen Point
    # R%Point is the last of something,
    # < see Around-ness (time collection)
    # < trace back to -Will
    me.Point_alldone = &acgtRL{
        if (0) {
            # or keep going...
            #con("Wander",1,{Pages:99,trail:3})
            me&log,R,"Wanderoff"
        }
        $x = me&Jx,R
        $Plot = xs&Plot
        $This = xc&This
        Plots&alldone = 1
        me&wants,R,"alldone",Plot
        me&log,R,'allDone'
        if (L) {
            me&nodei,R,Ls&Nine,'alldone',{dome:'forever'}
        }
        delete Ploty&Point
        Thiss&pause = 1
    }
    =pod
     make L of Nine/$t
        mostly by $t%L=L.t
      
      carryon%enNine=1|Nino.t - loads, runs a Nine
      -Will has the list of Nines you want:
       =1 pulls one from that list
        eg did Nine to get ready for Nino
       =W.t pushes this particular one
      
      Nino may return to more Nine, via -Will
      
    =cut
    # init: parse Nine:s/$t+ into L+
    me.Plot_PointoNine = &acgts,oL{
        $x = me&Jx,R
        $The = xs&The
        $getNine = &t{
            $Nine = me&fiu,The,t,7
            # Test/Nine
            Nine = Niney&Nine
            !Nine and debugger
            return Nine
        }
        $Plot = xs&Plot
        $Story = xs&Story
        # n = t,c,sc
        $N = []
        $req_L_sc = peel('enNine,Go,check,ignore')
        me&ioty,s .map(&ti{
            ts&L and $L = Cye([ts&L,1])
            i == 0 && !L and throw "first t not %L"
            each kv t.sc {
                req_L_sc[k] && !L and throw "must be with %L: "+k
            }
            # Eigh in last L
            !L and return
            
            # Eigh that starts a new L
            if (!oL && i == 0 && ts&Go) {
                # L%Go first, preceed with a startup ignorer
                #  will be ranged for beginning,startStory
                N.push(Cye(['startStory',1,{check:0}]))
                # will then have a page of mumbling,
                #  up to the 'Going'-log
                $sudden_Go = 1
            }
            N.push(L)
            # %check defor 1, can be 2 to check checking
            ts&check and Lc&check = ts&check
            ts&ignore and Lc&check = 0
            # another Stori->Nine
            $en = ts&enNine
            if (en) {
                en == 1 and en = Thes&about[1]
                # start The/Test looking for that Nine (to Stories/$Test)
                Lc&init = &LR{
                    me&log,R,L.t+'-init'
                    me&nodei,R,The,{Nine:en},{dome:'forNine'}
                }
                Lc&able = &LR{
                    $Nine = getNine(en)
                    Lc&nextc = {Nine}
                    Lc&intoaNine = Nine
                }
            }
            if (oL && oLc&intoaNine && i == 0) {
                # oL is &then()..consum()..here
                $also_init = &LR{
                    Ls&Nine != oLc&intoaNine and debugger
                    Ls&Nine != s and debugger
                }
            }
            $Go = ts&Go
            if (Go) {
                Go == 1 and Go = s.t
                Lc&init = &LR{
                    $Tra = xs&Travel
                    # by now, stuff (Story...Point++...)
                    if (sudden_Go) {
                        # kept in le-3, shut, ignored
                        Ploty&namePages = Ls&Nine
                        me&Pageturn_suddenly,R
                    }
                    else {
                        # could be swept into the last Page?
                        #me&Pageturn_pretendnow,R
                    }
                    me&log,R,'Going',{Go}
                    # < Travel%%Go=$Go -> Travel/$Go
                    $Eas = me&fiu,Tra,Go,7
                    me&nodei,R,Eas,'Go',{dome:'forGo'}
                }
            }

            # < L.c.* merging as an ah() field (Index)
            if (also_init) {
                $was_init = delete Lc&init
                Lc&init = &LR{
                    also_init(L,R)
                    was_init and was_init(L,R)
                }
            }
        })
        return N
    }
    me.Plot_Default = &acgtRs{
        # < based on Stori/* rhythms
        # < 300ms impatience for getting somewhere
        # < get Gump, protoJ for Ying
        
        # an L is always followed by L%checking
        #  generated in &able
        $x = me&Jx,R
        $The = xs&The
        $Plot = xs&Plot
        $Story = xs&Story
        $This = xc&This
        $D = Thiss&Storystream
        # Plot 298 init too early yet appears this time
        !D && !Rc&b && Rs&Plot and return me&waits,"enPlot"
        
        # The%about=[start.t,etc.t]:
        #  etc pulled by start's L:carryon%enNine=1|etc
        $start = me&ioty,The [0]
        start = starty&Nine
        start.t != Thes&about[0] and throw "start not"
        !me&ioty,start .length and throw "start/!*"
        
        # Nine/* should have %L=L.t etc
        $N = Ploty&incoming = me&Plot_PointoNine,start
        #N = [N[0]]
        me&Plot_incoming,R
    }
    # starts|continues generating L
    me.Plot_incoming = &acgtRq,oL{
        $x = me&Jx,R
        $Plot = xs&Plot
        $N = Ploty&incoming
        
        if (oL) {
            # connected to the last Point
            if (oLc&intoaNine) {
                # load Points from the Nine
                #  any N[Point+] potential now happen after it
                N.unshift(... me&Plot_PointoNine,oLc&intoaNine,oL )
            }
        }
        $n = N.shift()
        !n and return me&Point_alldone,R
        
        q and ex(n.c,q)
        $L = me&OPoint,R,[n.t,'-Point',n.c,n.sc]
        
        me&Point_addcheck,R,L
        
        return L
    }
    # L:oL gets subsequent L%checking,
    #  moves oL&able,&then to L
    me.Point_addcheck = &acgtRL{
        $x = me&Jx,R
        $Plot = xs&Plot
        $This = xc&This
        
        $able = Lc&able
        $checks = defor(Lc&check,1)
        Lc&able = &LR{
            # once L%%Checkable, in|for Page=3
            me&log,R,L.t+'-able'
            able and able(L,R)

            if (!checks) {
                Ls&ignore ||= 'nocheck'
                return
            }

            # fire continuation after checking
            $then = delete Lc&then
            $check = me&OPoint,R,['ok:'+L.t,'-Point',{},{checking:L}]
            if (checks == 2) {
                $thenafter = then
                then = &L,R,nothing{
                    # usually nothing
                    !Ls&resumed and return
                    # once L%Fuguing, never %%Checkable
                    #  so may never call &able
                    # keep on after the ok:ok:L.t
                    me&log,R,L.t+'-then%resumed'
                    # from the perspective of L%Fugue, accept:L.t
                    #  instead of the ok:ok:L.t 
                    $Fuguing = Ls&Fuguing
                    !Fuguing and debugger
                    debugger
                    # < the L:carryon nodei doesn't get it ready
                    #   by the time it becomes %%Checkable...
                    thenafter(Fuguing,R)
                }
                checkc&able = &L,R,thenvia{
                    Ls&resumed and debugger
                    me&log,R,L.t+'-able'
                    $ch = me&OPoint,R,['ok:'+L.t,'-Point',{},{checking:L}]
                    chc&then = thenafter
                }
            }
            checkc&then = then
        }
        $then = Lc&then
        $oL = L;
        # this &then may be moved onto L%checking
        Lc&then = &LRq{
            # when we realise L&then
            # we are in a small page between Ls

            # rename|number between Nine
            # eg &able is moved to L:(ok:)+carryon
            $re = oLc&intoaNine
            re and Ploty&namePages = re

            Ly&atPage = &R{
                # now the next page|L starts
                #  with no mention of the previous L
                $q = {Page_in:Plots&Page}
                oLc&nextc and ex(q,oLc&nextc)
                $uL = me&Plot_incoming,R,q,oL
                # < why without this, L:carryon has !Niney&Nine 
                me&wants,R,'Lup',Plot

                then and then(L,R)
            }
            Ls&ignore and Ly&atPage(R); delete Ly&atPage

            This = me&yfuture,This
            $la = me&ioty,This,'Yingates' .slice(-1)[0]
            # previous L wants that small page ignored
            #  we may be L%checking by now (&then may be moved)
            $Ignorable = 'pagebetween'
            me&nodei,R,la,{Ignorable},{dome:Ignorable}
        }
        return L
    }
    
    
 // Plot about Pages
    # This uses Ploty&Pageturnable, etc
    me.Plot_Pageness = &acgtRs{
        $x = me&Jx,R
        $This = xs&This
        # sense wanting quiet,wake
        # < to asap an L finishing
        sy&Pageturnable = &acgtr{
            #  may be Ying     ^
            # when Story/* is blank:
            !This and return
            $r = Thisy&R
            rs&pause and return 0
            $L = sy&Point
            # before Page++
            $i = ss&Page + 1
            $is = L && i && Lc&Page_out < i
            !is and return 0
            if (Ly&R && me&ja,Ly&R,'Checkable,L' ) {
                ~>5 still Pageturnable: L.t, Lc&Page_out, '<', i
                return 0
            }
            me&log,r,'Pageturnable',{Page:ss&Page,next:i,L,Page_out:Lc&Page_out}
            ~>5 is Pageturnable: L.t, Lc&Page_out, '<', i
            return 1
        }
        # title the next page
        # < name after Lf
        sy&Pageturning = &acgtrD{
            $i = Ds&z.length
            ss&Page ||= i
            ss&Page != i and ss&wanderi = ss&Page+'Page!='+i+'Stream'
            $name = 'le'
            $i = ++ss&Page
            $Nine = sy&namePages
            if (Nine) {
                # re-name|number subtests
                # < there would be a leading L
                #   more ideal place to coord this
                #   is not entered yet. allow before &init
                #    and naming them 00-name|desc
                name = Nine.t
                Niney&Pageturns ||= 0
                i = ++Niney&Pageturns
            }
            return name+'-'+i
        }
        # r:This has turned page from D:Stream/-2 to -1
        sy&Pageturn = &acgtrD{
            rc&s != xs&This and debugger
            me&Plot_Pageturn,R,s,r,D
        }
    }
    # This othering a Page++ (async)
    me.Plot_Pageturn = &acgtRsrD{
        $Plot = R
        $L = sy&Point
        # has incremented:
        $i = ss&Page
        me&log,r,'Pageturn',{i,L}
        if (!L) {
            # no Point until Story** on this page
            i != 2 && i < 6 and debugger
            return
        }

        # spring act, may &iPoint
        Ly&atPage and Ly&atPage(r,i); delete Ly&atPage
        
        me&Plot_Pageturn_Checkable,R,s,r,D
    }
    # R:Point demanding a new page, without %%quiet
    #  or the above &Plot_Pageturn responding to it (no &atPage)
    me.Pageturn_suddenly = &acgtR{
        $x = me&Jx,R
        $This = xs&This
        me&log,R,"Pageturn_suddenly"
        $D = me&yyt,This,'Pageturn'
        !D and throw "This!&Pageturn"
        $Plot = xs&Plot
        $L = Ploty&Point
        Lc&Page_in += 1
        Lc&Page_out += 1
    }
    # GONER R:Point demanding a clear page
    #  Page's stuff so far swept back onto lastPage
    # < may naff out Y:Dome
    #    eg drop empty: lastPage will already be gone
    # < slep D/*/*?
    me.Pageturn_pretendnow = &acgtR{
        debugger
        $x = me&Jx,R
        $This = xs&This
        $D = Thisy&Storystream
        $Page = Ds&z.slice(-1)[0]
        $lastPage = Ds&z.slice(-2)[0]
        # these are not input, mere ac z
        lastPages&z.push(... Pages&z)
        Pages&z = []
    }
 
 // Point
    # creation of $L=Plot/Point**
    #  may be This othering via &Pageturn handlers
    # < may be Plotted in advance, de-%eph now
    # < lowL between Ls, until quiet, to check l%ok
    #   allowing pages for acts, pages for checking
    #   < if not two async Yings
    # either causing immediate:
    #  Ploty&Point = L, having:
    #   Lc&Page_out for &Pageturn to complete it
    me.OPoint = &acgtRL{
        $x = me&Jx,R
        $Plot = xs&Plot
        $This = xc&This
        $D = Thiss&Storystream
        # Plot 298 init too early yet appears this time
        !D && !Rc&b && Rs&Plot and debugger
        !Plots&Page and throw "!Page"
        !D and throw "!D"
        
        # creation
        isar(L) and L = me&fiu,Plot,L,2
        !Plots&z.includes(L) and throw "!Plot/L"
        !Ly&R and me&wants,R,'Linit',Plot
        
        me.neigh(L,&lr{ Ly&l = l; Ly&r = r })
        $l = Ly&l
        if (l) {
            # later not created before this solves
            # < unless lowL, handling accepting
            #!ls&ok and return L
        }
        # L init: binds to Pages
        if (!Ly&initialis) {
            # inherit %Nine
            Lc&Nine and Ls&Nine = delete Lc&Nine
            l and Ls&Nine ||= ls&Nine
            l && !Ls&Nine and throw "L2!Nine"
            
            Ly&initialis = 1
            Lc&init and me&wants,R,"L-init",Plot
            
            # usu after the last L's Pages
            Lc&Page_in ||= l && lc&Page_out+1 || 1
            # usu Point%ok at the end of this Page
            Lc&Page_out ||= Plots&Page + (Lc&Pages||1) -1
            !Lc&Page_in and debugger
            !Lc&Page_out and debugger
            
            # for another L
            $oL = Ls&checking
            if (oL) {
                oLs&checked && oLs&checked != L and debugger
                !Plots&z.includes(oL) and debugger
                oLs&checked = L
            }
            
            # silently become Ploty&Point
            me&log,R,'Point++',{oL:Ploty&Point,L}
            Ploty&Point = L
            
        }
        
        # any time we can read Stream[Page_in..out]
        me&L_Streaming,R,L,D
        
        return L
    }
  // Point@37: L&init(), L&able(), L%ok <- Eigh-tally
    # R:Point 3ing, %%Checkable|L%resumed get L%ok
    #  returns true when ready to act on the state of L%ok (null until)
    me.Point_Eighs = &acgtRL{
        # asap, once
        me&ccb,L,'init',1,L,R
        # %%Checkable has two layers:
        # checking begins, going to - able to be checked
        me&da,R,'Checkable,L' and me&ccb,L,'able',2,L,R
        
        # checking completes, with each Nine/Eigh
        $Eighed = me&jaa,R,'Checkable,L,Eigh,efrom'
        
        # L%resumed acquired on commit of L/* in ReNine+unity
        #  are L%ok based on no !ok in empty Eighed
        Ls&resumed and me&Point_resumed,R,L; Eighed = []
        else
        !hak(Eighed) and return
        
        # L receives %%Eigh%%ready,ok?
        $ok = !hak(Eighed.filter(n => !ns&ok)) ? 1 : 0
        Rs&before = Ls&ok != null
        Rs&wasok = Ls&ok
        Ls&ok = ok
        !ok && Rs&wasok and Ls&became_notok = 1
        
        return Eighed
    }
  
  // Point%resumed to continue anyway
    # when R:ReNine+unity pushes (Eigh related to) L
    me.ReNine_pushed_Point = &acgtRL{
        !Ls&resumed and me&wants,R,"L-resumed",L
        Ls&resumed = 'ReNine'
        me&nodei,R,L,{Push:'resumed'},{dome:'resumed'}
    }
    # < &Pointness these two could be
    #   says each thing once - domes it into -Point
    #    links to other entanglements of
    #    notices if it changes across b-Rin-R7-R8:b
    #   knows where can do what
    #    wires in the y&Eigh|eight for Eigh@35
    #   our L%checking is waited for: R%nonCheckable
    #    or going weird: R%Fuguing
    #   &Effect collaboration
    # Point@38 may stop n%%Checkable signal getting to Nine
    me.Point_nonCheckable = &acgtRLn{
        if (Ls&ignore) {
            me&log,R,"%ignore-passed",{L}
            !Ls&resumed and me&waits,'ignored'
            # becomes L%ok:
            Ls&resumed = 'ignore'
            return 1
        }
        
        $ch = Ls&checking
        if (ch) {
            # this L%checking=lL%checked=L (lL,L)
            # not yet
            chs&ok == null and return me&tsc,"check..",0,'g'
            # not ok
            !chs&ok and return me&tsc,"Fuguing",0,'g'
            # without L%checked=rL%checking=L (L,rL)
            if (!Ls&checked) {
                !Ls&resumed and me&waits,'acheck'
                # becomes L%ok:
                Ls&resumed = 'acheck'
                me&ha,R,{Checkable:'acheck',L}
                return me&tsc,"acheck",0,'g'
            }
        }
    }
    # Eigh@35 may stop n%%Checkable signal getting to $eight
    me.Eigh_nonCheckable = &acgtRLn{
        !L and return
        Ls&ignore and return me&tsc,"Ignore",0,'g'
        
        $ch = Ls&checking
        if (ch) {
            !chs&ok and return me&tsc,"Fuguing",0,'g'
        }
    }
    # how L%Fugu(ed|ing)%resumed may recover (act onward anyway)
    me.Point_resumed = &acgtRL{
        $x = me&Jx,R
        $Plot = xs&Plot
        $This = xc&This
        # always has a later L%Fugue
        $Fugue = Ls&Fugued
        # may have an L%checking in between
        $ker = me&ioty,Plot .filter(ker => kers&checking == L) [0]
        if (Fugue && Fuguec&Page_out == 99) {
            # un-sinkhole -Fugue
            Fuguec&Page_out = Plots&Page
            Fugues&resumed = 1
            Thiss&pause = 0
            me&wants,R,'L-de-Fugue',Fugue
            if (ker) {
                # the L%checking may now &then
                kers&resumed = 1
                me&wants,R,'L-de-Fugued',ker
            }
        }
    }
  
  // Point@37: L%ok -> L&then(), acts onwards
    # if &Point_Eighs
    me.Point_then = &acgtRL{
        $x = me&Jx,R
        $Plot = xs&Plot
        $This = xc&This
        if (Lc&pi == 'Point') {
            if (Ls&ok && !Rs&wasok) {
                Rs&before and Ls&became_ok = 1
                # act onwards
                $say = Lc&then ? "..." : "!"
                me&log,R,"L-ok"+say,{L}
                
                $ch = Ls&checked
                # unblocks Point@38: %%Checkable L%checking
                ch and me&wants,R,'L-checked',Plot
                
                $oL = Ly&r
                #oL and me&OPoint,R,oL
                me&ccb,L,'then',2,L,R and 'then something'
                else
                oL and "more coming"
                else {
                    # Point: last one OK
                    # simply run out of &then
                    # is one way to end, or usually:
                    #  avoided by being %acheck, not made ok itself
                    #   oL&then will call L&then,
                    # and onward somehow, depends
                    me&Point_alldone,R,L
                }
            }
            elsif (!Ls&ok) {
                # oL%checked%Fugued
                # L%checking%Fuguing - ignored (even !%Fuguing?)
                #     -Fugue%Fugue   - not usually there
                
                # L%checking do no -eight til %%Checkable,
                #  avoided completely if %Fuguing, unless %resumed->%ok (above)
                Ls&Fuguing and debugger
                # throw merging test resumer
                if (!Ls&Fugued && !Ls&checking) {
                    # L 1, ch 2, Fugued 3 (may be instead of a ch 3, or extra)
                    $Fuguing = me&OPoint,R,['accept:'+L.t,'-Fugue',{}]
                    $ch = Ls&checked
                    ch and chs&Fuguing = Fuguing
                    Ls&Fugued = Fuguing
                    Fuguings&Fugue = L
                    # ^ becomes %resumed instead of %ok
                    me&wants,R,'Plot-en-Fugue',Plot
                    Fuguingc&Page_out = 99
                }
                if (Ls&resumed) {
                    me&tsc,"Error." .sc.fs = 20
                }
                else {
                    me&tsc,"Error?" .sc.fs = 40         
                }
                Thiss&pause = 1
            }
        }
        elsif (Lc&pi == 'Fugue') {
            me&tsc,"Accept-progress"
            #Thiss&pause = 0
        }
        else {
            throw "L!pi", Lc&pi
        }
    }
  
  // Point cosmetica
    # for R:Point
    me.Point_ology = &acgtRL{
        # sublate some R/%fix
        Rs&nofixfor = peel('Page_in,Page_out,Dome,Nine,ok,'
            +'checking,checked,resumed,had_ccb')
        Lc&pi == 'Point' and Rs&nofixfor.pi = 1
        Rs&goPoint and delete Rs&nofixfor
        
        # for the info
        $D = Cye(["Show",1])
        $ha = &c{ me&bracki,R,D,c }
        # when adding strange info, to insist open
        $strange = &c{ Ds&strange = 1 }
        # L has range, etc
        ha({Nine:Ls&Nine})
        each in Ls&Dome {
            ha({Dome:n})
        }
        if (Lc&Page_out && Lc&Page_in) {
            $Pages = 1+(Lc&Page_out*1)-(Lc&Page_in*1)
            ha({Pages,i:Lc&Page_in,o:Lc&Page_out})
        }
        # whether hungry?
        if (Ls&ok != null) {
            Ls&ok and me&tsc,"OK",0,'g' .y.cv = 0.01
            Ls&ok != 1 and strange()
            ha({ok:Ls&ok})
        }
        # which Lc&init|able|then have been called
        each tn Ls&had_ccb {
            ah(R,'fixablestyle',t,{opa:0.67})
        }
        # also says 'acheck' (Point@38) when not followed by a %checking (avoid loop)
        $l = Ly&l
        if (Ls&checking) {
            me&tsc,"check",0,'g'
            Ls&checking != l
                && strange(ha({checking:Ls&checking}))
        }
        if (Ls&resumed) {
            Ls&resumed != 'acheck'
                && strange(ha({resumed:Ls&resumed}))
        }
        
        # OK pseudo-Points, unless freakish, avoid ology
        # < one boost to lum them all
        #   eg know already if ology is boosted
        Ls&ok && (Ls&checking) && !Ds&strange and return
        
        #Ls&checking && !hak('checking,resumedme&bracki,R,D,{resumed:Ls&resumed}
        
        me&pibrackology,R,L,{D} .y.gog(&g{
            gy&cv = 0.8
            gs&dis = 1
        })
    }
    # for a relative (eg $eight or Eigh)
    me.Pointness = &acgtRs{
        $R = Cy&R
        $s = Rc&s
        if (Rs&TheEigh) {
            $z = Rs&got
            $L = z && zy&Point
            !z and me&tsc,"!%got",'...',"y"
        }
        else {
            $L = sy&Point
        }
        
        L ? me&tsc,"L.t",L.t,"y"
          : me&tsc,"L-less","L?","y"
        
        return L
    }
 },

// Gump - Know|That %%cha -> Travel
  # motivate updates
  // 0 @Gump
    &{
        # false, %%waitsing for named node
        me.Othersel2 = &acgtRt{
            $x = me&Jx,R
            $Gu = x.sc[t]
            !Gu and return
            !Gu and me&waits,"Othersel1",0,'say'; return
            !Guy&R and me&waits,"Othersel2",0,'say'; return
            return Gu
        }
        # ugly combo of 'Gump/* ready' and quiet wake sub
        me.quietready = &acgtR{
            $s = Rc&s
            $Y = me.cbu(R,'Ying').sc.Ying
            Ys&quiet_wakers_too_recently = &r{
                # r is R%Ying in waits_8 (not in time)
                # while never quiet it matters, want to self,
                !sy&ever_quiet and return "forself"
                # and even if too close to the last quiet,wake
                # ! DIY loop avoidance
                me&Gump_any_quiet_wake,R and return "forothers"
            }
            if (me&quiet_waker,R) {
                # ^ sets R%is_quiet=1
                sy&ever_quiet = 1
                !sy&ever_quiet and me&tsc,"First"
            }
            
            
           // < huh
            # can rely on another quiet_wake if any busy
            #  but for some reason they are forgotten
            $N = me&ioty,me.cbu(R,'Ying')
                .filter(r => me&ja,r,'waits' )
            if (hak(N)) {
                $v = v
                me&tsc,"early:"+joint(N,',')
                #~>5 Le: v
                # < for some reason they are forgotten
                #  new desire to get there
                N.map(&r{
                    me&wants,R,"forgotten",rc&s
                })
                # also gently nudge Travel
                $x = me&Jx,R
                me&wants,R,'alsoTravel',xs&Travel
                
                delete sy&ever_quiet
            }
            
            !sy&ever_quiet and return me&tsc,"quiet..."
        }
        # Gump...Gomp quiet wake sub
        me.Gump_any_quiet_wake = &acgtR{
            Rs&Gnomp and return me&Gnomp_any_quiet_wake,R
            return me&zaa,R,'by,locked',1 .filter(&z{
                $r = zy&R
                !(rs&Gome || rs&Gnome) and debugger
                # they also must bs&wakeful to get there
                return me&yyt,z,'want_quiet_wake'
            }) .length
        }
    },
    # receive %%chag, make updates
    ['Gumptio',0.5,&acgtRs{
        
        $x = me&Jx,R
        # < &mutex,'with:Story,quiet' and return
        # such that it can start after we do
        $Story = xs&Story
        $avoid = !sy&Storymaystart
            && Story && Storyy&running
        avoid and return me&tsc,"Story..."
        sy&Storymaystart = 1
        
        me&quietready,R and return
        
        #me&baleg,'Gwatch'
        me&baleg,'Gomes'
        me&baleg,'Goting'
        me&baleg,'Gutago'
        me&baleg,'Guten'
        me&baleg,'Gutwin'
        
        # < manage the Travel/$t
        # < %%chag instability before commit,
        #    see %Compiling!
        
        return;
      // go wandering
        uniq( me&jaa,R,'chag','efrom' ) .map(&Z{
            
            $c = {};
            #z.t == 'Easiness' and me&zu,"from",z;
            c.from = me&tpath,Z;
            c.to = [];
            me&otwin,Z .map(&z{
                #me&zu,z;
                $b = {to:me&tpath,z ,from:[]}
                c.to.push(b);
                me&otwin,z .map(&v{
                    #v != z and me&zu,"diff",v
                    $path = me&tpath,v
                    b.from.push(path)
                    v == Z and b.from.push("== from")
                    ##path == 'That/W/Easiness' and me&zu,"^from",v
                })
            })
            me&zu,"fro",c
        })
    },'ift,D'],
    
    
    # forward %%chag, now /* isnode
    ['Gumptio',0.6,&acgtRs{
        me&bewind,R and return
        me&reaw,R,'bal_tw_s'
        $Gu = me&Othersel2,R,'Guten'
        !Gu and return
        # Know..$K <-> K%Thing
        me&locked,s,'twins' and return
        me&dome_traction,R,'feels',{el:2}
        # not %%chag,dome:feels, which we just emptied
        me&jaa,R,'chag' .map(&n{
            me&nodei,R,Gu,n,{dome:'feels'}
        })
        me&nodei,R,Gu,'hello',{dome:'feels'}
        # K <-> Ghost..$z (%%chat) gen from Gutwin
    },'ift,D'],
  
  // 1 @Gutwin
    # check all around %twins
    #  for any odness besides what %Paving sends
    ['Gutwin',0.45,&acgtRs{
        
        me&sleepic,R and return
        $x = me&Jx,R
        $Gu = me&Othersel2,R,'Guten'
        # awkward start. &bewind goes forever?
        # < more multiobject finding multimeanings
        #    when eg %wakeful = $waits
        !Gu and Rs&wakeful = 1; return
        #Rs&wakeful = 1
        me&locked,xs&Gump,'twins' and return
        
        $chaf = &t,c,mix{
            c = ex({cha:t},c)
            me&ha,R,c,{dome:'feels'},mix
        }
        # these are in Schema order
        me&ioty,xs&Ying .reverse() .map(&p{
            !ps&twin and return
            
           // %twin link
            each iz py&N {
                # $p/**$z pointing to another $p
                !zy&twinning and continue
                
                $r = zy&R
                $n = me&zaa,r,{tw:1,eto:p,host:zy&host} [0]
                # find dead links: z with no K
                if (!n) {
                    chaf('lost',{lost:zy&twinning,p,z})
                    continue
                }
                # they %%inside (=$a for Travel/$t),
                #  when on the outside (...$z for Know|That/**)
                $outside = ns&inside
                # $K=$t and $z=$a when not outside (and t!%dige)
                $K = ns&s
                # notice when K%dige ~ z%dige
                if (outside && zs&dige != Ks&dige) {
                    $mix = zs&dige == null ? {is:Ks&dige}
                        : {is:zs&dige, was:Ks&dige}
                    chaf('dige',{p,z,K},mix)
                }
            }
            
           // remotes
            # find dead links: K|t with no z
            # note: p is s (Rc&s), not sy&p (about Schema)
            #  %twin guts are moving to sy&remotes etc.
            # < possibly undo the Ying/$s:step y&up=Ying thing
            #    what requires climbing s only up to the step?
            #   which forgot about how:
            # YET! for finding which way it all goes
            #  ie Know--->That
            #  use Schema's sy&p, re-ordering W:Fingo for workflow sense
            #   also the steps &bal in reverse, so things bubble upwards
            #  we would probably want $W/That first (as it &bal)
            #   the others being aux concern
            $pi = me&neaz,py&p,0
            # build Guten layout: That,To,Travel,Ghost,Know
            $c = {}
            each ih py&remotes {
                
                $hi = me&neaz,hy&p,0
                # flows upwards
                $forward = hi > pi
                # when $z, %%inside=$a: p/$a/**$z
                $outside = i > 0
                $desc = joint([
                    pi,p.t,(forward?"->":"<-"),
                    h.t,hi,(outside?'outside':''),
                ])
                #me&tsc,desc .sc.dis = 1
                # since p%twin %%tw...s=h/**$K
                me&zaa,hy&R,'tw,s' .map(&n{
                    $s = ns&s
                    $some = me&zaa,py&R,{tw:1,s}
                    if (!some.length) {
                        $mix = outside ? {K:s} : {t:s}
                        chaf('lonely',{lonely:h,p},mix)
                    }
                })
                
           // %twin layout
                c.p && c.p != p and debugger
                c.p = p
                c[outside ? 'outside' : 'inside'] = h
                if (c.outside && c.inside) {
                    !outside and throw "later !outside"
                    $mix = sex({},c,forward ?
                        # That:outside,To:p,Travel:inside
                        'outside,p,inside' : 
                        # Travel:inside,Ghost:p,Know:outside
                        'inside,p,outside'
                    )
                    me&nodei,R,xs&Guten,'layout',{dome:'feels'},mix
                    c = {}
                }
            }
            
        })
        me&dome_traction,R,'feels',{el:2}
    },'ift,D'],
    # %%locked:twins or not, ->
    ['Gutwin',0.46,&acgtRs{
        $x = me&Jx,R
        me&jaa,R,'cha' .map(&n{
            # %Paving passes %%n yet this inherits n
            #  they are handled differently, yet almost generic (p,z?,t|K)
            me&nodei,R,xs&Guten,n,{},{chat:'linkage'}
        })
    },'ift,D'],
  
  // 2 @Guten 
    # grouped by Travel/$t, differing
    ['Guten',0.45,&acgtRs{
        $Jx = me&Jx,R
        # xs&columns|pk <- %%layout
        
        $x = me&columns,R
        # before others send %%layout or anything
        !xs&columns.length and return me&tsc,"columns..."
        # stop exploring while Traveling
        #  twin may change, usu becoming %%satis
        me&locked,Jxs&Gump,'twins' and return me&tc,"locked",6
       
       // sprains <- %%cha*
        =sprains
         spread out to find means
         the more u-ish %%may=act with e
          or %%mot=levels of action onward
         
         chagt -> abyT -> clue
         from n to u:
         
         $chagt = %%cha[gt],...
        
         $abyT = %%t,etc,dome:byT,n:$chagt
          is a row
          %%t groups rows
           if present must be a Travel/$t
           < may be found in a %%clue etc
             promoted to guide the whole sprain
             on the elabourate regroup para
              needs easy detangle|explain
        
         $clue = %%cluey:infill,...,n:$abyT
          subrows, explaining aspects
          ... may include:
           %%step,column - identifies column
           %%gk=s,s - thing to put there
        
        =cut
        $seen = []
        # hopefully pk-columnish dome:byT
        $abyT = (n,q) => seen.push(n) && me&ha,R,q,{dome:'byT'},{n}
        # extenting u-ward
        $uby = (n,q) => me&ha,R,q,{},{n}
        
        
        # ghostings have a %%t,z,K,n and a %%cluey,Ghoscis
        #  from h=%%cha,is,was
        $Ghossc = &nh{
            # K%dige can affect all Travel..$t
            # %%was=K%dige
            # %%is=Thing%dige (may already be on $z)
            $K = ns&K
            $k = hs&cha
            !K || !k and throw "takes K+k"
            $some = 0
            # look up what To...K connects to
            $qs = me&ootwin,K (&tz{
                return {t,z,K}
            })
            if (!qs.length) {
                # eg Know..Bouree is nowhere else, yet may %%chag
                # should have a %%chat:linkage,lonely to sort out first
                $chat = me&jaa,R,{chat:'linkage',lonely:1,K}
                if (hak(chat)) {
                    # < attach note?
                    seen.push(n)
                }
                else {
                    me&tsc,"no-ootwin:"+dis(n.sc)
                }
                return
            }
            $z = ns&z
            if (z) {
                # linkage cha:dige have %%z
                #  only things via that z
                $notvia = grepout(qs,q => q.z != z)
                # %%chat,z=To/Loose%broken/W/Dealap
                #  will not find any Travel/$t via Loose
                #  < grouped into a %%lost,z=To/Loose%broken
                #    which may el:2 Travel/#$z:t
                !qs.length and qs = [{t:0,z,K}]
            }
            qs.map(&q{
                $z = q.z
                $p = q.p = zy&path[0]
                # groups by:
                q.t == null and debugger
                some = 1
                $a = abyT(n,q)
                
                $qe = {}
                # diag in the $p=Ghost|To column
                qe.step = p
                # should find 'dige' amongst $z,$K
                qe.says = k
                qe.Ghoscgk = k
                # may not have the correct value
                qe.Ghoscis = hs&is
                # chag..Ghoscis authors K (= K%Thing)
                # chat..Ghoscis complains that z !~ K
                #  isn't going to K = z, only runs make z = K
                if (hs&is == z.sc[k]) {
                    qe.satis = 1
                    ns&chag and qe.mot = 8
                }
                else {
                    # usu auto-%%Go level
                    qe.mot = 2
                }
                # needs Travel from right to left
                #  reversed on the left side of Travel
                qe.direction = qe.satis ? '>' : '<'
                uby(a,qe)
            })
            !some and me&nu,"ootwin!some",n.sc
        }
        # %Paving changes
        me&jaa,R,'chag,K' .map(n => Ghossc(n,ns&n))
        # %twin changes
        #  the %%z,is=$dige may match the %%K,is=$dige
        me&jaa,R,'chat,z,K' .map(n => Ghossc(n,n))
        
        
        # %twinning %%broken
        me&jaa,R,'chat,lost' .map(&n{
            $q = extil({},n.sc,'eto')
            $a = abyT(n,q)
            
            # guess what to mainly hang off (z)
            $nq = xy&inSteps(n)
            uby(a,{step:nq.step,says:'lost'})
            
            # all %%lost %%z, z being the link (either %twin)
            $z = ns&z
            !z and debugger
            # suggest +$t based on $z
            uby(a,{step:ns&lost,may:'el2',gk:'z',z,spacer:1})
            
            # cluey infill the non-broken end
            me&revtwin,z (&s{
                # s=t|K
                $qe = {cluey:'infill',s}
                # mix choosen column for t
                #  brings up the fact of $gk=cluey, also
                
                xy&inSteps(qe,qe)
                uby(a,qe)
            })
        })
        # no %twinning, perhaps guessable
        #  eg K:w/Brackio -> $t:Brackio
        #   J:Brackio will not look like a W,
        #    yet will update $me code
        me&jaa,R,'chat,lonely' .map(&n{
            $q = extil({},n.sc,'eto')
            $a = abyT(n,q)
            # the %twin that would
            $p = ns&p
            !p and debugger
            # guess what to mainly hang off (t|K)
            $nq = xy&inSteps(n)
            uby(a,{step:nq.step,says:'lonely'})
            if (ns&lonely == xs&pk) {
                # must %%Go to Know|That
                uby(a,{step:p,says:'empty',mot:3})
            }
            else {
                # must be created, to then become lonely as before
                # < go searching for That/W/$t
                #   import To|Ghost from W.5
                # find Travel from Ghost+Know
                $other = py&remotes.filter(s => s != ns&lonely)[0]
                $actq = {step:other,may:'el2',spacer:1}
                # sometimes t|K
                actq.gk = nq.gk
                actq[nq.gk] = n.sc[nq.gk]
                #me&nu,"Says",nq
                uby(a,actq)
            }
        })
        
        
        $all = []
        all.push(... me&jaa,R,'chag')
        all.push(... me&jaa,R,'chat')
        all.map(&n{
            !seen.includes(n) and me&zu,"Unseen-input",n
        })
        
        me&dome_traction,R,'byT',{el:2}
        
       // sprains
        $N = me&jaa,R,{dome:'byT'}
        # < group by t,(z|K), whichever tidier, see elabourate regroup
        
        me&sortial,N,'t' .map(&N{
        me&sortial,N,'K' .map(&N{
            each ih N {
                # $h:byT is from n%%cha*
                $n = hs&n
                # Know|That..$K !
                $K = hs&K
                $p = hs&p
                $z = hs&z
                $t = hs&t
                
                xy&arow(h,'K,p,z,t')
                
                $columns = xs&columns
                $col = xs&row.col
                $left = xs&row.left
                
                # h %%K,z want label in those columns
                # < imagine %%distance from the %%layout,inside
                #   so distance=1 for t
                #   and %%closeness = radius - distance
                #   so closeness=0 for K, 1 for p|z etc
                # That,To or Know,Ghost
                # < know better
                $ou = left ? col.slice(0,2) : col.slice(-2).reverse()
                K and xy&usun(K,ou[0])
                #  comp. same .t as neighbour (K>v)
                z && (!K || z.t != K.t) and xy&usun(z,ou[1])
                
                # u
                # < little peeks at what could be there
                me&jaa,R,{n:h} .map(&li{
                    $mostk = haks(l.sc)[0]
                    if (ls&step) {
                        $se = xy&stepcol(ls&step)
                        $s = ls&gk && l.sc[ls&gk]
                        
                        $labe = ls&says || (s ? s.t : '@?')
                        $tite = joint([mostk,i,l.sc[mostk]],':')
                        
                        # point flow
                        $di = ls&direction
                        if (di) {
                            !left and labe = labe+di
                            else {
                                # flip sign
                                di = di == '>' ? '<'
                                   : di == '<' ? '>'
                                   : di
                                # put before, coming from K=That
                                labe = di+labe
                            }
                        }
                        # clickable act
                        $may = ls&may
                        if (may) {
                            labe += "?"
                            tite += "-may:"+may
                            if (may == 'el2') {
                                # < having a node per instance of $s)%ball
                                !ls&spacer and throw "only spacers"
                                $act = &mTe{
                                    # < create Travel/$t like MayTwine
                                    #   so attention goes there and back
                                    #    Gutwin &settle Travel?
                                }
                            }
                        }
                        # native mirage
                        $types = ls&cluey ? ['cluey'] : ['']
                        each ik types {
                            if (!k) {
                                $gc = me&mtsc,se,tite,labe,'g'
                            }
                            else {
                                # < it should be inline cell something?
                                #$see = se.y [k] = se.y [k]
                                #    || sey&can('m',k)
                                #seey&step = sey&step
                                $gc = xy&usun(s,se)
                                # or fadey
                                gcs&opa = 0.6
                                ls&satis and debugger
                            }
                            gcs&dis = 1
                            ls&satis and gcs&opa = 0.6
                            act and me.nto(R,gc,act)
                        }
                    }
                    else {
                        me&nu,"%"+mostk+"!%step",l
                    }
                })
                
                xy&arowed()
            }
        })
            xy&arowgrouped()
        })
       
       // sprains -> @Gutago
        $N = []
        # those with motivation
        me&jaa,R,'mot' .map(&n{
            $t = ns&t
            $K = ns&K
            ns&dome == 'onward' and return
            if (!t || !K) {
                # look &nward for t,K to attach
                $h = xy&nward(n)[0]
                t ||= hs&t
                K ||= hs&K
                if (!t) {
                    # the That/W/Dealap To/Loose...>dige
                    # < mute %%Ghosc once a !%%t
                    me&nu,"tfurthern",{n,h}
                    return
                }
            }
            $q = {t}
            K and q.K = K
            N.push(
                me&nodei,R,Jxs&Gutago,n,{dome:'onward'},q
            )
        })
        me&dome_traction,R,'onward',{el:2}
        $runable = me&sortial,N,'t' .length
        me&tsc,"mot",0,'b'
        me&tsc,"x"+runable
    },'ift,D'],
  
  // 3 @Gutago
    # <- @Guten %%mot,t,K,? 
    # %%Go-able Travel/$t
    # < %%Go-abled also
    #   mot:9 log from job tractor?
    # < currently running should be preferred, negotiated
    ['Gutago',0.4,&acgtRs{
        $Jx = me&Jx,R
        me&ha,R,{layout:1,mostly:Jxs&Travel}
        me&ha,R,{layout:1,also:'mot'}
        me&ha,R,{layout:1,also:'step'}
        me&ha,R,{layout:1,also:'etc'}
        me&ha,R,{layout:1,also:'dep'}
        
        $x = me&columns,R
        !xs&columns.length and return me&tsc,"columns..."
        
       // all Goable
        $all = me&jaa,R,{mot:1,eto:s}
        me&sortial,all,'t' .map(&N{
        me&sortial,N,'mot' .map(&N{
        me&sortial,N,'K' .map(&N{
            each ih N {
                $t = hs&t
                $mot = hs&mot
                !t || !mot and debugger
                
                xy&arow(h,'t')
                
                $mo = xy&stepcol('mot')
                moy&can('i',hs&mot)
                
                # < step,etc want binding so they group as far as possible
                $ep = xy&stepcol('step')
                if (hs&step) {
                    epy&can('i',hs&step.t)
                }
                else {
                    me&mtsc,ep,'no-step',"?",'g'
                }
                
                $et = xy&stepcol('etc')
                $says = hs&says || "?"
                me&mtsc,et,'says',says,'g'
                
                $dep = xy&stepcol('dep')
                $K = hs&K
                if (K) {
                    $co = depy&can('i',K.t)
                    # < GOING doesn't need managing
                    #    since that other %%mot will be lower
                    $others = hs&mot == 8
                        && all.filter(n => ns&K == K && ns&mot < 8)
                    if (hak(others)) {
                        # waits for all other mot:<8,K
                        $gr = xs&row.gr
                        $ol = xy&brackcell('etc',others)
                        ac(dep,'z',ol)
                        grs&bgh = '000'
                        me&ha,R,{t,mot,blockage:'otherKbefore8'}
                    }
                }
                
                if (0) {
                    $et = xy&stepcol('etc')
                    # for etc = %%step,says...
                    $etc = Cye(['etc',1])
                    sex(etc.sc,h.sc,'step,says')
                    $ol = xy&brackcell('etc',[etc])
                    me&mtsc,ol,'...',0,'6'
                    ac(et,'z',ol)
                }
                
                
                #me&nu,"Ro"+i,xs&row
                xy&arowed()
            }
            #t and xy&plusrows("The "+t.t,N)
        })
        })
        xy&arowgrouped()
        })
       
       // next Goable
        # lowest %%mot, first %%t is %%Goable -> @Goting
        #  %%K not required
        $mots = uniq( me&jaa,R,'mot,t',1 ).sort()
        
        # < double-check @Gutwin the first time
        #   TEST why not.
        # < and more? suppose %Bat-ness will refresh acts
        if (1 && hak(mots) && !sy&checkedGutwin) {
            sy&checkedGutwin = 1
            # < this never happens?
            me&wants,R,"re1:Gutwin",xs&Gutwin,{say:1}
            $wa = me&waits,"checked:Gutwin",'',{later:1,say:1}
            #me&nu,"wa",wa
            return
        }
        
        each i,mot mots {
            if (mot >= 9) {
                me&tsc,"relink-K:"+ki(K,2)
                break
            }
            $ts = uniq( me&jaa,R,{t:1,mot},1 )
            each it ts {
                # pipe all %%mot-ish for that $t,
                #  to detect ~u
                
                me&jaa,R,{t,mot:1} .map(&h{
                    hs&blockage and return
                    $bl = sex({blockage:1},h.sc,'t,mot')
                    if (me&ja,R,bl) {
                        #me&tc,"blockage!"
                        return
                    }
                    $q = {Goable:t.t}
                    hs&mot != mot and q.anyway = 1
                    # -> @Goting
                    me&nodei,R,Jxs&Goting,h,{},q
                    q.anyway and return
                    # visual
                    $row = hy&arow
                    $te = row.te
                    tes&bri = 1.6
                    $se = xy&stepcol('mot',row)
                    ses&bri = 1.6
                })
                # < parallel
                break
            }
            break
        }
        
    },'ift,D'],
  
  // 4 @Goting
    # %%Go-ing Travel/$t
    ['Goting',0.4,&acgtRs{
        $Jx = me&Jx,R
        $Tr = Jxs&Travel
        
        me&ha,R,{layout:1,mostly:'Goable'}
        me&ha,R,{layout:1,mostly:'tid'}
        me&ha,R,{layout:1,also:'el'}
        me&ha,R,{layout:1,also:'mot'}
        me&ha,R,{layout:1,also:'phase'}
        me&ha,R,{layout:1,also:'dep'}
        me&ha,R,{layout:1,also:'etc'}
        $x = me&columns,R
        !xs&columns.length and return me&tsc,"columns..."
        
       // all Goable
        $all = [
            # incoming on many %%mot...
            ... me&jaa,R,{Goable:1,eto:s} ,
            # %%historic... - $lo-ish that once were
            ... me&zaa,R,{Goable:1,historic:1}
        ]
        # $tid increases or persists while %%lowel,el<6
        $tidgen = &c{
            $t = c.groure.Goable
            $was = ahsk(s,'y','ttid',t)
            !was and $now = 1
            else {
                !num(was) and debugger
                $now = was + 1
            }
            ah(s,'y','ttid',t,now)
            return now
        }
        me&sortial,all,'Goable' .map(&Ni{
            #0 < i and debugger
            # grouped by %%Goable:$t
            $t = N[0].sc.Goable
            # related rows mix $Goable to group
            $Goable = {Goable:t,mot:1}
            # includes $lo-ish hist
            $historic = grepout(N,n => ns&historic)
            # and current %%mot-ivation to Travel/$t
            $mots = N
            
            $rows = []
            # generating current $lo
            # from @Gutago only, making $tid, about %%Goable,mot
            $c = {tidgen,groure:Goable}
            # state as string|drawing over time, making:
            #  %%lowel,tid,el,D,oD? - the state of it
            #  %%current,wid,el,fromt - many efroms
            $lo = me&version_efroms,R,mots,c
            if (lo) {
                # this would become the four version
                #  Jproto dome has the three version
                $tid = los&tid
                # maybe have $lo-ish hist
                $hi = grepout(historic,hi => his&tid == tid)[0]
                # to recycle or create
                hi = me&historicalise,R,{lo,hi}
                hiy&latest = 1
                rows.push(lo, hi)
            }
            # and history, not including hi - lo's first impression
            rows.push(
                ... me&sortial,historic,'tid','sort,flat'
                    # first|newer have greater $tid
                    .reverse()
                    # recycle
                    .map(hi => me&historicalise,R,{hi})
            )
            $jaa = &cs{
                isst(c) and c = peel(c)
                s and ex(c,peel(s))
                return me&jaa,R,ex(c,Goable)
            }
        
       // tabulk
            ex(c,{t,Tr,jaa})
            c.diff = {labelimplied:'Gump/Gutago'}
            each ih rows {
                xy&arow(h,'Goable,tid')
                hs&Goable != t and debugger
                $te = xs&row.te

                $mo = xy&stepcol('tid')

                hs&lowel and me&lowelrow,R,x,h,c
                else {
                    # misc row
                    $ti = moy&can('i',(hs&tid||''))
                    me&tsc,mo,'misc-row','?','g'
                }
                xy&arowed()
            }
            xy&arowgrouped()
        })
    },'ift,D'],
    &{
      // front
        me.lowelrow = &acgtRxhc{
            $Jx = me&Jx,R
            # &jaa using c.q={Goable:$t,mot}
            $jaa = c.jaa
            $t = c.t
            $Tr = c.Tr
            
            # hist or not
            xy&cean('el','i',hs&el)
            xy&cean('mot','i',hs&mot)
            $wire = &se,{
                return &tc{
                    me&mtsc,se,t,0,c
                }
            }
            $phase = xy&cean('phase')
            $ph = wire(phase)
            $se = xy&cean('etc')
            $dep = xy&cean('dep')
            $ed = wire(dep)
            
            $lo = h
            $tid = los&tid
            $D = los&D
            $oD = los&oD
            !D and debugger
            
            if (hs&historic) {
                # hist permits %%Go
                if (xy&cean('el').sc.ope) {
                    ah(te,'brackaft','lo',lo)
                }
                # < diff D <-> Dy&parent=oD
                ph("Go",'b')
                !me&fiu,Tr,t,8 and ph('el2','g')

                los&el <6 and 'notice ~u: loses Permit with a new D'

                # ▷▶+◼⏏ the %%Go
                $reasonable = hs&mot <3 || hs&mot >6
                $grant = reasonable && tid == 1
                $ope = me&ypermit,R,{D,se:dep,grant}
                # to the supervisor
                ope and me&nodei,R,Jxs&Gomes,{Go:t,tid,n:lo,Goting:Rc&s,mot:los&mot}
                else
                ope != null and hs&invalid = 1
                
                # what goes into it
                me&sixing,R,{D,se}
                jaa('Goners') .map(&n{
                    me&nu,"Goners",{n,w:ns&n}
                })
                $diffc = c.diff || {}
                diffc.se = se
                ope != null and diffc.dont = 1
                $di = me&diffany,R,los&D,los&oD,diffc
            
                hs&invalid and ed("not","b")
            }
            else {
                ph("Thing",'b')
                #$r = me&baleg,'El'+t,'Teag'
                #rs&Teag = 1
                #me&zuct,dep,r
            }
        }
        me.ypermit = &acgtRc{
            $D = c.D
            c.grant && Dy&permit == null and Dy&permit = 1
            $ope = Dy&permit
            $sym = ope ? "▶" : "▷"
            $pla = me&mtsc,c.se,"ypermit-control",sym,'g'
            plas&fs = 16
            me.nto(R,pla,&{
                Dy&permit = Dy&permit ? 0 : 1
            })
            return ope
        }
        # what goes into it
        me.sixing = &acgtRc{
            $Jx = me&Jx,R
            $D = c.D
            $se = c.se
            $sixing = me&opeolo,'-six',{se}
            if (sixings&ope) {
                $six = Dy&six
                # displays
                $ol = me&yology,six
                ac(R,'M', ol)
                oly&cv = 0.7
                me&nu,"D",D
                Jx.ro("see-string?",{}) &&
                n streng 7 $s:Ds&string %e:2,mh:30
            }
        }
      // back
        # for h that may be|produce hi%%historic
        #  c.shade/$k - delete hi%$k (only h %%lowel)
        #  c.x - (&columns) hide current %%historic row
        me.historicalise = &acgtRc{
            $hi = c.hi
            $lo = c.lo
            if (!hi) {
                # just $tid++
                hi = Cye(['historicalise',1])
                his&historic = 1
                ex(hi.sc,lo.sc)
                if (c.shade) {
                    haks(peel(c.shade))
                        .map(k => delete hi.sc[k])
                }
            }
            else {
                # hide hi row of current h?
                if (hiy&arow) {
                    $gr = hiy&arow.gr
                    grs&bgh = '101'
                }
            }
            return me&ha,R,hi
        }
        
        # for a bunch of %%...efrom
        #  difference them, auf. &brackstill's $current
        #  only what's in N (eg %%Goable:$t group) matters
        #   $current merely helps it sleep
        # < probably rename slep slip
        me.version_efroms = &acgtRNc{
          // pool currents
            $s = Rc&s
            c = peel(c)
            # grouping and where if !1
            $groure = c.groure
            $to = Rc&s
            # efrom=node
            $efroms = uniq(N.map(n => ns&efrom))
            c.fromone && hak(efroms) > 1 and debugger
            # each %current version
            # Gotingy&efroms/Gutago %etos=$eto:
            # Gutagoy&etos/Goting:eto %to=Goting %from=Gutago %current
            $currents = efroms .map(&from,{
                $N = me&ioty,sy&efroms
                    .map(n => ns&etos)
                    .filter(eto => etos&from == from)
                    .filter(eto => etos&to == to)
                    .map(eto => etos&current)
                
                hak(N) != 1 and debugger
                return N[0]
            }) .filter(n=>n)
            
            # remembered
            # [w:old]
            $old = me&zaa,R,ex({wid:1,fromt:1,current:1},groure)
            $collect = N.slice()
            $potent =
            currents .map(&c{
                # find w:old, knowing $current, which has:
                $from = cs&from
                $fromt = cs&fromt
                !from || !fromt and debugger
                # by name
                $olds = grepout(old, n => ns&fromt == fromt)
                hak(olds) > 1 and debugger
                $w = olds[0]
                # overall new, same, diff
                $el = !hak(olds) ? 2
                    : ws&current == c ? 8
                    : 3
                # %%mot...* noise
                $froms = grepout(collect, n => ns&efrom == from)
                
                return {current:c,fromt,w,froms,el}
            })
            
          // watch el
            # any low el (from any from)
            $lowel = potent.map(d => d.el).sort()[0]
            # called %%lowel even if %%el is not low,
            #  otherwise %%began=now(),prev=lo
            $lo = me&zaa,R,ex({lowel:1},groure)
                .filter(n => !ns&historic)
            lo = theone(lo)
            
            # stops being sent:
            !lowel and return
            
            # any groure/*=1 shall aggregate to the lowest variety
            #  ie N/%%mot=2,3 makes %%lowel,mot=2
            each kv groure {
                v != 1 and continue
                $lowest = N.map(n => n.sc[k]).filter(d=>d).sort()[0]
                groure[k] = lowest || "?"
            }
            
            if (lowel <6) {
                
                $noise = []
                potent.map(&d{
                    $N = delete d.froms
                    noise.push(...N)
                })
                # convert noise to D%string/-row/-vat
                $t = joint(potent.map(d => d.fromt),"+")
                $D = Cye([t,1])
                Ds&z = noise
                #  creating on this D:brack means no history
                $sev = me&pisix,R,D,{D}
                !Ds&string || !Ds&dige and debugger
                
                # get $lo versioning
                #  D is now &storable
                $d = {lowel:t}
                $oD = lo && los&D
                # < degrees of change
                #   like brackstill knowing ref noise < string|key noise
                #   -six with history
                #   squish|dimension its -ology with diff
                #    where it goes, have a diff to bring
                if (oD && oDs&dige == Ds&dige) {
                    # ignore new D, so ref stays still
                    # < -eight wants to learn this
                    d.el = 8
                    d.tid = los&tid
                    sex(d,lo.sc,'oD,D')
                }
                else {
                    # $tid++
                    d.el = oD ? 3 : 2
                    d.tid = c.tidgen(c,lo)
                    oD and d.oD = oD
                    d.D = D
                }
                
          // usu %%lowel,tid... / %%current,wid...+
                # lo may not change if -six compresses what &brackstill
                lo = me&ha,R,d,{},groure
                potent.map(&d{
                    $w = delete d.w
                    # re-$wid per w that supposedly changed
                    d.wid = d.el <6
                        ? (w && ws&wid || 0) + 1
                        : ws&wid
                    me&ha,R,d,{},groure
                })
            }
            else {
                # lo and its w relax to %%...el=8 over time
                !lo and debugger
                lo = me&ha,R,lo,{},{el:lowel}
                potent.map(&d{
                    # usu roll
                    $el = d.el
                    $w = d.w
                    me&ha,R,w,{},{el}
                })
            }
            !los&tid and debugger
            # old become %%Goners
            old .map(w => me&ha,R,{Goners:1,wid:ws&wid,n:w},{},groure )
            # all noise collected
            hak(collect) and debugger
            
            #me&nu,"collectGo",collect
            #me&nu,"current",currents
            #me&nu,"tid",lo
            #$now = me&jaa,R,ex({wid:1,fromt:1,current:1},groure)
            #me&nu,"wids",now
            
            return lo
        }
    },
  
  // 5 @Gomes/@Gome per $tid
    ['Gomes',0.293,&acgtRs{
        #Rs&onlyish = 1
    },'ift,D'],
    ['Gomes',0.296,&acgtRs{
        me&bin,'Gome'
        $namer = n => ns&Go+" v"+ns&tid
        me&balforward,R,'Go',{namer}
        Rs&wakeperc = 1
    },'ift,D'],
    &{
    },
    ['Gome',0.5,&acgtRs{
        $x = me&Jx,R
        me&acting,R,'Gome'
        $Gump = isnode(s)
        # receive %%Go
        $Go = me&Gome_permit,R,s
        !Go and return
        
        # Gome, being a macro Dome,
        #  can incorporate sleeping content
        me&tc,"mot:"+Gos&mot,'g'
        if (Gos&mot == 8) {
            # just to update K to what they think they are
            $N = me&zaa,xc&Goting,{Goable:Gos&Go,Ghoscgk:1,K:1}
            !me&SuperGhosc,R,s,{N} and return
        }
        else {
            # fully doing
            !me&SuperGome,R,s,{Go} and return
            # contains &SuperGansp etc
        }
        # push W:Fingo
        !me&SuperGens,R,s,{t:'Release'} and return
        me&unlock,Gump,'twins',s
        
        # go back
        me&nodei,R,Goy&R,sex({finished:s},Go.sc,'Go,tid')
        delete Rs&wakeful
    },'ift,D'],
  
  // sleep|wake Gome
  
   // %Superpost takes %%pre=$to &wants
    ['Superpost',0.52,&acgtRs{
        # < relying on pur,pre
        me&jaa,R,'pre' .map(&n{
            ns&wakeful and '20s timer'
            ns&restless and '4s timer'
            # wakes us when ^^Gump%quiet_now
            ns&restless || ns&wakeful and Rs&wakeful = 1
            # supetime's pur:talk,pre=$n
            $to = ns&restless || isnode(ns&pre) && ns&pre
            # < test sute:twinethings where we &want $to
            to and me&wants,R,'prepur:'+ns&pur,to
        })
    },'ift,D'],
    ['wakeperc',0.6,&acgtRs{
        me&reaw,R,'wakeperc'
        # R%wakeful if (s/*)%wakeful
        me&ioty,s .map(&z{
            $r = zy&R
            !rs&wakeful and return
            Rs&wakeful = 1
            me&tc,"wake:"+r.t
        })
    },'ift,D,sleeping'],
  
  // @G(n)ome/*, @Run/*, namespace
        &{
        # Gome** namespace, must t,SC
        me.Gome_Jx = &acgtR{
            #Rs&Gomex and return Rs&Gomex
            $cl = Rs&Gome ? R : me.cbu(R,'client')
            # if %client is something:
            $clcl = cl && isC(cls&client) && cls&client
            if (clcl) {
                # Gome%client=Travel/Fish
                #  is really the @Travel
                # Gnome%client=1
                # Piing%client=Gnome
                !cls&Gome and cl = clcly&R
                !cl and debugger
            }
            !cl and throw "!client"
            # < cl%Piing when unhired
            if (cls&Gnome || cls&Piing) {
                $x = me&Gnome_Jx,R,cl
            }
            else {
                # will get a thing of params
                # < use &jaaz
                $pa = theone( me&ja,cl,'Travelable,Cat' )
                    || theone( me&za,cl,'Travelable,Cat' )
                !pa and return
                $t = pas&Travelable
                $SC = pas&Cat
                !isnode(SC) and return
                Rs&Gome and Rs&client = t

                $SCr = SCy&R
                !SCr and return
                !isR(SCr) and debugger
                # sees $SC/* (eg Jrunto)
                # sees %client%Gome/* (eg Fories)
                $x = me&Jx,R,{c:{SC:SCr,Gome:cl}}
                xs&Pro = xs&Jproto
                xs&Run = xs&Jrunto
                xs&F = xs&TheF
                xs&t = t
            }
            Rs&Gomex = x
            return x
        }
        # Gome** gets E-This
        # < want to rely on Run/* being in xs&*
        me.Gome_This = &acgtR{
            # < o @Jrunto/-This
            $x = Rs&Gomex
            $Run = xs&Run
            !Run and return
            $This = me&fiu,Run,'This',8
            if (!This && Runy&tv) {
                # < put in Runy&tw? only in Runs&z
                #   to stop it %ball-ing without its styling
                o $Run/This
                $This = theone(ays&s)
            }
            !This and return
            !Thisc&pi and return
            $EThis = fi&getpi,This
            !EThis and return
            return xs&This = EThis
        }
        # gets x with This etc
        me.Gome_xThis = &acgtR{
            $x = Rs&Gomex
            return x && me&Gome_This,R && x
        }
        },
  
  // Control, @Gome**
    &{
      // Residents
        # Gome/Fories for W:**
        # Gome/TheF/%TheFest-Accept/%TheFine-nine/%TheFe-Ness
        me.Gome_Resides = &acgtRc{
            $t = c.t
            !t and debugger
            # < s/ies/y/
            me&bal,'Fories','Fories,eph'
            # event grabulator
            me&bal,'Thy','TheThy,eph'
            # < TheF defaults to $t.t
            $r = me&bal,'TheF','TheF,eph'
            $TF = rc&s
            TFs&about ||= [t]

            # < into The/$t, fully as...
            #   they might be Tings (controls SC)
            #    and things to exp (results to match)
            #   we make eight/seven into a thing, in order...
            #   The.. picks up things from This..
            #    already resulting as exp...
            me&Ring,R,{inside:R,ov:0.4}
        }
        # o %%Go, one Gome per Gump
        me.Gome_permit = &acgtRs{
            me&reaw,R,'Gome,client'
            me&inode,R
            $Gump = isnode(s)
            # o Goting... permit
            $n = theone(me&jaa,R,'Go' )
            if (!n) {
                if (!sy&sometime) {
                    # early
                    me&tc,"Loading..."
                    return
                }
                me&unlock,Gump,'twins',s
                me&tc,"disconnect"
                return
            }
        
            # avoid Gu* changes
            me&lock,Gump,'twins',s
            sy&sometime = 1
            
            $h = ns&n
            if (!(h && hs&lowel)) {
                # not from @Goting's historicising?
                #  @Intro circumvents tracking inputs there
                me&zu,"NOLOWEL",h
                return
            }

            # in time %%quiet_wake:Gump
            Rs&wakeful = 1
            $quiet = me&is_quiet_now,Gump
            quiet and me&tsc,'quiet'
            quiet and Rs&Gump_quiet = 1
            me&tc,"\n"
            # < &SuperGens:startTravel
            #    commit unrelated changes for tidiness...
            return n
        }
      
      // Dialectics
        # < sync with TheFine
        me.Gome_SC_SetTings = &acgtRF,ha{
            $x = Rs&Gomex
            me&nodei,R,xs&Pro,'noautoDuolish'
            x.ro('looksdone',{}) and me&nodei,R,xs&Pro,'mayDuolish'
            # < should keep the main thing awaking (dome:now)
            #   redoing elvising every so often, keepalive duty
            # development mode
            else me&nodei,R,xs&Pro,'keeprunning'
            # and may begin if SC%Con (if t%Con)
            !x.ro('maynotRun',{}) and me&nodei,R,xs&Run,'mayRun'
        }
        # Gome <- This wanted
        me.Gome_Thischa_other = &acgtRF{
            $This = me&Gome_This,R
            !This and return 1
            $c = {This}
            me&FasyncThis,F,c
            return c.el <4
        }
        # Gome <- This wanted and applied
        me.Gome_Thischa_self = &acgtRF,ha{
            $x = me&Gome_xThis,R
            !x and return ha('pur:This')
            $This = xs&This
            
            $s = xs&Gome
            $c = {This}
            me&FasyncThis,F,c
            c.wake.map(&z{
                # wake Fc&InFine=%TheFine, or sometimes This...
                $name = "~This->"+z.t
                !isnode(z) and debugger
                !isnode(z) and return me&nu,"nonnodetractor",{c,z}
                me&wants,R,name,z
                ha({pur:name})
            })
            c.el < 2 and ha('pur:unreadyThis')
            if (c.el == 2) {
                # suppose only current Fine needs reselfing
                #  this forgets|resets|rebuilds Fine** R+s
                $z = c.InFine
                Fc&InFine != z and debugger
                # Fest generates /Fine
                $Fest = zy&up
                me&Effect,s,Fest,'pullThis',{curse:z}
                # < &Effect to maybe unexistent places...
                # reself Fc&InFine=Fine
                me&tc,"pullThis",'y'
            }
        }
    },
  // @Gome -> %Zaving
    # remote R%Gome wants to push,
    # < as long as all %Settled? ie, not just changed.
    ['Zaving','2918',&acgtRs{
        me&rollbs,R,'allope'
    },'ift,D'],
    ['Zaving+allope','3141',&acgtRs{
        # must be deleted from R by the remote
        me&rollbs,R,'allope'
        !Rs&allope and return
        me&reaw,R,'allope',1
        each ir Rs&Zaving {
            rs&Describing = 1
        }
    },'ift,D'],
    
    # make %laReal=R!%sleeping
    #  so we can find the latest real %Zaving
    # GONER? soon as not needed for &Zaving_haul
    # %Tey&Real=R includes R%sleeping
    # %Zaving doesn't exist while tunneling through,
    #  or since Ying 2926 happens before much %Zaving
    # %JRom=c is like &reaw, R.sc recipe for this
    ['Gens+Zaving','78',&acgtRs{
        $p = Ry&up
        !ps&JRom and return
        Rs&laReal == R and debugger
        Rs&laReal = R
        ps&JRom.laReal = R
        # < working via %JRom/R or &reaw
        #me&reaw,R,'laReal',1
    },'ift,D'],
    ['Gens+Zaving+laReal','77',&acgtRs{
        $p = Ry&up
        ps&JRom.reallyreal = 1
        Rs&reallyreal = 1
    },'ift,D'],
    &{
        # < perm. give any R %laReal (Te%Recipe?)
        # finding the latest real R
        # < should be obvious re Abit
        me.laRealier = &acgtZ{
            $Zo = Zs&laReal
            # must be before Z (supposing we are in Z, see SupelaRealier)
            if (Zo == Z) {
                # also not awake this time,
                #  not having %Zaving completed yet
                Z = Zc&b
                Zo = Zs&laReal
            }
            return Zo
        }
    },
    
  
// &Supe*
    
    &{
       // &SuperGome inter %SummerCat
        =doc
         sync Ting, play|pause|rewind|stop, re tests
         
         @Fine/* reiteratively
          are:
           
           Step-Ness <- This**
            if 'OK', deal the next bunch of:
           
           Act-Do -> @Run
            interactions, e:something, @Pro-pulsion?
             usu just wake:@Run for iteration via @Gome
           
           /View-Ting -> The
            a Fish Te. usu how This** should ope
          
          wakes at quiet
           when @Pro|@Run out of plans|reactions (%%waits)
           following up:
          -Ness <- This**
           emitting 'OK' if nicely
            < else pause?
           is $got:
          progressing thenceforth:
           -Do and -Ting
            are essentially testing instructions
             > compiled into the Outs -Ness
            act when their preceeding -Ness is $got
           they:
            end up in @Run/The
            which Fish uses as %Te
            to be influenced by it
            
           /Act-Do dealing
            @Run or @Pro wait for @Gome|the-outside-world
             eg could reply to A:mess in some way
            either could expect any kind of reply
             inc a bunch of e to bring another kind of reply in
             eg @Pro takes e to %%C on %%Four
           /View-Ting lighting
            adjustments to This**/-log**
          ->
           @Run/The
            makes %dige
             Outs -Ness may note to confirm compilation?
              while not modified
              and|or diff against W:Stories/$t/-Ness/The ?
               make &Accept different formats easy
            taken by various users as inputs
             eg @Pro or @Run could take some setting
              eg @Pro wants a versionable %Te thing
               eg rewind|forking it when it does free will
                eg the @Gome linearities binding or not with @Pro
                 ie should @Fine rewind to sync with @Pro
                  or should it watch @Pro rewind...
             eg Fish %TX, matching $Tt
          
         @Fine/View-Ting ->
          The/$src='View'/Subdivisible/$ope-op
           Subdivisible specifies cause (%TX stuff)
            C** free to be documentary and where-clausey
           -op specifies the effect (%RX stuff)
          -> The%TX
           as known up to date by They&things&TX
           and every ~ into The** tracked there
          
          ⚡️
          %TX cause, %RX receive effects
           inc more %RX/TX to use within
          
          eg The%TX/$A=Such,
           would find all A:Such anywhere and etc:
          eg The%TX/$A=-Eight
           find -Eight when &complace introduces it
           makes -Eight%RX
            receives effects, eg $ope for -Eight
            or waits for && expression in %TX to solve
            may more specific %TX within:
          eg The%TX/$rare//$common
           is to be preferred for speed
           various match logics configured in:
          
          The/Time-yds/Path/$ope-op
           as default e:click capture place
           -yds you did something
           config their pointerism
            look for defining characteristics
            do we mean things that look similar
            big etc
           all about forming %TX to find itself
           push to @Fine proper
           may recycle into future @The
          
          play with the scope of the selectors
           and how to conceive of its parts
           as how to structure the index
          
          putting $A=-Eight type things at the top
           X/$A may be $At strings and $A objects together
           > locate given $A by ip, even in vanished history
           see &Ariv
            < finds A:loading itself
           see &pio
            finds -Eight:'A:loading' etc
           enabling the finder of that self
          
          Subdivisible
           is homing the -op and anything else
           it starts pointing to things in empiricle ways
            ie seq, types
           pointing gets organised:
            more|less detail
             usu as ANDing with nearby e:clicks
            CRUD, fork, merge?
             via CodeMirror?
            put in human-meaningful containers
          
          so
           a %TX clause can need more clauses,
            eg $A=-Eight && $C=A:loading
             is $A -> %RX/TX/$C
             more %RX/TX are for -Eight**
             introducing another pool of information to draw from
             sync newly matchable TX to -Eight%X thus far
             so the $C=A:loading is got now if already i
             %RX knows TX+ versions got
              new ones sync 
           
         @Fine/*-Ness <- @Run/This**
         @Fine/*-Ting -> @Gome/The**
          which ready-steadies
           and -> @Run/The**
          and the process of
           persisting loose fiddles beyond a @Fine
            eg with -log expression
             should come back next time
            hanging around @TheFest, 'Leave'-able stuff
            connecting or rejecting fields of stuff
             fully, partly, to various storables:
              Fine/StepPrep-Ting
               in Outs, amongst -Ness
               may fill out a pointered:
              Fine%u/SuchVariety
               shared, pattern catalogue
           adjusting the adjustments
            until targeting correct one|many things
             eg some -log singularly
              or all the -log similar to that one
           
           simpler than Fish %TX %RX makes it sound...
           which compiles to $Tt, resolving in &log
        
        
         many @Fine
             they might have things to version control
              esp. &SuperGhosc|Gens: push versions
              any remarkables for this @Goting-ing
               which should complete nicely,
                have %%Go/time

         anyway, &SuperGome is:
          selfy to the -Ness and their config
          othery to This, SC
           which we sync:
            -Ness/-Eight/-seven inflate from:
            This/-Eight/-seven
             /Event-log/-row/-vat**
            are done, in R time for This..-seven
             or in &log time for -log**
              their how by @Run/The
          
          goes on to Duolish, remarking on u used
          which needs to hoist from A:loading now...
         
              
           < both 'Leave' + 'Attend' equally?
           < OKing -Effect -> Fine... borrow Story signals

              maybe ok when created? also:
           < accepting new is noisy,
             should surf string looks over the top of This** it from
              fast This** ope+- and geo grabbing
          < &SuperGome notices test run state
           is going to revoke Jrunto %%mayRun when quiet
           taking memories etc
           the -sevens nail themselves down?

        
           &SuperGome middle has:
            &SuperIntro - ~u/time
             Ting-able responder
              be synth ghostups from -Do-ing
             and init wait for @Inc?
              to avoid the er:async we know are coming
            &SuperSC - controls SC, ~This/time
             seeing @Pro
              as put into This/A:Pro
             putting @Pro
              as ~Fine pointers to things it wants
               hopefully resume at any point passed
                drop -sevens to do so?
                or simply revert This&X back to there
            &SuperFine - ~Fine/time
         
         past Fine (or so) of the same name (or so)
          may lend their -Ness%string (or so)
           for similar chunk finding
           for a 'looks like last time'
           
        =cut
        me.SuperGome = &acgtRsce{
        # 1:
        #  %%Go -> Travel +/$t/$SC - what to control
        #  Gome/Fories/$t Resides - how to control
        #  Gome/TheF/$t** - receiver of testrun
         // 1
            $x = me&Jx,R
            # the %%Go,+Gome
            $Go = c.Go
            
            c.t ||= 'Gome'
            $su = me&supetime,R,c.t
            # we slowly wind up the runlevel !
            # allowing eg $SC to +%Con before R:SC/*
            # 1
            su('Go-SC',{perm:&zaa,jaa,ha,ar{
                # %%Go -> Travel +/$t/$SC - what to control
                me&nodei,R,xs&Travel,Go,{},{Gome:s}
                
                # have Travel/$t/$SC looking ready
                # set R:Gome%client, other &Jx will see Gome/*
                x = me&Gome_Jx,R
                # required to form the x
                !x and return ha('pur:t+SC')
                $t = xs&t
                $SC = xs&SC
                if (ts&Con) {
                    # something we test
                    # Run waits for %%mayRun
                    SCs&Con = 1
                    
                    # Gome/Fories/$t Resides - how to control
                    # Gome/TheF/$t** - receiver of testrun
                    # < &Effect each $t in there, to create it?
                    me&Gome_Resides,R,{t:t.t}
                    # < meaning Gome/* are ready
                    # want ever_quiet once here to continue
                    me&Superwaits,R,{ha,zaa,t:'Resides',until_next:Rs&Gump_quiet}
                    
                    x = me&Gome_Jx,R
                    !xs&Fories and ha('pur:!Fories')
                }
            }})
            &&
        # 2:
        #  knowing how, %%Control -> $SC +/*
        #  until %%Releasor exits
        #   < should only have to pause until pushed:
        #    to store J osc via Duolish** &SuperGansp
         // 2 see things
            su('SC/*',{until:&zaa,jaa,ha,ar{
                $t = xs&t
                # $tid versioning:
                $SC = xs&SC
                
                # enable @Intro
                $Intro = xs&Introtivity
                Intro and me&nodei,R,Intro,{Intro:1,Cat:SC}
                
                # %%Control -> SC => $SC/*
                me&nodei,R,SC,{Control:1}
                
                x = me&Gome_Jx,R
                !x and debugger
                # < should stay
                $Pro = xs&Jproto
                $Run = xs&Jrunto
                !Pro and return ha('pur:!Jproto')
                !Run and return ha('pur:!Jrunto')
                if (ts&Con) {
                    # < Story/$t informs Cat modes:
                    # stays %%now until tests satisfied
                    $F = xs&TheF
                    !F and return ha('pur:!F')
                    
                    me&Gome_SC_SetTings,R
                    
                    # puts xs&This
                    $This = me&Gome_This,R

                    # we then expect to go quiet
                    # allow Gump to quiet wake while ~This**
                    sy&want_quiet_wake =
                        () => me&Gome_Thischa_other,R,F
                    
                    !This and return ha('pur:!This')
                    
                    me&Gome_Thischa_self,R,F,ha
                    
                    # observe Proto !now not over finishline
                    
                    Rs&goGome and me&nu,"Fins",{t,SC,Pro,This,F}
                
                    x.ro('end') and return
                }
                
                # o Duolish... run
                $e = me&receivan,'Releasor'
                !e and return ha('pur:Releasor')
                ha('rec:once,arg',{Releasor:e})
                ha('rec:gotReleasor,sayable,gotReleasor')
            }})
            &&
         // 7 Push
            su('Push?',{until:&zaa,jaa,ha,ar{
                $e = ar.Releasor
                !e and return
                # n|u all done
                me&tc,"Push?"
                # deal with Travel|Duolish
                # < notice when Ghost..Bouree no longer used
                !me&SuperGansp,R,s,{},e and return ha('pur:SuperGansp')

                # < &SuperGens:finishTravel
                #    what run did in W:Fingo,
                #     probably nothing, pushables are in $e
                #    may subtract startTravel
                #   < then permit Releasor to begin
                #     now, is starting already
            }})
            &&
            su('Pushed',{until:&zaa,jaa,ha,ar{
                # n|u all done
                me&tc,"all-done"
                ha('rec:Pushed,sayable,all-done')
            }})
            
            return su('done')
        }
       
       // &SuperGhosc auto %Paving Thing believer
        # supervise K%dige=%%Ghoscis
        me.SuperGhosc = &acgtRsce{
            c.t ||= 'Ghosc'
            $NK = c.N
            $su = me&supetime,R,c.t
            su('was',{until:&zaa,jaa,ha,ar{
                # group by $K, then $gk
                # < reconstitute objects that might have A
                me&sortulat,NK,'K,Ghoscgk','firstonly' (&KkgN{
                    $gk = k
                    $is = gs&Ghoscis
                    # should be Ghost<-Know until all Ghosts align
                    $ises = uniq(N.map(g => gs&Ghoscis))
                    hak(ises) > 1 and ha("pur:!oneval",{gk,ises,N})
                    
                    $was = K.sc[gk]
                    me&tc,was
                    
                    # remember what it is now
                    # < have a clue for how to undo
                    #   besides resetting (parts of) W:Fingo
                    ha({K,Ghoscgk:gk,Ghoscwas:was})
                    ha({K,Ghoscgk:gk,Ghoscis:is})
                    # should be different
                    # < is the complaints process out of date?
                    #   have to &unlock and see, etc
                    #    demanding a return to this before @Goting changes
                    was == is and ha('pur:!different',{K,gk,was,is})
                })
            },permasay:1})
            &&
            su('change',{until:&zaa,jaa,ha,ar{
                # jaa(c,i=1) selects either recycled or latest, but not both
                # from the previous sute (defaults to this one)
                $N = jaa('sute:was,K,Ghoscgk,Ghoscis',1)
                me&sortulat,N,'K,Ghoscgk','firstonly' (&KkgN{
                    $gk = k
                    $is = gs&Ghoscis
                    
                    me&tc,is
                    K.sc[k] = is
                    
                    # want K to realise
                    # < if &settle was more transient, that would do...
                    #   then we'd have a picture of K%%* reacting
                    $r = Ky&R
                    ha({K,r})
                })
            },permasay:1})
            &&
            # < wants to reset from here if %%wants should fail
            su('refresh',{once:&zaa,jaa,ha,ar{
                jaa('sute:change,K,r',1) .map(&n{
                    $K = ns&K
                    me&wants,R,'K-refresh',K
                })
            }})
            &&
            su('refreshed',{until:&zaa,jaa,ha,ar{
                $N = jaa('sute:change,K,r',1)
                me&sortulat,N,'K' (&Kn{
                    $r = ns&r
                    # < until K has woken since r
                    $c = {cb:(k,r) => ha('pur:'+k+'-yet',{r})}
                    me&wokesince,R,r,c and me&tc,'ok'
                    else {
                        me&tc,'...','G'
                    }
                })
            }})
            return su('done')
        }
        # find first+notnow (or c.last|all) real awake yfuture since r
        me.wokesince = &acgtRrc{
            c = peel(c) || {}
            c.last and $all = c.last = c.notnow = 1
            else
            !c.all and c.first = c.notnow = 1
            else {
                $all = c.all
            }
            $i = c.i || 50
            
            # list
            c.all = []
            c.sleep = []
            c.wake = []
            $ac = &k{
                $N = c[k] ||= []
                N.includes(r) and debugger
                N.push(r)
            }
            # callback
            $cb = &k{
                c[k] and c[k] (r)
                else
                # usu into %%pur=${k}yet
                c.cb and c.cb (k,r)
            }
            while (1) {
                $was = r
                r = ry&future
                i-- < 0 and return cb('farout')
                if (!r) {
                    # &yfuture goes one further,
                    #  using the uncommit X...
                    r = me&yfuture,was
                    if (!r || r == was) {
                        all and break
                        return cb('not')
                    }
                }
                ac('all')
                if (Rc&N.includes(r)) {
                    c.now = r
                    # supposedly the end?
                    all and break
                    c.notnow and return cb('now')
                }
                if (rs&sleeping) {
                    ac('sleep')
                    continue
                }
                ac('wake')
                c.first and return r
            }
            c.last and return (c.wake||[]).slice(-1)[0]
        }
        # make groups aggregating values
        # < hooks for begin|end each grouped value
        # < integrating with &columns...
        #   the general modulat -> structure thing (KnowC?)
        #    shall wrap titles into cells, so things can align
        #     loosely, shove other says in spare rooms
        me.sortulat = &acgtNqc{
            c = peel(c)||{}
            if (!c.y) {
                # < Babz like BlockQuote, for &trailing (&callback{...}
                return &y{
                    c.y = y
                    me&sortulat,N,q,c
                }
            }
            c.rows ||= []
            q = ex({},peel(q))
            $k = haks(q)[0]
            $v = delete q [k]
            $more = hak(q)
            $cee = c
            me&sortial,N,k .map(&Nk,{
                c = ex({},cee)
                c.y = cee.y
                $K = Nk[0].sc[k]
                # first or non-last get b-igger title
                $tc = [joint([K]),((!c.into || more) ? 'b' : 'G')]
                c.into and tc.unshift(c.into)
                c.into = me&tcl,...tc
                c.args = [...(cee.args||[]),K]
                if (more) {
                    me&sortulat,Nk,q,c
                }
                else {
                    $No = c.firstonly ? [Nk[0]] : Nk
                    No.map(g => c.y (...c.args,g,Nk))
                }
            })
        }
       
       // &SuperGansp auto %MayGansp
        # supervise %MayGansp/%MayTwine**
        #  ha waiting:
        #   %%pre... and %%wants... via &diagno
        #  may ha
        #   %%Pushable
        # < ha n,{k:0} means delete %%$k, after inheriting
        me.SuperGansp = &acgtRsce{
            
            $x = me&Jx,R
            o $e/twine/:Gansp
            $N = ays&Gansp || []
            $twine = (ays&twine||[])[0]
            !(twine && hak(N)) and debugger
            
            c.t ||= 'Gansp'
            $su = me&supetime,R,c.t
            su('twinethings',{perm:&zaa,jaa,ha,ar{
                # scans the %MayTwine tree
                #   that climbs the %twin tree
                #  bringing back any %%Pushable
                $twinething = &r,n,ono,talk{
                    $nr = ny&R
                    
                    # zy&allthings/* should all be %%thing
                    $th = me&zaone,r,{thing:n}
                    if (!th) {
                        ono('sometwine')
                        me&tc,".."
                        return
                    }

                    # Gansp should also have a:
                    $wantpush = me&zaone,r,{wantpush:n}
                    if (wantpush) {
                        talks&bgh = '000'
                        $Pu = me&zaone,nr,{s:n,Pushable:1}
                        if (Pu) {
                            # from &readyok, only if el:2
                            Pus&el && me&tc,'el:'+Pus&el,6
                            me&ha,R,Pu
                        }
                        me&Zifsum,nr
                        return
                    }
                    $ok = theone( me&zaa,r,{ok:n} )
                    if (ok) {
                        me&tc,"ok",'g'
                        return 1
                    }
                    me&tc,"..?",6
                    ono('alltwine')
                }
                
                N.map(&z{
                    me&tsc,"t",z.t,'b'
                    # make fault, to bump z%MayGansp
                    $ohno = &tn{
                        me&ha,R,{pre:t,Gansp:z,restless:n||z}
                    }
                    # all of them asap
                    $all = zy&allthings
                    if (!all) {
                        hak(me&ioty,z ) and debugger
                        me&tc,'empty','y'
                        ohno('empty')
                        return
                    }
                    $r = zy&R
                    # gradually show up as push situation
                    # < &Accept these, have an observer mode
                    all.map(&n{
                        # bubble per n %%thing
                        $talk = me&tcl,n.t
                        me&walls,talk,'b:1.2h2'
                        $capture = me&Mwcap,R,'twinething-'+n.t,talk
                        
                        # make fault, to bump n%MayTwine
                        $ono = &t{
                            me&walls,talk,'b:1.2h6'
                            ohno(t,n)
                        }
                        $ok = twinething(r,n,ono,talk)
                        !ok and ha({notok:n})
                        
                        capture()
                    })
                    #me&nu,'Gansp',z
                    me&tc,"\n"
                })
                # solve any %%pre-vention
                me&diagno,'restless','twinebump'
                    .map(n => me&wants,R,'twinebump',ns&Gansp )
                # %%pre-vention into %%pur
                #  similar meaning, for &supetime
                me&jaa,R,'pre' .map(&n{
                    ha({pur:ns&pre,Gansp:ns&Gansp})
                })
            }})
            &&
            su('Pushable',{until:&zaa,jaa,ha,ar{
                $push = me&ja,R,'Pushable'
                !push and return
                $auto = 0
                $specie = joint(uniq(push.map(n => ns&species||1)))
                if (specie == '5') {
                    $auto = ha('rec:speciefive,sayable,autopush:all5')
                }
                if (!auto) {
                    !x.ro('push?') and return ha('pur:push?')
                }
                me&tc,"pushing..."
                # < seeing each one of these:
                #    think it has pushed
                #    have an e:elQup
                # sent to nearest R%MayTwine%%thing!%%extra
                #  so all the %%extra (eg .5) push with it
                $nonextra = z => me&za,zy&R,'extra' ? zy&up : z
                $things = uniq(push.map(n => nonextra(ns&s)))
                things .map(&z{
                    me&nodei,R,z,{maypush:1},{dome:'tilpushed-push'}
                })
                # should become %%quiet once pushed
                # as detected every time:
                jaa('sute:twinethings,notok') .map(&n{
                    n = ns&notok
                    me&wants,R,'twinepushing',nonextra(n)
                    ha('pur:pushing',{n})
                })
            }})
            &&
            su('Pushed',{until:&zaa,jaa,ha,ar{
                # n|u all done
                me&tc,"all-done"
            }})
            
            return su('done')
        }
       
       // &SuperGens auto %Gens%Zaving
        # < &voice must have an arg realiser, D%args ||= &arfgunc
        # < waits_8 for bringing in 5s/20s non-quiet waker
        # < auto Gens patch looking like the %%Ghoscgk said it would
        me.SuperGens = &acgtRsc{
            $x = me&Jx,R
            c.t = joint(['SuperGens',c.t],':')
            $su = me&supetime,R,c.t
            # the R:Fingo%Peace=5,Gens,Zaving
            #  above W:Fingo%Peace=4,Ying
            me&SupeallopeGens,R,s,{},su
            &&
            me&SupesavingGens,R,s,{},su
            &&
            su('donesaving',{until:&zaa,jaa,ha,ar{
            },finishline:1})
            return su('done')
        }
        
        # start (& finish) Z%allope
        #  allowing real|awake Z-time to pass
        #  %Describing -> %Described
        me.SupeallopeGens = &acgtRsc,su{
            # check %Gens%Zaving state with %allope
            # push|reset|ignore then close
            c.t ||= "allopeGens"
            c.k ||= 'Z'
            c.find ||= (R => me.cbu(R,'Gens'))
            # open, gets %Describing
            c.start ||= (Z => Zs&allope = s)
            # opened, is %Described
            c.like ||= (Z => Zs&Zaving && Zs&allope == s)
            # < %allope should stop %Describing once %Described is got
            #   needs some unique object to pass to it? is the @Gome for now
            c.finish ||= (Z => delete Zs&allope)
            c.pur ||= {pur:'Zaving-ack',wait:1}
            return me&Supewokesince,R,s,c,su
        }
        # allowing real|awake Z-time to pass since c.start(Z), etc
        # < wake Z (&SupeGens does)
        # < case for easy access to latest woke other,
        #   Effect it and ack. show RingMap
        me.Supewokesince = &acgtRsc,su{
            # $Z = c.find() current thing
            # then want a %laReal=Z after the first Z, 
            # c.like() extra Z check
            c.t ||= "wokesince"
            c.pur ||= {pur:c.t}
            c.k ||= 'Z'
            c.kb ||= c.k+'b'
            
            su(c.t,{c,once:&zaa,jaa,ha,ar{
                $Z = c.find(R)
                
                ha('rec:once,arg',hashkv(c.kb,Z))
                
                c.start and c.start(Z)
                
                $et = c.t+'-start'
                isnode(Z)
                    ? me&wants,R,et,Z
                    : me&elvis,R,et,{wake:Z}
            }})
            &&
            su('since',{perm:&zaa,jaa,ha,ar{
                $Zb = ar[c.kb]
                !Zb and debugger
                $wa = t => ha({pur:t,wait:1})
                
                # last|first since, a finished one
                $since = {}
                since[c.first ? 'first' : 'last'] = 1
                $Z = me&wokesince,R,Zb,since
                
                !Z and wa("!Z")
                # get the curret one
                $Zn = c.find(R)
                Z == Zn and wa("Znow")
                !since.all.includes(Zn) and wa("dontseeZn")
                if (c.like && !jaa('wait').length) {
                    !c.like(Z) and wa("Z!like"); me&nu,"!like:"+Z
                }
                
                jaa('wait').length and return
                #me&nu,"Since",since
                
                hak(jaa('pur')) and me&zu,"laReal",Z
                else {
                    # redefine Z to the latest woke,
                    #  c.perm() always starts with the Zb from c.once
                    ha('rec,arg',hashkv(c.k,Z))
                }
            }})
            return su()
        }
        
        me.SupesavingGens = &acgtRsc,su{
            $abutton = &ty{
                $auto = ahsk(c,'auto',t)
                auto and ~>4 auto: t
                auto and y (); delete T.wake; y = &{}
                $n = me&ty,t+'?' (y)
                auto and ns&bri = 1.6
            }
            $if_state = &zaa,jaa,ha,Z,n{
                me&Zifsum,n
                if (ns&Amountto == 2) {
                    # is about to come back?
                    return ha('pur:ispushing')
                }
                $ignore = theone(jaa('rec:resol,ignore'))
                ignore and return me&tc,"ignore"
                
                # probably because it hasn't already pushed
                # < detect need to pull?
                # < easier want to pull to reset things:
                #   avoiding pull W, reself + dup node errors,
                #    then pushing mem, then reset
                #   if mem versioned for a while we could
                #    pull W, push mem auto
                #   then reset or reself
                #   this is why haul?
                abutton('haul',&{
                    # hard pull There -> mem & reset
                    me&Zaving_haul,n
                    # will try to wake after this, but reset
                })

                me&tc,'or',6

                abutton('push',&{
                    # hard pull There -> mem & reset
                    ns&reallyWantsto = 'push'
                    me&elvis,R,'reallyWantsto',{wake:Z}
                    T.wake = 'not'
                })
                
                me&tc,'or',6
                
                abutton('ignore',&{
                    # you can probably just keep staging changes
                    # < easier getting signals back to this ...$sute/ignore
                    # < dodging ha-indexing
                    ~>5 Gotignoring: 1
                    purs&wantsabutton = 'ignore'
                })
                $purb = theone(zaa('pur:push?'))
                if (purb && purbs&wantsabutton == 'ignore') {
                    me&tc,'ignoring...','y'
                    ignore = ha('rec:resol,ignore')
                    
                }
                !ignore and $pur = ha('pur:push?')
            }
            # for each Z%Zaving/n%Zave
            su('savingGens',{until:&zaa,jaa,ha,ar{
                $Z = ar.Z
                $Zb = ar.Zb
                # < %%eph that become c&drop @Doming7
                
                Rs&wakeful = 1
                each tn Zs&Zaving {
                    De and me&tc,"\n"
                    me&tsc,"t",t,'b'
                    !ns&Zave and debugger
                    #me&nu,"Zave:"+t,n
                    
                    # %Here=R%Ying now, %Described=R%Ying%string
                    $De = ns&Described
                    #me&nu,"De:"+t,De
                    # < want to see when Z%Here==Z%Described, when it encodes
                    #   and that Zb < encZ <? Z, < meaning time-before
                    #   and that eventually %Settled=De%dige
                    
                    $ting = ns&Saveting
                    $Q = tings&Q
                    $P = Qs&P
                    
                    !Ps&string && Pc&el != 9 and debugger
                    $equal = De && Des&string == Ps&string
                    equal and me&tc,"=="
                    
                    $q = sex({},n.sc,'Unsure,Settled,Amountto',1)
                    # < K resolves tings
                    $stir = s => s && ss&string ? dig(ss&string) : "?"
                    $more = ex({
                        Here: stir(De),
                        There: stir(P),
                    },q)
                    #me&nu,"Ksc",more
                    delete q.Settled
                    delete q.Unsure
                    $state = joint(haks(q))
                    ns&summary && !state and ha('pur:summary!state')
                    !equal && !state and ha('pur:!eq!state')
                    
                    state and if_state(zaa,jaa,ha,Z,n)
                }
            }})
            return su()
        }
       
  // &supetime etc
       
       // &supetime
        # a process %%supe=$k
        #  has steps %%sute=$t,supe,dome=$k-$t,...
        me.supetime = &acgtRk{
          
          // 1 supe
            $supen = me&tcl,k+':','B'
            supens&dis = 5
            me&walls,supen,'b:3.2h2'
            Rs&Superpost = 1
            me&ty,supen,'reset?' (&{
                me&jaa,R,{supe:k} .map(n => nc&drop = 1)
            })
            
            
            # pseudo-lexicals, picking up %%arg,Z -> ar.Z
            $ar = {}
            # < when jaa is jaa (is zaa when not tried)
            #    suppose undef these should wait to become real?
            $argon = &jaa,{
                jaa('arg') .map(&n{
                    sex(ar, n.sc, ksaf(n.sc,{aft:'arg'}))
                })
            }
            # simple remarks, visible forever (if %%rec or etc)
            $sayables = &jaa,talk{
                jaa('sayable') .map(&n{
                    $q = sex({}, n.sc, ksaf(n.sc,{aft:'sayable'}))
                    $qs = G&depeel,q
                    me&tc,talk,qs,'y'
                })
                
            }
            
            $faulty = 0
            $sutes = []
            $talkat = &m{
                return &tc{
                    t == null and return m
                    t = me&mtsc,m,t,0,defor(c,'g')
                    ts&ma = 0.3
                    return t || m
                }
            }
            return &tc{
                t == 'done' and t = null
                # su() checks still ok, like su(...)
                t == null and return !faulty
                
          // 2   sute
                $inq = {supe:k,sute:t}
                $inc = c => ex(ex({},inq),peel(c))
                $dome = inq.supe+'-'+inq.sute
                # see|input to %sute=$t...
                # zaa,jaa meaning recycled or not
                #  both &jaa underneath, %%dome reentered every time
                #  jaa(c,i=1) selects either
                #   weird - usu one column mode (see &bracko)
                $zaa = c => me&jaa,R,inc(c) .filter(n => nc&recycled)
                $jaa = (c,i) => me&jaa,R,inc(c) .filter(n => !nc&recycled || i)
                $ha = (c,s) => me&ha,R,ex({dome},inc(c)),{},s
                
                $talk = me&mtsc,supen,'sute:'+t,0,'1'
                me&walls,talk,'b:1.2h2'
                me&tcl,talk,inq.sute,'T'
                $ta = talkat(talk)
                # label container, next to the heading
                $talklabel = ta('labelspace','s')
                $tal = talkat(talklabel)
                
                # make c into a sute object...
                ex(c,inq)
                ex(c,{zaa,jaa,ha,ta,ar})
                T.sute = c
                sutes.push(c)
                
          // 3 when
                # < make this %%pre,
                #    &diagno for a %%supe,sute
                $tried = zaa('tried')[0]
                $complete = tried && !hak(zaa('pur'))
                $finished = hak(zaa('finished'))
                finished && !complete and debugger
                finished && !tried and debugger
                $q = c.c
                #q && !finished && q.finish and me&tc,"Yarlbeback"
                if (c.finishline && !tried) {
                    # < do this when $supe is all done, and stays done...
                    #   dont know: su(...) calls might keep happening
                    # earlier sutes are finished, stop c.perm, stay ok
                    
                    # super (eg &SuperGens)
                    #   calls &supetime, own $supe
                    # suter (eg &Supewokesince)
                    #   asserts su(...)+, own each $sute
                    # q instructs suter,
                    #  mostly for itself,
                    #   to api their sute codes
                    #  yet we can see eg q.finish()
                    # c instructs sute,
                    #  c.finishline shall cause:
                    #   earlier q.finish() to happen (once)
                    #   no more c.perm()
                    #   etc
                    # q.finish means this $sute has something to do later
                    
                    sutes.map(&sute,{
                        sute == c and return
                        hak(sute.jaa('finished',1)) and return
                        # also, if multiple finishlines before jaa->zaa:
                        sute.finished and return
                        
                        sute.ha('rec:finishline,finished,el2')
                        sute.finished = 1
                        $care = 0
                        sute.perm and care = 1
                        # c.c == &Supewokesince,c:q
                        $q = sute.c
                        if (q) {
                            q.k and $Z = ar[q.k]
                            q.finish and q.finish(Z); care = 1
                        }
                        # note only if something seemed to matter
                        care and sute.ta("finished",'y')
                    })
                }
                # if a later
                if (complete && (!c.perm || finished)) {
                    ta("ok\n")
                    talks&bri = 0.6
                    # pickup ar from old time
                    argon(zaa)
                    sayables(zaa,talk)
                    if (c.permasay) {
                        $n = theone(zaa('figure_container'))
                        !n and ta("!permasay",'q')
                        else me&cloneinto,talk,ns&figure_container
                    }
                    return 1
                }
                
          // 6 doing it
                $doing = &k{
                    $y = c[k]
                    !y and return
                    y (zaa,jaa,ha,ar)
                }
                # all other modulat already in talk
                $capture = me&Mwcap,R,dome,talk
                if (c.once) {
                    if (!tried) {
                        doing('once')
                        argon(jaa)
                    }
                    else {
                        # pickup ar from old time
                        argon(zaa)
                    }
                }
                !complete and doing('until')
                doing('perm')
                capture(&{
                    # figure container
                    $m = ta('figure','s1')
                    delete mc&s
                    ms&dis = 1
                    c.permasay and ha({figure_container:m})
                    return m
                })
                
          // 7 tried
                tried = (tried && trieds&tried||0)+1
                ha({tried})
                
                # %%rec... are permanent, remain while going faulty
                #  per %%supe,sute,rec
                #   so the value of %%rec works like a %%dome
                # < dome within dome
                zaa('rec')
                    .filter(&n{
                        $hasnew = hak(jaa({rec:ns&rec})
                            .filter(n => !nc&recycled)
                        )
                        return !hasnew
                    })
                    .map(n => ha(n.sc))
                # pickup %%arg from new time, + any %%rec,arg
                argon(jaa)
                sayables(jaa,talk)
                
                $faults = jaa('pur')
                $success = !hak(faults)
                if (success) {
                    tal("ok"+(c.perm?"...":""))
                    ha("ok")
                    # in case the next sutes select from this one via jaa(c,1),
                    #  what would be in zaa(c) drops, to be as jaa(c)
                    me&dome_traction,R,dome,{el:2}
                    return 1
                }
                else {
                    me&walls,talk,'b:1.2h6'
                    $fa = ta('faultspace','s1')
                    $ta = talkat(fa)
                    # group by %%pur
                    $h = vpartN(faults,n => ns&pur)
                    each iN h.vs {
                        $n = N[0]
                        !isst(ns&pur) and debugger
                        
                        $l = me&tcl,fa,ns&pur,'1B'
                        #$l = ta(ns&pur+": ",'1')
                        each in N {
                            $se = sex({}, n.sc, ksaf(n.sc,{aft:'pur'}))
                            se = hak(se) ? dis(se) : "..."
                            me&mtsc,l,se,0,6
                        }
                        1 <= i and me&ioty,l .map(&m{ ms&dis = 1 })
                        # < why no Display when se+"\n"?:
                        #ta(se,6)
                        
                        # also, respond a bit...
                        # < joining &diagno, or without T.diagno,
                        #    making one just for this context 
                        ns&wait == 1 and me&waits,joint([dome,ns&pur])
                        else
                        ns&wait and debugger
                    }
                    tal("."+tried,6)
                    # < ...
                    faulty = 1
                }
            }
        }
       
  // funcs
      // Superfuncs
       // f
        # prep row per call to &Superquiet etc
        me.superclasspile = &acgtqck{
            # name or seq per sute
            c.t ||= hak(q.jaa(k))+1
            # what we will write once etc
            c.c = {}
            # %%Superarg=firstkey
            c.c[k] = c.t
            c.t = k+':'+c.t
        }
        # for c=%%Superarg,fail, make %%pur
        me.purforate = &acgtc{
            $h = T.sute
            c = peel(c)
            $k = haks(c)[0]
            h.jaa(c) .map(&n{
                # %%pur=Superarg,k=whichone
                # nothing else is allowed to say %%Superarg (exclusive gk)
                # < understand %%Superfunc=arg, brackology to position
                $c = {pur:k,k:n.sc[k]}
                # + anything to add for %%pur, eg %%pre=node
                $cbt = k+'_purfor'
                me[cbt] and me&mearg,cbt,[n,c]
                h.ha(c)
            })
        }
       // ready quiets waits
        # return true if you should wait (and return)
        
        # detect readiness, fatalise mild oddnesses
        # < really pur-veys mild oddnesses,
        #   fatalising resets more?
        # at sute completion we !%%pur
        me.Superready = &acgt{
            $h = T.sute
            # make %%pur for only mild oddnesses
            me&purforate,'Superarg,fail'
            me&purforate,'Superquiets,Pending'
            return hak(h.jaa('pur'))
        }
        # waits for the next quiet
        #  adds t
        # < notice if no activity since asserted
        me.Superquiets = &acgtRc{
            c ||= {}
            $q = T.sute
            # c.t ||= name or seq per sute
            # ends up %%Superquiets:c.t,
            me&superclasspile,q,c,'Superquiets'
            # try
            c.until_next = Rs&is_quiet
            $ok = !me&Superwaits,R,c
            if (ok) {
                q.ha(c.c)
                return 0
            }
            # until, give cause to quiet_wake
            q.ha(c.c,{Pending:1})
            return 1
        }
        # waits for (a later)? perception of true
        me.Superwaits = &acgtRc{
            $q = T.sute
            $past = {Superwaitsed:c.t}
            $present = {Superwaitsing:c.t}
            $ok = hak(q.zaa(past)) || c.until
                || c.until_next && hak(q.zaa(present))
            if (ok) {
                q.ha(past)
                return 0
            }
            q.ha(present)
            return 1
        }
     // f
       
       // &diagno, &receivan, &zaone, theone() when to what why
        # responds to each q=(%%fault),... once
        #  and return true if we haven't tried t:fix
        # restated on &diagno, not domed. re-fix also if none.
        # < improvement in some faults makes others re-fix?
        me.diagno = &acgtqt{
            $R = Cy&R
            q = peel(q)
            $k = haks(q)[0]
            $faults = me&ja,R,q
            !faults and return []
            # restate %%diagno:k,... every time,
            #  until none, then reappearing faults re-fix
            me&zaa,R,{diagno:k} .map(n => me&ha,R,n )
            # each fault once
            $fixable = faults.filter(n => !me&ja,R,ex({diagno:k},n.sc) )
            if (hak(fixable)) {
                fixable.filter(n => me&ha,R,n,{},{diagno:k} )
                return fixable
            }
            me&tc,"diagno:"+k+"%ataloss"
            return []
        }
        # for receiving one thing once, true if waiting
        # < for multiples
        me.receivan = &acgtqc{
            $R = Cy&R
            $say = isst(q) ? q : joint(haks(q))
            $k = isst(q) ? q : haks(q)[0]
            $oldk = 'old'+k
            
            # supposed to receive something, or fail
            $e = theone( me&jaa,R,q,1 ,say)
            if (!e) {
                if (T.sute) {
                    # channel to &supetime
                    T.sute.ha({pre:'%%'+k})
                }
                else {
                    # look like &supetime would
                    me&tsc,k+"..."
                    me&ha,R,{pre:k,receivan:1}
                }
                return 0
            }
            
            # put %%old$k:$e when it changes
            $be = theone( me&zaa,R,q,1 ,'had-'+say)
            be && be != e and me&ha,R,hashkv(oldk,be),{},{dome:oldk}
            theone( me&jaa,R,oldk,1 ) and me&tsc,"has("+oldk+")",0,'g'
            
            return e
        }
        me.zaone = &acgtRq{
            $k = haks(q)[0]
            return theone( me&zaa,R,q ,R.t+'%%'+k )
        }
        # < the enclosing line is more important to display
        window.theone = &Nk{
            !N and return
            !isar(N) and throw "theone "+k+" !isar: "+ki(N,2)
            N.length <= 1 and return N[0]
            k ||= ''
            throw "theone "+k+" is "+N.length
        }
       
       // &lock
        # add e to lockedness of k
        me.lock = &acgtzke{
            ah(z,['y'],'lock',k,e)
        }
        # if any for a k
        me.locked = &acgtzk{
            $R = Cy&R
            $N = ahsk(z,'y','lock',k)
            !hak(N) and return 0
            N.map(by => me&ha,R,{locked:k,by},{} )
            return me&ty,"(locked)" (&{ delete zy&lock[k] })
            return 1
        }
        me.unlock = &acgtzke{
            $N = ahsk(z,'y','lock',k)
            hak(N) and grepout(N,e)
            # < el9-ing, path-tidying
            if (!hak(N)) {
                $lock = zy&lock
                lock and delete lock[k]
            }
        }
        
       // Zifsum(s), etc
        # < -head a -zif
        me.Zifsum = &acgtr{
            $sum = rs&summary
            if (sum) {
                $su = me&tc,'Zifsum','s6'
                me&cloneinto,su,sum
            }
            else {
                me&tc,'!sum',6
            }
        }
        me.cloneinto = &acgtmn{
            i $m/@sum/** y o $n:sum/**
        }
    },
  
  // 8 @Gwatch things happen
    ['Gwatch',0.6,&acgtRs{
        $x = me&Jx,R
        $la = me&ioty,xs&Gomes [0]
        !la and return
        la = lay&R
        #la = las&wou.y.R
        x.ro('●') and ss&from = la; delete ss&lives
        if (ss&from && x.ro('◼')) {
            $since = {all:1}
            me&wokesince,R,ss&from,since
            ss&lives = since.all
        }
        !ss&lives and return
        me&nu,'lives',ss&lives
        
        me&ha,R,{layout:1,mostly:'icount'}
        me&ha,R,{layout:1,also:'etc'}
        $x = me&columns,R
        
        $la = null
        $lar = null
        each ir ss&lives {
            # clone r since y&arow = xs&row
            xy&arow(Cye(r),'icount')
            $N = me&bracko,R,rs&wou,{sute:'since'}
            $D = ry&Dsix = me&bracksix,rs&icount,N
            
            $se = xy&cean('etc')
            rc&b != lar and me&tc,se,"^!"
            $six = Dy&six
            # displays
            #ac(se,'z', me&yology,Dy&six )
            me&pibrackology,R,D,{D,se}
            me&mnu,se,r
            ac(se,'z', me&yology,Dy&brackology )
            #me&sixing,R,{D,se}
            
            $diffc = {}
            diffc.se = se
            #ope != null and diffc.dont = 1
            #$di = me&diffany,R,D,la,diffc
            
            xy&arowed()
            la = D
            lar = r
            #xy&arowgrouped()
        }
        
        # ▶+◼
    },'ift,D'],
    &{
        # convert noise to D%string/-row/-vat
        me.bracksix = &acgttN{
            $D = Cye([t,1])
            Ds&z = me&ioty,N
            #  creating on this D:brack means no history
            $sev = me&pisix,R,D,{D}
            !Ds&string || !Ds&dige and debugger
            return D
        }
                
    },
     
// %Teoptic - customise -eight etc
    # see configure to Te/togcon/$p-ology/$n
    # < -group* like io.ind, columns from $p.split(/\b/)
    #   these things split by -0
    # < of hoisting parts upward:
    #   to configure a view to carry onward,
    #   then unset after a while?
    #   it is &t wanting to know where $Q is
    #    in frozen time, in the case of This/*
    
    
    
    
    
    
    
    
    
    
    
    
    ['Teoptic',0.88,&acgtRs{
        me&reaw,R,'Teoptic'
        Rs&sleeping and return
        $x = me&Jx,R
        !x.ro('Te',{}) and return
        
        $Te = me&theTe,R
        me&nu,"Tee",Te
    },'ift,D,sleeping'],
  
// Travel/$t may /%SummerCat
    ['Travels',0.39,&acgtRs{
        # < wants to cautiously inode while adhere-ing,
        #   to see if we set up:
        Rs&twmt_only = &jz{
            return zs&W || 1
        };
        me&ha,R,"Travels,to:Morrocco";
    },'ift,D'],
    
    &{
        # for Tr%%Go.../->$Go:t
        me.balforward = &acgtRqc,balc{
            c ||= {}
            q = peel(q)
            $s = Rc&s
            me&jaa,R,q .map(&n{
                # usu t=%%Go, if q='Go'
                $t = c.t != null ? c.t
                    : c.namer ? c.namer(n)
                    : n.sc[haks(q)[0]]
                $z = me&fiu,s,t,8
                z ||= me&bal,t,balc .c.s
                zy&path ? me&nodei,R,z,n : me&waits,"node.."
            })
        }
    },
    # < a process similar to Travel itself,
    #   acty:3 saving a W
    # Travel
    ['Travelables',0.297,&acgtRs{
        me&reaw,R,'bal_tw_s'
        me&bin,'Travelable'
        me&balforward,R,'Go',{},'eph'
    },'ift,D'],
    # Travel/$t(%play?%SummerCat)
    ['Travelable',0.2971,&acgtRs{
        me&reaw,R,'bal_tw_s'
        me&inode,R
        Rs&stopsadhere = 1
        #ah(R,'noadhere','twmt',1)
        $x = me&Jx,R
        
        Rs&Gorows = me&balreadyGorows,R,x
        !Rs&Gorows and return
        # %eph while %%Go-created, up permanence:
        me&supsphere,s,x
    },'ift,D'],
    &{
        # for Tr%%Go.../->$Go:t
        me.balreadyGorows = &acgtRx{
            $s = Rc&s
            $N = me&ja,R,'Go'
            if (!N && !Rs&play) {
                # < GONER, before it was $t/$tid it was $t
                Rs&SummerCat and debugger
                delete Rs&SummerCat
                Rs&Shouldbeempty = 1
                return
            }
            if (Rs&play) {
                # enliven wild $t with R%play: shift-click
                if (xc&Gump) {
                    # R%play -> %%Goable -> @Gump/@Goting
                    $q = {Goable:s.t,mot:1}
                    # gets a $tid, returns as %%Go
                    $Gu = xc&Gump
                    $Got = Gu && me&ioty,Gu,'Goting' [0]
                    Got and me&nodei,R,Got,q
                    else me&waits,"$tid..."
                    !N and me&tc,"$tid.."; return
                }
                else {
                    # need something that */Run
                    me&tc,"%play-how?"; return
                }
            }
            return N || [Cye(['dunno',1])]
        }
    },
    ['Travelable+Gorows',0.2972,&acgtRs{
        each in Rs&Gorows {
            $tid = ns&tid
            $c = {eph:1}
            $Catfunc = ns&Catfunc || "SummerCat"
            c[Catfunc] = 1
            $r = me&bal,"v"+(tid||'0'),c
            rc&s.y.Gorow = n
        }
    },'ift,D'],
    &{
        # %%Cat introduces itself, waits for %%Control
        me.haveGorowgetControl = &acgtRst{
            # must Gorow
            $n = sy&Gorow
            !n and return me&tc,"caut!Gorow"
            # may Gome-Control, must if t%Con
            if (ns&Gome || ts&Con) {
                !ns&Gome and return me&tc,"Gorow!Gome"
                # give our @Gome a chance to configure $SC
                me&nodei,R,ns&Gome,{Travelable:t,Cat:s,n}
                # reply
                me&ja,R,{Control:1,efrom:ns&Gome} and return 0
                else return me&tc,"Gome->%%Control..."
            }
        }
        # if s looks cloned from z
        #  eg z=%%Go returning as s=%%Cat,...,n=z%%Go
        # < could swim z%%n or zy&up=...s
        me.etoward = &acgtsz{
            !isC(s) and return 0
            # s%%Go...Gome,Catfunc,etc may have come along
            $c = sex({},s.sc,haks(z.sc))
            # should have %%Go,tid
            return heq(c,z.sc)
        }
    },
    
    
    
    # noise
    ['Travelty',0.39,&acgtRs{
        $x = me&Jx,R
        me&ha,R,"Travels,to:everywhere",{R};
        #!me&za,R,'fodder' ? me&ha,R,'fodder,lamp' : me&ha,R,'lamp'
        
        me&ha,R,"Travels,to:everywhere",{R};
        $le = me&zaa,R,"Travels",'to';
        
        if (xs&Duolish) {
            # sends %pat as %%pat
            $pat = ss&pat ||= 'ology';
            me&nodei,R,xs&Duolish,{pat};
            me&nodei,R,xs&Duolish,{pat:'ex'};
            # returns %%raga
            me&jaa,R,{efrom:xs&Duolish,raga:1} .map(&n{
                le.push(ns&raga)
            })
        }
        
        if (xs&Ligno) {
            # sends
            me&ioty,s .map(z => me&nodei,R,z,{terspesia:"^"} )
            me&nodei,R,xs&Ligno,{terspesia:"^"}
        }
        
        each in le {
            n = me&tsc,"land",n,'G';
            ns&dis = 1;
            ns&fs = 33;
            
            ns&hue = i*40;
            ns&blr = 9;
        }
    },'ift,D'],

// Duolish push <- Travel
   // %Duolish
   # finished Travels commit
    ['Duolish',0.303,&acgtRs{
        # unrelated
        me&jaa,R,"efrom,pat" .map(&n{
            $q = {};
            q.raga = ns&pat.split('').join('_');
            me&nodei,R,ns&efrom,q
        })
        # Travel/* forwards finisheds it to worriment device
        me&jaa,R,"e" .map(&n{
            $e = ns&e
            $f = ns&efrom
            $S = fy&path[0]
            ey&participant = Sy&p
            $SC = ey&runtime
            $Gorow = SCy&Gorow
            $fullname = Gorow && Gorows&Gome && Gorows&Gome.t || e.t
            $r = me&bal,"Du:"+fullname,'Duolisher,eph'
            $z = rc&s
            zy&Duolic = e
        })
    },'ift,D'],
    ['Duolisher',0.303,&acgtRs{
        me&reaw,R,'Releasor'
        $S = me&inode,R
        
        $e = sy&Duolic
        me&bal,"Re:"+e.t,e,'Releasor,MayGhost,eph'
    },'ift,D'],
 
 # < de y&p %twin
   // %Releasor
    =pod see %Compiling
      a %Compiling in its push-phase,
       can decide to redo, because CBing, already
    
     Travel%%tw=$t should match:
     Ghost%twin/$t, giving (/of/$kt)
     Know%%tw=$kt same in reverse
     # on the inside of the join:
      Ghost..$t may know %%tw,s,host=Travel|Know already
     # on the outsides:
     Travel|Know p are %twinned by Ghost,
      Ghost providing queries from their perspective
       on Ghost p %structure, [C:t,C:of,C:t]
     
     Then we should end up with...
     < sheets of $t..$kt to apply to the joins:
       u towards Know:
        should still be that version
       n towards That:
        
       
     < other Ghost..$z joining Know..$kt etc,
       all have a %dige on Ghost..z, not:
       must have their truth shrunk onto the join,
       since we are replacing the shared record of something
       this is like getting pinned at a version, 
     < some even more complex Zave-tuition
    =cut 
    ['Releasor','298',&acgtRs{
        me&reaw,R,'Releasor'
        $S = me&inode,R
        # to %ball/* from y&tw over s&z
        Rs&childy = 'tw'
        # Travel is %twinned to other steps
        $p = sy&participant
        # Travel/$t == sy&client (the experience)
        py&s != sy&client.y.up and throw "parts!client"
        !p and throw "nop"
        #$tr = Ry&up;
        #tr = trc&s;
        # < stop using y&p
        #$p = try&p;
        #!p || tr.t != 'Duolish' and throw "Travel?"
        
        # s was e, replaced on shunt
        # is the reality (Re:$t), beside the thing itself ($t)
        $SC = sy&runtime
        $Gorow = SCy&Gorow
        if (Gorow && Gorows&Gome) {
            me&nodei,R,Gorows&Gome,{Releasor:s}
        }
        
     // func
      # < io this easy
      // y&Q leavers
        # $Steu/of(/args)?/t -> callback
        me.ofargsity = &acgt,Steu{
            return &y{
            me&indo,Steu (&sd{
                d.d <3 and return 's/of'
                $more = me&ioty,s .length
                more and return 'is an /args/ layer'
                $l = me.cby(d,&d{ return d.d <3 }).map(d => d.s);
                $t = l.pop();
                t != s and throw "confu";
                $of = l.shift();
                $args = l[0];
                # may not have args
                y (of,args,t)
            });
            }
        }
        # warn of args: $Steu/of(/args)?/t -> $f/of(/args)?/t
        # < for stretching %twin to support anyindex
        me.warn_argsity_of = &acgtWf{
            # W is the of column, nest it
            $cont = Cye(['eachofalone',1])
            me&fiu,cont,W;
            # warn of non of/t pushing (or whatever the %twin wants)
            me&ofargsity,cont (&of,args,t{
                $fo = me&fiu,f,of.t;
                args and fo = me&fiu,fo,args.t; ah(fo,'warn',"args-layer",1)
                $to = me&fiu,fo,t.t;
                args and me&zu,"hasArgs:",to
                toy&Q = t;
            })
        }
        # ac args: $Steu/of(/args)?/t -> $f/of/t%args[]
        # for writing as W.5
        me.Stearchish_to_twin = &acgt,Steu,f{
            $N = [];
            me&ofargsity,Steu (&of,args,t{
                $fo = me&fiu,f,of.t;
                $to = me&fiu,fo,t.t;
                tos&dige && tos&dige != ts&dige and throw "multiple diges ->"+to.t, t, toy&Q
                toy&Q = t;
                tos&dige = ts&dige;
                args and ac(to,'args',args.t)
                N.push(to)
            });
            return N
        }
        me.Stegroup_species = &acgtW,Steg{
            # sublate any species (share one $kt)
            #  $m:Dealap,$n:Dealap/js -> $m:Dealap/$n:js
            # < order by length of SteW/*.t, hier not fair
            $c = {yorigin:'Q',
                match:&mn{ return n.t.startsWith(m.t) },
                then:&mng{ 
                    g.t = gs&species = n.t.substr(m.t.length+1);
                    g.t && !g.t.includes('/') and 'ok'
                    else {
                        throw "species!grouping", m, n
                    }
                }
            };
            me&sublatile,W,Steg,c;
        }
      
      // y&origin leavers
        # rebuild and replace? $n/#$t
        me.Stereo = &acgtWt{
            !isC(W) and throw "!C W"
            W = Wy&origin || W;
            $eg = Cye(W);
            # to somewhere else
            isC(t) and $F = t
            else {
                # replacing
                $F = Wy&up;
                !F and throw "W!up"
                # ~t adding
                isst(t) and eg.t = t
                
            }
            egy&origin = W;
            return &y{
                y (W,eg);
                # places new thing
                !F and return
                $f = me&fiu,F,eg,8
                f && f != W && fy&origin != W and throw "knot sure", F, eg, f
                F and me&fiu,F,eg
            }
        }
        # regroup into each other
        me.sublatile = &acgtWtc{
            $into = t;
            c.yorigin ||= 'origin';
            me&ioty,W .map(&n{
                $g = Cye([n.t,2]);
                g.y [c.yorigin] = n;
                each im intos&z {
                    m == n || !c.match(m,n) and continue
                    c.then(m,n,g);
                    me&fiu,m,g
                    return
                }
                me&fiu,into,g
            })
        }
        
     // dunketha
      // outputs + 5 -> twin-form
        # have outputs
        $Sten = me&fiu,s,'n';
        $Steu = me&fiu,s,'u';
        
        # to output, nego into %twin
        $twine = me&fiu,s,'twine';
        # z first, leading up
        ss&z = arou(ss&z,z => z == twine,[]);
        ss&z.unshift(twine);
        
        # n
        $twn = me&fiu,twine,'n';
        # < various use cases for a wait-for-ok
        !me&fiu,Sten,'W' and return me&waits,"!W"
        
        me&ioty,Sten .map(&W{
            me&Stereo,W,twn (&W,eg{
            # schematic of what Q to place where
            $Steg = Cye(['g',1])
            
            if (W.t == 'W') {
                # make a pile of W%dige/[species%dige+]
                me&Stegroup_species,W,Steg;
        
                # each W make W.5 re this u/n configuration
                # make W.5 for each W grouping
                me&ioty,Steg .map(&m{
                    $f = Cye([m.t,9]);
                    # the 5.sc[$species] = dige, inc 1=Ws&dige
                    $spec = {1:m};
                    me&ioty,m .map(n => spec[n.t] = n);
                    each tn spec {
                        # the SteW/* is Qish: Q%string%dige without %of%args
                        #  which are implied by their placement in the Searchish
                        $Q = ny&Q;
                        f.sc[t] = Qs&dige
                    }
                    # re this u, flattening args
                    # < of:wjs -> of:w through the join?
                    #   see W|w: their species pool dige sensitivity
                    me&Stearchish_to_twin,Steu,f;
                    # f -> Qish q
                    $q = Cye(['5',2]);
                    qs&string = me&Lineso,f;
                    qs&dige = dig(qs&string);
                    # species thing fronting q as a writable of $W
                    me&fiu,m,q.t,8 and throw "already had a W.5", m
                    # into the Qish pile we began with
                    $n = me&fiu,m,q.t;
                    ny&Q = q;
                })
            }
            else {
                # copy anyway!
                me&warn_argsity_of,W,Steg;
            }
            
            # n... have %string etc from y&Q
            #  Steg structure y&Q -> g
            #  for something %%twin->Paving compatible re %species
            #  all other $of should just work?
            # < io resolving to y&Q, type checking
            me&indo,Steg (&sd{
                d.d <2 and return
                $p = d.la || eg;
                $v = sy&Q;
                !vs&dige and throw "notdiged",s,v
                v = d.la = Cye(v);
                # < doesn't keep the 
                vy&Steg = s;
                # t=$W/js -> js
                v.t = s.t;
                me&fiu,p,d.la
            });
            })
        })
        
        # n/W is now folded like %twin of/t
        #  with extra n/W/$species for Pave to realise exactly
        # checks others dont /args/
        # < %twin should learn anyindex:
        
        # < only for of:wjs?
        #   you might want the %twin|%Paving indexing to carry the args
        #   eg for watching lists,
        #    or anything but W|w which pool one big dige per thing
        # so in the .5 we know individual args,
        #  so reruns can more fully prepare eg of:wjs
        # yet for overall versioning,
        #  w:$t%dige is all Ghost/Know remembers
        #  will cover wjs:$t%dige(same)%args
        # W%dige covers W.js etc but not W.5,
        #  but W.5%dige covers W+W.js
        # < a ghost/w/wjs have the same %dige?
        
        # fold up all the u:
        # < wjs->w?
        # u... only have %dige etc (not even %args?)
        $twu = me&fiu,twine,'u';
        me&Stearchish_to_twin,Steu,twu .map(&to,{
            # drop deindexed info
            delete tos&args;
        })
      // outputs -> twin-linkage
        # looks for u/n stores behind/ahead of Travel
        # < complicated ideas
        
        # made a 5 about this s, added to itself,
        # added to n, to push via %twin
        #   W:Dealap will be a single yonder,
        #    though while this awake the 5 + js may update
        #   then Fingo should save asap
        
        each in ps&twinned {
            # < find t there, make &acty=3
            ns&remotes[0] != p and throw "aban"
            $r = ns&remotes[1];
            $h = r.t == 'Know' ? twu :
                r.t == 'That' ? twn : 0
            !h and throw "unremote", n, r;
            # for %MayGansp
            hy&release = s
            # Travely&p
            hy&host = p
            # Ghosty&pc&s
            hy&twin = ny&s
            # Knowy&p
            hy&remote = r
        }
    },'ift,D'],
   
   // Releasor/%MayGansp/%MayTwine+
    &{
    me.deboost = &acgt{
        $R = Cy&R;
        # < Babz: //= # !null-or
        Rs&boost == null and Rs&boost = -1
    }
    
    me.bin = &acgtk{
        $R = Cy&R;
        k ||= T.act.t
        isst(k) and k = G&peel,k;
        each tv k {
            ah(R,'inheritscif','ball',t,v)
        }
    }
    },
    ['sleeping+wou_accepted','297',&acgtRs{
        # %wou must be there to access _accepted
        # < why w_a if no w when tunneling?
        me&rollbs,R,'wou'
    },'ift,D'],
    ['MayGhost','298',&acgtRs{
        me&reaw,R,'MayGhost,eph';
        me&bin,'MayGhost';
        $l = me.cby(R,'^^Releasor').length;
        l == 2 and s.t == 'twine' ? me&bin,'MayGansp' : me&deboost
        
        l <2 and return
        (Rs&boost||0) < 0 and Rs&thiding = me&ioty,s .map(z=>z.t)
    },'ift,D'],
   
   
   // u|n%MayGansp - %twin find
    # %twin climb beings, to its idea of us
    ['MayGansp','298',&acgtRs{
    
        me&reaw,R,'MayGansp,eph';
        $S = me&inode,R;
        
        $g = me&case,34
        $twin = sy&twin;
        !twin and return me&mtsc,g,"!twin",'','g'
        gy&can('m','to').y.can('i',twin.t);
        me&bin,'MayTwine';
        
        $rs = sy&release;
        !rs and throw "!t->u/n bunch"
        !rsy&client and throw "release!client"
        # Ghost%%tw,host=from|yonder
        $host = sy&host;
        !host and throw "!join from"
        #hosty&s != sy&path[0] and throw "join from!this step", host, s
        # < %twin-like anyindex to anywhere
        $re = sy&remote;
        !re and throw "!remote host yonder"
        
        # < p only as Schema meta, make twin = s, sy&structure
        $tp = twiny&p;
        sy&structure = tps&structure;
        
        # Ghost%%tw=t.t,host=Travel
        $c = {
            q: {tw:rs.t},
            got: &n,t,zt{
                # %%found:Ghost/$zt, also found its Travel/$t
                # $n coming from Ghost%tw... has efrom=$zt, s=$t
                me&ha,R,{found:zt,t}
                $zt = ns&efrom;
                # which we remember from running it
                ns&s != rsy&client and throw "whose"
                # < $zt &settle $zt/*, so $zt/*/* changes ping
                me&settle,R,zt
            },
            not: &{
                # auto input Ghost/$zt
                #  this eto retracting when Ghost has it
                me&nodei,R,twin,{tw:rs.t,el:2}
            },
        }
        me&twin_nodeo,R,twin,host,c
        
        $st = me&ollbs,R,'brackstable'
        
        me&ha,R,{twin}
        # bump Ghost when s/** settle
        # < aux brack, so response to stable doesn't tailspin
        if (me&ollbs,R,'brackstable' == 1 && !sy&bumpedtwin) {
            me&ha,R,{waits:'heard',wants:twin}
            me&tsc,'bumpedtwin'
            sy&bumpedtwin = 1
        }
        me&tsc,"mg",'','d'
        
        #(Rs&boost||0) > 0 and me&zu,"MayGansp.s",s;
    },'ift,D'],
   
   // twin|tw nodeo
    &{
    # the _nodeo c.t make %%(found|yonder)=$s,via=$z
    me.nodeo_foundha = &acgtRcqn{
        $found = c.found
        !n && q.s and q[found] = delete q.s
        # < n.sc[c.k], returns what to iterate as $s
        q[found] ||= ns&s
        !q[found] and throw "foundrow !%%"+found
        me&ha,R,q
    }
    # nodeo but with a perspective on a %twin
    # < tysc args: this is c||,=t(c)
    me.twin_nodeo = &acgtR,twin,host,c{
        $q = c.q
        !q and throw "!c.q"
        $j = me&yfuture,twin
        # %MayGansp &settles j/$zt once found
        #  is too specific to &settle j|Ghost itself
        q.host ||= 1;
        $N = me&zaa,j,q
            # spec %%host gives us the %%inside (or not)
            .filter(n => ns&host.t == host.t)
        
        # can't handle many yonders...
        # < unless c.each()?
        N.length > 1 and debugger
        N.length > 1 and return me&waits,"many:"+twin.t+"->"+host.t
        # may be %%broken while setting up
        N.filter(n => ns&broken).length and return me&waits,"broken:"+twin.t+"..."+ki(q,2)+"->"+host.t
        
        N.map(&n{
            c.found and me&nodeo_foundha,R,c,{via:ns&efrom},n
            c.got and c.got (n,ns&s,ns&efrom)
        })
        !N.length and c.not()
    }
    # tw ^%%found -> %%found or %%almost,into
    # < is a spacer buildup for io
    # < &settle zp,z you might?
    # < tysc args: this is c||=t(c)
    me.tw_nodeo = &acgtRpsc{
        # p has %%found
        $zp = me&zaa,p,c.q||c.found,1 [0];
        zp && !zpy&R and zp = 0
        if (zp) {
            # to be put in $zp/$z
            $z = me&fiu,zp,s.t,8;
            !z and me&ha,R,{almost:c.t,into:zp}
        }
        # they must node init
        # < occasion to force %%wants?
        z && !zy&R and z = 0
        if (z) {
            me&nodeo_foundha,R,c,{s:z}
            c.got and c.got (z)
        }
        !z && zp && c.nearly and c.nearly(zp)
    }
   
   // &otwin, &elnodes
    # use a %twin join, given Know|Travel..s
    # finds Travel|Know..s
    # < gives paths and takes directions like &jaa
    me.otwin = &acgts{
        # Know..s, find Know%twinned = Ghost
        $S = sy&path[0];
        $p = Sy&p;
        $N = [];
        each in ps&twinned {
            $twin = ny&R
            # Ghost eto the index:
            #  %%s:Know..$s
            #  %%inside:Ghost/$a
            #  %%efrom=Ghost..$z that found Know%%tw,s
            # < use with host:$p if tw, needs a direction to go
            me&jaa,twin,{s} .map(&n{
                # Ghost/$a <-> Ghost..$z%%inside
                $q = ns&inside ? {efrom:ns&inside} : {inside:ns&efrom}
                #N.push(q)
                N.push( ... me&jaa,twin,q .map(n => ns&s) )
            })
        }
        return N
    }
    # same as above, finding $z
    #  eg Know..$K finds Ghost..$z and Travel..$t
    me.ootwin = &acgtK{
        return &per,{
            $S = Ky&path[0]
            $some = []
            # for all connected to Know (To)
            each ip Sy&twinned {
                $twin = py&R
                # look for To%%tw...s=K
                me&jaa,twin,{tw:1,s:K} .map(&n{
                    # go to the other side
                    #  Ghost/$a <-> Ghost..$z%%inside
                    $q = {tw:1}
                    $z = null
                    !ns&inside and q.inside = ns&efrom
                    else {
                        q.efrom = ns&inside
                        z = ns&efrom
                    }
                    me&jaa,twin,ex(q,{tw:1}) .map(&n{
                        $t = ns&s
                        # when K=Travel..$t, still select $z
                        z ||= ns&efrom
                        !z and throw "no Ghost..z"
                        some.push(per(t,z,K))
                    })
                    
                })
            }
            return some
        }
    }
    # Ghost..$z finds Ghost/$a
    #  also $a finds many $z
    # twinning: t (a z) K
    me.revtwin = &acgtz{
        $S = zy&path[0]
        $twin = Sy&R
        !twins&twin and throw "twin!%twin"
        $j = zy&R
        !js&twin and throw "z!%twin"
        # get the other side
        return &per,{
            $some = 0;
            
                # find ourselves to see if %%inside
                (me&za,twin,{tw:1,efrom:z}
                    || me&zaa,twin,{broken:1,efrom:z}
                ) .map(&n{
                    # go to the other side
                    #  Ghost/$a <-> Ghost..$z%%inside
                    $q = {}
                    # this side's target (not on %%broken)
                    $K = ns&s
                    !ns&inside and q.inside = ns&efrom
                    else {
                        q.efrom = ns&inside
                    }
                    (me&za,twin,ex({tw:1},q)
                        || me&zaa,twin,ex({broken:1},q)
                    ) .map(&n{
                        $a = ns&efrom
                        # not on %%broken
                        $t = ns&s
                        some = 1
                        # in order of unknownness
                        #  when $z=$a you $per=&Kzta{}
                        per(t,a,K,z)
                    })
                    
                })
                
            return some
        }
    }
    
    # nodein %%el,tw requets +|- $s/#$e
    # < get flowing
    me.elnodes = &acgts{
        $R = Cy&R;
        me&jaa,R,'el,tw,efrom' .map(&n{
            $t = ns&tw;
            $was = me&fiu,s,t,8;
            ns&el == 2 and me&fiu,s,t
            else
            ns&el == 9 and me&fiu,s,t,9
            else {
                # < waits takes params?
                return me&waits,"unknown-e"
            }
            $cha = ns&el == 2 && !was
                || ns&el == 9 && was;
            if (cha) {
                # if we are a step, dont %onlyish
                sy&p and Rs&numberclicked = 1;
                # < wake s to init n, only, so adhere etc
                #   wants a pointer to not yet node
                me&ha,R,{waits:'elnode',elnode:ns&el,wants:s}
                #me&Rsync,R;
            } 
            # < %twin them immediately
            # sender must &settle Ghost**
        })
    }
    
    },
   
   
   // %MayTwine - %twin climber
    ['MayTwine','298',&acgtRs{
        
        me&reaw,R,'MayTwine,eph,activy';
        me&bin,'MayTwine';
        $S = me&inode,R;
        $x = me&Jx,R;
        $ja = &c{ return me&ja,R,c };
        # n|u should have To|Ghost/$t
        $mg = me.cbu(R,'MayGansp');
        $ms = mgc&s;
        # some distance in
        $li = sy&path.indexOf(ms);
        li < 0 and throw "!^^MayGansp"
        $l = sy&path.slice(li);
        li = l.length-1;
        # we start beyond 0 (MayGansp's To|Ghost/$t)
        $h = msy&structure[li];
        # t/of/t/species is pushed but not remembered
        !h and me&ha,R,'extra'
        # a t/of/t, or any complete leg of index
        #  that we want to push a state to
        if (!msy&structure[li+1]) {
            me&ha,R,'thing'
            $all = msy&allthings ||= []
            !all.includes(s) and all.push(s)
        }
        
        # $ms (MayGansp) knows about the Ghost/** structure
        #   ms%%found:$sz
        # Travel/$t <-> Ghost/$sz..$z <-> Know..$K
        $K;
        
        # twin|tw_nodeo: p%%found=$zt|$z / #$s
        $p = Ry&up;
        $c = {
            found: 'found',
            got: &z{
                me&jaa,R,'found',1 [0] != z and debugger;
                # we are %%found=z
                $zj = zy&R;
                !zj and return me&waits,"theyR"
                !ja('thing') and return

                # Ghost%%tw... again for the other side
                #  %%efrom: Ghost..$z we have climbed to, finds:
                #  %%s: Know..$K that was located by %twin itself
                $c = {
                    q: {efrom:z},
                    found: 'yonder',
                    got: &n{
                        # we are %%yonder=K
                        # wake %MayGansp on Know..K connection
                        !me&za,R,'yonder,via'
                            && me&ha,R,{waits:'foryondering',wants:ms}
                    },
                    not: &{
                        # tell it to nodeo input a Know..%Pave
                        $tp = me&tpath,s
                        $tpz = me&tpath,z
                        ~>5 nottwin: tpz, tp
                        $may = me&jaa,zj,'may:input' .filter(n => !ns&eto)
                        if (may.length) {
                            me&nodei,R,zj,{s,may:'input'}
                            # < then making sure Know/ finishes 
                            !me&za,R,'s,may:input'
                                && me&ha,R,{waits:'forKnow',wants:ms}
                        }
                    },
                }
                me&twin_nodeo,R,msy&twin,msy&remote,c
            },
            nearly: &into,{
                # we are %%almost=found,into:zabove
                # not beyond the path
                me&ja,R,'extra' and return
                # i $into/#$s:z, remembering we did so
                ~>6 el2: msy&remote+'..'+s.t
                # < settle it before this. attend back here after|before,
                #    depending on the relativities of those wakers
                me&nodei,R,into,{tw:s.t,el:2},{dome:'awakes'}
            },
        }
        me&tw_nodeo,R,p,s,c
        
   // %twin->%Pave
        # < check %%extra are %%ok...
        # < Gansp's %%thing collection should become stable
        # < &settle (no other) - for all so far
        # < &settle cv, EXPR - EXPR||Ying-wide wait
        #   if lower cv settles await !
        # < x&ja,c,1 for:
        $K = me&jaa,R,'yonder',1 [0]
        $z = me&jaa,R,'found',1 [0]
        $sz = me&jaa,mg,'found',1 [0]
        if (K) {
            !sz and debugger
            $c = {
                q: {s:K,inside:sz},
                got: &n{
                    # Know..K can find other Ghost..z
                    ns&s == K and return
                    me&ha,R,{otherz:ns&s,via:ns&efrom}
                },
            }
            me&twin_nodeo,R,msy&twin,msy&remote,c
        }
        $twin = me&ja,mg,'twin',1 [0];
        if (ja('thing')) {
            !K and 'wait-for-climbing'
            elsif (me&settle,R,K ) {
                me&ha,R,{waits:'forK',wants:K};
                me&tsc,'..K'
            }
            else {
                # < flavours of waiting for something
                # Ghost..z has the Travel'd version, K may ~
                $was = ss&dige
                zs&dige = ss&dige
                was != zs&dige and me&wants,R,'z%dige=',z
                # < or perhaps only if it's not as K implies,
                #   requiring all changes of K%dige to offset all its twin..z
                #ss&dige == Ks&dige and delete zs&dige

                # can expect|%%actey-vate %Paving on things
                if (twin.t == 'Ghost') {
                    # should be as we u, or slightly old
                    !Ks&dige and me&ha,R,{waits:'Kdige',wants:K}
                    me&ha,R,'ok'
                }
                elsif (twin.t == 'To') {
                    # should be as it was
                    # < to %parent, if ~ since we Travel to replace it?
                    #   esp if it was W load+save
                    me&toPave,R,R,K,s
                }
                else {
                    me&zu,"weird_twin",twin
                }
            }
            # %MayGansp collects %%thing,ok?
            $q = {thing:s}
            ja('ok') and q.ok = 1
            me&nodei,R,mg,q
        }
        
        if (ja('extra')) {
            # sent to nearest R%MayTwine%%thing!%%extra
            #  so all the %%extra (eg .5) push with it
            $K = me&jaa,Ry&up,'yonder',1 [0]
            me&toPave,R,Ry&up,K,s,{species:s.t}
        }
        
        # < something to settle all %%thing,
        # < mark each then all %%wantpush
        
        #(Rs&boost||0) > 0 and me&zu,"MayTwine.s",s;
    },'ift,D'],
   
   
   // u|n%MayGansp unit of push
    ['MayGansp','299',&acgtRs{
        
        $x = me&Jx,R;
        
        me&jaa,R,'thing',1 .map(&z{
            $j = zy&R;
            # should lead back here after rattle
            me&settle,R,z
            
            me&ja,j,'ok' and return me&ha,R,{ok:z}
            me&ja,j,'wantpush' and me&ha,R,{wantpush:z}
            else {
                # < curio: match jam to lateral shunt
                if (0 && !me&ja,j,'yonder' ) {
                    me&nodei,R,z,{actey:3},{dome:'tilpushed-actey'}
                    $found = me&jaa,j,'found',1 [0]
                    if (found && me&ja,j,'eto,s,may:input'
                        # input done,
                        && me&ja,foundy&R,'eto,s,may:input'
                        # without That%%tw, no To%%tw yet:
                        && !me&ja,foundy&R,'eto,tw,s' ) {
                        # < unfreezable numberclicked That
                        # jy&up
                        #me&nodei,R,z,{actey:3},{dome:'tilpushed'}
                        me&tsc,z.t+"-may:"
                        $rp = sy&remote;
                        $r = me&yfuture,rp;
                        rs&numberclicked = 1;
                        me&ha,R,{waits:"may:input-shunt",wants:rc&s}
                    }
                    # then waiting for:settle-!down
                }
                me&ha,R,{waiting:z}
            }
        })
        # wait for all %%ok|wantpush
        # < periodically poke the $of of any %%waiting
        me&ja,R,'waiting' and return
        !(me&ja,R,'ok' || me&ja,R,'wantpush' ) and return
        # desend %%actey now they all must have succeeded
        me&za,R,'waiting' and me&dome_traction,R,'tilpushed-actey',{el:2}
        # wait for all %%ok after any %%maypush
        if (me&ja,R,'wantpush' ) {
            x.ro("push*") &&
            me&jaa,R,'thing',1 .map(&z{
                $jo = me&yfuture,z;
                # < slow dige-through only, user must see diffs
                me&nodei,R,z,{maypush:1},{dome:'tilpushed-push'}
                me&ha,R,{waits:'tilpushed',wants:z}
            });
            return
        }
        me&tsc,"Done!"
    },'ift,D'],
   

]}