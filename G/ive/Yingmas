# R -> Ying
# < -> A revival!
# R%Ying becomes - see %Ying in Sch_emas
# < make Yc&tug?
=pod
 Ying needs to be above whats awaking,
   but then can do many reactions in a single self
 for groups of language to find their completion
 
 Know->That was an I mixer,
  becomes one of many things we could do with W
  Place for generating to e

 Gump|Story->Travel do wander
  < an A for R code. Ying like Ring when Ay&R=A
  < A subscribe to A|A&cv|A&X...
    
  
     < &Ying, &Yong copy to &Aon, &Ain
        the A (Y) wants to be|have Cy&A,
         may be othering: A:n&C..Cy&A:etc
          having one A find another via C
          which is an eg &Xout of some kind
           coming from somewhere...
           to position A|C^^ relative to each other
            that slope having a &Ying_8-ness
           to whatever that &Xout will continue
            maybe A:n making an &Aon,J,'osc'
            maybe demanding all A get done
         
         basically amenable to
          mixing in others, eg:
           to I: mind (Yc&N) 
           to C: over matter (Yc&M)
          being in potential X-space,
           open to operations being more coordinated
            I via X%I or X%Ac.N
            C via X%tv or X%t...
          while A has X having the X-space-trip
          actinopterygian
          
          the A@1 scans itself
          
           some kind of pointer (C.c?)
            see X.At for any A/A
            also X.t, about the A&s
            may be imposed (put) from above,
             perhaps with notes about how it is imposed
             for us to obey
            and acts on A|C.*.* or X, or whatever
             for lively resorting of orders
             and hot-swapping I,
              diving layers of shadowpuppets
             and deciding C
              sorting its organs into the
               large
                forward attentions to
              or
               small
                thing comping from
              room,
              the energy of things you would place
              directs where in the room it goes
              if (a) dup replaces the last one with its name (el:2)
          
          the A@2 realises itself
          
           preliminary C-I matchability with any history
            including the flock, what alignment they solved
           decides to be the next real thing
          
          the A@3 creates others
           
           the &pin
            threads &S
             which can io
              which spec -pi and arrange names, joins etc
              in a repeat|repeal-here way
           in tree entry
         
          both and more being A having X with C in it
           or not
            dome imposes things into X and beyond
            in known|handled namespaces eg X.k...
            to places|how to bring up A...
             ie after some pointer path,
              some recipe-part is configured
            so the edge of knowing (C) pushes:
           beyond x..$v are eg sc to see|change,
            as part of an input or output,
            perhaps a read+feed-to-A...
         
         such A:etc inside C the stuff that A:n includes
          see 'other A can be met: X.oAt'
          have some relationship
          or winding if A:n&cv > A:etc
          
        A inloading aspects of C
         inc where|what all values and structures in memory are|mean
         through X, the structure-fact noticer
          see &Xin etc
        leaves lots of inhibitors|words in X space
         which you inhibit, via e
          to produce more io|wake|reality|stylehouse
         and e may emerge from the natural runningness of a 
           
        the sy&R is Cy&e, last micromind got to C
         C the pointed, the &e othered with news for it
          e re-refd but e.*, e.*.*, etc same is data
          could be just a wakeup
          to A to take a random turn+stop somewhere
        are persisting C A
         know where a Cy&A is currently engaged
         many slightly different Aon|in
          on the same A inside of each other
          should make sense
           as in climbing into ling housings
           and looking back at where you were
          slope between A determine most of self|other-ness
           if in the same time-capsule, or some such:
            not if its inside a completed|abandoned|sleeping A%dome
         &Ain is C-adopting, usu rewind: redo domes
          is how we transmit $ov to ambient-complete found A
          A.T state wait
         &Aon is close-up Action
          already aware if|how C is other to it
           simpler (no) relation strategy
           it may i|o &something that C
    This join That
     s&e&t
   
   w:Dome for A as A...
    mapping brack in A&z may get it done
     for a boot.js &t, that can make /wjs/ requests
    &t, &a - there|here
     &t-hing with qualities
     &a-ccessors of:i (&ja etc)
    intention pitches radiated to sub
      # want to hotwire w/I it uses
      #  to implant me&T hooks etc
       which would be some A&I imposed close to the target A..
        so that &t sees the A&I,
         as it is inclined to rush past A&X,
         leaving that for &a to access, teeth made to fit
 
 eventually X can inflate from
  and conclude the joins between:
 Know $W used, versions in here
 Travel $W using: $W used, why/how
 That $W using

Yingwhen
 what sense we arrive to this R%Ying
 usu tunneling there
 < relate to e%term
=cut

// Yingwards
# mind
 // Yingf
    me.Yingmind ||= {};
    # get I = me.Yingminds.$t ||= me.Yingmind.$t
    me.Yingminds ||= {};
    me.Yingmindo = &acgtt{
        !t and throw "Yingminds!t"
        $N = me.Yingminds[t];
        N and return N
        !me.Yingmind[t] and throw "Yingmind!t:"+t
        $M = me.Yingmind[t](A,C,G,T);
        $N = [];
        each in M {
            # sack of me.functions
            isfu(n) and n(); continue
            N.push(Cye(n))
        }
        N.map(n => n.c = {s:n.c})
        me.Yingminds[t] = N;
        return N
    };
    # drink grounds into Ying/Schema
    me.Ying_Schema = &acgtRtc{
        $SC = me&rollbsc,R,'Ying';
        $s = me&Yong,R,SC,'Schema',{t:t},1;
        # steps adopted from recent: n ...
        sy&domed = &{
            $N = me&ydome;
            me&Yong,R,s,{N:N},2;
        };
        return s
    };
    # py&l|r - linked listness of a step
    me.neigh = &py{
        $Steps = py&up;
        $z = Stepss&z;
        $pi = z.indexOf(p);
        pi <0 and throw "!step"
        y (z[pi-1],z[pi+1])
    }
    # find s's +1|-1 neighbour, or 0 for itself
    me.neaz = &acgtsy{
        $p = sy&up
        $z = ps&z
        $si = z.indexOf(s)
        si < 0 and throw "!neaz"
        if (num(y)) {
            y == 0 and return si
            return z[si+y]
        } 
        else {
            throw "either direction until y()?"
        }
    }
# appear
 // Yong - use sy&Y link to Ying $s**
    =pod conventionae Yongus

      Yong,$s:Steps,{sc},ov
        has Stepsy&Y to resume
      Yong,$s:SC,$t=Steps,{sc},ov
        is a difft, Ying Steps@o1 to create/find $s:Steps
         giving it this new Y
     either then:
      sy&R!future - Ying @o2, resyncing new R
        saving higher cv/ov until Steps does Yc&resumeov()
     and:
      Ying up to that ov
     
    =cut
    # me&Yong R $s(y&Y?) $mind? {Y.sc intro} $ov||=9 - 
    #  $mind on est. might return forked Y/Y:$mind
    me.Yong = &acgtRst,sc,ov{
        isob(t) and ov = sc; sc = t; t = null
        ov < 0 and $rewind = ov = ov *-1
        ov = scaf(ov) || 0.9;
        
        # s may be inside SC
        # < io: optimise SC**/$s knowing sy&up
        # < slope sy&up and know stuff, part of wider Aing
        $dive = me.cby(s);
        $SC = dive[0];
        $Y = sy&Y;
      
      // begin if c.t || !sy&R
        $began = Y && Yc&cv || 0;
        $rem = "";
        if (t) {
            rem += " +Y:"+t;
            # o1 with new Y:Yc&t, create/find s for itself
            #   starting from the s
            $Y = me&Ying,R,s,{t:t,ov:0.01},sc,SC;
            # intro Yong(...sc) once, any of these places
            sc = {};
            s = Ys&returns;
            !s and throw t+"@01 !returns"
        }
        if (sy&R && me&yfuture,sy&R != sy&R
                || Rs&sleeping && R != sy&R) {
            # o2 per sy&R checks Y into lowov
            #  join macro A (eg R)
            #   so it can give/take grounds there
            $c = {};
            c.cv = c.ov = 0.02;
            # saving higher cv/ov until Y is ready
            !Y and debugger;
            Yc&resumeov = extemp(Y.c,c);
            c.Y = Y;
            # doing o2 even if cv==o2
            # < rename incv=ov, for iterating same t
            c.incv = c.ov;
            $Y = me&Ying,R,s,c,sc,SC;
            sc = {};
            rem += " ~R"
        }
      // continue if ->?ov
        # what to do
        $c = {ov};
        if (!Y) {
            # begins itself, mind Yc&t = s.t
            c.t = s.t;
            rem += " s+Y:"+c.t;
        }
        else {
            c.Y = Y
        }
        if (rewind && Y && Yc&cv >= ov) {
            c.incv = c.cv = ov;
            Y = null
        }
        !Y || Yc&cv < ov and Y = me&Ying,R,s,c,sc,SC
        
        $ind = dive.map(s=>s.t).join('/');
        SCc&verbose and ~>6 Yingd: ind, began, Yc&cv, ov, rem, ki(c)
        
        $re = Ys&returns || (Yc&M||[])[0];
        rey&Y != Y and throw "returning !yY=Y"
        return re
    };
# act
 // Ying - mind (Yc&N) over matter (Yc&M)
    # uses mind @01 find C -> Yc&M
    #  they then y&Y=Y
    # may c.t=newmind
    # may !c.Y, is created
    # sets sy&Y=Y for Yc&M/*
    #  and on itself if it returns so from 0.01
    me.Ying = &acgtRsc,sc,SC{
        # incv allows doing Ycv==tcv
        $incv = delete c.incv;
        # Y = c.Y explicitly, probably is sy&Y
        $Y = delete c.Y;
        if (!Y) {
            # init happens this way, from Yong $t
            # 
            # could Yy&up = sy&Y before it reinits?
            Y = Cye(['Y:'+c.t,'']);
            # for isA(), alternative to A.y==A
            Yy&A = Y
        }
        # A:$t cv-ov are life + time to be
        # < see me&tempwind undoing some of this, 
        ex(Y.c,c);
        Yc&ov and Yc&ov = sca(Yc&ov)
        Yc&cv and Yc&cv = sca(Yc&cv)
        $wascv = Yc&cv;
        # its quest for a specific etc
        ex(Y.sc,sc);
        # of this linguistic actuation linearity
        Yc&N = me&Yingmindo,Yc&t;
        # and this exception actuator, and the one above
        $oT = T;
        $T = {};
        $returns = &{
            Yc&M and Yc&M.map(s => sy&Y ||= Y)
            return Y
        }
        $il = 30;
        while (1) {
            il-- < 0 and throw "ManyYing"
            # fracseek
            # < near Yc&N being changed while Yinging
            $ci = t ? Yc&N.indexOf(t) : -1;
            $t = Yc&N[ci+1];
            !t and break
            ty&cv > Yc&ov and break
            ty&cv <= Yc&cv && incv != ty&cv and continue
            
            # < thinkseek
            
            # < bitseek
            incv and wascv = incv
            # usu so many at == cv all happen
            incv = ty&cv;
            # <=@o2 iterate themselves
            $M = ty&cv > 0.02 && !ts&self && Yc&M || [s];
            each in M {
                delete T.not;
                # t act, n ground
                
                # deciding
                if (ns&sleeping) {
                    # misses everything but sleeping spells
                    !(ts&sleeping || t.t.substr(0,8) == 'sleeping') and T.not = 'sleeping'
                }
                T.not and continue
                
                # can't always trust whatever these might be:
                #$r = ny&R || sy&R || Cy&R;
                # R is from the Ying above (R%SC)
                # < elabourate argumentation
                sc&verbose and ~>4 Ying: s.t, t.t, t.y.cv, n.t, Yc&ov
                $re = tc&s(A,C,G,T,R,Y,n,SC);
                
                T.Z and me&T_Z,Y
                $nocvt = delete T.nocvt;
                !nocvt and Yc&cv = ty&cv;
                if (ty&cv == 0.01) {
                    # Y claims what o1 returns
                    #  or $s if non-forking o1
                    re ||= Ys&returns || s;
                    !isC(re) and throw "o1ret!C"
                    # 3 makes child, required for &Yingbal
                    rey&cv == 0.3 and rey&up = s
                    # < may switch to it?
                    rey&Y and rey&oldY = rey&Y
                    rey&Y = Y;
                    Ys&returns ||= re;
                    s = re;
                }
            }
            delete T.not;
            T.hwack and Yc&cv = wascv; oT.hwack = T.hwack; return returns();
        }
        # so Y looks @2, if last ty&cv < 2
        Yc&cv = Yc&ov;
        return returns();
    };
    me.T_Z = &acgtY{
        $cv = delete T.Z;
        T.nocvt = 1;
        Yc&cv = scaf(cv);
    };

# get from R to Ying
me.Sch_ema = &acgt{ return [
 
 // R:Ying, how it /*
  
  // %SCinto # schemas employable from s/s%SC
    ['SCinto','2922',&acgtRs{
        
        Rs&mindused = 'SCones';
        me&reaw,R,'mindused';
        # look for R/r(%SC=ForThee
        #  becomes R%ForThee%SupplyChai
        $g = me&opeolo,'SCinto';
        $autoad = Rs&icount != 1
        me&ioty,s,'SC','' .map(&z{
            $t = zs&SC;
            # .1 starts it, can be switched off
            !autoad and autoad = R.sc['maydo_label_SCinto_SC-able_'+t] = 1
            $c = gy&can('m','SC-able');
            $n = cy&can('n',t,{label:1});
            # %Ying is persisted early by %nextlifesc
            !ns&ope and delete Rs&Ying
            else {
                # switch on the %$schema
                #  will create %Ying here
                R.sc[t] = 1;
                $ml = cy&label;
                mls&fs = 6;
                # switch on Search P -> J
                4s&Pringit = 1;
            }
        });
    },'ift,D'],
    
  // R%Ying  # joining Steps time
   # building on the e%tunnel function
   #  to wake+sleep togethers
   #  tunneling past R:Ying%sleeping most of the time
    # early, no schema, only steps that are tunneled
    ['sleeping+Ying','2926',&acgtRs{
        $SC = me&rollbsc,R,'Ying';
        isR(SC) and throw "%Ying became R"
        me&Yingwhen,R,SC and return
        me&Yong,R,SC,{},9;
    },'ift,D'],
    
    # Ying normally after R%Peace and schemas load 
    ['Ying','2926',&acgtRs{
        T.Mw = 'SC';
        me&reaw,R,'Ying,Outlog';
        $SC = me&rollbsc,R,'Ying';
        me&rollbs,R,'Outlog';
        me&Yingwhen,R,SC and return
        # < feedback, early intro tunneling
        ah(R,'nextlifesc','Ying',SC);
        # steps congealed
        $s = me&Yong,R,SC,{},9;

        s&boc = 588;
    },'ift,D'],
   
  // &Yingwhen - assign R/*%onlyish
    &{
    # since tunneling 18 you can see what's tunneled
    #   what's recycled will also be there
    me.whotun = &acgtR{
        $N = me&ioty,R;
        if (!Rs&tunneling) {
            # nothing
            # < a loose wave of attention,
            #   do 100ms work, etc.
            #   casually refreshing around:
            #   $R/*/(*/*), $R/(*/*), ($R/*)
            # ($R/*)
        }
        return N.filter(n => ns&tunneling && Rc&N.includes(n))
    }
    # see what's tunneled
    me.Yingwhen = &acgtRY{
        $tunneling = me&whotun,R
        if(0) {
            $blab = tunneling.map(&n{
                return n.t + (ns&sleeping ? "%sleeping" : "")
                    + (!ns&tunneling ? "!tun" : "")
                    + " P="+ns&Peace
            }).join(',');
            ~>3 tunneling: blab
        }
        $b = Rc&b;
        $est = b && bs&Ying;

        # the main things, $p%ball
        $two = tunneling.filter(n => ns&Peace == 2);
        # $p only, eg delivering %%eto:$p
        est && two.filter(n => !ns&sleeping).map(n => ns&onlyish = 1)
        # $R/$p only, all of them
        if (!tunneling.length) {
            if (est) {
                $e = me&Dtunneling,R
                e && me&Yingwhen_e,R,e and me&gosleep,R; return 1
                
                ah(R,'inheritscif','ball','onlyish',1)
            }
        }
        else
        # no &Ying for $R/$nonp (Yingu)
        !two.length and return 1
    };
    me.gosleep = &acgtRt{
        me&recycleRbitXz,R
        Rs&sleeping = t||'gosleep'
    }
    # lets go to sleep
    me.sleepic = &acgtRk{
        me&ollbs,Ry&up,'numberclicked' and return
        $b = Rc&b
        !b and return
        bs&wakeful and return
        Rs&tunneling and return
        Rs&sleeping = k||1
        me&recycleRbitXz,R
        Rs&wou_sleepic = Rs&wou
        Rs&wou = Rs&wou_accepted
        return 1
    }
    # climb Rc&b until R is real
    # < not used anymore, since &sleepic makes &ja as &za
    #   probably some instances of this around though
    me.lastnonsleepingR = &acgtR{
        # R:start, y:wanted, y:climb
        return me.cbu(
            me&yfuture,R ,
            r => !rs&sleeping,
            r => rc&b
        )
    }
    },
   
  // %onlyish
    # me&tunnel a cul de sac, to $p/*%sleeping
    ['Peace+onlyish','294',&acgtRs{
        $b = Rc&b;
        !b and return
        #throw "%onlyish !b"
        $N = bs&z;
        each ib N {
            !bs&Peace and continue
            bs&wakeful and continue
            $was = (Rs&z||[]).filter(r => r.t == b.t)[0]
            was and ~>4 %onlyish-already: R.t, b.t
            was and continue
            $c = me&tunnel,R,{b};
            c.aleeping = 'aleep';
            c.JRom and throw "%onlyish/%JRom"
            me&tunnelin,R,c
        }
    },'ift,D'],
    # go %sleeping after arriveRbitX (@17), like tunneling @18
    ['aleeping','18',&acgtRs{
        me&sleepic,R,Rs&aleeping and me&rollbs,R,'bal_tw_s'; return
    },'ift,D'],
    # like tunneling @94, copy all other sc, eg %elvis
    ['sleeping+aleeping','94',&acgtRs{
        each kv Rc&b.sc {
            R.sc[k] ||= v;
        }
        delete Rs&aleeping
    },'ift,D'],
   
  // %supr
    #
    # the %eph and its /** become %supr
    #  and %$sy&supr - suprise puts that
    ['ball+supr','291',&acgtRs{
        sy&R = R;
        # children get %supr in time to get here
        ac(R,'inheritsc','supr');
        # our %ball/%fix appear after @4
        
        
        
        
        
        Rs&fixatfour = 1;
        # %supr only becomes %$supr if a node:
        #  me&suprise mostly just transfers it
        #   to sy&supr on entering a node
        sy&supr and R.sc[sy&supr] = 1
        # see Y:Steps about %nextlifesc %nottilund
    },'ift,D'],

  // schema %KnowThee
    # http://hereth.localhost:1812/?Wayout/Fingo
    ['KnowThee','2924',&acgtRs{
        
        $h = me&Ying_Schema,R,'KnowThee',{};
        # G, storage type of step
        # bunch of G&t Q written down
        #  hierarchical looking, W/[W,W,W]
        #   able to conserve some hierarchy of W inclusion,
        #   and write down the essential Q of any ghost,
        #     may involve specificity, random folders
        #   in a pile easier to read than all the W.5s everywhere
        n Know 1  %bri:0.7,Pavings
        
        # Comal/Conal, Comste/Conste
        #n Compiling 3  %hue:70,supr:Conal
        #n Seq 5  %hue:110,supr:Conste,Omplateau
        
        # join
        # schema.c.twin puts %twin on the s.sc
        #  so does %Pavings, puts s%twmt
        n Ghost 2 twin:Travel|Know#of/t
        # awakening
        n Gump 3  %Gumptio
        n Introtivity 31  %Introtivity
        n Travel 4  %Travels,Travelables
        n Wormhole 42
        n Duolish 5  %Duolish
        # in a puff of ghost
        n To 6 twin:Travel|That#of/t
        
        n That 7  %Pavings
        n Story 8  %Story

        hy&domed()
    },'ift,D'],

  // schema %TravelThee
    # http://hereth.localhost:1812/?Wayout/Lingo
    # @Fingo without @Know|@That or @Gome having any Story-ness
    #  @Travel/$t must %play (shift-click)
    #  to request %%Go from @Gump
    ['TravelThee','2924',&acgtRs{
        
        $h = me&Ying_Schema,R,'TravelThee',{};
        n Gump 3  %Gumptio
        n Travel 4  %Travelty,Travelables
        n Duolish 5  %Duolish
        n Story 8  %Story

        hy&domed()
    },'ift,D'],
  // schema %ThyThee
    # http://hereth.localhost:1812/?Wayout/Thy
    ['ThyThee','2924',&acgtRs{
        
        $h = me&Ying_Schema,R,'TravelThee',{};
        
        n Ya 6  %Gnomp
        n Travel 4  %Travelables
        n Introtivity 31  %Introtivity
        n More 3  %Moreism,eph
        n Less 2  %Moreism,eph
        n Thyer 12  %Thyer

        hy&domed()
    },'ift,D'],
    
]};

me.Yingmind ||= {};
me.Yingmind.Schema = &acgt{ return [
    # SC/Schema/Y:$src/$step+ posit SC/Steps/$step+
    #  every time R%Ying wakes
    # < slep @2
    # %*T pronounces how it will be, arranging for SCing:
    # A:SC@1 %SupplyChai=C macro laterer
    #  A:Schema@1 %SCh/$t=C micro schema
    #   ...gets finished:
    #  A:Schema@2 can slep & tell macro
    #   @3 with each other, notice late joiners
    #   @4 patterns emerge
    #   @5 decide how to change the game in progress
    #   @6 Ret (via bal) the step
    # SCing:
    # A:SC@2 inits
    #  A:Schema@6 may be moved in here,
    #   to avoid it Ringing outside the SCing

    # %KnowThat forks SC/Schema/t=KnowThat
    ['+Schema',0.01,&acgtRYs,SC{
        # organise SC's Ys as of/t:
        $Sch = me&fiu,SC,'Schema';
        $t = Ys&t;
        !t and throw "give t"
        # el:1 recreates, string t makes spacer
        #  and sets sy&Y = Y
        $s = me&fiu,Sch,t,{el:1,Y:Y};
        # drop cache # < wake Y:Schema if diff
        delete Schc&compiled;
        # makes the subject of iteration, sets sy&Y=Y
        return s
    },'ift,D'],
    # day, display zone
    ['on',0.02,&acgtRYs,SC{
        sy&R = R;
        # nowhere:
        $g = sy&g = me&opeolo,s.t,{walls:'b:2.2h6',label:{walls:'bg'}};
        Rc&brackuiet = 1;
        gy&can('ope',&{ Rc&brackuiet = 0 });
    },'ift,D'],
    # i $s:schema/$step o T.nN/*:step
    # steps adopted from recent: n ...
    ['steps adopted',0.11,&acgtRYs,SC{
        $N = Ys&N;
        !N and throw "nosteps"
        each in N {
            $p = fio(s,[n.t,n.y.cv||1]);
            py&Schema_step and throw "multi schema step", n
            py&Schema_step = n;
        }
    },'ift,D'],
]};
