# I J
# part of ruv, which is assembled on the outside, so:
# me/io global:
$me = 4c&me;
!me and throw "no me";
$io = me.io;
window.io = io;
window.me = me;
me.Peaceness = &acgt{ return [
    &{
    # wrap calls to me&t so they don't throw if !ready
    # will go weird if we're not one Ring deep
    me.JRom_asyncQs = &acgtR{
        T.asyncQs = [];
        return &{
            $was = delete T.asyncQs
            was.length and return T.cancel = was.map(n=>n.t).join(', ')
        }
    };
    
    },
    # J: w (Peace) with W (R.t)
    # unfold a structure from code and data
    ['Peace','291',&acgtRs{
        #n Sleigh  R %Slei,ting:W,Gens,tingspot
        # run field of exclaimation into others!
        
        # A:Peace
        # uses A.1-5 for %Peace=1-5
        # relies on %Peace all the way down
        $p = Ry&up;
        $AA = A;
        ps&Ace and A = ps&Ace
        else
        me&ollbs,p,'Ace' and A = me&ollbs,p,'Ace'
        # < RbitX might extend to deal b into Ace/**
        $Y = Rs&Ace = G&Aye,'Peace';
        A = AA;
        Yc&Y = A;
        # stash the A.I somewhere, our G.t uses:
        !ps&Ace and Y.6 = Y.4; Y.7 = Y.5;
        !ps&Ace and [2,3,4,5].map(&k{ delete Y[k] })
        # A.1=R, usually J
        Y.1 = R;
        # R's part of the %Peace organism
        num(Rs&Peace) and $step = A&Sonly = Rs&Peace
        # A.2-5=A, usually J
        # < suppose you go A.up to where A.1==A.3 etc
        step && step > 1 and Y[step] = Y
        me&reaw,R,'Peace,Ace';
    },'ift,D,sleeping'],
    ['Peace','291',&acgtRs{
        $Y = Rs&Ace;
        # J 6 pin
        $done = me&JRom_asyncQs,R;
        me&way,R,'Peace',{R,Y};
        # < other pins
        done() and return
        
        # default some steps
        $step = A&Sonly;
        if (step) {
            # done ? base types : defaults
            # < way might want to around something, etc
            $done = ahsk(A&doings,step,'done');
            if (step == 9) {
                # 9 5s
                # < see if there's a w:R.t
                #   to use as well as w:Peace
                #    and its meanings for W ball
                $s = Cye([R.t,1,{},{}]);
                # allows the 9/5%task to be ^^%mindused
                # < load minds wanted inside %Gens
                $r = me&personify,R,s,Y,step;
            }
            if (step == 5) {
                # 5: bits of housing (boh), store <-> self
                #  eg ballRom does JRom/5/3
                !Rs&Gens and throw "5!Gens"
                me&reaw,R,'Gens,self,Here,Zaving';
                delete Rs&ting;
                
                Rs&Zaving = "mem,W";
                # 5/4 then 5/3
                $four = me.cby(R,"^^^Peace")
                    .filter(n=>ns&Peace==4)[0];
                $next = !four ? 4 : 3;
                ah(R,'inheritscif','ball','Peace',next)
                # %Gens is about to %Here = %self)%ball
            }
            if (step == 4) {
                # in this blob of Peace
            }
            if (step > 1 && step < 5) {
                !Rs&ball and throw step+"!ball"
                !isC(s) and throw step+"!s"
                # a node sloping 4,(3,2)+
                # spreading 2
                ah(R,'inheritscif','ball','Peace',2)
                
                if (ss&W || ss&J || ss&R) {
                    # switch on layers of person
                    s&bgh = '010';
                    $r = me&personifyif,R,s,Y,step;
                }
            }
            if (step == 8) {
                # JRom/osc transaction join
                #  plot out of time together
                !Rs&JRom and throw "8!JRom"
            }
            if (step == 1) {
                # an edge
            }
        }
        
    },'ift,D'],
    &{
    me.personifyif = &acgtRsY,step{
        [ss&W,ss&J,ss&R].filter(n=>n).length > 1 and throw "mul"
        # we could be on a %Peace=2-4
        # R on 3 or 4 (tops of a J) auto
        $would = ss&R ? !(step <3) :
            # J immediately under 4
            Y.up == Y.4;
            # or anywhere before another 5? ie one J deep
            step <3 && Y.4 && Y.5 == Y.4[5];
        
        !(Rs&play || would) and return
        Rs&play && would and return
        return me&personify,R,s,Y,step;
    };
    me.personify = &acgtRsY,step{
        $c = {};
        # the $s <-> $self
        #  outside $s/** may be to inside $self/** related
        #   the R|W|J already having a pile here
        #    < ein ledger
        #   or thing%W:javascript/** compiling thinger
        #    < via e to javascript%W
        #      does c&W need babbling and s&W not?
        #   or simply being more stuff here,
        #    which the inside is allowed to use
        #  balls for it may happen or dup out
        #   if the inside R uses them first
        $outsphere = (ss&z||[]).length;
        
        # J into the last J
        # < %Zaving %directory=p%Zaving
        ss&J and c.directory = Y.5[1];
        
        # < using W to mean thinger (see the $s)
        # < $W1/$W2 looks for $W2 and $W1/$W2
        ss&W and ''
        
        if (ss&R) {
            if (isst(ss&R) && ss&R.substr(0,1) == '+') {
                # modes to enable on R
                # < it might want to be here from the start
                #   rollhauntedb, ghost of a process
                ss&R.split('+').map(&k{
                    !k and return
                    # ballRom would copy ss&* to rs&*
                    R.sc[k] = hak(s.sc,k) ? s.sc[k] : 1
                });
                return 'nothing'
            }
            # ballRom:
            #  makes r%Some%Thing if R=Some+Thing
            #   or r%Peace may be all if R=1
            #  copies ss&* to rs&*
            #  rs&other = s
            # R Ret 6
            c.Doming = 2;
            c.Peace = 6;
        }
        else {
            # W|J JRom 8 Gens 5
            c.Doming = 3;
            c.JRomc = {Peace:8};
            c.Peace = 5;
            # ballRom compulsively r%Gens once ^^%Gens
            c.Gens = 1;
        }
        
        c.Doming <3 and 'Ret'
        else {
            # Rom may normalise %task
            # < JRom should be more normal?
            #   this could be the osc identity
            #   the G lang for out/in connection
            #  so we can leave a mind with one call
            
            c.task = me&Rsc,R,'^^mindused' || 'ruv';
            c.JRomc.task = c.task;
            me&tsc,'u:'+c.task,0,'y';
            # ss&task might be
        }
        # < let A:Peace out there?
        # < e all 4s&things
        $r = me&ballRom,R,s,c;
        # does only Ret, put in Rc&N
        c.Doming <3 and me&zN,r
        else {
            # < uplink moreso
            # < resolve through JRom
            #   just for SC steps?
            # < collect things, G lang
            Rs&Inner = r;
        }
        return r
    }
    },
]};