# test, runs on W:Thy, 33
n doafew 1 s:Things!
$R = A.Run
$h = A.h
fatal.ish(h)
# < becoming Babz 'more of a title -Fez=>\n  ...'

    
S 1 test data for -hat ref noticing, limits, specialfx
    $h = A.h.o('Something')
        # $time-seven, as long as it contains something:
        # to make stuff up
        $dat = me&PiRet_data
        dat.moreso = dat.asee
        $Bow = h.hat('Bowler',dat)

        $da = {more:'some',figaro:dat.asee}
        da.furhtin = {llatin:4}
        $Bow = h.hat('Lol',da)

        $da = {fer:dat.asee,even:'more',figaro:dat.asee}
        da.furhtin = {llabin:4}
        $Bow = h.hat('Room',da)
        # 
        $i = 0
        while (i < 60) {
            da = da.th = {}
            i++
        }
        da.is = 'all'
        # < &Eing preferring this to more level$n !
        #   diversity seeking
        $ej = Bowc&s.neesd = Cye(['Nees',3
            ,{mo:3,tor:68,functions:"of an elabourate sort",s:"Thsideratea"}])
        ejy&fig = dat.asee
        ejy&vig = 2
        Bowc&s.leveridge = Cye(['Nose',7,{s:'li'}])
        $i = 0
        while (i < 55) {
            Bowc&s['lever'+i] = 'thing'
            i++
        }
        
    $h = A.h.o('Someact')
        $da = {as:dat.asee,fol:33,vanas:dat.asee,vaees:dat.asee}
        da.string = <<''
            Til
              forward
               motion
              was
               it
               all
            
            etc!
             etc
        
        $D = Cye(['Ling',1,{s:da.string},{}])
        da.encodes = me&enL,D
        da.spaceynum = num("  ")
        da.stringynum = num(" 0")
        da.verylong = new Array(100) .join('123-')
        
        $links = {fig:'ure'}
        ahk(links,'with','in',links)
        da.links = links
        da.lonk = links
        
        $Bow = h.hat('Bowler',da)
        # lurkfa faing!onn.. fa
        

S 2 twos
    $h = A.h.o('brackstract')
    
    # < Tool for zooming into Ying-gate !!!
    
    #$s = 4s&interestoYing
    $s = me&mock_Thyergate,R
    !s || !ss&X and return me&tc,"awaits"
    ss&X.A != R and debugger
    # X by &bracki (ish), make &Shx_isX
    # < the &Shx p.ist('X') check is too silent
    me&brackstract,ss&X
    
    # < a holding X, knowing what format the inner might like
    each ks R.sc {
        !k.endsWith('W') && (!isob(s) || isC(s) || !isC(s.A)) and continue
        # the &Saturn %%inst,listen_node there coops these:
        $pi = k.endsWith('W') ? 'Womb' : 'Fez'
        
        h.tys(k,pi,s)
    }
    
S 3 Pictures hashy misc
    $h = A.h.o('Something')
    $hat = h.hat
    # < sample all calls to ahk() etc during a bunch of Stories
    #    keeping a taxography of all uses
    #     the data condenses a schema!!!!!!!!!!!!
   // modulat!
    # < T.act.t should be steppy?
    # < autogen C.t < argmo
    # < Babz 'n anyoldtext -Bow => &yada,&m{'
    #    DIY closing bracket etc
    #    should be possible, -Bow knowing how to interpret such a housing
    #    so c&s = c&code or so, during T.act of A:n
    #     which knows its proper title
    #    this is a nice realm
    #    we make the BQ a subroutine, mini-pin...
    #     so it may define handlers in the dome
    #     they would be on the ground..? receive calls on a telephone...
    #     also make them, on eg a lamp, that can be used to be the origin,
    #      to write the address relative to.
    #       carrier assurance of messages coming from elvis.
    #    the 'stricter title 33-Fez: %such:even =>'
    #     also. is BQ dependent?
    #    perhaps shorter 'n some = ...' # have to eval first? put in sub?
    #    or the 'n some i yo/plo//%chi' # some = any spheres with %chi across yo/plo
    #    and '$n o such/where' # notice !n
    #    then '$z o yer/$n' # still !n
    #    then 'i mixio/$n &quant $z' # fatal
    #     < wants empty spaces sometimes
    # < stub a bunch of ways as above! devob, mkv, etc
    h.Womb('&ts?c?', me&abTap,'Picmodu',Cye(['Picmodu',1]) (&{
        me&tsc,'becomes',0,'6y'
        me&tsc,'tos','','6g'
        me&tsc,'untos','la','6b'
        me&tsc,'basictsc','la'
        me&tsc,'moretsc','la','46yl'
        me&tc,"tctitle"
        me&tc,"tcstyle",'G'
        me&ts,"ts0",0,'6'
    }))
    h.Womb('boxcap_test_situation', me&abTap,'situa',Cye(['situa',1]) (&{
            $two = me&boxcap,"pile1",'1y'
                me&tc,"<"
                $three = me&boxcap,"yondsome",'1y'
                    me&tc,"insidde"
                three()
                me&tc,">"
            two()
            
            $two = me&boxcap,"pile2",'1y'
                $three = me&boxcap,"empty",'1y'
                three()
                me&tc,"outside"
            two()
            $two = me&boxcap,"Achgindi",'1y'
                me&tc,"stuff"
            two()
            $two = me&boxcap,"Achgindi",'1y',2
                me&tc,"stuff"
            two()
            $two = me&boxcap,"Achgindi",'1y'
                me&tc,"additional"
            two()
            $two = me&boxcap,"Achgindi",'1y',2
                me&tc,"andmore"
            two()
    }))
  
  # notes a heading in Pictures:
   // # types
    # < title as expr, expect true. just '!iske(44)' on a line.
    $D = Cye(['D',3])
    $Dot = Cye(['Dot','-Dot'])
    hat('Fividy types',{
        "isha({})": isha({}),
        # causes ish([])
        "isha([])": isha([]),
        "!isha(D)": isha(D),
        "isob({})": isha({}),
        "isR(R)": isR(R),
        "!isR(D)": isR(D),
        
        # avoid
        "sca(333)": sca(333),
        "sca(333.3)": sca(333.3),
        "dec(333.3)": dec(333.3),
        "dec(333)": dec(333),
        "dec('333')": dec('333'),
        # < more
    });
    hat('types',{
        "!isba(D)": isba(D),
        "isba(R)": isba(R),
        
        "iske(str)": iske('stri'),
        "iske(num)": iske(44),
        "iskeyish(num)": iskeyish(46),
        "!iske({})": iske({}),
        "!iske(null)": iske(null),
        # housey - looks like index
        "!ish(null)": ish(null),
        "!ish('str')": ish('str'),
        "!ish(D)": ish(D),
        "ish([])": ish([]),
        "ish({})": ish({}),
        
        "!isit({})": isit({}),
        "!isit([])": isit([]),
        "isit(D)": isit(D),
        "isit(str)": isit('str'),
        
        "!ispi(D)": ispi(D),
        "ispi(Dot)": ispi(Dot),
        "ispi(Dot,'Dot')": ispi(Dot,'Dot'),
        "!ispi(Dot,'Else')": ispi(Dot,'Else'),
    })
    # < fatal variations
   // # access new
    $ala = me&yio,Dot,'Allah'
    # &yio
    hat("&yio",{
        "returns what .ohe.e was": [
            ala.i('ohe','e','m'),
            ala.i('ohe','e','igla'),
            ala.i('ohe','e','m'),
        ],
        "uniq accumulate": [
            ala.i(['loth'],'e','m','ding'),
            ala.i(['loth'],'e','m','ding'),
            ala.i(['loth'],'e','m','dong'),
        ],
        "fod:1, frod++": [
            ala.i('fod'),
            ala.i(['frod'],1),
            ala.i(['frod'],1),
            ala.i(['frod'],1),
            # doesnt count!
            #ala.i(['frod'],3),
            ala.i('ohe','e','mot'),
        ],
        "m": ala.o('ohe','e','m'),
        "e": ala.o('ohe','e'),
        "!e": ala.o('e'),
        "all loth": ala.o('loth'),
        "fod:1": ala.o('fod'),
        "root": ala.o(),
        "is on Doty&...": Dot,
    })
    
   
  # misc() access
  # misc() hash
   // ahk()
    # &yio covers what it returns each time (was value)
    $aC = Cye(['bling',3])
    $notC = {}
    ahk(aC,'usual','scing','things',1)
    ahk(aC,'more',3,4)
    ahk(aC,'more',1,4)
    # allows just k,v
    ahk(aC,'moren',3)
    ahk(aC,'moren',1)
    ahk(aC,'moren',1)
    # < catch "listend!num"
    #ahk(aC,['moren'],1)
    ahk(aC,['mores'],1)
    ahk(aC,['cumu'],'la','place')
    ahk(aC,['cumu'],'la','loose')
    ahk(aC,['cumu'],'loose','ly')
    # samey
    ahk(aC,['cumu'],'la','loose')
    ahk(aC,['c'],'cumu','la','va')
    ahk(aC,['c'],'cumu','la','vava')
    ahk(aC,['y'],'cumula','ar')
    # samey
    ahk(aC,['y'],'cumula','ar')
    ahk(aC,['y'],'cumula','uniques')
    ahk(aC,['y'],'cumula','all')
    # see indexOf string!=num
    ahk(aC,['y'],'cumula',3)
    ahk(aC,['y'],'cumula','3')
    # < catch "listend!ar"
    #ahk(aC,['c'],'cumu','va')
    ahk(notC,'things','that','were','here')
    ahk(notC,'things','that','were','there')
    ahk(notC,['things'],'all','was','finiga')
    # starts adding to a number
    ahk(notC,['things'],'FROT','was','finiga',2)
    ahk(notC,['things'],'FROT','was','finiga',1)
    ahk(notC,['things'],'all','was','finigaL')
    # already exists
    ahk(notC,['things'],'all','was','finiga')
    
    # count
    ahk(notC,['things'],'all','was','3',1)
    ahk(notC,['things'],'all','was','3',1)
    ahk(notC,['things'],'all','was','3',1)
    # < but not add
    #ahk(notC,['things'],'all','was','3',3)
    
    ahk(notC,'vari','k',1)
    ahk(notC,'vari','k',1)
    ahk(notC,'y','varo',1)
    ahk(notC,'c','all','was','3',1)
    hat('ahk()',{
        aC,
        notC,
        "counts return": {
            "first": ahk(notC,['ret'],'friv',1),
            "then": ahk(notC,['ret'],'friv',1),
            "etc": ahk(notC,['ret'],'friv',1),
        }
    })
    
   // hashkv()
    # < an n@3 hook to pipe s through eg hashkv and arrange the results
    $abunch = {}
    $em = (t,s) => abunch[t] = s
    
    $abc = {aye:4,bee:3,cee:2}
    $disc = hashkv(haks(abc).map(k => ['the '+k,"said "+abc[k]]))
    em("remap",{abc,disc})

    em("ark:$v",
        hashkv('ark','$v'))
    # ! string object k
    em("'it' -> {it:1}",
        hashkv('it'))
    em("[[nc&sip,n]+] -> {'0 1 2':n}",
        hashkv([['0 1 2','One'],['0 1 2 1','Two']]))
    em("!N.length -> {}",
        hashkv([]))
    em("'key',{thing:1} -> {key:{thing:1}}",
        hashkv('key',{thing:1}))
        
    hat('hashkv()',abunch)
    abunch = {}
   // < # more type
    
   // # peel(), arq()
    em("one",peel("can"))
    em("two",peel("can,you"))
    em("two.5",peel("can,you:feel"))
    em("three, first : only",peel("the:lunch:tonight,that,was::fiver"))
   
    hat('peel()', abunch)
    abunch = {}
    
    try {
    em("already",
        arq({seeing:{theeing:"is"}},{qk:{seeing:1}}))
    # < catch
    #em("c.seeing!housey",
    #    arq({seeing:"lovely,ness"}, {qk:{seeing:1}}))
    em("put into",
        arq({thanks:3}, {qk:{seeing:1}}))
    em("!peel, put into",
        arq({thanks:"diat"}, {qk:{seeing:1},peely:1}))
    em("peel, put into 2",
        arq({thanks:"figaro,thjin:k"}, {qk:{seeing:1,thanks:1},peely:1}))
    em("peel some, dont put into",
        arq({thanks:"figaro,thjin:k",seeing:"fully:knowing,myself"},
            {qk:{seeing:1},peely:1}))
    em("peel, dont put into",
        arq({thanks:"figaro,thjin:k",seeing:{fully:2,five:5}},
            {qk:{seeing:1,thanks:1},peely:1}))
    
    em("see nothing",
        arq({thanks:"figaro,thjin:k",se:{fully:2,five:5}},
            {qk:{seeing:1},peely:1}))
    em("see nothing qk/$k=dept",
        arq({thanks:"figaro,thjin:k",se:{fully:2,five:5}},
            {qk:{seeing:'abranchof'},peely:1}))
    }
    # we dont expect an error
    catch(er) {
        bunch.an_error = ''+er
    }
    hat('arq()', abunch)
    abunch = {}
    
   // ex()
    # in ascending depth of s(.*)+
    # < or is that descending depth? slope
    hat('ex()',{
        "simple": ex(ex({},
            {ela:'borate',ti:3,glab:1}),
            {fly:1,ti:4,la:4,loose:{}}),
        "array !merge":
            ex({sh:['And','all']},
               {sh:['will','dwell']}),
        "s.*.* !merge":
            ex({and:{all:'will'},be:3},
           {s:3,and:{will:'dwell'},be:4}),
    })
    hat('mex()',{
        "simple same": mex(mex({},
            {ela:'borate',ti:3,glab:1}),
            {fly:1,ti:4,la:4,loose:{}}),
        "array merge":
            mex({sh:['And','all']},
               {sh:['will','dwell']}),
        "s.*.* !merge":
            mex({and:{all:'will'},be:3},
           {s:3,and:{will:'dwell'},be:4}),
    })
    hat('ex2()',{
        "simple same": ex2(ex2({},
            {ela:'borate',ti:3,glab:1}),
            {fly:1,ti:4,la:4,loose:{}}),
        "array merge":
            ex2({sh:['And','all'],also:{inhere:["ent"]}},
               {sh:['will','dwell'],also:{inhere:["able"]}}),
        "s.*.* merge":
            ex2({and:{all:'will'},be:3},
           {s:3,and:{will:'dwell'},be:4}),
        "s.* peel":
            ex2({and:'all:will',be:1},
           {s:3,and:{will:'dwell'},be:{there:'specifically'}}),
    })
    # and other
    $la = {will:'dwell',and:'all',vague:null}
    hat('*ex*()',{
        # only and
        'sex()': sex({},{will:'dwell',and:'all',vague:null},'and'),
        # all but will
        'nex()': nex({},{will:'dwell',and:'all',vague:null},'will'),
        # fit to print
        'tex()': tex({},{will:'dwell',and:'all',vague:null}),
        'tex() hashy': tex({},{will:'dwell',and:{let:3},vague:null},'and'),
        # definite
        'dex()': dex({},{will:'dwell',and:'all',vague:null,hash:{e:{s:{}}}}),
        # takes and out
        'tax()': {
            revenue: tax({},la,'and'),
            leaving: la,
        },
        # may peel
        'pex()': pex('and:all','will:brie'),
        # < get this all coded as individuated catchables
        #' unlike ex()': ex('and:all','will:brie'),
        
    })
    
    
   // # misc() array
    // data
        $Tom = <<''
            Long way going to
            Get my medicine
            Skys the autumn grey of a lonely wren
            
            Piano from a window played
            Gone tomorrow, gone yesterday
            
            I found it in the street
            At first I did not see
            Lying at my feet
            A trampled rose

        $h = hashkv(grep(Tom.split("\n")).map(s => split(s,' ',1)))
        
        
        
        
        
        
        
        $a = haks(h)
    
    # given c, no default c.inc=1
    # < return sliced hash..? already returns sliced arrays
    # < until, (til, aft), after
    #    io etc shall know... til(C) the T.iteration?
    #    and til1, aft1 for the :p/$s<1 maneuvre
    #     also looking for aft(tow)
    # < convert these to joint() the result
    #    once all the /(^\d+) -String "/ and /"\n/ in the patch
    #     can be identified as such
    $yesterday = v => v.includes('yesterday')
    hat('ksaf()',{
        origin: {h,a},
        'on hash': {
            until: ksaf(h,{bow:'Skys'}),
            til: ksaf(h,{bow:'Skys',inc:1}),
            aft: ksaf(h,'Gone'),
            after: ksaf(h,{aft:'Gone'}),
        },
        # < Textl notice ^ and v are mostly same!
        'on array': {
            until: ksaf(a,{bow:'Skys'}),
            til: ksaf(a,{bow:'Skys',inc:1}),
            aft: ksaf(a,'Gone'),
            after: ksaf(a,{aft:'Gone'}),
        },
        'where': {
            "after v~~/yesterday/":
                ksaf(h,{aft:yesterday}),
            "after v~~/yesterday/ til k~~'At'":
                ksaf(ksaf(h,{aft:yesterday}), {bow:'At',inc:1}),
            " same + hash sliced":
                sex({},h, ksaf(ksaf(h,{aft:yesterday}),
                    {bow:'At',inc:1})),
            "after v~~/yesterday/ til v~~/^L/ + hash sliced":
                sex({},h, ksaf(ksaf(h,{aft:yesterday}),
                    {bow:v => v.startsWith('L'),inc:1})),
            'until v~~/indo/':
                ksaf(h,{bow:(v) => v.includes('indo')}),
            'aft k~~/ing/':
                ksaf(h,{aft:(v,k) => k.includes('ing'),inc:2}),
        },
    })
    
    # < the above as range args to grep:
    #    $N = grep /yesterday/../^L/ 
    #    $N = grep ..(/^indo/) # range makes () less-selecting. usu more? <art.
    #    $N = grep ..k~~/ing/ # range makes bare k ok?
    hat('grep()',{
        "Piano": grep((v,k) => k == 'Piano',h),
        "no a": grep(v => !v.match('a'),h),
        "a value": grep('at my feet',h),
        "for truth": grep({la:1,non:0,li:4,fe:0}),
    })
    
    
    $N = [3,2,4,3,Cye(["la",3],2,1)]
    $l = N[3]
    hat('grap()',{
        # instead of writing (N||[]).includes(l)
        "yes": grap(l,N),
        "no": grap(56,N),
    })
    hat('grop()',{
        "little numbers": grop(v=>v<3,N),
        "are gone": N,
    })
    
    $aa = a.slice()
    hat('grepout()',{
        "Piano": grepout(aa,'Piano'),
        "is gone": joint(aa),
        "in array": grepout(aa,['At','The','Lying']),
        "are": joint(aa),
        "short|early keys": grepout(aa,(v,i) => hak(v)==1 || i < 3),
        "leaving only": aa
    })
    hat('split()',{
       'no limit': split("3,3,3,3,3,3",','),
       'limit=2': split("3,3,3,3,3,3",',',2),
       'regex': split("3,3,,,,3,,,3,,3,3",/,+/,3),
    })
    hat('flatten()',{
        "doc": flatten([1,[1,2]]),
        "N = z|N": flatten([[1]]),
    })
    $D = Cye(['thing',3])
    hat('joint() derived',{
        "nulls vanish": [
            cint(1,2,3,'',4),
            slant(1,null,3,0,5,-0,NaN,undefined,Infinity),
        ],
        "it works": cint(a),
        "ignores later args if isar(arg[0])": cint(a,D),
        "it works": cint(['Mix',D,'Sturct']),
    })

   // js trivia
    # javascript weirdnesses!
    // types
        
        $l = ['1', '2', '3']
        hat('indexOf string!=num',{l,li: l.indexOf(2) ,number_btw:9})

        # use before buy!
        l.map(&n{
            use = 3
            $use = n
        })
        # < Plying test output to here,
        #   generating blog with <code>1+1 # 2</code>
        hat('null <>-ier than undefined',{
            null_lt_6: null < 6,
            null_gt_6: null > 6,
            null_gt_neg6: null > -6,
            undef_lt_6: undefined < 6,
            undef_gt_6: undefined > 6,
            undef_gt_neg6: undefined > -6,
        })
        hat('more types',{
            'zero': [
                '' == 0,
                '0' == 0,
                '' == '0',
            ],
            'undef': [
                false == undefined,
                false == null,
                null == undefined,
            ]
        })
    
    // sub
        # has to be &{} to get arguments
        $disnobrack
        $set = &{
            disnobrack = (s) => dis([...arguments])
        }
        set("the args","to the sub defining the sub")
        $disbrack = &{ return dis([...arguments]) }
        hat('to get arguments',{
            "dont (...)=>{...}":
                disnobrack('yab','yob','yup'),
            "do &...{...}":
                disbrack('yab','yob','yup'),
            " one arg":
                disbrack('yab'),
            " no args":
                disbrack(),
        })
        
        // hash key order
        #  because of how javascript (v8) stores properties & elements
        #  keys that look like array indices (dec(s,0) == s) will come first
        #   eg assigning -2,-1,0 iterates 0,-2,-1
        #  ! anywhere we rely on hash key order might be affected
        
    
   // &indo etc
    # < see that M == &indo... &e{ return e } works like 3d grep
    # < &deL for tabless lines from the editor
    #    checks they are peely-types
    if (0) {
        $M = []
        # e** until !y&pack, to the point of eg e:elIntro
        me&indo,e (&ed{
            # an enveloping, at %JRom or so..? see elvoids
            ec&pack and return
            M.push(e)
            d.not = 1
        })
        return M
    }
   
S 4 @Gnome
    $h = A.h.o('Something')
    # eats C(y&R%wou), %wou, [n+]
    $ios = h.brack
 // dep processes
  // reself resync
    $This = me&Names_get,R,'This'
    $Fine = me&Names_get,R,'Fine'
    # uses the REy&main, aka sy&$pi:
    $This = Thisy&This
    $Nine = Cye(['TryNine','-nine'])
    # inflates Ness** from Fine/Ness**
        # isolating Ness < this one
        $stop = 0
        $copiq = {match:&nz{
            n.t == '-Gnome-4' and stop = 1
            stop and return
            return 1
        }}
    me&EsyncThe,Nine,Fine,{copiq}
    !Ninec&Into and throw "!Into"
        # isolating This** < now
        $clintoq = {match: &snz{
            # s:from(This|Eight) n:item(Eight|seven) z:to(Eis|Ei)
            s == This and return n.t.match(/^(Some(thing|act)|brackstract)$/)
            nc&pi != 'seven' and debugger
            # before this step
            return n.t < 4
        }}
    me&EsyncThis,Nine,Fine,{This,clintoq}
    
    # contain %dige, subject to change
    me&fiu,Nine,'The',9
    me&fiu,Nine,'This',9
    # can sometimes see %%next_Ness_title_clue (not after first Run)
    $next = delete Ninec&Into
    $Ness = me&fiu,Nine,'Ness',7
    me&fiu,Ness,next,9
    
    
    h.Bow('reself resync',{Nine},{nl:300})
    
  // diff stack finding
    $a = <<''
        1
         14
          a
         2
          3
          3b
          3c
    
    $b = <<''
        1
         14
          a
         2
          3
          3bc
          3c
    
    # las.t ends up being the R.t of the diff...  !
    me&mockdiffWomb,'diff-stack-finding',{},a,b
    
 
  // &Sharg saves the Bowler -Strings with &Stringchew
    $rg = me&Sharg,'$s/Someact/1/Bowler//E/-hat/*(R%String)//R',[This]
    $all = Cye(['sche',1])
    rg.N
        .map(n => me&fiu,all,n.t .sc.z = flatten(ns&M||[]))
    h.Womb("&Stringchew",all)
    
  // -hat data immediately
    # < look at the Yingulog!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #   first try only, comes back to see 'after'
    #    a couple of times as per %wakeful or so?
    $da = {here:'before'}
    da.stringstract = a
    h.hat("-hat data immediately",da,{funktime:1,first_truest:1})
    da.here = 'after'
    
  // passing ER%many_thresh
    # pushing back the %limit:many from 20
    $a = [...new Array(96)] .map(n => ' oOo')
    h.hat("can pass theshholds",{liter:{of:a}},{many_thresh:36})
    # < pointer -Lab (or h.hat c.TX?) can want things
    #    that would have come after the chop
    #    see %limit:many prioritises space for keen e
 
 // Doming
  // %%dome
    $t = h
    # < %opa doesnt undo on e:r?
    #    we don't %igV, only async drop -seven/*
    #    give R-seven %amnesia, so -six %igV?
    #     via nextlifesc + inheritsc?
    me&mockR,'art' (&Cr{
        $h = me&hajasute
        h.ha("Cartful:ness")
        h.ha("Artful:ness,dome:ze")
        h.ha("Artful:ness,dome:alism")
        ios('see art',C)
    }) (&Cr{
        $h = me&hajasute
        # simply added
        h.ha("Artful:ry")
        # with stuff from last time
        ios('see art 2',{
            "whole": C,
            'the old Artful': h.zaa("Artful"),
            'old+new Artful': h.jaa("Artful"),
        })
        
        h.ha("Artful:re,do,dome:ze")
        h.ha("Artful:re,de")
        # two generations of %%dome:ze, no traction yet
        ios('see art 2.1',{
            "whole": C,
        })
    }) (&Cr{
        $h = me&hajasute
        
        $first = h.jaa("Artful")
        h.ha("Artful:Wobsica,dome:alism")
        $next = h.jaa("Artful")
        ios('see art 3.1',{
            "first %%Artful, are recycled": first,
            "added to %%Artful, are all": next,
        })
        
        me&dome_traction,r,'alism'
        ios('see art 3.2',{
            "dome:alism has been redone": h.jaa("Artful"),
        })
        
        # el2 means delete olds even if no news
        me&dome_traction,r,'aside',{el:2}
        # without it, requires some new to displace them
        me&dome_traction,r,'ze'
        ios('see art 3.3',{
            "noop el2:unhad + no-news dome": h.jaa("Artful"),
        })
        
        me&dome_traction,r,'ze',{el:2}
        $then_gone = h.jaa("Artful")
        ios('see art 3.4',{
            "dome:ze gone": h.jaa("Artful"),
            "past still available":  h.zaa("Artful"),
            "whole": C,
        })
    }) (&Cr{
        $h = me&hajasute
        
        ios('see art 4',{
            "whole": C,
        })
    })
  // %%dome fork
    $v1 =
    me&mockR,'forks' (&Cr{
        $h = me&hajasute
        h.ha("Cartful:ness")
        h.ha("Artful:ness,dome:ze")
        ios('forks 1',C)
    })
    $v2 =
    v1(&Cr{
        $h = me&hajasute
        h.ha("Lute,dome:ze")
        ios('forks 2',C)
    })
    $v2_1 =
    v1(&Cr{
        $h = me&hajasute
        h.ha("Flake,dome:ze")
        ios('forks 2 1',C)
    })
    v2(&Cr{
        $h = me&hajasute
        h.ha("floops")
        ios('forks 3',C)
    })
    v2_1(&Cr{
        $h = me&hajasute
        h.ha("floops")
        ios('forks 3 1',C)
    })
  
  // %%rec & &hajadome
   # fair bit more complicated
   # < variation: no_hajasute=0 the whole time
   #   various %%rec,do stop happening due to &zaaj seeing %%rec traction
   // unit
    $unit = 1
    $no_hajasute = 1
    $title = ''
    $brainfront = &y{
        return &Cr{
            # mix %%dome=bf into every sute.ha(...)
            $sute = me&hajadome,r,{dome:'bf'}
            # and with %%rec &zaaj knowing, T.sute
            $Tap = me&Tap,{sute}
            $h = no_hajasute ? sute : me&hajasute
            
            $i = {}
            y (C,h,r,i)
            
            # %%rec computing
            sute.traction()
            delete T.hajasute
            # < move ^ to v via sute.packdown[]()?
            Tap()
            # and finish, as Ying would sort out all the pieces of the sun
            me&mockR_commit,r
            
            $say = "unit "+(title||unit)
            rs&ver != unit and say += '   r.'+rs&ver
            # < reverse expe(): it shrinks to whole if others. collapsy.
            $see = hak(i) ? ex(i,{whole:C}) : C
            $c = {}
            
            $six = ios(say,see,c)
            !title and unit += 1
            title = ''
        }
    }
    $neuro = &h{
        # every time
        # finds -> oughtta
        h.jaa('observe,finds') .map(&n{
            ns&stepula and return
            
            $v = ns&finds*1 + 2
            $more = v > 6 ? ',recind' : ''
            ns&once and more += ',once'
            h.ha("rec:do,oughtta:finds:"+v+more)
        })
        $c = "rec:do"
        # oughtta(finds) -> stepula
        $N = h.zaaj ? h.zaaj(c) : h.zaa(c)
        N.map(&n{
            if (ns&oughtta) {
                $finds = h.jaa(ns&oughtta)
                ns&once && hak(finds) and nc&drop = 1
                finds.map(&f{
                    $rec = "complete"
                    $firk = haks(f.sc)[1]
                    ns&recind and rec = daint(rec,cint(firk,f.sc[firk]))
                    h.ha(ex(
                        {rec,stepula:ns&oughtta},
                        {labels:joint(haks(f.sc))},
                    ))
                })
            }
        })
    }
   
   // 1
    $moreR =
    me&mockR,'unit' (brainfront(&Chr{
        h.ha("observe:casual,things:about")
        h.ha("Artful:ness,dome:ze")
        h.ha("Artful:ness,dome:al")
        neuro(h)
    }))
    (brainfront(&Chr{
        h.ha("observe:casual,things:about")
        # -> %%oughtta
        h.ha("observe:3,finds:4")
        # not finding:
        h.ha("unobserved:3,finds:4")
        # redome ze
        h.ha("Frypan,lapan,dome:ze")
        neuro(h)
    }))
    # 3
    (brainfront(&Chri{
        # %%rec still %%oughtta, would even from %%dome, now
        i["not &jaa finds"] = h.jaa('finds:4')
        i["are &zaa finds"] = h.zaa('finds:4')
        h.ha("observe:casual,things:around")
        # does jaa|zaa, sort of.
        i["lot &jaa,'finds',1"] = h.jaa('things',1)
        neuro(h)
        h.ha('finally')
        # a new %%rec,oughtta made from traction, not neuro
    }))
    (brainfront(&Chr{
        # %%rec still %%oughtta, %%dome would lose for neu:%%observe
        h.ha("observe:casual,things:about")
        # to find what we %%oughtta once we find a find!
        h.ha("observe:hedge,hedge,finds:6")
        neuro(h)
    }))
    (brainfront(&Chr{
        h.ha("observe:casual,sitars")
        h.ha("observe:jazz,jazz,band,finds:4")
        h.ha("observe:fafe,faff:3,band,finds:6")
        neuro(h)
    }))
   
   // 6
    # 6
    $x = {}
    $la = k => ahk(x,k,t.lasix)
    $thesix = &Chr{
        h.ha("observe:casual,sitars")
        # make %%oughtta:10|10|8
        h.ha("observe:lat,jazz,band,finds:8")
        h.ha("observe:long,operate,band,finds:8")
        #  latest %%rec:complete being:
        h.ha("observe:moreothat,moreothat,finds:6")
        # there are two &jaa %%oughtta:8
        #  if &zaaj, would be one
        # they share the hall of fame, on id-groupy %%rec
        neuro(h)
        h.ha("finality")
    }
    #no_hajasute = 1
    moreR (brainfront(thesix))
    la(6)
    
    title = '6 1 fork same'
    moreR (brainfront(thesix))
    la(61)
    
    $six = x[6]
    $ER = me&Sharg,'$s//E/.y.main//R',[six] .N[0]
    $before = {string:sixs&string,Rcv:sixy&R.y.cv,ERcv:ERy&cv}
    # wind up
    grep(six => me&finishPiing,six ,x)
    $ER = me&Sharg,'$s//E/.y.main//R',[six] .N[0]
    t.hat("to differance",{
        "there is no string before &finishPiing": before,
        "string after &finishPiing":
            {string:sixs&string,Rcv:sixy&R.y.cv,ERcv:ERy&cv},
        x,
    },{dl:3,first_truest:1})
    t.diff('6 1 is the same',x[6],x[61],'see')
    
    no_hajasute = 0
    title = '6 2 one zaaj oughtta'
    $nextR =
    moreR (brainfront(thesix))
    la(62)
    grep(six => me&finishPiing,six ,x)
    t.diff('6 2 different',x[6],x[62],'see')
    
   // 7
    # 7
    # seeing rec:select:long redoming and more
    nextR(brainfront(&Chr{
        h.ha("lalala")
        # this will be ignored by the &zaaj next time
        h.ha("observe:laser,shop,finds:4")
        neuro(h)
        h.ha("fin")
    }))
    (brainfront(&Chr{
        h.ha("observe:least,find")
        #  because these generate new %%rec:do (being redone|redomed)
        # < variation: on the above selectivity
        #   maybe this and last round, or everything since a certain wave
        # there are twice as many %%oughtta for 8 than for 6
        h.ha("observe:long,pirate,session,finds:8")
        h.ha("dealwitty,observe:this,itis,finds:6")
        h.ha("dealwata,observe:ata,ata,finds:6")
        # find != finds
        h.ha("observe:laser,shop,find:4")
        neuro(h)
        h.ha("fin")
    }))
    la(8)
    
    title = '7 1 prepare to finds:6 next time'
    nextR = nextR(brainfront(&Chr{
        h.ha("lalala")
        # this will be ignored by the &zaaj next time
        h.ha("observe:laser,shop,finds:4")
        neuro(h)
        h.ha("fin")
    }))
    title = '8 1 finds:6 if we finds:4 this time'
    nextR(brainfront(&Chr{
        h.ha("observe:least,find")
        # this will be in neuro()/&zaaj
        h.ha("observe:frivo,late,finds:4")
        h.ha("observe:long,pirate,session,finds:8")
        h.ha("dealwitty,observe:this,itis,finds:6")
        h.ha("dealwata,observe:ata,ata,finds:6")
        neuro(h)
        h.ha("fin")
    }))
    la(81)
    grep(six => me&finishPiing,six ,x)
    t.diff('only 8 1 finds:6',x[8],x[81],'see')
    
S 5 &sustain
    $h = A.h.o('sustain')
  
  // <
    # Jug fills, boils, held
    # Pot fills, rices
    $be = me&mockbrackR,'JugRice'
    be.Again(&Chir{
        h.ha('sing,song')
        h.ha('sing,notes')
        i.whole = 1
        #n Jug -Bow me&sustain,'Jug',{Full:1}
        i.Bow = {
            Jug: me&sustain,'Jug',{Full:1} ,
            Pot: me&sustain,'Pot',{Full:0} ,
        }
    })(&Chir{
        h.zaa('sing') .map(n => h.ha("loudly",n.sc))
        i.whole = 1
        i.Bow = {
            Jug: me&sustain,'Jug',{Full:1} ,
            # a.el=1 as v becomes|remains true
            Pot: me&sustain,'Pot',{Full:1} ,
        }
    })(&Chir{
        # &jaa,c,1 for either now or now-1
        i.all_notes = h.jaa('notes',1)
        i.whole = 1
        i.Bow = {
            Jug: me&sustain,'Jug',{Full:1} ,
            # a.el=2 since v changes amongst true
            Pot: me&sustain,'Pot',{Full:4} ,
        }
        h.zaa('notes') .map(n => h.ha("loudly",n.sc))
    })
    be.Again("differently",bec&_2,&Chir{
        h.zaa('notes') .map(n => h.ha("madly",n.sc))
        i.whole = 1
        i.Bow = {
            # a.el=10 as v becomes|remains false
            Jug: me&sustain,'Jug',{Full:0} ,
            Pot: me&sustain,'Pot',{Full:1} ,
        }
    })
    # < the idea of not deleting things
    #    they just have a final scene together, then are gone
    # < to select recent six by numbers in title?
    # < h.traction() won't sane more than once
    #  < will &dome_traction ?
    # < show %%dome, %%rec losing the order of things
    
    # < diff|Ply may concentrate on parts
    #    Ply usu has a diff, but could E**-select from a y&thing
    #     to then feed to a diff (and maybe further itself)
   
    # < grep({bow:&vki{}},f.sc) or grep({bowi:1},f.sc)
    #   grep bowk=$such $f
    #    such that grep cannot be used for C.*
    #     or C/* without expr: $f/
    #  < Babz floaty params for any known function like that
    #  < and for s&* not in c&shade.*
    #  # see neuro / $firk = ...
    # < sub() for &ha doing clone-from via q.base=$n
    #  # see neuro / h.ha(ex(
    
    
    
    
