# test, runs on W:Thy, 33
n doafew 1 s:Things!
$R = A.Run
$h = A.h
fatal.ish(h)
# < becoming Babz 'more of a title -Fez=>\n  ...'

    
S 1 test data for -hat ref noticing, limits, specialfx
    $h = A.h.o('Something')
        # $time-seven, as long as it contains something:
        # to make stuff up
        $dat = me&PiRet_data
        dat.moreso = dat.asee
        h.hat('Bowler',dat)



        $da = {more:'some',figaro:dat.asee}
        da.furhtin = {llatin:4}
        
        $links = {fig:'ure'}
        ahk(links,'with','in',links)
        # can Eref see its parents
        da.links = links
        da.lonk = links
        
        h.hat('Lol',da,{first_truest:1})
        # about to get a da.links.nowsays
        h.lasix.t != 'Lol' and debugger
        #me&finishPiing,h.lasix



        $da = {fer:dat.asee,even:'more',figaro:dat.asee}
        da.furhtin = {llabin:4}
        # < can Eref see its previous state change to now
        links.nowsays = 'this'
        da.libkit = links
        
        # test Rc&dl
        # < Babz each i 1..100 {
        $i = 0
        $ya = da
        while (i < 60) {
            ya = ya.th = {}
            i++
        }
        ya.is = 'all'
        # < &Eing preferring this to more level$n !
        #   diversity seeking
        $ej = da.neesd = Cye(['Nees',3,
            {mo:3,tor:68,
                functions:"of an elabourate sort",
                s:"Thsideratea"}
        ])
        ejy&fig = dat.asee
        ejy&vig = 2
        da.leveridge = Cye(['Nose',7,{s:'li'}])
        $i = 0
        # too many
        while (i < 55) {
            da['lever'+i] = 'thing'
            i++
        }
        h.hat('Room',da,{many_tail:2})
        # it knows where Room gave up!
        h.hat(' all th way',da.th,{dl:66})
        
    $h = A.h.o('Someact')
        $da = {as:dat.asee,fol:33,vanas:dat.asee,vaees:dat.asee}
        da.string = <<''
            Til
              forward
               motion
              was
               it
               all
            
            etc!
             etc
        
        $D = Cye(['Ling',1,{s:da.string},{}])
        da.encodes = me&enL,D
        da.spaceynum = num("  ")
        da.stringynum = num(" 0")
        da.verylong = new Array(100) .join('123-')
        $Bow = h.hat('Bowler',da)
        # lurkfa faing!onn.. fa
        

S 2 twos
    $h = A.h.o('brackstract')
    
    # < Tool for zooming into Ying-gate !!!
    
    #$s = 4s&interestoYing
    $s = me&mock_Thyergate,R
    !s || !ss&X and return me&tc,"awaits"
    ss&X.A != R and debugger
    # X by &bracki (ish), make &Shx_isX
    # < the &Shx p.ist('X') check is too silent
    me&brackstract,ss&X
    
    # < a holding X, knowing what format the inner might like
    each ks R.sc {
        !k.endsWith('W') && (!isob(s) || isC(s) || !isC(s.A)) and continue
        # the &Saturn %%inst,listen_node there coops these:
        $pi = k.endsWith('W') ? 'Womb' : 'Fez'
        
        h.tys(k,pi,s)
    }
    
S 3 Pictures hashy misc
    $h = A.h.o('Something')
    $hat = h.hat
    # < sample all calls to ahk() etc during a bunch of Stories
    #    keeping a taxography of all uses
    #     the data condenses a schema!!!!!!!!!!!!
   // modulat!
    # < T.act.t should be steppy?
    # < autogen C.t < argmo
    # < Babz 'n anyoldtext -Bow => &yada,&m{'
    #    DIY closing bracket etc
    #    should be possible, -Bow knowing how to interpret such a housing
    #    so c&s = c&code or so, during T.act of A:n
    #     which knows its proper title
    #    this is a nice realm
    #    we make the BQ a subroutine, mini-pin...
    #     so it may define handlers in the dome
    #     they would be on the ground..? receive calls on a telephone...
    #     also make them, on eg a lamp, that can be used to be the origin,
    #      to write the address relative to.
    #       carrier assurance of messages coming from elvis.
    #    the 'stricter title 33-Fez: %such:even =>'
    #     also. is BQ dependent?
    #    perhaps shorter 'n some = ...' # have to eval first? put in sub?
    #    or the 'n some i yo/plo//%chi' # some = any spheres with %chi across yo/plo
    #    and '$n o such/where' # notice !n
    #    then '$z o yer/$n' # still !n
    #    then 'i mixio/$n &quant $z' # fatal
    #     < wants empty spaces sometimes
    # < stub a bunch of ways as above! devob, mkv, etc
    h.Womb('&ts?c?', me&abTap,'Picmodu',Cye(['Picmodu',1]) (&{
        me&tsc,'becomes',0,'6y'
        me&tsc,'tos','','6g'
        me&tsc,'untos','la','6b'
        me&tsc,'basictsc','la'
        me&tsc,'moretsc','la','46yl'
        me&tc,"tctitle"
        me&tc,"tcstyle",'G'
        me&ts,"ts0",0,'6'
    }))
    h.Womb('boxcap_test_situation', me&abTap,'situa',Cye(['situa',1]) (&{
            $two = me&boxcap,"pile1",'1y'
                me&tc,"<"
                $three = me&boxcap,"yondsome",'1y'
                    me&tc,"insidde"
                three()
                me&tc,">"
            two()
            
            $two = me&boxcap,"pile2",'1y'
                $three = me&boxcap,"empty",'1y'
                three()
                me&tc,"outside"
            two()
            $two = me&boxcap,"Achgindi",'1y'
                me&tc,"stuff"
            two()
            $two = me&boxcap,"Achgindi",'1y',2
                me&tc,"stuff"
            two()
            $two = me&boxcap,"Achgindi",'1y'
                me&tc,"additional"
            two()
            $two = me&boxcap,"Achgindi",'1y',2
                me&tc,"andmore"
            two()
    }))
  
  # notes a heading in Pictures:
   // # types
    # < title as expr, expect true. just '!iske(44)' on a line.
    $D = Cye(['D',3])
    $Dot = Cye(['Dot','-Dot'])
    hat('Fividy types',{
        "isha({})": isha({}),
        # causes ish([])
        "isha([])": isha([]),
        "!isha(D)": isha(D),
        "isob({})": isha({}),
        "isR(R)": isR(R),
        "!isR(D)": isR(D),
        
        # avoid
        "sca(333)": sca(333),
        "sca(333.3)": sca(333.3),
        "dec(333.3)": dec(333.3),
        "dec(333)": dec(333),
        "dec('333')": dec('333'),
        # < more
    });
    hat('types',{
        "!isba(D)": isba(D),
        "isba(R)": isba(R),
        
        "iske(str)": iske('stri'),
        "iske(num)": iske(44),
        "iskeyish(num)": iskeyish(46),
        "!iske({})": iske({}),
        "!iske(null)": iske(null),
        # housey - looks like index
        "!ish(null)": ish(null),
        "!ish('str')": ish('str'),
        "!ish(D)": ish(D),
        "ish([])": ish([]),
        "ish({})": ish({}),
        
        "!isit({})": isit({}),
        "!isit([])": isit([]),
        "isit(D)": isit(D),
        "isit(str)": isit('str'),
        
        "!ispi(D)": ispi(D),
        "ispi(Dot)": ispi(Dot),
        "ispi(Dot,'Dot')": ispi(Dot,'Dot'),
        "!ispi(Dot,'Else')": ispi(Dot,'Else'),
    })
    # < fatal variations
   // # access new
    $ala = me&yio,Dot,'Allah'
    # &yio
    hat("&yio",{
        "returns what .ohe.e was": [
            ala.i('ohe','e','m'),
            ala.i('ohe','e','igla'),
            ala.i('ohe','e','m'),
        ],
        "uniq accumulate": [
            ala.i(['loth'],'e','m','ding'),
            ala.i(['loth'],'e','m','ding'),
            ala.i(['loth'],'e','m','dong'),
        ],
        "fod:1, frod++": [
            ala.i('fod'),
            ala.i(['frod'],1),
            ala.i(['frod'],1),
            ala.i(['frod'],1),
            # doesnt count!
            #ala.i(['frod'],3),
            ala.i('ohe','e','mot'),
        ],
        "m": ala.o('ohe','e','m'),
        "e": ala.o('ohe','e'),
        "!e": ala.o('e'),
        "all loth": ala.o('loth'),
        "fod:1": ala.o('fod'),
        "root": ala.o(),
        "is on Doty&...": Dot,
    })
    
   
  # misc() access
  # misc() hash
   // ahk()
    # &yio covers what it returns each time (was value)
    $aC = Cye(['bling',3])
    $notC = {}
    ahk(aC,'usual','scing','things',1)
    ahk(aC,'more',3,4)
    ahk(aC,'more',1,4)
    # allows just k,v
    ahk(aC,'moren',3)
    ahk(aC,'moren',1)
    ahk(aC,'moren',1)
    # < catch "listend!num"
    #ahk(aC,['moren'],1)
    ahk(aC,['mores'],1)
    ahk(aC,['cumu'],'la','place')
    ahk(aC,['cumu'],'la','loose')
    ahk(aC,['cumu'],'loose','ly')
    # samey
    ahk(aC,['cumu'],'la','loose')
    ahk(aC,['c'],'cumu','la','va')
    ahk(aC,['c'],'cumu','la','vava')
    ahk(aC,['y'],'cumula','ar')
    # samey
    ahk(aC,['y'],'cumula','ar')
    ahk(aC,['y'],'cumula','uniques')
    ahk(aC,['y'],'cumula','all')
    # see indexOf string!=num
    ahk(aC,['y'],'cumula',3)
    ahk(aC,['y'],'cumula','3')
    # < catch "listend!ar"
    #ahk(aC,['c'],'cumu','va')
    ahk(notC,'things','that','were','here')
    ahk(notC,'things','that','were','there')
    ahk(notC,['things'],'all','was','finiga')
    # starts adding to a number
    ahk(notC,['things'],'FROT','was','finiga',2)
    ahk(notC,['things'],'FROT','was','finiga',1)
    ahk(notC,['things'],'all','was','finigaL')
    # already exists
    ahk(notC,['things'],'all','was','finiga')
    
    # count
    ahk(notC,['things'],'all','was','3',1)
    ahk(notC,['things'],'all','was','3',1)
    ahk(notC,['things'],'all','was','3',1)
    # < but not add
    #ahk(notC,['things'],'all','was','3',3)
    
    ahk(notC,'vari','k',1)
    ahk(notC,'vari','k',1)
    ahk(notC,'y','varo',1)
    ahk(notC,'c','all','was','3',1)
    hat('ahk()',{
        aC,
        notC,
        "counts return": {
            "first": ahk(notC,['ret'],'friv',1),
            "then": ahk(notC,['ret'],'friv',1),
            "etc": ahk(notC,['ret'],'friv',1),
        }
    })
    
   // hashkv()
    # < an n@3 hook to pipe s through eg hashkv and arrange the results
    $abunch = {}
    $em = (t,s) => abunch[t] = s
    
    $abc = {aye:4,bee:3,cee:2}
    $disc = hashkv(haks(abc).map(k => ['the '+k,"said "+abc[k]]))
    em("remap",{abc,disc})

    em("ark:$v",
        hashkv('ark','$v'))
    # ! string object k
    em("'it' -> {it:1}",
        hashkv('it'))
    em("[[nc&sip,n]+] -> {'0 1 2':n}",
        hashkv([['0 1 2','One'],['0 1 2 1','Two']]))
    em("!N.length -> {}",
        hashkv([]))
    em("'key',{thing:1} -> {key:{thing:1}}",
        hashkv('key',{thing:1}))
        
    hat('hashkv()',abunch)
    abunch = {}
   // < # more type
    
   // # peel(), arq()
    em("one",peel("can"))
    em("two",peel("can,you"))
    em("two.5",peel("can,you:feel"))
    em("three, first : only",peel("the:lunch:tonight,that,was::fiver"))
   
    hat('peel()', abunch)
    abunch = {}
    
    try {
    em("already",
        arq({seeing:{theeing:"is"}},{qk:{seeing:1}}))
    # < catch
    #em("c.seeing!housey",
    #    arq({seeing:"lovely,ness"}, {qk:{seeing:1}}))
    em("put into",
        arq({thanks:3}, {qk:{seeing:1}}))
    em("!peel, put into",
        arq({thanks:"diat"}, {qk:{seeing:1},peely:1}))
    em("peel, put into 2",
        arq({thanks:"figaro,thjin:k"}, {qk:{seeing:1,thanks:1},peely:1}))
    em("peel some, dont put into",
        arq({thanks:"figaro,thjin:k",seeing:"fully:knowing,myself"},
            {qk:{seeing:1},peely:1}))
    em("peel, dont put into",
        arq({thanks:"figaro,thjin:k",seeing:{fully:2,five:5}},
            {qk:{seeing:1,thanks:1},peely:1}))
    
    em("see nothing",
        arq({thanks:"figaro,thjin:k",se:{fully:2,five:5}},
            {qk:{seeing:1},peely:1}))
    em("see nothing qk/$k=dept",
        arq({thanks:"figaro,thjin:k",se:{fully:2,five:5}},
            {qk:{seeing:'abranchof'},peely:1}))
    }
    # we dont expect an error
    catch(er) {
        bunch.an_error = ''+er
    }
    hat('arq()', abunch)
    abunch = {}
    
   // ex()
    # in ascending depth of s(.*)+
    # < or is that descending depth? slope
    hat('ex()',{
        "simple": ex(ex({},
            {ela:'borate',ti:3,glab:1}),
            {fly:1,ti:4,la:4,loose:{}}),
        "array !merge":
            ex({sh:['And','all']},
               {sh:['will','dwell']}),
        "s.*.* !merge":
            ex({and:{all:'will'},be:3},
           {s:3,and:{will:'dwell'},be:4}),
    })
    hat('mex()',{
        "simple same": mex(mex({},
            {ela:'borate',ti:3,glab:1}),
            {fly:1,ti:4,la:4,loose:{}}),
        "array merge":
            mex({sh:['And','all']},
               {sh:['will','dwell']}),
        "s.*.* !merge":
            mex({and:{all:'will'},be:3},
           {s:3,and:{will:'dwell'},be:4}),
    })
    hat('ex2()',{
        "simple same": ex2(ex2({},
            {ela:'borate',ti:3,glab:1}),
            {fly:1,ti:4,la:4,loose:{}}),
        "array merge":
            ex2({sh:['And','all'],also:{inhere:["ent"]}},
               {sh:['will','dwell'],also:{inhere:["able"]}}),
        "s.*.* merge":
            ex2({and:{all:'will'},be:3},
           {s:3,and:{will:'dwell'},be:4}),
        "s.* peel":
            ex2({and:'all:will',be:1},
           {s:3,and:{will:'dwell'},be:{there:'specifically'}}),
    })
    # and other
    $la = {will:'dwell',and:'all',vague:null}
    hat('*ex*()',{
        # only and
        'sex()': sex({},{will:'dwell',and:'all',vague:null},'and'),
        # all but will
        'nex()': nex({},{will:'dwell',and:'all',vague:null},'will'),
        # fit to print
        'tex()': tex({},{will:'dwell',and:'all',vague:null}),
        'tex() hashy': tex({},{will:'dwell',and:{let:3},vague:null},'and'),
        # definite
        'dex()': dex({},{will:'dwell',and:'all',vague:null,hash:{e:{s:{}}}}),
        # takes and out
        'tax()': {
            revenue: tax({},la,'and'),
            leaving: la,
        },
        # may peel
        'pex()': pex('and:all','will:brie'),
        # < get this all coded as individuated catchables
        #' unlike ex()': ex('and:all','will:brie'),
        
    })
   
   // # misc() array
    // data
        $Tom = <<''
            Long way going to
            Get my medicine
            Skys the autumn grey of a lonely wren
            
            Piano from a window played
            Gone tomorrow, gone yesterday
            
            I found it in the street
            At first I did not see
            Lying at my feet
            A trampled rose

        $h = hashkv(grep(Tom.split("\n")).map(s => split(s,' ',1)))
        
        
        
        
        
        
        
        $a = haks(h)
    
    # given c, no default c.inc=1
    # < return sliced hash..? already returns sliced arrays
    # < until, (til, aft), after
    #    io etc shall know... til(C) the T.iteration?
    #    and til1, aft1 for the :p/$s<1 maneuvre
    #     also looking for aft(tow)
    # < convert these to joint() the result
    #    once all the /(^\d+) -String "/ and /"\n/ in the patch
    #     can be identified as such
    $yesterday = v => v.includes('yesterday')
    hat('ksaf()',{
        origin: {h,a},
        'on hash': {
            until: ksaf(h,{bow:'Skys'}),
            til: ksaf(h,{bow:'Skys',inc:1}),
            aft: ksaf(h,'Gone'),
            after: ksaf(h,{aft:'Gone'}),
        },
        # < Textl notice ^ and v are mostly same!
        'on array': {
            until: ksaf(a,{bow:'Skys'}),
            til: ksaf(a,{bow:'Skys',inc:1}),
            aft: ksaf(a,'Gone'),
            after: ksaf(a,{aft:'Gone'}),
        },
        'where': {
            "after v~~/yesterday/":
                ksaf(h,{aft:yesterday}),
            "after v~~/yesterday/ til k~~'At'":
                ksaf(ksaf(h,{aft:yesterday}), {bow:'At',inc:1}),
            " same + hash sliced":
                sex({},h, ksaf(ksaf(h,{aft:yesterday}),
                    {bow:'At',inc:1})),
            "after v~~/yesterday/ til v~~/^L/ + hash sliced":
                sex({},h, ksaf(ksaf(h,{aft:yesterday}),
                    {bow:v => v.startsWith('L'),inc:1})),
            'until v~~/indo/':
                ksaf(h,{bow:(v) => v.includes('indo')}),
            'aft k~~/ing/':
                ksaf(h,{aft:(v,k) => k.includes('ing'),inc:2}),
        },
    })
    
    # < the above as range args to grep:
    #    $N = grep /yesterday/../^L/ 
    #    $N = grep ..(/^indo/) # range makes () less-selecting. usu more? <art.
    #    $N = grep ..k~~/ing/ # range makes bare k ok?
    hat('grep()',{
        "Piano": grep((v,k) => k == 'Piano',h),
        "no a": grep(v => !v.match('a'),h),
        "a value": grep('at my feet',h),
        "for truth": grep({la:1,non:0,li:4,fe:0}),
    })
    
    
    $N = [3,2,4,3,Cye(["la",3],2,1)]
    $l = N[3]
    hat('grap()',{
        # instead of writing (N||[]).includes(l)
        "yes": grap(l,N),
        "no": grap(56,N),
    })
    hat('grop()',{
        "little numbers": grop(v=>v<3,N),
        "are gone": N,
    })
    
    $aa = a.slice()
    hat('grepout()',{
        "Piano": grepout(aa,'Piano'),
        "is gone": joint(aa),
        "in array": grepout(aa,['At','The','Lying']),
        "are": joint(aa),
        "short|early keys": grepout(aa,(v,i) => hak(v)==1 || i < 3),
        "leaving only": aa
    })
    hat('split()',{
       'no limit': split("3,3,3,3,3,3",','),
       'limit=2': split("3,3,3,3,3,3",',',2),
       'regex': split("3,3,,,,3,,,3,,3,3",/,+/,3),
    })
    hat('flatten()',{
        "doc": flatten([1,[1,2]]),
        "N = z|N": flatten([[1]]),
    })
    $D = Cye(['thing',3])
    hat('joint() derived',{
        "nulls vanish": [
            cint(1,2,3,'',4),
            slant(1,null,3,0,5,-0,NaN,undefined,Infinity),
        ],
        "it works": cint(a),
        "ignores later args if isar(arg[0])": cint(a,D),
        "it works": cint(['Mix',D,'Sturct']),
    })

   // js trivia
    # javascript weirdnesses!
    // types
        $l = ['1', '2', '3',1]
        hat('indexOf string!=num',{l,
            for_num_1: l.indexOf(1),
            for_string_1: l.indexOf('1'),
            for_num_2: l.indexOf(2),
            for_string_2: l.indexOf('2'),
        })

        # use before buy!
        l.map(&n{
            use = 3
            $use = n
        })
        
        # < Plying test output to here,
        #   generating blog with <code>1+1 # 2</code>
        hat('null <>-ier than undefined',{
            null_lt_6: null < 6,
            null_gt_6: null > 6,
            null_gt_neg6: null > -6,
            undef_lt_6: undefined < 6,
            undef_gt_6: undefined > 6,
            undef_gt_neg6: undefined > -6,
        })
        hat('null mathsier than undefined',{
            "5+null": 5+null,
            "5+undefined": 5+undefined,
            # right way:
            "5+(undefined||0)": 5+(undefined||0),
        })
        
        hat('more types',{
            'zero': [
                '' == 0,
                '0' == 0,
                '' == '0',
            ],
            'undef': [
                false == undefined,
                false == null,
                null == undefined,
            ]
        })
    // hash key order
        #  because of how javascript (v8) stores properties & elements
        #  keys that look like array indices (dec(s,0) == s) will come first
        #   eg assigning -2,-1,0 iterates 0,-2,-1
        #  ! anywhere we rely on hash key order might be affected
        $hash = peel("and:all,will:be,we:ll")
            # ~$v keeps order of $k
            hash.and = '...all!'
            # numbers go first, in numeric order
            hash.3 = 'dun'
            #  only if they look like array indices
            hash[3.14159] = 'dun'
            # type coercy, unlike Array.indexOf()
            hash['1'] = 'dunn'
            # on the end
            hash.flower = '?'
            # gone + come again resets order of $k
            delete hash.will
            hash.will = 'vee'  
            hash.vil = 'la'  
        hat('key order',hash)
        
        # and more of a stylehouse quirk,
        #  
        hat('isha([])',isha([]))
    
    // sub
        # has to be &{} to get arguments
        $disnobrack
        $set = &{
            disnobrack = (s) => dis([...arguments])
        }
        set("the args","to the sub defining the sub")
        $disbrack = &{ return dis([...arguments]) }
        hat('to get arguments',{
            "dont (...)=>{...}":
                disnobrack('yab','yob','yup'),
            "do &...{...}":
                disbrack('yab','yob','yup'),
            " one arg":
                disbrack('yab'),
            " no args":
                disbrack(),
        })
        
        if (0) {
            # < catch error
            # ran into this while debugging 'zygomorph &Ereftakedown'
            #  see 'doesnt fully solve the &Rcrux panic after &forgetRunStep'
            # it seems javascript was optimising away lexicals no longer referred to
            #  this can be seen in &Rcrux_seek / # < supposed to be deleted
            #   trying to set rr again keeps it undefined, renaming rrr works
            #  so good: accessing C.*.* should be fatal if !isC(C)
            $ina = &rl,rr{
                if (rl.sc.Pier && rr.sc.Pier) {
                    return 0
                }
                return 1
            }
            hat('if (properties of undefs)',{
                "are fatal": ina(),
            })
        }
        
        
    
   // &indo etc
    # < see that M == &indo... &e{ return e } works like 3d grep
    # < &deL for tabless lines from the editor
    #    checks they are peely-types
    if (0) {
        $M = []
        # e** until !y&pack, to the point of eg e:elIntro
        me&indo,e (&ed{
            # an enveloping, at %JRom or so..? see elvoids
            ec&pack and return
            M.push(e)
            d.not = 1
        })
        return M
    }
   
S 4 @Gnome
    $h = A.h.o('Something')
    # eats C(y&R%wou), %wou, [n+]
    $ios = h.brack
 // dep processes
  // reself resync
    $This = me&Names_get,R,'This'
    $Fine = me&Names_get,R,'Fine'
    # uses the REy&main, aka sy&$pi:
    $This = Thisy&This
    $Nine = Cye(['TryNine','-nine'])
    # inflates Ness** from Fine/Ness**
        # isolating Ness < this one
        $stop = 0
        $copiq = {match:&nz{
            n.t == '-Gnome-4' and stop = 1
            stop and return
            return 1
        }}
    me&EsyncThe,Nine,Fine,{copiq}
    !Ninec&Into and throw "!Into"
        # isolating This** < now
        $clintoq = {match: &snz{
            # s:from(This|Eight) n:item(Eight|seven) z:to(Eis|Ei)
            s == This and return n.t.match(/^(Some(thing|act)|brackstract)$/)
            nc&pi != 'seven' and debugger
            # before this step
            return n.t < 4
        }}
    me&EsyncThis,Nine,Fine,{This,clintoq}
    
    # contain %dige, subject to change
    me&fiu,Nine,'The',9
    me&fiu,Nine,'This',9
    # can sometimes see %%next_Ness_title_clue (not after first Run)
    $next = delete Ninec&Into
    $Ness = me&fiu,Nine,'Ness',7
    me&fiu,Ness,next,9
    
    
    h.Bow('reself resync',{Nine},{nl:300})
    
  // diff stack finding
    $a = <<''
        1
         14
          a
         2
          3
          3b
          3c
    
    $b = <<''
        1
         14
          a
         2
          3
          3bc
          3c
    
    # las.t ends up being the R.t of the diff...  !
    me&mockdiffWomb,'diff-stack-finding',{},a,b
    
 
  // &Sharg saves the Bowler -Strings with &Stringchew
    $rg = me&Sharg,'$s/Someact/1/Bowler//E/-hat/*(R%String)//R',[This]
    $all = Cye(['sche',1])
    rg.N
        .map(n => me&fiu,all,n.t .sc.z = flatten(ns&M||[]))
    h.Womb("&Stringchew",all)
    
  // -hat data immediately
    # < look at the Yingulog!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #   first try only, comes back to see 'after'
    #    a couple of times as per %wakeful or so?
    $da = {here:'before'}
    da.stringstract = a
    h.hat("-hat data immediately",da,{funktime:1,first_truest:1})
    da.here = 'after'
    
  // passing ER%many_thresh
    # pushing back the %limit:many from 20
    $a = [...new Array(96)] .map(n => ' oOo')
    h.hat("can pass theshholds",{liter:{of:a}},{many_thresh:36})
    # < pointer -Lab (or h.hat c.TX?) can want things
    #    that would have come after the chop
    #    see %limit:many prioritises space for keen e
 
 // Doming
  // %%dome
    $t = h
    # < %opa doesnt undo on e:r?
    #    we don't %igV, only async drop -seven/*
    #    give R-seven %amnesia, so -six %igV?
    #     via nextlifesc + inheritsc?
    me&mockR,'art' (&Cr{
        $h = me&hajasute
        h.ha("Cartful:ness")
        h.ha("Artful:ness,dome:ze")
        h.ha("Artful:ness,dome:alism")
        ios('see art',C)
    }) (&Cr{
        $h = me&hajasute
        # simply added
        h.ha("Artful:ry")
        # with stuff from last time
        ios('see art 2',{
            "whole": C,
            'the old Artful': h.zaa("Artful"),
            'old+new Artful': h.jaa("Artful"),
        })
        
        h.ha("Artful:re,do,dome:ze")
        h.ha("Artful:re,de")
        # two generations of %%dome:ze, no traction yet
        ios('see art 2.1',{
            "whole": C,
        })
    }) (&Cr{
        $h = me&hajasute
        
        $first = h.jaa("Artful")
        h.ha("Artful:Wobsica,dome:alism")
        $next = h.jaa("Artful")
        ios('see art 3.1',{
            "first %%Artful, are recycled": first,
            "added to %%Artful, are all": next,
        })
        
        me&dome_traction,r,'alism'
        ios('see art 3.2',{
            "dome:alism has been redone": h.jaa("Artful"),
        })
        
        # el2 means delete olds even if no news
        me&dome_traction,r,'aside',{el:2}
        # without it, requires some new to displace them
        me&dome_traction,r,'ze'
        ios('see art 3.3',{
            "noop el2:unhad + no-news dome": h.jaa("Artful"),
        })
        
        me&dome_traction,r,'ze',{el:2}
        $then_gone = h.jaa("Artful")
        ios('see art 3.4',{
            "dome:ze gone": h.jaa("Artful"),
            "past still available":  h.zaa("Artful"),
            "whole": C,
        })
    }) (&Cr{
        $h = me&hajasute
        
        ios('see art 4',{
            "whole": C,
        })
    })
  // %%dome fork
    $v1 =
    me&mockR,'forks' (&Cr{
        $h = me&hajasute
        h.ha("Cartful:ness")
        h.ha("Artful:ness,dome:ze")
        ios('forks 1',C)
    })
    $v2 =
    v1(&Cr{
        $h = me&hajasute
        h.ha("Lute,dome:ze")
        ios('forks 2',C)
    })
    $v2_1 =
    v1(&Cr{
        $h = me&hajasute
        h.ha("Flake,dome:ze")
        ios('forks 2 1',C)
    })
    v2(&Cr{
        $h = me&hajasute
        h.ha("floops")
        ios('forks 3',C)
    })
    v2_1(&Cr{
        $h = me&hajasute
        h.ha("floops")
        ios('forks 3 1',C)
    })
  
  // %%rec & &hajadome
   # fair bit more complicated
   # < variation: no_hajasute=0 the whole time
   #   various %%rec,do stop happening due to &zaaj seeing %%rec traction
   // unit
    $unit = 1
    $no_hajasute = 1
    $title = ''
    $brainfront = &y{
        return &Cr{
            # mix %%dome=bf into every sute.ha(...)
            $sute = me&hajadome,r,{dome:'bf'}
            # and with %%rec &zaaj knowing, T.sute
            $Tap = me&Tap,{sute}
            $h = no_hajasute ? sute : me&hajasute
            
            $i = {}
            y (C,h,r,i)
            
            # %%rec computing
            sute.traction()
            delete T.hajasute
            # < move ^ to v via sute.packdown[]()?
            Tap()
            # and finish, as Ying would sort out all the pieces of the sun
            me&mockR_commit,r
            
            $say = "unit "+(title||unit)
            rs&ver != unit and say += '   r.'+rs&ver
            # < reverse expe(): it shrinks to whole if others. collapsy.
            $see = hak(i) ? ex(i,{whole:C}) : C
            $c = {}
            
            $six = ios(say,see,c)
            !title and unit += 1
            title = ''
        }
    }
    $neuro = &h{
        # every time
        # finds -> oughtta
        h.jaa('observe,finds') .map(&n{
            ns&stepula and return
            
            $v = ns&finds*1 + 2
            $more = v > 6 ? ',recind' : ''
            ns&once and more += ',once'
            h.ha("rec:do,oughtta:finds:"+v+more)
        })
        $c = "rec:do"
        # oughtta(finds) -> stepula
        $N = h.zaaj ? h.zaaj(c) : h.zaa(c)
        N.map(&n{
            if (ns&oughtta) {
                $finds = h.jaa(ns&oughtta)
                ns&once && hak(finds) and nc&drop = 1
                finds.map(&f{
                    $rec = "complete"
                    $firk = haks(f.sc)[1]
                    ns&recind and rec = daint(rec,cint(firk,f.sc[firk]))
                    h.ha(ex(
                        {rec,stepula:ns&oughtta},
                        {labels:joint(haks(f.sc))},
                    ))
                })
            }
        })
    }
   
   // 1
    $moreR =
    me&mockR,'unit' (brainfront(&Chr{
        h.ha("observe:casual,things:about")
        h.ha("Artful:ness,dome:ze")
        h.ha("Artful:ness,dome:al")
        neuro(h)
    }))
    (brainfront(&Chr{
        h.ha("observe:casual,things:about")
        # -> %%oughtta
        h.ha("observe:3,finds:4")
        # not finding:
        h.ha("unobserved:3,finds:4")
        # redome ze
        h.ha("Frypan,lapan,dome:ze")
        neuro(h)
    }))
    # 3
    (brainfront(&Chri{
        # %%rec still %%oughtta, would even from %%dome, now
        i["not &jaa finds"] = h.jaa('finds:4')
        i["are &zaa finds"] = h.zaa('finds:4')
        h.ha("observe:casual,things:around")
        # does jaa|zaa, sort of.
        i["lot &jaa,'finds',1"] = h.jaa('things',1)
        neuro(h)
        h.ha('finally')
        # a new %%rec,oughtta made from traction, not neuro
    }))
    (brainfront(&Chr{
        # %%rec still %%oughtta, %%dome would lose for neu:%%observe
        h.ha("observe:casual,things:about")
        # to find what we %%oughtta once we find a find!
        h.ha("observe:hedge,hedge,finds:6")
        neuro(h)
    }))
    (brainfront(&Chr{
        h.ha("observe:casual,sitars")
        h.ha("observe:jazz,jazz,band,finds:4")
        h.ha("observe:fafe,faff:3,band,finds:6")
        neuro(h)
    }))
   
   // 6
    # 6
    $x = {}
    $la = k => ahk(x,k,t.lasix)
    $thesix = &Chr{
        h.ha("observe:casual,sitars")
        # make %%oughtta:10|10|8
        h.ha("observe:lat,jazz,band,finds:8")
        h.ha("observe:long,operate,band,finds:8")
        #  latest %%rec:complete being:
        h.ha("observe:moreothat,moreothat,finds:6")
        # there are two &jaa %%oughtta:8
        #  if &zaaj, would be one
        # they share the hall of fame, on id-groupy %%rec
        neuro(h)
        h.ha("finality")
    }
    #no_hajasute = 1
    moreR (brainfront(thesix))
    la(6)
    
    title = '6 1 fork same'
    moreR (brainfront(thesix))
    la(61)
    
    $six = x[6]
    $ER = me&Sharg,'$s//E/.y.main//R',[six] .N[0]
    $before = {string:sixs&string,Rcv:sixy&R.y.cv,ERcv:ERy&cv}
    # wind up
    grep(six => me&finishPiing,six ,x)
    $ER = me&Sharg,'$s//E/.y.main//R',[six] .N[0]
    t.hat("to differance",{
        "there is no string before &finishPiing": before,
        "string after &finishPiing":
            {string:sixs&string,Rcv:sixy&R.y.cv,ERcv:ERy&cv},
        x,
    },{dl:3,first_truest:1})
    t.diff('6 1 is the same',x[6],x[61],'see')
    
    no_hajasute = 0
    title = '6 2 one zaaj oughtta'
    $nextR =
    moreR (brainfront(thesix))
    la(62)
    grep(six => me&finishPiing,six ,x)
    t.diff('6 2 different',x[6],x[62],'see')
    
   // 7
    # 7
    # seeing rec:select:long redoming and more
    nextR(brainfront(&Chr{
        h.ha("lalala")
        # this will be ignored by the &zaaj next time
        h.ha("observe:laser,shop,finds:4")
        neuro(h)
        h.ha("fin")
    }))
    (brainfront(&Chr{
        h.ha("observe:least,find")
        #  because these generate new %%rec:do (being redone|redomed)
        # < variation: on the above selectivity
        #   maybe this and last round, or everything since a certain wave
        # there are twice as many %%oughtta for 8 than for 6
        h.ha("observe:long,pirate,session,finds:8")
        h.ha("dealwitty,observe:this,itis,finds:6")
        h.ha("dealwata,observe:ata,ata,finds:6")
        # find != finds
        h.ha("observe:laser,shop,find:4")
        neuro(h)
        h.ha("fin")
    }))
    la(8)
    
    title = '7 1 prepare to finds:6 next time'
    nextR = nextR(brainfront(&Chr{
        h.ha("lalala")
        # this will be ignored by the &zaaj next time
        h.ha("observe:laser,shop,finds:4")
        neuro(h)
        h.ha("fin")
    }))
    title = '8 1 finds:6 if we finds:4 this time'
    nextR(brainfront(&Chr{
        h.ha("observe:least,find")
        # this will be in neuro()/&zaaj
        h.ha("observe:frivo,late,finds:4")
        h.ha("observe:long,pirate,session,finds:8")
        h.ha("dealwitty,observe:this,itis,finds:6")
        h.ha("dealwata,observe:ata,ata,finds:6")
        neuro(h)
        h.ha("fin")
    }))
    la(81)
    grep(six => me&finishPiing,six ,x)
    t.diff('only 8 1 finds:6',x[8],x[81],'see')
    
S 5 &sustain
    $h = A.h.o('sustain')
    A.h.sixc = 'expectλ'
  // JugRice
    # sustain Jug|Pot:$v over time...
    $be = me&mockbrackR,'JugRice'
    be.Again(&Chir{
        h.ha('sing,song')
        h.ha('sing,notes')
        #n Jug -Bow &sustain,'Jug',{Full:1}
        i.Bow = {
            Jug: me&sustain,'Jug',{Full:1} ,
            Pot: me&sustain,'Pot',{Full:0} ,
        }
    })(&Chir{
        h.zaa('sing') .map(n => h.ha("loudly",n.sc))
        i.Bow = {
            Jug: me&sustain,'Jug',{Full:1} ,
            # a.el=1 as v becomes|remains true
            Pot: me&sustain,'Pot',{Full:1} ,
        }
    })(&Chir{
        # &jaa,c,1 for either now or now-1
        i.all_notes = h.jaa('notes',1)
        i.Bow = {
            Jug: me&sustain,'Jug',{Full:1} ,
            # a.el=2 since v changes amongst true
            Pot: me&sustain,'Pot',{Full:4} ,
        }
        h.zaa('notes') .map(n => h.ha("loudly",n.sc))
    })
    be.Again("differently",bec&_2,&Chir{
        h.zaa('notes') .map(n => h.ha("madly",n.sc))
        i.Bow = {
            # a.el=10 as v becomes|remains false
            Jug: me&sustain,'Jug',{Full:0} ,
            Pot: me&sustain,'Pot',{Full:1} ,
        }
    })
  
  // RiceDay
   // unit
    $be = me&mockbrackR,'RiceDay'
    # < i.* all lexicals as:
    #be.i_pi = 'hat'
    $day = 1
    $luck = 1
    $equipment = 0
    be.main = &Chir{
        
        # o having rice, may remember per day
        $magic = luck && h.zaa('situation:no rice')
            .length ? 66 : 0
        $have = be.have = me&sustain,{day},{RiceDay:magic}
        
        h.ha("Things,do:i")
        $Jugging
        if (have.el > 8) {
            # no rice
            # < supermind would wait for ** before re-Jugging
            if (equipment
                && !hak( me&sustaining,'Jugging' )
                && !hak( me&sustaining,'Pot' )) {
                Jugging = me&sustain,{},{Jugging:1}
                Jugging.temp ||= 16
            }
        }
        # o winding up Juggings
        #  as opposed to i winding up, for more unfold
        #  ie we don't &sustain Jugging|Pot after enacting it
        me&sustaining,'Jugging' .map(&a,{
            Jugging ||= a
            Jugging != a and throw "Jugs?"
            have.el < 9 and return a.done({u:have})
            a.temp += 30
        })
        if (Jugging && Jugging.temp >= 100) {
            # Jug -> Pot
            $Pot = me&sustain,{},{Pot:1}
            Jugging.done({n:Pot})
            Jugging.shouldbegone = "Jug"
            # the food has careful labels
            Pot.began ||= {day,ver:rs&ver}
            # < ideally this would show Jug done?
            i.zaarec = [...h.zaa('rec')]
        }
        me&sustaining,'Pot' .map(&Pot,{
            # pot takes one r to cook
            if (Pot.began.ver < rs&ver) {
                # cant take days to cook
                $s = {day:Pot.began.day}
                $c = {RiceDay:1}
                have = me&sustain,s,c
                # we have posited such the $day, so...
                Pot.done({u:have})
                Pot.shouldbegone = 1
                
                h.ha("cooking:done",
                    {began:Pot.began.ver,now:rs&ver})
            }
            else {
                h.ha("cooking:now",
                    {began:Pot.began.ver,now:rs&ver})
            }
        })
        
        
        #i.Bow = {have}
        h.ha({day,situation: have.el < 9 ? "rice" : "no rice" })
    }
   // # 1
    # < the -Bow a.sustain could do with rearranging lines
    #   about having one odd type|geo-magnitude
    #   the small things first
    #   mirage thingo sym (~) tells of the reorder
    #    usu pointing to original position of big thing
    #     if 1-2 of them, that can column
    #     depending on the rigidity of certain innards,
    #      eg diffsplay
    be.do()
    # something made rice!
    be.do()
    # 3
    # still have rice, found keying by $day+'RiceDay'
    # < some record or deal about $v going el:9
    luck = 0
    be.do()
    # something happens to the rice!
    # < what from whom?
    # < merely go el=9??
    be.have.done()
    be.do()
    be.do()
    # luck returns, have rice again
    luck = 1
    be.do()
   // # 7
    # the rules of the universe change,
    #  now!
    luck = 0
    equipment = 1
    be.have.done()
    be.do("start Jugging")
    be.do()
    # takes all day to boil Jug
    day = 2
    be.do("into the Pot")
    # 10
    # Jugging not restarting while Pot is cooking
    be.do("Pot is ready")
    be.do("still have rice")
    be.do("yet more")
    # a day!
    day = 3
    be.do("day three")
    be.do()
    # 15
    # magically have rice, done Jugging
    luck = 1
    be.do("luck had, done Jugging")
    luck = 0
    be.do(bec&_14,"without luck, into Pot")
    be.do("mockbrackR Further from that fork")
    
    
    #  < from seeing historical a.sublated?
    #    a vote for %%sustain somewhat remaining...
    #   or is this when you would use &sustrain?
    # < done(a.sublated={u:Upward_Process}), a.el=11?
    #    see the notions of u|n amongst Gump/*
    #  < args like that of &strange|&wants|&waits
    #    they could be string message and|or hash of relations
    
    # < dethrow having w:TryPiWarmer
    # < drop the == elIntro on init
    # < drop the %dodge on init
    
    # < DeckChair puts Gnome to work
    #   would interpret activity, actuate:
    # < make RunStep%dodge redo first next time
    #    by 4s&whereGnome[$t][$S]
    #  < -nine seems to "waitsfor:Try@1"
    #  < and various other memorables, holding:
    #     various other settings, start as buttons
    #      wired up the slope to be more permanent
    #      should be easy to cause|effect Lab,The,This,
    
    # < CacophanyDescriber sprouts in This**
    #   is for self-diffs (CED** vs D** expected)
    #   and laterals: any good chunks of similarity
    #   should notice when array inserts cause i++ ripple
    #   and of course show whole -brack to make tidier patch
    #    unless it really looks like the same thing mutating
    #    negating the encoded-ness
    #   train on:
    #    886d21ed02135d1e9 - lose all the have, unindent
    #    7325462e30095219 - see day++ for v9 (was v10)
    
    # community: remark (i $s/**-rem) highly removable thing that you i to the code
    # < give Ying some more speed
    # < Accept yay chunks for now
    #    helps make commits more coherent,
    #    accumulate aggreeable parts of -six** til all good
    # < want %eph HEAD..HEAD^1 diff ongoingly (Yinguto?)
    
    # < a.n could point to the last true one?
    #   ny&future always the latest, so .done() knows
    
    # < ex(s,c+)
    # < fatal.isfu() etc returning the thing
    # < &Ay for climbing up and around
    #    finding s as a limit:ref amongst s^^
  // Waters
    # < turn off the water when the filter isn't running
  // CodeUp
    # the projection of change into ...
    =use of &sustain so far
     < and where it could be used
     
    =elIntro was
        elIntro_i e:elIntro(/$Q), makes idc $gs:
        elIntro s=v=$gs
       &sustaining,'elIntro' a, still aka $gs ->
        < realise source revoked, see 'poison mode'
        IncBefore s=$gs,v=1
         if el==2 (first)
          return &wants @Inc
        IncAfter s=$gs,v=R%is_quiet
         if el>8 (not quiet)
          return a.pur
         any gs.steps:
        RunStep s=$gs,v=$S
         
    =RunStep was
      having:
        RunStep s=$gs,v=$S
         as above
        RunStep v=time
         is randomly from buttons or autostart|through
      &rowcap RunStep:
        < ~Fe, diag|help about it
          we some simply push on, end up Ness++ (Fe to us)
          similarly:
          < ~ninec&Into (not per RunStep), could be -Lab next?
            would know if next is Run-syncable, plan speedrun
        < ~quiettime, by counting R%quiet
          ie sustain driving time:quiet++
           and binding a particular time to it,
           supposing it is A piling up X for other A
        < ~unsure, sum lots of inputs, eg quiettime el=10
      # then joins RunningStep=$S as $any
        < needing !unsure to compute any >@5
          ie not while This>Fine
        < Fugue: notice going dodgy
           could be done while unsure, unquiet
           check Ply works out, log it all
      # it occasionally will:
       &dotheRunStep:
        RunningStep v=$S
         also knows quiet time
         < etc, it has a time itself
           commits to it snapshots of other time around it
         < this becoming 
         starts only, dropped by:
      # notice starting, completing, etc
        < merely sublate each RunningStep, like being @8
          once Fe OK for it
          it would have delta profiling etc
         < list of stuff to chuck if lowmem
        RunStep v=$S+1
         orders the next step if %through
    < whats &eisa?
        
    =cut
  
  // etc
    # < Gnow() possibly with timetravel
    #    to use fetime + delta since engaging in timetravel
    # < peel() that 'th:ing=s' -> {th:{ing:'s'}}
    # < peel() that 'th=ing=s' -> {th:'s',ing:'s'}
    
    # < the idea of not deleting things
    #    they just have a final scene together, then are gone
    # < h.traction() won't sane more than once
    #  < will &dome_traction ?
    # < show %%dome, %%rec losing the order of things
    
    # < diff|Ply may concentrate on parts
    #    Ply usu has a diff, but could E**-select from a y&thing
    #     to then feed to a diff (and maybe further itself)
    
    # < Babz grep(_s&RunningStep == ns&RunStep,any)
    # < grep({bow:&vki{}},f.sc) or grep({bowi:1},f.sc)
    #   grep bowk=$such $f
    #    such that grep cannot be used for C.*
    #     or C/* without expr: $f/
    #  < Babz floaty params for any known function like that
    #  < and for s&* not in c&shade.*
    #  # see neuro / $firk = ...
    # < sub() for &ha doing clone-from via q.base=$n
    #  # see neuro / h.ha(ex(
    
    
    
    
