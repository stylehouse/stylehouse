# test, runs on W:Thy, 33
n doafew 1 s:Things!
$R = A.Run
$h = A.h
fatal.ish(h)
# < becoming Babz 'more of a title -Fez=>\n  ...'

    
S 1 test data for -hat ref noticing, limits, specialfx
    $h = A.h.o('Something')
        # $time-seven, as long as it contains something:
        # to make stuff up
        $dat = me&PiRet_data
        dat.moreso = dat.asee
        h.hat('Bowler',dat)



        $da = {more:'some',figaro:dat.asee}
        da.furhtin = {llatin:4}
        
        $links = {fig:'ures'}
        ahk(links,'with','in',links)
        # can Eref see its parents
        da.links = links
        da.lonk = links
        
        h.hat('Lol',da,{first_truest:1})
        # about to get a da.links.nowsays
        h.lasix.t != 'Lol' and debugger
        #me&finishPiing,h.lasix



        $da = {fer:dat.asee,even:'more',figaro:dat.asee}
        da.furhtin = {llabin:4}
        # < can Eref see its previous state change to now
        links.nowsays = 'this'
        da.libkit = links
        
        # test Rc&dl
        # < Babz each i 1..100 {
        $i = 0
        $ya = da
        while (i < 60) {
            ya = ya.th = {}
            i++
        }
        ya.is = 'all'
        # < &Eing preferring this to more level$n !
        #   diversity seeking
        $ej = da.neesd = Cye(['Nees',3,
            {mo:3,tor:68,
                functions:"of an elabourate sort",
                s:"Thsideratea"}
        ])
        ejy&fig = dat.asee
        ejy&vig = 2
        da.leveridge = Cye(['Nose',7,{s:'li'}])
        $i = 0
        # too many
        while (i < 55) {
            da['lever'+i] = 'thing'
            i++
        }
        h.hat('Room',da,{many_tail:2})
        # it knows where Room gave up!
        h.hat(' all th way',da.th,{dl:66})
        
    $h = A.h.o('Someact')
        $da = {as:dat.asee,fol:33,vanas:dat.asee,vaees:dat.asee}
        da.string = <<''
            Til
              forward
               motion
              was
               it
               all
            
            etc!
             etc
        
        $D = Cye(['Ling',1,{s:da.string},{}])
        da.encodes = me&enL,D
        da.spaceynum = num("  ")
        da.stringynum = num(" 0")
        da.verylong = new Array(100) .join('123-')
        $doing = Cye(['Linga',3])
        da.insidery = {v:doing}
        da.outsidery = doing
        $Bow = h.hat('Bowler',da)
        # lurkfa faing!onn.. fa
        

S 2 twos
    $h = A.h.o('brackstract')
    
    # < Tool for zooming into Ying-gate !!!
    
    #$s = 4s&interestoYing
    $s = me&mock_Thyergate,R
    !s || !ss&X and return me&tc,"awaits"
    ss&X.A != R and debugger
    # X by &bracki (ish), make &Shx_isX
    # < the &Shx p.ist('X') check is too silent
    me&brackstract,ss&X
    
    # < a holding X, knowing what format the inner might like
    each ks R.sc {
        !k.endsWith('W') && (!isob(s) || isC(s) || !isC(s.A)) and continue
        # the &Saturn %%inst,listen_node there coops these:
        $pi = k.endsWith('W') ? 'Womb' : 'Fez'
        
        h.tys(k,pi,s)
    }
    
S 3 Pictures hashy misc
    $h = A.h.o('Something')
    $hat = h.hat
    # < sample all calls to ahk() etc during a bunch of Stories
    #    keeping a taxography of all uses
    #     the data condenses a schema!!!!!!!!!!!!
   // modulat!
    # < T.act.t should be steppy?
    # < autogen C.t < argmo
    # < Babz 'n anyoldtext -Bow => &yada,&m{'
    #    DIY closing bracket etc
    #    should be possible, -Bow knowing how to interpret such a housing
    #    so c&s = c&code or so, during T.act of A:n
    #     which knows its proper title
    #    this is a nice realm
    #    we make the BQ a subroutine, mini-pin...
    #     so it may define handlers in the dome
    #     they would be on the ground..? receive calls on a telephone...
    #     also make them, on eg a lamp, that can be used to be the origin,
    #      to write the address relative to.
    #       carrier assurance of messages coming from elvis.
    #    the 'stricter title 33-Fez: %such:even =>'
    #     also. is BQ dependent?
    #    perhaps shorter 'n some = ...' # have to eval first? put in sub?
    #    or the 'n some i yo/plo//%chi' # some = any spheres with %chi across yo/plo
    #    and '$n o such/where' # notice !n
    #    then '$z o yer/$n' # still !n
    #    then 'i mixio/$n &quant $z' # fatal
    #     < wants empty spaces sometimes
    # < stub a bunch of ways as above! devob, mkv, etc
    h.Womb('&ts?c?', me&abTap,'Picmodu',Cye(['Picmodu',1]) (&{
        me&tsc,'becomes',0,'6y'
        me&tsc,'tos','','6g'
        me&tsc,'untos','la','6b'
        me&tsc,'basictsc','la'
        me&tsc,'moretsc','la','46yl'
        me&tc,"tctitle"
        me&tc,"tcstyle",'G'
        me&ts,"ts0",0,'6'
    }))
    h.Womb('boxcap_test_situation', me&abTap,'situa',Cye(['situa',1]) (&{
            $two = me&boxcap,"pile1",'1y'
                me&tc,"<"
                $three = me&boxcap,"yondsome",'1y'
                    me&tc,"insidde"
                three()
                me&tc,">"
            two()
            
            $two = me&boxcap,"pile2",'1y'
                $three = me&boxcap,"empty",'1y'
                three()
                me&tc,"outside"
            two()
            $two = me&boxcap,"Achgindi",'1y'
                me&tc,"stuff"
            two()
            $two = me&boxcap,"Achgindi",'1y',2
                me&tc,"stuff"
            two()
            $two = me&boxcap,"Achgindi",'1y'
                me&tc,"additional"
            two()
            $two = me&boxcap,"Achgindi",'1y',2
                me&tc,"andmore"
            two()
    }))
  
  # notes a heading in Pictures:
   // # types
    # < title as expr, expect true. just '!iske(44)' on a line.
    $D = Cye(['D',3])
    $Dot = Cye(['Dot','-Dot'])
    hat('Fividy types',{
        "isha({})": isha({}),
        # causes ish([])
        "isha([])": isha([]),
        "!isha(D)": isha(D),
        "isob({})": isha({}),
        "isR(R)": isR(R),
        "!isR(D)": isR(D),
        
        # avoid
        "sca(333)": sca(333),
        "sca(333.3)": sca(333.3),
        "dec(333.3)": dec(333.3),
        "dec(333)": dec(333),
        "dec('333')": dec('333'),
        # < more
    });
    hat('types',{
        "!isba(D)": isba(D),
        "isba(R)": isba(R),
        
        "iske(str)": iske('stri'),
        "iske(num)": iske(44),
        "iskeyish(num)": iskeyish(46),
        "!iske({})": iske({}),
        "!iske(null)": iske(null),
        # housey - looks like index
        "!ish(null)": ish(null),
        "!ish('str')": ish('str'),
        "!ish(D)": ish(D),
        "ish([])": ish([]),
        "ish({})": ish({}),
        
        "!isit({})": isit({}),
        "!isit([])": isit([]),
        "isit(D)": isit(D),
        "isit(str)": isit('str'),
        
        "!ispi(D)": ispi(D),
        "ispi(Dot)": ispi(Dot),
        "ispi(Dot,'Dot')": ispi(Dot,'Dot'),
        "!ispi(Dot,'Else')": ispi(Dot,'Else'),
        
        "fatal.isst('st')": fatal.isst("st")
    })
    # < fatal variations testable with &catch
    
   // # access types|many
    hat("&fuN",{
        "func -> one":
            fuN(&ab{ return a+"_"+b },
                "sch",'nn'),
        
        "fonc -> many":
            fuN((s) => map((v,i)=>s+(i+3),[...new Array(3)]),
                "sch",'nn'),
        
        "one -> [one]": fuN("Ayething"),
        "[many] -> [many]": fuN(['sev','er','al']),
        "[] -> []": fuN([]),
        "{} -> [{}]": fuN({}),
    })
    
    # &iot for xpath bit selector, not sy&R logic
    $z = me&simpdeL,<<""
        Yada 3
          Cleavage Site  4
          Lots 3 s:later
          Lotz 1 s:layer %Figi
          Lotza 1 s:layer %Figi:3
            Atoms -with spaces when,you,cant,type,tabs
          Lotzr -Mat s:layer %Fyh
          Atoms -with spaces hey
          Atoma -Mat S:teve Figi,Lation
    
    $iot = k => joint( me&iot,z,k )
    hat("&iot",{
        't': iot('Lots') ,
        'sc': iot('%Figi') ,
        'pi': iot('-Mat') ,
    })
    
    # &yio
    $ala = me&yio,Dot,'Allah'
    hat("&yio",{
        "returns what .ohe.e was": [
            ala.i('ohe','e','m'),
            ala.i('ohe','e','igla'),
            ala.i('ohe','e','m'),
        ],
        "uniq accumulate": [
            ala.i(['loth'],'e','m','ding'),
            ala.i(['loth'],'e','m','ding'),
            ala.i(['loth'],'e','m','dong'),
        ],
        "fod:1, frod++": [
            ala.i('fod'),
            ala.i(['frod'],1),
            ala.i(['frod'],1),
            ala.i(['frod'],1),
            # doesnt count!
            #ala.i(['frod'],3),
            ala.i('ohe','e','mot'),
        ],
        "m": ala.o('ohe','e','m'),
        "e": ala.o('ohe','e'),
        "!e": ala.o('e'),
        "all loth": ala.o('loth'),
        "fod:1": ala.o('fod'),
        "root": ala.o(),
        "is on Doty&...": Dot,
    })
    
   
  # misc() access
  // # misc() hash
   // ahk()
    # &yio covers what it returns each time (was value)
    $aC = Cye(['bling',3])
    $notC = {}
    ahk(aC,'usual','scing','things',1)
    ahk(aC,'more',3,4)
    ahk(aC,'more',1,4)
    # allows just k,v
    ahk(aC,'moren',3)
    ahk(aC,'moren',1)
    ahk(aC,'moren',1)
    # < catch "listend!num"
    #ahk(aC,['moren'],1)
    ahk(aC,['mores'],1)
    ahk(aC,['cumu'],'la','place')
    ahk(aC,['cumu'],'la','loose')
    ahk(aC,['cumu'],'loose','ly')
    # samey
    ahk(aC,['cumu'],'la','loose')
    ahk(aC,['c'],'cumu','la','va')
    ahk(aC,['c'],'cumu','la','vava')
    ahk(aC,['y'],'cumula','ar')
    # samey
    ahk(aC,['y'],'cumula','ar')
    ahk(aC,['y'],'cumula','uniques')
    ahk(aC,['y'],'cumula','all')
    # see indexOf string!=num
    ahk(aC,['y'],'cumula',3)
    ahk(aC,['y'],'cumula','3')
    # < catch "listend!ar"
    #ahk(aC,['c'],'cumu','va')
    ahk(notC,'things','that','were','here')
    ahk(notC,'things','that','were','there')
    ahk(notC,['things'],'all','was','finiga')
    # starts adding to a number
    ahk(notC,['things'],'FROT','was','finiga',2)
    ahk(notC,['things'],'FROT','was','finiga',1)
    ahk(notC,['things'],'all','was','finigaL')
    # already exists
    ahk(notC,['things'],'all','was','finiga')
    
    # count
    ahk(notC,['things'],'all','was','3',1)
    ahk(notC,['things'],'all','was','3',1)
    ahk(notC,['things'],'all','was','3',1)
    # < but not add
    #ahk(notC,['things'],'all','was','3',3)
    
    ahk(notC,'vari','k',1)
    ahk(notC,'vari','k',1)
    ahk(notC,'y','varo',1)
    ahk(notC,'c','all','was','3',1)
    hat('ahk()',{
        aC,
        notC,
        "counts return": {
            "first": ahk(notC,['ret'],'friv',1),
            "then": ahk(notC,['ret'],'friv',1),
            "etc": ahk(notC,['ret'],'friv',1),
        }
    })
    
   // hashkv()
    # < an n@3 hook to pipe s through eg hashkv and arrange the results
    $abunch = {}
    $em = (t,s) => abunch[t] = s
    
    $abc = {aye:4,bee:3,cee:2}
    $disc = hashkv(haks(abc).map(k => ['the '+k,"said "+abc[k]]))
    em("remap",{abc,disc})

    em("ark:$v",
        hashkv('ark','$v'))
    # ! string object k
    em("'it' -> {it:1}",
        hashkv('it'))
    em("[[nc&sip,n]+] -> {'0 1 2':n}",
        hashkv([['0 1 2','One'],['0 1 2 1','Two']]))
    em("!N.length -> {}",
        hashkv([]))
    em("'key',{thing:1} -> {key:{thing:1}}",
        hashkv('key',{thing:1}))
        
    hat('hashkv()',abunch)
    abunch = {}
   // < # more type
    
   // # peel(), arq()
    em("nothing",peel())
    em("null",peel(null))
    em("empty string",peel(''))
    em("one",peel("can"))
    em("two",peel("can,you"))
    em("two.5",peel("can,you:feel"))
    em("three, first : only",peel("the:lunch:tonight,that,was::fiver"))
    # clones supplied hash
    #  this is not for eg &uptonode c arg
    #   allows giving a c to read details from after
    $fugo = {log:'ratio'}
    $peeled = peel(fugo)
    peeled.log = 'standing'
    em("clones hash",{fugo,peeled})
    # pex() avoids cloning hash s, may peel it
    $fugo = pex('log:ratio','deal')
    $peeled = pex(fugo,'licio')
    peeled.log = 'standing'
    em("< pex() avoids cloning hash s",{fugo,peeled})
    
    hat('peel()', abunch)
    abunch = {}
    
    try {
    em("already",
        arq({seeing:{theeing:"is"}},{qk:{seeing:1}}))
    # < catch
    #em("c.seeing!housey",
    #    arq({seeing:"lovely,ness"}, {qk:{seeing:1}}))
    em("put into",
        arq({thanks:3}, {qk:{seeing:1}}))
    em("!peel, put into",
        arq({thanks:"diat"}, {qk:{seeing:1},peely:1}))
    em("peel, put into 2",
        arq({thanks:"figaro,thjin:k"}, {qk:{seeing:1,thanks:1},peely:1}))
    em("peel some, dont put into",
        arq({thanks:"figaro,thjin:k",seeing:"fully:knowing,myself"},
            {qk:{seeing:1},peely:1}))
    em("peel, dont put into",
        arq({thanks:"figaro,thjin:k",seeing:{fully:2,five:5}},
            {qk:{seeing:1,thanks:1},peely:1}))
    
    em("see nothing",
        arq({thanks:"figaro,thjin:k",se:{fully:2,five:5}},
            {qk:{seeing:1},peely:1}))
    em("see nothing qk/$k=dept",
        arq({thanks:"figaro,thjin:k",se:{fully:2,five:5}},
            {qk:{seeing:'abranchof'},peely:1}))
    }
    # we dont expect an error
    catch(er) {
        bunch.an_error = ''+er
    }
    hat('arq()', abunch)
    abunch = {}
    
   // ex()
    # in ascending depth of s(.*)+
    # < or is that descending depth? slope
    hat('ex()',{
        "simple": ex(ex({},
            {ela:'borate',ti:3,glab:1}),
            {fly:1,ti:4,la:4,loose:{}}),
        "array !merge":
            ex({sh:['And','all']},
               {sh:['will','dwell']}),
        "s.*.* !merge":
            ex({and:{all:'will'},be:3},
           {s:3,and:{will:'dwell'},be:4}),
    })
    hat('mex()',{
        "simple same": mex(mex({},
            {ela:'borate',ti:3,glab:1}),
            {fly:1,ti:4,la:4,loose:{}}),
        "array merge":
            mex({sh:['And','all']},
               {sh:['will','dwell']}),
        "s.*.* !merge":
            mex({and:{all:'will'},be:3},
           {s:3,and:{will:'dwell'},be:4}),
    })
    hat('ex2()',{
        "simple same": ex2(ex2({},
            {ela:'borate',ti:3,glab:1}),
            {fly:1,ti:4,la:4,loose:{}}),
        "array merge":
            ex2({sh:['And','all'],also:{inhere:["ent"]}},
               {sh:['will','dwell'],also:{inhere:["able"]}}),
        "s.*.* merge":
            ex2({and:{all:'will'},be:3},
           {s:3,and:{will:'dwell'},be:4}),
        "s.* peel":
            ex2({and:'all:will',be:1},
           {s:3,and:{will:'dwell'},be:{there:'specifically'}}),
    })
    # and other
    $la = {will:'dwell',and:'all',vague:null}
    hat('*ex*()',{
        # only and
        'sex()': sex({},{will:'dwell',and:'all',vague:null},'and'),
        # all but will
        'nex()': nex({},{will:'dwell',and:'all',vague:null},'will'),
        # fit to print
        'tex()': tex({},{will:'dwell',and:'all',vague:null}),
        'tex() hashy': tex({},{will:'dwell',and:{let:3},vague:null},'and'),
        # definite
        'dex()': dex({},{will:'dwell',and:'all',vague:null,hash:{e:{s:{}}}}),
        # takes and out
        'tax()': {
            revenue: tax({},la,'and'),
            leaving: la,
        },
        # may peel
        'pex()': pex('and:all','will:brie'),
        # < get this all coded as individuated catchables
        #' unlike ex()': ex('and:all','will:brie'),
        
    })
   
  // # misc() array
   // ksaf()
    // data
        $Tom = <<''
            Long way going to
            Get my medicine
            Skys the autumn grey of a lonely wren
            
            Piano from a window played
            Gone tomorrow, gone yesterday
            
            I found it in the street
            At first I did not see
            Lying at my feet
            A trampled rose

        $h = hashkv(grep(Tom.split("\n")).map(s => split(s,' ',1)))
        
        
        
        
        
        
        
        $a = haks(h)
    
    # given c, no default c.inc=1
    # < return sliced hash..? already returns sliced arrays
    # < until, (til, aft), after
    #    io etc shall know... til(C) the T.iteration?
    #    and til1, aft1 for the :p/$s<1 maneuvre
    #     also looking for aft(tow)
    # < convert these to joint() the result
    #    once all the /(^\d+) -String "/ and /"\n/ in the patch
    #     can be identified as such
    $yesterday = v => v.includes('yesterday')
    hat('ksaf()',{
        origin: {h,a},
        'on hash': {
            until: ksaf(h,{bow:'Skys'}),
            til: ksaf(h,{bow:'Skys',inc:1}),
            aft: ksaf(h,'Gone'),
            after: ksaf(h,{aft:'Gone'}),
        },
        # < Textl notice ^ and v are mostly same!
        'on array': {
            until: ksaf(a,{bow:'Skys'}),
            til: ksaf(a,{bow:'Skys',inc:1}),
            aft: ksaf(a,'Gone'),
            after: ksaf(a,{aft:'Gone'}),
        },
        'where': {
            "after v~~/yesterday/":
                ksaf(h,{aft:yesterday}),
            "after v~~/yesterday/ til k~~'At'":
                ksaf(ksaf(h,{aft:yesterday}), {bow:'At',inc:1}),
            " same + hash sliced":
                sex({},h, ksaf(ksaf(h,{aft:yesterday}),
                    {bow:'At',inc:1})),
            "after v~~/yesterday/ til v~~/^L/ + hash sliced":
                sex({},h, ksaf(ksaf(h,{aft:yesterday}),
                    {bow:v => v.startsWith('L'),inc:1})),
            'until v~~/indo/':
                ksaf(h,{bow:(v) => v.includes('indo')}),
            'aft k~~/ing/':
                ksaf(h,{aft:(v,k) => k.includes('ing'),inc:2}),
        },
    })
    
   // grep()
    # < the above as range args to grep:
    #    $N = grep /yesterday/../^L/ 
    #    $N = grep ..(/^indo/) # range makes () less-selecting. usu more? <art.
    #    $N = grep ..k~~/ing/ # range makes bare k ok?
    hat('grep()',{
        "Piano": grep((v,k) => k == 'Piano',h),
        "no a": grep(v => !v.match('a'),h),
        "a value": grep('at my feet',h),
        "for truth": grep({la:1,non:0,li:4,fe:0}),
        "truth of [0]": grep([0]),
        
    })
    
    
    $N = [3,2,4,3,Cye(["la",3],2,1)]
    $l = N[3]
    hat('grap()',{
        # instead of writing (N||[]).includes(l)
        "yes": grap(l,N),
        "no": grap(56,N),
        "intersection": grap([2,4,7,8],N),
    })
    hat('grop()',{
        "little numbers": grop(v=>v<3,N),
        "are gone": N,
    })
    
    $aa = a.slice()
    hat('grepout()',{
        "Piano": grepout(aa,'Piano'),
        "is gone": joint(aa),
        "in array": grepout(aa,['At','The','Lying']),
        "are": joint(aa),
        "short|early keys": grepout(aa,(v,i) => hak(v)==1 || i < 3),
        "leaving only": aa
    })
    hat('flatten()',{
        "doc": flatten([1,[1,2]]),
        "N = z|N": flatten([[1],3]),
    })
    
    $ile = 0
    $origin = {la:3,loose:6}
    hat('map() also',{
        "Piano": map(
            v => v+'an',
            (v,i) => i+v+(ile++),
            ['o','oo','ooo']
        ),
        "map() not in-place": {
            doing: map(v => v*2,origin),
            origin: ex({},origin)
        },
        "rap() is in-place": {
            doing: rap(v => v*2,origin),
            origin
        },
        "armap() returns array": armap(v => v*2,{la:2,loose:4}),
    })
    
  // # misc() array string
    # < text-array transforms?
    
    hat('sum()',{
       '15': sum([1,2,3,null,4,5]),
       'partsof': sum(a => a.v,
           [{},{},{v:0.9},{v:{hut:1}},{v:0.3}]
       ),
    })
    
    hat('split()',{
       'no limit': split("3,3,3,3,3,3",','),
       'by ||= space': split("3  3 3 3"),
       'by anywhere': split("3  3 3 3",''),
       'limit=2': split("3,3,3,3,3,3",',',2),
       'limit=4': split("3,3,3,3,3,3",',',4),
       'regex': split("3,3,,,,3,,,3,,3by6,3",
           /[g-z]|,+/),
       # < use &parserify ?
       'regex+limit bad': split("3,3,,,,3,,,3,,3by6,3",
           /[g-z]|,+/,3),
    })
    
    $D = Cye(['thing',3])
    $V = Cye(['Middle'])
    $W = Cye(['Log',4])
    hat('joint() derived',{
        "nulls vanish": [
            cint(1,2,3,'',4),
            slant(1,null,3,0,5,-0,NaN,undefined,Infinity),
        ],
        "it works": cint(a),
        "ignores later args if isar(arg[0])": cint(a,D),
        "it works": cint(['Mix',D,'Sturct']),
        "idint()": armap(idint, [{V},{W},{W,with:'some more'}]),
    })


  // js trivia
    # javascript weirdnesses!
    // misc
        hat('perl [" "x3]',
            map(s => " ",[...new Array(3)]),
        )
    // speed
      # how long does stuff take
      # < Storying stuff like this... the stats channel
      # < automate discovery of the scale of time these want to be in
      #   plot O notation from various obj_length samples
      if (0) {
        # so n=5
        $obj = peel("some,things,that,you,look:like")
        if (1) {
            # make big: n=100 (x14), slows:
            #  obkeys x70?
            #  hak* 30x
            #  indexOf* x3-4
            map(&vi{
                map(k => obj[k+i] = 'also',obj)
            },[...new Array(32)])
        }
        # what we look for
        $item = {}
        obj.finally = item
        obj.the = 'end'
        # as an array
        $ray = havs(obj)
        
        $h = {}
        # 1/4 million per second
        h[3*10**5] = {
            dig: s => dig("Steve")
        }
        # 3-5 million per second 
        h[3*10**6] = {
            # twice the speed of hak
            haks: s => haks(obj).length,
            # 1/10th the speed of obkeys
            hak: s => hak(obj),
        }
        # 30 million per second
        h[3*10**7] = {
            indexOf: s => ray.indexOf('end'),
            indexOf_object: s => ray.indexOf(item),
            obkeys: s => Object.keys(obj).length,
        }
        $resulto = {}
        resulto.obj_length = ray.length
        $div = 30
        each ity h {
            $start = Gtime()
            $ii = i*1
            ii /= div
            while (ii-- > 0) { y() }
            resulto[i+" "+t] = (Gtime()-start) * div
        }}
        hat('speedtest',resulto)
      }
        
        

        
    // types
        $l = ['1', '2', '3',1]
        hat('indexOf string!=num',{l,
            for_num_1: l.indexOf(1),
            for_string_1: l.indexOf('1'),
            for_num_2: l.indexOf(2),
            for_string_2: l.indexOf('2'),
        })

        # use before buy!
        l.map(&n{
            use = 3
            $use = n
        })
        
        # < Plying test output to here,
        #   generating blog with <code>1+1 # 2</code>
        hat('null <>-ier than undefined',{
            null_lt_6: null < 6,
            null_gt_6: null > 6,
            null_gt_neg6: null > -6,
            undef_lt_6: undefined < 6,
            undef_gt_6: undefined > 6,
            undef_gt_neg6: undefined > -6,
        })
        hat('null mathsier than undefined',{
            "5+null": 5+null,
            "5+undefined": 5+undefined,
            # right way:
            "5+(undefined||0)": 5+(undefined||0),
        })
        
        hat('more types',{
            'zero': [
                '' == 0,
                '0' == 0,
                '' == '0',
            ],
            'undef': [
                false == undefined,
                false == null,
                null == undefined,
            ]
        })
    // hash key order
        #  because of how javascript (v8) stores properties & elements
        #  keys that look like array indices (dec(s,0) == s) will come first
        #   eg assigning -2,-1,0 iterates 0,-2,-1
        #  ! anywhere we rely on hash key order might be affected
        $hash = peel("and:all,will:be,we:ll")
            # ~$v keeps order of $k
            hash.and = '...all!'
            # numbers go first, in numeric order
            hash.3 = 'dun'
            #  only if they look like array indices
            hash[3.14159] = 'dun'
            # type coercy, unlike Array.indexOf()
            hash['1'] = 'dunn'
            # on the end
            hash.flower = '?'
            # gone + come again resets order of $k
            delete hash.will
            hash.will = 'vee'  
            hash.vil = 'la'  
        hat('key order',hash)
        
        # and more of a stylehouse quirk,
        #  
        hat('isha([])',isha([]))
    
    // sub
        # has to be &{} to get arguments
        $disnobrack
        $set = &{
            disnobrack = (s) => dis([...arguments])
        }
        set("the args","to the sub defining the sub")
        $disbrack = &{ return dis([...arguments]) }
        hat('to get arguments',{
            "dont (...)=>{...}":
                disnobrack('yab','yob','yup'),
            "do &...{...}":
                disbrack('yab','yob','yup'),
            " one arg":
                disbrack('yab'),
            " no args":
                disbrack(),
        })
        
        if (0) {
            # < catch error
            # ran into this while debugging 'zygomorph &Ereftakedown'
            #  see 'doesnt fully solve the &Rcrux panic after &forgetRunStep'
            # it seems javascript was optimising away lexicals no longer referred to
            #  this can be seen in &Rcrux_seek / # < supposed to be deleted
            #   trying to set rr again keeps it undefined, renaming rrr works
            #  so good: accessing C.*.* should be fatal if !isC(C)
            $ina = &rl,rr{
                if (rl.sc.Pier && rr.sc.Pier) {
                    return 0
                }
                return 1
            }
            hat('if (properties of undefs)',{
                "are fatal": ina(),
            })
        }
  
  // &indo etc
    # &deL for tabless lines from the editor
    $z = me&simpdeL,<<""
        Yada 3
          Cleavage Site  4
          Lots 3 s:later
          Lotz 1 s:layer %Figi
          Lotza 1 s:layer %Figi:3
            Atoms -with spaces when,you,cant,type,tabs
          Lotzr -Mat s:layer %Fyh
            Lotzromsg -with spaces hey
              Lotzrmig -with "spaces" hey
          Atoms -with spaces hey
            Atomsg -with spaces hey
              Atomig -with "spaces" hey
          Atoma -Mat S:teve Figi,Lation
    
    A.h.Bow('&indo',{
        'indenting strings': me&indo,z (&sd{
            # < not returning anything if no children do
            !sc&s and return cvs(sy&cv)
            s.t == 'Atoms' and return d.not = 1
            return slant(cvs(sy&cv),' ',s.t)
        }),
        'flat map': me&indo,z (
            s => s.t.includes('tz') && Cye(['w:'+s.t,1,ex({},s.c)])
        ),
        # < 3d map... as above + returning s
        #    + Cology reassemble hierarchy from [a,b,c(y&up=b)] etc
    })
    
    
    if (0) {
        $M = []
        # e** until !y&pack, to the point of eg e:elIntro
        me&indo,e (&ed{
            # an enveloping, at %JRom or so..? see elvoids
            ec&pack and return
            M.push(e)
            d.not = 1
        })
        return M
    }
   
S 4 @Gnome
    $h = A.h.o('Something')
    # eats C(y&R%wou), %wou, [n+]
    $ios = h.brack
 // @Gnome
  // reself resync
    $This = me&Names_get,R,'This'
    $Fine = me&Names_get,R,'Fine'
    # uses the REy&main, aka sy&$pi:
    $This = Thisy&This
    $Nine = Cye(['TryNine','-nine'])
    # inflates Ness** from Fine/Ness**
        # isolating Ness < this one
        $stop = 0
        $copiq = {match:&nz{
            n.t == '-Gnome-4' and stop = 1
            stop and return
            return 1
        }}
    me&EsyncThe,Nine,Fine,{copiq}
    !Ninec&Into and throw "!Into"
        # isolating This** < now
        $clintoq = {match: &snz{
            # s:from(This|Eight) n:item(Eight|seven) z:to(Eis|Ei)
            s == This and return n.t.match(/^(Some(thing|act)|brackstract)$/)
            nc&pi != 'seven' and debugger
            # before this step
            return n.t < 4
        }}
    me&EsyncThis,Nine,Fine,{This,clintoq}
    
    # contain %dige, subject to change
    me&fiu,Nine,'The',9
    me&fiu,Nine,'This',9
    # can sometimes see %%next_Ness_title_clue (not after first Run)
    $next = delete Ninec&Into
    $Ness = me&fiu,Nine,'Ness',7
    me&fiu,Ness,next,9
    
    
    h.Bow('reself resync',{Nine},{nl:300})
    
  // diff stack finding
    $a = <<''
        1
         14
          a
         2
          3
          3b
          3c
    
    $b = <<''
        1
         14
          a
         2
          3
          3bc
          3c
    
    # las.t ends up being the R.t of the diff...  !
    me&AhdiffWomb,'diff-stack-finding',{},a,b
    
 
  // &Sharg saves the Bowler -Strings with &Stringchew
    $rg = me&Sharg,'$s/Someact/1/Bowler//E/-hat/*(R%String)//R',[This]
    $all = Cye(['sche',1])
    rg.N
        .map(n => me&fiu,all,n.t .sc.z = flatten(ns&M||[]))
    h.Womb("&Stringchew",all)
    
  // -hat data immediately
    # < look at the Yingulog!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #   first try only, comes back to see 'after'
    #    a couple of times as per %wakeful or so?
    $da = {here:'before'}
    da.stringstract = a
    h.hat("-hat data immediately",da,{funktime:1,first_truest:1})
    da.here = 'after'
    
  // passing ER%many_thresh
    # pushing back the %limit:many from 20
    $a = [...new Array(96)] .map(n => ' oOo')
    h.hat("can pass theshholds",{liter:{of:a}},{many_thresh:36})
    # < pointer -Lab (or h.hat c.TX?) can want things
    #    that would have come after the chop
    #    see %limit:many prioritises space for keen e
 
 // Doming
  // %%dome
    $t = h
    # < %opa doesnt undo on e:r?
    #    we don't %igV, only async drop -seven/*
    #    give R-seven %amnesia, so -six %igV?
    #     via nextlifesc + inheritsc?
    me&mockR,'art' (&Cr{
        $h = me&hajasute
        h.ha("Cartful:ness")
        h.ha("Artful:ness,dome:ze")
        h.ha("Artful:ness,dome:alism")
        ios('see art',C)
    }) (&Cr{
        $h = me&hajasute
        # simply added
        h.ha("Artful:ry")
        # with stuff from last time
        ios('see art 2',{
            "whole": C,
            'the old Artful': h.zaa("Artful"),
            'old+new Artful': h.jaa("Artful"),
        })
        
        h.ha("Artful:re,do,dome:ze")
        h.ha("Artful:re,de")
        # two generations of %%dome:ze, no traction yet
        ios('see art 2.1',{
            "whole": C,
        })
    }) (&Cr{
        $h = me&hajasute
        
        $first = h.jaa("Artful")
        h.ha("Artful:Wobsica,dome:alism")
        $next = h.jaa("Artful")
        ios('see art 3.1',{
            "first %%Artful, are recycled": first,
            "added to %%Artful, are all": next,
        })
        
        me&dome_traction,r,'alism'
        ios('see art 3.2',{
            "dome:alism has been redone": h.jaa("Artful"),
        })
        
        # el2 means delete olds even if no news
        me&dome_traction,r,'aside',{el:2}
        # without it, requires some new to displace them
        me&dome_traction,r,'ze'
        ios('see art 3.3',{
            "noop el2:unhad + no-news dome": h.jaa("Artful"),
        })
        
        me&dome_traction,r,'ze',{el:2}
        $then_gone = h.jaa("Artful")
        ios('see art 3.4',{
            "dome:ze gone": h.jaa("Artful"),
            "past still available":  h.zaa("Artful"),
            "whole": C,
        })
    }) (&Cr{
        $h = me&hajasute
        
        ios('see art 4',{
            "whole": C,
        })
    })
  // %%dome fork
    $v1 =
    me&mockR,'forks' (&Cr{
        $h = me&hajasute
        h.ha("Cartful:ness")
        h.ha("Artful:ness,dome:ze")
        ios('forks 1',C)
    })
    $v2 =
    v1(&Cr{
        $h = me&hajasute
        h.ha("Lute,dome:ze")
        ios('forks 2',C)
    })
    $v2_1 =
    v1(&Cr{
        $h = me&hajasute
        h.ha("Flake,dome:ze")
        ios('forks 2 1',C)
    })
    v2(&Cr{
        $h = me&hajasute
        h.ha("floops")
        ios('forks 3',C)
    })
    v2_1(&Cr{
        $h = me&hajasute
        h.ha("floops")
        ios('forks 3 1',C)
    })
  
  // %%rec & &hajadome # very bad test writing
   # fair bit more complicated
   # < variation: no_hajasute=0 the whole time
   #   various %%rec,do stop happening due to &zaaj seeing %%rec traction
   // unit
    $unit = 1
    $no_hajasute = 1
    $title = ''
    $brainfront = &y{
        return &Cr{
            # mix %%dome=bf into every sute.ha(...)
            $sute = me&hajadome,r,{dome:'bf'}
            # and with %%rec &zaaj knowing, T.sute
            $Tap = me&Tap,{sute}
            $h = no_hajasute ? sute : me&hajasute
            
            $i = {}
            y (C,h,r,i)
            
            # %%rec computing
            sute.traction()
            delete T.hajasute
            # < move ^ to v via sute.packdown[]()?
            Tap()
            # and finish, as Ying would sort out all the pieces of the sun
            me&mockR_commit,r
            
            $say = "unit "+(title||unit)
            rs&ver != unit and say += '   r.'+rs&ver
            # < reverse expe(): it shrinks to whole if others. collapsy.
            $see = hak(i) ? ex(i,{whole:C}) : C
            $c = {}
            
            $six = ios(say,see,c)
            !title and unit += 1
            title = ''
        }
    }
    $neuro = &h{
        # every time
        # finds -> oughtta
        h.jaa('observe,finds') .map(&n{
            ns&stepula and return
            
            $v = ns&finds*1 + 2
            $more = v > 6 ? ',recind' : ''
            ns&once and more += ',once'
            h.ha("rec:do,oughtta:finds:"+v+more)
        })
        $c = "rec:do"
        # oughtta(finds) -> stepula
        $N = h.zaaj ? h.zaaj(c) : h.zaa(c)
        N.map(&n{
            if (ns&oughtta) {
                $finds = h.jaa(ns&oughtta)
                ns&once && hak(finds) and nc&drop = 1
                finds.map(&f{
                    $rec = "complete"
                    $firk = haks(f.sc)[1]
                    ns&recind and rec = daint(rec,cint(firk,f.sc[firk]))
                    h.ha(ex(
                        {rec,stepula:ns&oughtta},
                        {labels:joint(haks(f.sc))},
                    ))
                })
            }
        })
    }
   
   // 1
    $moreR =
    me&mockR,'unit' (brainfront(&Chr{
        h.ha("observe:casual,things:about")
        h.ha("Artful:ness,dome:ze")
        h.ha("Artful:ness,dome:al")
        neuro(h)
    }))
    (brainfront(&Chr{
        h.ha("observe:casual,things:about")
        # -> %%oughtta
        h.ha("observe:3,finds:4")
        # not finding:
        h.ha("unobserved:3,finds:4")
        # redome ze
        h.ha("Frypan,lapan,dome:ze")
        neuro(h)
    }))
    # 3
    (brainfront(&Chri{
        # %%rec still %%oughtta, would even from %%dome, now
        i["not &jaa finds"] = h.jaa('finds:4')
        i["are &zaa finds"] = h.zaa('finds:4')
        h.ha("observe:casual,things:around")
        # does jaa|zaa, sort of.
        i["lot &jaa,'finds',1"] = h.jaa('things',1)
        neuro(h)
        h.ha('finally')
        # a new %%rec,oughtta made from traction, not neuro
    }))
    (brainfront(&Chr{
        # %%rec still %%oughtta, %%dome would lose for neu:%%observe
        h.ha("observe:casual,things:about")
        # to find what we %%oughtta once we find a find!
        h.ha("observe:hedge,hedge,finds:6")
        neuro(h)
    }))
    (brainfront(&Chr{
        h.ha("observe:casual,sitars")
        h.ha("observe:jazz,jazz,band,finds:4")
        h.ha("observe:fafe,faff:3,band,finds:6")
        neuro(h)
    }))
   
   // 6
    # 6
    $x = {}
    $la = k => ahk(x,k,t.lasix)
    $thesix = &Chr{
        h.ha("observe:casual,sitars")
        # make %%oughtta:10|10|8
        h.ha("observe:lat,jazz,band,finds:8")
        h.ha("observe:long,operate,band,finds:8")
        #  latest %%rec:complete being:
        h.ha("observe:moreothat,moreothat,finds:6")
        # there are two &jaa %%oughtta:8
        #  if &zaaj, would be one
        # they share the hall of fame, on id-groupy %%rec
        neuro(h)
        h.ha("finality")
    }
    #no_hajasute = 1
    moreR (brainfront(thesix))
    la(6)
    
    title = '6 1 fork same'
    moreR (brainfront(thesix))
    la(61)
    
    $six = x[6]
    $ER = me&Sharg,'$s//E/.y.main//R',[six] .N[0]
    $before = {string:sixs&string,Rcv:sixy&R.y.cv,ERcv:ERy&cv}
    # wind up
    grep(six => me&finishPiing,six ,x)
    $ER = me&Sharg,'$s//E/.y.main//R',[six] .N[0]
    t.hat("to differance",{
        "there is no string before &finishPiing": before,
        "string after &finishPiing":
            {string:sixs&string,Rcv:sixy&R.y.cv,ERcv:ERy&cv},
        x,
    },{dl:3,first_truest:1})
    t.diff('6 1 is the same',x[6],x[61],'see')
    
    no_hajasute = 0
    title = '6 2 one zaaj oughtta'
    $nextR =
    moreR (brainfront(thesix))
    la(62)
    grep(six => me&finishPiing,six ,x)
    t.diff('6 2 different',x[6],x[62],'see')
    
   // 7
    # 7
    # seeing rec:select:long redoming and more
    nextR(brainfront(&Chr{
        h.ha("lalala")
        # this will be ignored by the &zaaj next time
        h.ha("observe:laser,shop,finds:4")
        neuro(h)
        h.ha("fin")
    }))
    (brainfront(&Chr{
        h.ha("observe:least,find")
        #  because these generate new %%rec:do (being redone|redomed)
        # < variation: on the above selectivity
        #   maybe this and last round, or everything since a certain wave
        # there are twice as many %%oughtta for 8 than for 6
        h.ha("observe:long,pirate,session,finds:8")
        h.ha("dealwitty,observe:this,itis,finds:6")
        h.ha("dealwata,observe:ata,ata,finds:6")
        # find != finds
        h.ha("observe:laser,shop,find:4")
        neuro(h)
        h.ha("fin")
    }))
    la(8)
    
    title = '7 1 prepare to finds:6 next time'
    nextR = nextR(brainfront(&Chr{
        h.ha("lalala")
        # this will be ignored by the &zaaj next time
        h.ha("observe:laser,shop,finds:4")
        neuro(h)
        h.ha("fin")
    }))
    title = '8 1 finds:6 if we finds:4 this time'
    nextR(brainfront(&Chr{
        h.ha("observe:least,find")
        # this will be in neuro()/&zaaj
        h.ha("observe:frivo,late,finds:4")
        h.ha("observe:long,pirate,session,finds:8")
        h.ha("dealwitty,observe:this,itis,finds:6")
        h.ha("dealwata,observe:ata,ata,finds:6")
        neuro(h)
        h.ha("fin")
    }))
    la(81)
    grep(six => me&finishPiing,six ,x)
    t.diff('only 8 1 finds:6',x[8],x[81],'see')
    
S 5 &sustain
    $h = A.h.o('sustain')
  // JugRice
    # sustain Jug|Pot:$v over time...
    $be = me&mockbrackR,'JugRice'
    # < -Lab for expressing when a is|not as it was more clearly
    #   has tiny little Eref to notice
    $occasion = 1
    $bel = &is{
        i.Bow = s
        each ia s {
            a['occie'+occasion] = 'Steve'
        }
        occasion++
    }
    be.Again("Jug Full",&Chir{
        h.ha('sing,song')
        h.ha('sing,notes')
        #n Jug -Bow &sustain,'Jug',{Full:1}
        bel(i,{
            Jug: me&sustain,'Jug',{Full:1} ,
            Pot: me&sustain,'Pot',{Full:0} ,
        })
    })("both Full",&Chir{
        h.zaa('sing') .map(n => h.ha("loudly",n.sc))
        bel(i,{
            Jug: me&sustain,'Jug',{Full:1} ,
            # a.el=1 as v becomes|remains true
            Pot: me&sustain,'Pot',{Full:1} ,
        })
    })("Pot becomes Full=4",&Chir{
        # &jaa,c,1 for either now or now-1
        i.all_notes = h.jaa('notes',1)
        bel(i,{
            Jug: me&sustain,'Jug',{Full:1} ,
            # a.el=2 since v changes amongst true
            #  recreates $a
            Pot: me&sustain,'Pot',{Full:4} ,
        })
        h.zaa('notes') .map(n => h.ha(n.sc,"loudly:4"))
    })
    # going false
    be.Again("Jug loses Full: el9, still brack",bec&_2,&Chir{
        h.zaa('notes') .map(n => h.ha("madly",n.sc))
        bel(i,{
            # a.el=9 as v becomes false
            Jug: me&sustain,'Jug',{Full:0} ,
            Pot: me&sustain,'Pot',{Full:1} ,
        })
    })("Jug gone: el10, not brack",&Chir{
        h.zaa('notes') .map(n => h.ha("zoomish",n.sc))
        bel(i,{
            # a.el=10 as v remains false
            Jug: me&sustain,'Jug',{Full:0} ,
            Pot: me&sustain,'Pot',{Full:1} ,
        })
    }) ("Jug el10",&Chir{
        h.zaa('notes') .map(n => h.ha("fading",n.sc))
        bel(i,{
            # a.el=10 as v becomes|remains false
            Jug: me&sustain,'Jug',{Full:0} ,
            Pot: me&sustain,'Pot',{Full:1} ,
        })
    })
  
  // PermaRice q=2
    $be = me&mockbrackR,'PermaRice'
    # q=2 always el1 once established
    # eg this part of elIntro
    #   $IncAfter = rand ? 1 : 0
    #   $af = me&sustain,gs,{IncAfter},2
    
    $luck = 0
    $gs = {Facing:'East'}
    $occasion = 1
    be.main = &Chir{
        $a = be.luga = me&sustain,gs,{luck},2
        a['occie'+(occasion++)] = 'Steve'
    }
    
    # not
    be.do("not yet")
    luck = 1
    # el2
    be.do("got lucky!")
    # el1...
    be.do("still lucky")
    luck = 0
    # the n%luck and a.v are resurrected
    be.do("still was lucky")
    be.do("still was lucky")
    luck = 1
    # 6
    # el1
    # luck returns, is remembered the same
    be.do("double lucky")
    luck = 0
    be.luga.done('yon')
    be.do("done, luck over")
    # 7 1
    # and show how a.done() affects the last time only as $n(c&drop)
    be.do("done still, refork",bec&_6)
    #  still has ver 6's $a
    be.do("!done on refork^1",bec&_5)
  
  // RiceDay
   // unit
    $be = me&mockbrackR,'RiceDay'
    # < i.* all lexicals as:
    #be.i_pi = 'hat'
    $day = 1
    $luck = 1
    $equipment = 0
    be.main = &Chir{
        
        # o having rice, may remember per day
        $magic = luck && h.zaa('situation:no rice')
            .length ? 66 : 0
        $have = me&sustain,{day},{RiceDay:magic}
        
        h.ha("Things,do:i")
        $Jugging
        if (have.el > 8) {
            # no rice
            # < supermind would wait for ** before re-Jugging
            if (equipment
                && !hak( me&sustaining,'Jugging' )
                && !hak( me&sustaining,'Pot' )) {
                Jugging = me&sustain,{},{Jugging:1}
                Jugging.temp ||= 16
            }
        }
        # o winding up Juggings
        #  as opposed to i winding up, for more unfold
        #  ie we don't &sustain Jugging|Pot after enacting it
        me&sustaining,'Jugging' .map(&a,{
            Jugging ||= a
            Jugging != a and throw "Jugs?"
            have.el < 9 and return a.done({u:have})
            a.temp += 30
        })
        if (Jugging && Jugging.temp >= 100) {
            # Jug -> Pot
            $Pot = me&sustain,{},{Pot:1}
            Jugging.done({n:Pot})
            Jugging.shouldbegone = "Jug"
            # the food has careful labels
            Pot.began ||= {day,ver:rs&ver}
            # < ideally this would show Jug done?
            i.zaarec = [...h.zaa('rec')]
        }
        me&sustaining,'Pot' .map(&Pot,{
            # pot takes one r to cook
            if (Pot.began.ver < rs&ver) {
                # cant take days to cook
                #  may or not update the $have we already got on this day
                $s = {day:Pot.began.day}
                $c = {RiceDay:1}
                me&sustain,s,c
                # we have posited such the $day, so...
                Pot.done({u:have})
                Pot.shouldbegone = 1
                
                h.ha("cooking:done",
                    {began:Pot.began.ver,now:rs&ver})
            }
            else {
                h.ha("cooking:now",
                    {began:Pot.began.ver,now:rs&ver})
            }
        })
        
        # Pot done -> RiceDay misses the idc.day logic
        #  unless we pseudo-&sustain again now
        # < update the $have we already got
        #   which is sometimes el:10, so unrememberable...
        #    perhaps some Name hanging on T.sute?
        # < theone() wrapper should be sub variation: &sustaining1
        #    and a non-fatal many use &sustaining0
        # < Babz have =|| ... # if ... true, overwrite have
        such = theone( me&sustaining,'RiceDay',{day} )
        # < A.h.o for &c:
        #such && such.el != have.el and ~>2 have found:
        !such && have.el < 9 and debugger
        such and have = such
        be.have = have
        h.ha({day,situation: have.el < 9 ? "rice" : "no rice" })
    }
   // # 1
    # < the -Bow a.sustain could do with rearranging lines
    #   about having one odd type|geo-magnitude
    #   the small things first
    #   mirage thingo sym (~) tells of the reorder
    #    usu pointing to original position of big thing
    #     if 1-2 of them, that can column
    #     depending on the rigidity of certain innards,
    #      eg diffsplay
    be.do()
    # something made rice!
    be.do()
    # 3
    # still have rice, found keying by $day+'RiceDay'
    # < some record or deal about $v going el:9
    luck = 0
    be.do()
    # something happens to the rice!
    # < what from whom?
    # < merely go el=9??
    be.have.done()
    be.do()
    be.do()
    # luck returns, have rice again
    luck = 1
    be.do()
   // # 7
    # the rules of the universe change,
    #  now!
    luck = 0
    equipment = 1
    be.have.done()
    be.do("start Jugging")
    be.do()
    # takes all day to boil Jug
    day = 2
    be.do("into the Pot")
    # 10
    # Jugging not restarting while Pot is cooking
    be.do("Pot is ready")
    be.do("still have rice")
    be.do("yet more")
    # a day!
    day = 3
    be.do("day three")
    be.do()
    # 15
    # magically have rice, done Jugging
    luck = 1
    be.do("luck had, done Jugging")
    luck = 0
    # 15_1
    be.do(bec&_14,"without luck, into Pot")
    # 16
    be.do("mockbrackR Further from that fork")
    # 16_1
    # we dont track the mass of rice itself,
    #  only a cooked Pot+day(began) satis the RiceDay+day
    #  also see # Pot done -> RiceDay misses the idc.day logic
    # so it is suddenly no good. Russian ending.
    day = 4
    be.do(bec&_15_1,"Pot the next day")
    
  // RiceRun
   // u
    # how to run people at a pot of rice
    $be = me&mockbrackR,'RiceRun'
    $eat = 0.05
    $feedrate = 3
    $hungeri = 1
    $ihunger = s => me&sustain,s,{hunger:hungeri++},'k'
    be.main = &Chir{
        # operating on $a, until &suso can show our brushstrokes
        
        # sum Reserved as an amount to eat
        $leave = sum(a => a.v, me&osus,'Reserve' ) * eat
        
        # < Babz: &sus Pot # or &pur, return
        $Pot = theone( me&osus,'','Pot' )
        Pot.et ||= 0
        
        $fed = 0
        map(&ai{
            # feedrate at a time
            feedrate-1 < i and return a.queued = rs&ver
            # imagine giving away that rice
            Pot.et + eat + leave > 0.9 and return a.missed = rs&ver
            Pot.et += eat
            # < these all together:
            a.satisfaction = rs&ver
            a.done('et')
            fed++
        }, me&osus,'hunger' .slice(0,feedrate+1) )
        
        i.hat = {leave,fed}
    }
   // n
    be.do("the setup", &Chir{
        # the resource
        me&sustain,'',{Pot:1}
        # reservations
        me&sustain,'of:doers',{Reserve:3}
        me&sustain,'of:gate',{Reserve:5}
        # eaters
        map(v => ihunger('early'), [...new Array(8)])
    },be.main)
    be.do('reserves some rice')
    # 3
    # a Reserve -> many hungers
    $pluck = &h,k,of{
        $Res = theone( me&osus,{of},'Reserve' )
        Res.done()
        # < they would have to %%rec separately
        #    as we assume later &sustain $k defs replace all previous
        #     this could change:
        #      &rec_traction could group by &sustain s.* + c.$k
        #       but not the other c.*?
        #       looking at n = %%sustain,(...s),rec,(...c) ?
        #        ie s + c[0]
        #       but it breaks the underlying intelligibility of %%rec
        #        and would complicate &jaaz beyond safety
        #   which all implies...
        #    sus:hunger are serial-numbering, each %%rec=hunger:$i
        #     &sustain adapts vector (hunger++) to what is
        #      < or it is one big hunger, with a quantity
        #        then we also have sus:missed, etc
        #        perhaps sus:hunger a.z=[sus:person+] might help:
        #      < trying not to let any one person down too much
        #    or:
        # we should reacknowledge the entire set
        # < leads to more robust software?
        # < or tell &sustain to do %%rec-conserving add
        #    aka having modes approaching|for 'resolve $n'
        #   eg q.el=1 (not q.num, sets protocol) (not a.el, is result)
        #    should enter the other %%rec (default q.el=2: let go)
        #    yet allow later &sustain q.el=1 them too
        #     drop other y&future they remember?
        # < h.ha cant $s=$n because of mixage
        #   its concerns should be mixed into &ha q.* under it
        #    use params for this
        $hungers = me&osus,'hunger'
        # prioritise Reserved hunger
        map(() => ihunger(k), [...new Array(Res.v)])
        map(a => h.ha(a.n.sc), hungers)
    }
    be.do("gate plucked", &Chir{
        pluck(h,'gator','gate')
    })
    be.do('serves that rice')
    # fed gators, still 4 hungry
    be.do('serves some rice')
    # 6
    be.do("doers plucked", &Chir{
        pluck(h,'doonya','doers')
    })
    be.do('serves more rice')
    # so 
    be.do('the last of them, still got 11.1**% of a Pot')
  
  // RiceDrop | RiceArrive | RiceNonText
    # ensure we can done|drop all the way to nothing
    #  thought I saw %%dome bringing things back, but no
    # see also PermaRice / !done on refork^1
    #  because .done() only affects the $n
    #   < unless format wants otherwise
    $be = me&mockbrackR,'RiceDrop'
    $any
    be.do("the setup", &Chir{
        any = me&sustain,'','Anything'
    })
    be.do("the vanishing", &Chir{
        any.done('lepro')
    })
    be.do("vanished", &Chir{
    })
    
    
    $be = me&mockbrackR,'RiceArrive'
    # multitudes should simply arrive
    be.do("many of them", &Chir{
        me&sustain,'','Rice' .day = 1
        me&sustain,'','Rice' .day = 3
        me&sustain,'','Rice' .day = 5
    })
    be.do("simply arrive", &Chir{
        $one = me&sustain,'','Rice'
        $three = me&sustain,'','Rice'
        $five = me&sustain,'','Rice'
        $nada = me&sustain,'','Rice'
        i.hat = {
            arrived: map(a => a.day, {one,three,five,nada}),
        }
    })
    
    
    $be = me&mockbrackR,'RiceNonText'
    
    # non-text s.* is ignored, not in n%*
    $chang = {le:'d'}
    $woplatio = {fold:1}
    $Then = be.do("one of them", &Chir{
        me&sustain,{seeing:'sight',chang},{Rice:2,zomb:'ie',woplatio}
    })
    
    # j
    # < these all basically point to the two %%sustain being Eref or not
    Then("has s.* ref change", &Chir{
        # s.* not in n%* dont matter
        chang = {le:'d'}
        # < do something meaningful about no more n%seeing
        me&sustain,{chang,lep:[1,2]},{Rice:2,zomb:'ie'}
    })
    Then("not s.* text change", &Chir{
        me&sustain,{seeing:'looking'},{Rice:2,zomb:'ie'}
        me&sustain,{lapis:'wave'},{Rice:2,zomb:'ie'}
    })
    Then("not c.* ref change", &Chir{
        me&sustain,{chang},{Rice:2,woplatio:{leaves:5}}
    })
    Then("not c.* text change", &Chir{
        me&sustain,{chang},{Rice:2,zomb:'ies'}
        me&sustain,{},{Rice:2,lapismo:{}}
        # however, we can:
        me&sustain,{},{Rice:2}
    })
    
S 6 &sustrain
    $h = A.h.o('sustrain')
  // < RiceJigger
    $be = me&mockbrackR,'RiceJigger'
    # the really simple
   // u
    $day = 1
    
    $N = []
    be.main = &Chir{
        me&sustrain ({
            i: N ,
            Glance: &yea{
                $idc = {t:e.t}
                y (idc)
            },
            Push: &yea{
                $idc = {t:'gladly '+e.t,day}
                y (idc)
            },
            Pot: &yea{
                # is wanted
            },
        })
    }
    
   // 1
    # no N
    be.do("empty")
    # now N
    N[0] = Cye(["lat",2])
    # dodgy sidetrack:
        # < GONE - since fixing Eref ea629d21ba3755c0c9af7f
        #    Display must have bugs but they're quite rare...
        #   0/sc/sustain/v not Display'ing the first time...
        #   shows up in E** via -Bat / -Spheres
        #    < further in there by yfuture of %target=R
        #   avoidable? pretty major.
        #    easier -Spheres** diving needed to investigate?
        #     or how do we add a mindthing via %TX?
        #   redo Display soon
        #   it could also be because we visit RE twice,
        #    again while hoisting outwards... see %%oust
    # note that 1/%sustain/a == 1/%Glance
    #  that is a.a=ish(v), which is like A.up
    # < point to these things ^
    #   ghost-embed points to give to -Eight
    #    mergible to|from -The
    be.do("something", be.main, &Chir{
        $Gli = theone( me&osus,'Glance_i' )
        $n = Gli.n
        # neither of these should be
        # < better assertions
        ns&Glance_i != N[0] and ahk(i,'difGlance_i',1)
        Gli.v != N[0] and ahk(i,'difGlance_i.v',1)
    })
    
    # sus:Glance is el:1, knows gs hash eq
    # sidetrack:
        # < Eref %sustain show on the new sus:Glance, not old (is first)
        #     the show: the one Eref with self-expression
        #   have to make E/*/*-wide decision about which, once -brack etc
        #    see < -brackios mirage
        #  < needing to rename &Piero etc
        #    they are waves of consciousness (twoism, threeism?)
    be.do("still something")
    
    # stops coming in
    N.shift()
    # < nothing on sus:Glance_i to say it stopped
    #    just the un-redone-ness of it
    #    see -brackios mirage
    be.do("sustained something")
    
    # be.diff to make sure
    be.diff(' diff: Glance_i zombies')
    # sidetrack:
        # < this patch ^ is annoying:
        #   the 5\t-brack is spread too thinly over a bunch of --
        #   same problem as 'resolve $n'
        # < the 0/%sustain.v space might be used for historic comparison
        #    though it would be something else in %sustain.c... that wases
        # < Eref 0/%sustain say '@six<<1'
        #    implying the rest of the path is the same (ups ~~ downs)
    
    # 0/%Glance_i: is the canonical one (less depth)
    be.do("still sustained something")
    be.diff('   diff: Glance_i still zombie')
    
    N[0] = Cye(["lot",2])
    be.do("lat->lot")
    be.diff('   diff: changes to lot')
  
  // < RiceTrain
    $be = me&mockbrackR,'RiceTrain'
    # RiceDay with better limbing
    # < allow using day-1 rice in crackers, cook hard
    # < sync more E/e** after an inital -six
    #    they could have more -seven in them about time?
    #    so they can show a part progressing over time
   // u
    $day = 1
    $poweroutage = 0
    $serving = 0
    $supply = ['ri']
    $incon = 0
    be.main = &Chir{
        $outage = poweroutage
        poweroutage = 0
        outage || me&sustrain ({
            i: supply,
            # make pots of each
            # < accumulate in a Pot
            Pot: &yea{
                $gs = {of:e}
                #~>4 Pot: rs&ver, e
                y (gs)
            },
            Cooked: &yea{
                # sus:Cooked_i leads to Cooked
                a.ov ||= 0.1
                if (a.ov < 0.6) {
                    # mutate .cooked
                    $s = a.cooked || ''
                    # adds new ingredient
                    a.el > 1 and s += a.of
                    ahk(a,['ebtw'],e)
                    s = split(s,'').join(' ')
                    a.cooked = s
                    # call that Cooked
                    a.cooked.match(/ {4}/) and a.ov = 0.8
                }
                #~>4 Cooked: rs&ver, e.of
                a.ov > 0.6 and y ({day},"Look",{food:a.cooked})
            },
        }, {incon})
        $onlydoneone = 0
        serving && me&sustrain ({
            i: me&osus,'Cooked' ,
            Dishing: {hord:&yea{
                # s={day,food}
                onlydoneone++ and return 0
                #~>4 DOMID: a.food
                $u = y (a)
                a.a.done({u})
            },sleeping:&yea{
                #~>4 dontmid: a.food
                
            }},
        })
    }
    
   // 6
    be.do("start cooking ri")
    be.do("keep cooking ri")
    supply.push('ce')
    be.do("start cooking ce too")
    be.do("they keep going")
    supply = []
    be.do("and are done")
    be.do("stay done")
    supply = ['yag']
    be.do("yag takes over the kitchen")
    
    # Cooked->Dishing
    serving = 1
    # Dishing starts using recv.hord
    #  to accumulate all sus:Dishing ever
    # but can only move one of them at a time
    #  Dishing_i:ce remains
    be.do("yag continues, others served")
    
    # dont Cooked:yag
    poweroutage = 1
    # Dishing:ce made
    be.do("yagless")
    
   // 10
    be.do("yag dished")
    # Dishing:yag sleeping now
    #  pressure still on Pot...Cooked...Dishing_i:yag
    be.do("yag pipeline idle")
    supply = []
    # 12
    # emptying mode
    #  else Pot stops happening, the rest pick up from the domed Pot
    incon = 1
    # all of it!!!
    # they look like they would go away
    be.do("yag pipeline vanished")
    # then we have Dishing_i:yag, Dishing sleeping
    #  tmi flooding in on recycled Dishing.a|n
    #   all for things unheard of this time
    #    < wants lv
    be.do("finality")
    
    # an electroding: these wrap be.do(), another somewhere in &sustrain
    #T.sustabug = 'Pot'
    delete T.sustabug
    T.sustablag = 'PotCooked'
    delete T.sustablag
    
S 7 @elIntro
    $h = A.h.o('elIntro')
    A.h.sixc = 'nl:500'
    $be = me&mockbrackR,'IntroBits'
    $bi = me&mockbrackR,'IncBits'
    # the process of Q++ -> a system
    #  to clean up @Gnome / &SG_elIntro
    #   which only uses one &sustrain, then a few &sustain
    be.supply = []
    $sup = &tsc{
        $Q = Cye([t,1,pex('of:wjs',c)])
        Qs&string = s
        Qs&dige = dig(Qs&string)
        # a strange event from @Aearch
        $e = Cye(['elIntro',1,{e:Q}])
        be.supply.push(e)
    }
    be.main = &Chir{
       // supply -> elIntro
        me&sustrain ({
            i: be.supply,
            # extra step, persists the above
            #  usu ignore the first one if i empty, laters still &osus it
            graspQ: &yea{
                $Q = ec&e
                # less index|many-ing than later
                y ({t:Q.t},Q)
            },
            elIntro: &yQa{
                # usu &diffPs returns di.gs|Comp etc
                $gs = me&Qidc,Q
                $ofc = nex({},gs,'dige')
                # ofc thing, gs version
                y (gs,Q,ofc)
            },
            # recv.any|all may regroup rows
            # < this will have no Inc_i.v, see: q.origin and a.v = v
            Inc: {init:1,all:&yNa{
                h.ha({Incsum:hak(N),givena:a})
                each iQ N {
                    h.ha({Inclood:Q.t}, me&Qidc,Q )
                }
                return 0
                # < a.firstInc = time:Inc
                # < return 0 until Inc++
            }},
            
        # loco.pk=cors: use send()'s c (ofc ^) or s (t:Q.t ^^)
        #  forming &sustain q.pk=t:such:of:wjs
        },'pk:cors')
        # e once
        be.supply = []
        
    }
    
    sup('Bliss',<<'')
        S Uverallic
            33 3
        S Latch
            33 3
    
    sup('Ulvs',<<'')
        &diatoms
    
    be.do("first")
    
    
    sup('Bliss',<<'')
        S Uverallic
            35 3
        S Latch
            33 3
    
    #T.sustabug = 'Inc'
    be.do("quick revision")
    delete T.sustabug
    # < 14 sus:Inc_i:Ulvs is el2!
    #   see # our last $v was not C
    be.do("Inc still")
    
    
    
    # see loco.incon !
    # < also if we have car.i yet no car.o emerge (after having some)
    
    # < this bunch of #msgs in RiceTrain should be an Eight
    
    # < try getting sleepings to &sustain anyway...
    #    is tricky, unless a.c|sc becomes confident to reproduce s,c,q exactly
    #    perhaps this is &suso? an other-time interaction
    #   mostly so they go el1 over time?
    #    do %%rec redomings want to experience them all?
    
    
    # < recv.ovs{ ov: middle-if-ov }'
    #    auto set to next ov defined (anywhere) if tao
  // generals
    3
    #  < from seeing historical a.sublated?
    #    a vote for %%sustain somewhat remaining...
    #   or is this when you would use &sustrain?
    # < done(a.sublated={u:Upward_Process}), a.el=11?
    #    see the notions of u|n amongst Gump/*
    #  < args like that of &strange|&wants|&waits
    #    they could be string message and|or hash of relations

    # < dethrow having w:TryPiWarmer
    
    # < DeckChair puts Gnome to work
    #    see Doming & Beeping will separate
    #    see wiki/Intentional_programming
    #   would interpret activity, actuate:
    # < make RunStep%dodge redo first next time
    #    by 4s&whereGnome[$t][$S]
    #  < -nine seems to "waitsfor:Try@1"
    #  < and various other memorables, holding:
    #     various other settings, start as buttons
    #      wired up the slope to be more permanent
    #      should be easy to cause|effect Lab,The,This,
    
    # < CacophanyDescriber sprouts in This**
    #   is for self-diffs (CED** vs D** expected)
    #   and laterals: any good chunks of similarity
    #   should notice when array inserts cause i++ ripple
    #   and of course show whole -brack to make tidier patch
    #    unless it really looks like the same thing mutating
    #    negating the encoded-ness
    #   train on:
    #    886d21ed02135d1e9 - lose all the have, unindent
    #    7325462e30095219 - see day++ for v9 (was v10)
    
    # community: remark (i $s/**-rem) highly removable thing that you i to the code
    # < give Ying some more speed
    # < Accept yay chunks for now
    #    helps make commits more coherent,
    #    accumulate aggreeable parts of -six** til all good
    # < want %eph HEAD..HEAD^1 diff ongoingly (Yinguto?)
    
    # < a.n could point to the last true one?
    #   ny&future always the latest, so .done() knows
    
    # < ex(s,c+)
    # < fatal.isfu() etc returning the thing
    # < &Ay for climbing up and around
    #    finding s as a limit:ref amongst s^^
    3
  // CodeUp <- elIntro
    # the projection of change into ...
    =CodeUp
     the projection of change into ...
     we could begin further back in:
     @Search
      having async receive, compile, flock ready
     @Intro
      supervise -> @Inc
       which could take it from there (its own @Intro)
      and compute what to tell @Pro about it
       we can probably model what to do fairly completely
      usu redo the process related to ~chunk (eg RunStep)
       @Pro having each $W
        < and the @Inc version its for
        < and any unmerged branches, Afield
      config auto ->@Inc, ->@Pro, ->@Run
       usu @Inc it and then el:3 some @Pro/$W
      
      Anyway,
       many $gs identify the Intro-ing rows
        until assimilated
       per $gs
        syncInc: v=@Inc//R
         wants a new wake of R:Inc, since that observed with $gs
          ie a.el=2 with a.b
           < a.b
           < or q.num=4, will el:3 the non-first?
        intRun: v=$S
         what to do in response
         < receives a done() when OK
       
       many $gs at once:
        many syncInc, one wake:Inc until all got
        no intRun until all syncInc got
          
     
    =use of &sustain so far
     < and where it could be used
     
    =elIntro was
        elIntro_i e:elIntro(/$Q), makes idc $gs:
        elIntro s=v=$gs
       &sustaining,'elIntro' a, still aka $gs ->
        < realise source revoked, see 'poison mode'
        IncBefore s=$gs,v=1
         if el==2 (first)
          return &wants @Inc
        IncAfter s=$gs,v=R%is_quiet
         if el>8 (not quiet)
          return a.pur
         any gs.steps:
        RunStep s=$gs,v=$S
         
    =RunStep was
      having:
        RunStep s=$gs,v=$S
         as above
        RunStep v=time
         is randomly from buttons or autostart|through
      &rowcap RunStep:
        < ~Fe, diag|help about it
          we some simply push on, end up Ness++ (Fe to us)
          similarly:
          < ~ninec&Into (not per RunStep), could be -Lab next?
            would know if next is Run-syncable, plan speedrun
        < ~quiettime, by counting R%quiet
          ie sustain driving time:quiet++
           and binding a particular time to it,
           supposing it is A piling up X for other A
        < ~unsure, sum lots of inputs, eg quiettime el=10
      # then joins RunningStep=$S as $any
        < needing !unsure to compute any >@5
          ie not while This>Fine
        < Fugue: notice going dodgy
           could be done while unsure, unquiet
           check Ply works out, log it all
      # it occasionally will:
       &dotheRunStep:
        RunningStep v=$S
         also knows quiet time
         < etc, it has a time itself
           commits to it snapshots of other time around it
         < this becoming 
         starts only, dropped by:
      # notice starting, completing, etc
        < merely sublate each RunningStep, like being @8
          once Fe OK for it
          it would have delta profiling etc
         < list of stuff to chuck if lowmem
        RunStep v=$S+1
         orders the next step if %through
    < whats &eisa?
        
    =cut
  
  // etc
    # < Gnow() possibly with timetravel
    #    to use fetime + delta since engaging in timetravel
    # < peel() that 'th:ing=s' -> {th:{ing:'s'}}
    # < peel() that 'th=ing=s' -> {th:'s',ing:'s'}
    
    # < the idea of not deleting things
    #    they just have a final scene together, then are gone
    # < h.traction() won't sane more than once
    #  < will &dome_traction ?
    # < show %%dome, %%rec losing the order of things
    
    # < diff|Ply may concentrate on parts
    #    Ply usu has a diff, but could E**-select from a y&thing
    #     to then feed to a diff (and maybe further itself)
    
    # < Babz grep(_s&RunningStep == ns&RunStep,any)
    # < grep({bow:&vki{}},f.sc) or grep({bowi:1},f.sc)
    #   grep bowk=$such $f
    #    such that grep cannot be used for C.*
    #     or C/* without expr: $f/
    #  < Babz floaty params for any known function like that
    #  < and for s&* not in c&shade.*
    #  # see neuro / $firk = ...
    # < sub() for &ha doing clone-from via q.base=$n
    #  # see neuro / h.ha(ex(
    3
    
    
    
