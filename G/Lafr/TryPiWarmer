# test, runs on W:Thy, 33
n doafew 1 s:Things!
$R = A.Run
$h = A.h
fatal.ish(h)
# < becoming Babz 'more of a title -Fez=>\n  ...'

    
S 1 test data for -hat ref noticing, limits, specialfx
    $h = A.h.o('Something')
        # $time-seven, as long as it contains something:
        # to make stuff up
        $dat = me&PiRet_data
        dat.moreso = dat.asee
        $Bow = h.hat('Bowler',dat)

        $da = {more:'some',figaro:dat.asee}
        da.furhtin = {llatin:4}
        $Bow = h.hat('Lol',da)

        $da = {fer:dat.asee,even:'more',figaro:dat.asee}
        da.furhtin = {llabin:4}
        $Bow = h.hat('Room',da)
        # 
        $i = 0
        while (i < 60) {
            da = da.th = {}
            i++
        }
        da.is = 'all'
        # < &Eing preferring this to more level$n !
        #   diversity seeking
        $ej = Bowc&s.neesd = Cye(['Nees',3
            ,{mo:3,tor:68,functions:"of an elabourate sort",s:"Thsideratea"}])
        ejy&fig = dat.asee
        ejy&vig = 2
        Bowc&s.leveridge = Cye(['Nose',7,{s:'li'}])
        $i = 0
        while (i < 55) {
            Bowc&s['lever'+i] = 'thing'
            i++
        }
        
    $h = A.h.o('Someact')
        $da = {as:dat.asee,fol:33,vanas:dat.asee,vaees:dat.asee}
        da.string = <<''
            Til
              forward
               motion
              was
               it
               all
            
            etc!
             etc
        
        $D = Cye(['Ling',1,{s:da.string},{}])
        da.encodes = me&enL,D
        da.spaceynum = num("  ")
        da.stringynum = num(" 0")
        da.verylong = new Array(100) .join('123-')
        $Bow = h.hat('Bowler',da)
        # lurkfa faing!onn.. fa
        

S 2 twos
    $h = A.h.o('brackstract')
    
    # < Tool for zooming into Ying-gate !!!
    
    #$s = 4s&interestoYing
    $s = me&mock_Thyergate,R
    !s || !ss&X and return me&tc,"awaits"
    ss&X.A != R and debugger
    # X by &bracki (ish), make &Shx_isX
    # < the &Shx p.ist('X') check is too silent
    me&brackstract,ss&X
    
    # < a holding X, knowing what format the inner might like
    each ks R.sc {
        !k.endsWith('W') && (!isob(s) || isC(s) || !isC(s.A)) and continue
        # the &Saturn %%inst,listen_node there coops these:
        $pi = k.endsWith('W') ? 'Womb' : 'Fez'
        
        h.tys(k,pi,s)
    }
    
S 3 Pictures hashy misc
    $h = A.h.o('Something')
    $hat = h.hat
    # < sample all calls to ahk() etc during a bunch of Stories
    #    keeping a taxography of all uses
    #     the data condenses a schema!!!!!!!!!!!!
   // modulat!
    # < T.act.t should be steppy?
    # < autogen C.t < argmo
    # < Babz 'n anyoldtext -Bow => &yada,&m{'
    #    DIY closing bracket etc
    #    should be possible, -Bow knowing how to interpret such a housing
    #    so c&s = c&code or so, during T.act of A:n
    #     which knows its proper title
    #    this is a nice realm
    #    we make the BQ a subroutine, mini-pin...
    #     so it may define handlers in the dome
    #     they would be on the ground..? receive calls on a telephone...
    #     also make them, on eg a lamp, that can be used to be the origin,
    #      to write the address relative to.
    #       carrier assurance of messages coming from elvis.
    #    the 'stricter title 33-Fez: %such:even =>'
    #     also. is BQ dependent?
    #    perhaps shorter 'n some = ...' # have to eval first? put in sub?
    #    or the 'n some i yo/plo//%chi' # some = any spheres with %chi across yo/plo
    #    and '$n o such/where' # notice !n
    #    then '$z o yer/$n' # still !n
    #    then 'i mixio/$n &quant $z' # fatal
    #     < wants empty spaces sometimes
    # < stub a bunch of ways as above! devob, mkv, etc
    h.Womb('&ts?c?', me&abTap,'Picmodu',Cye(['Picmodu',1]) (&{
        me&tsc,'becomes',0,'6y'
        me&tsc,'tos','','6g'
        me&tsc,'untos','la','6b'
        me&tsc,'basictsc','la'
        me&tsc,'moretsc','la','46yl'
        me&tc,"tctitle"
        me&tc,"tcstyle",'G'
        me&ts,"ts0",0,'6'
    }))
    h.Womb('boxcap_test_situation', me&abTap,'situa',Cye(['situa',1]) (&{
            $two = me&boxcap,"pile1",'1y'
                me&tc,"<"
                $three = me&boxcap,"yondsome",'1y'
                    me&tc,"insidde"
                three()
                me&tc,">"
            two()
            
            $two = me&boxcap,"pile2",'1y'
                $three = me&boxcap,"empty",'1y'
                three()
                me&tc,"outside"
            two()
            $two = me&boxcap,"Achgindi",'1y'
                me&tc,"stuff"
            two()
            $two = me&boxcap,"Achgindi",'1y',2
                me&tc,"stuff"
            two()
            $two = me&boxcap,"Achgindi",'1y'
                me&tc,"additional"
            two()
            $two = me&boxcap,"Achgindi",'1y',2
                me&tc,"andmore"
            two()
    }))
  
  # notes a heading in Pictures:
   // # types
    # < title as expr, expect true. just '!iske(44)' on a line.
    $D = Cye(['D',3])
    $Dot = Cye(['Dot','-Dot'])
    hat('Fividy types',{
        "isha({})": isha({}),
        # causes ish([])
        "isha([])": isha([]),
        "!isha(D)": isha(D),
        "isob({})": isha({}),
        "isR(R)": isR(R),
        "!isR(D)": isR(D),
        
        # avoid
        "sca(333)": sca(333),
        "sca(333.3)": sca(333.3),
        "dec(333.3)": dec(333.3),
        "dec(333)": dec(333),
        "dec('333')": dec('333'),
        # < more
    });
    hat('types',{
        "!isba(D)": isba(D),
        "isba(R)": isba(R),
        
        "iske(str)": iske('stri'),
        "iske(num)": iske(44),
        "iskeyish(num)": iskeyish(46),
        "!iske({})": iske({}),
        "!iske(null)": iske(null),
        # housey - looks like index
        "!ish(null)": ish(null),
        "!ish('str')": ish('str'),
        "!ish(D)": ish(D),
        "ish([])": ish([]),
        "ish({})": ish({}),
        
        "!isit({})": isit({}),
        "!isit([])": isit([]),
        "isit(D)": isit(D),
        "isit(str)": isit('str'),
        
        "!ispi(D)": ispi(D),
        "ispi(Dot)": ispi(Dot),
        "ispi(Dot,'Dot')": ispi(Dot,'Dot'),
        "!ispi(Dot,'Else')": ispi(Dot,'Else'),
    })
    # < fatal variations
   // # access new
    $ala = me&yio,Dot,'Allah'
    # &yio
    hat("&yio",{
        "returns what .ohe.e was": [
            ala.i('ohe','e','m'),
            ala.i('ohe','e','igla'),
            ala.i('ohe','e','m'),
        ],
        "uniq accumulate": [
            ala.i(['loth'],'e','m','ding'),
            ala.i(['loth'],'e','m','ding'),
            ala.i(['loth'],'e','m','dong'),
        ],
        "fod:1, frod++": [
            ala.i('fod'),
            ala.i(['frod'],1),
            ala.i(['frod'],1),
            ala.i(['frod'],1),
            # doesnt count!
            #ala.i(['frod'],3),
            ala.i('ohe','e','mot'),
        ],
        "m": ala.o('ohe','e','m'),
        "e": ala.o('ohe','e'),
        "!e": ala.o('e'),
        "all loth": ala.o('loth'),
        "fod:1": ala.o('fod'),
        "root": ala.o(),
        "is on Doty&...": Dot,
    })
    
   
  # misc() access
  # misc() hash
   // ahk()
    # &yio covers what it returns each time (was value)
    $aC = Cye(['bling',3])
    $notC = {}
    ahk(aC,'usual','scing','things',1)
    ahk(aC,'more',3,4)
    ahk(aC,'more',1,4)
    # allows just k,v
    ahk(aC,'moren',3)
    ahk(aC,'moren',1)
    ahk(aC,'moren',1)
    # < catch "listend!num"
    #ahk(aC,['moren'],1)
    ahk(aC,['mores'],1)
    ahk(aC,['cumu'],'la','place')
    ahk(aC,['cumu'],'la','loose')
    ahk(aC,['cumu'],'loose','ly')
    # samey
    ahk(aC,['cumu'],'la','loose')
    ahk(aC,['c'],'cumu','la','va')
    ahk(aC,['c'],'cumu','la','vava')
    ahk(aC,['y'],'cumula','ar')
    # samey
    ahk(aC,['y'],'cumula','ar')
    ahk(aC,['y'],'cumula','uniques')
    ahk(aC,['y'],'cumula','all')
    # see indexOf string!=num
    ahk(aC,['y'],'cumula',3)
    ahk(aC,['y'],'cumula','3')
    # < catch "listend!ar"
    #ahk(aC,['c'],'cumu','va')
    ahk(notC,'things','that','were','here')
    ahk(notC,'things','that','were','there')
    ahk(notC,['things'],'all','was','finiga')
    # starts adding to a number
    ahk(notC,['things'],'FROT','was','finiga',2)
    ahk(notC,['things'],'FROT','was','finiga',1)
    ahk(notC,['things'],'all','was','finigaL')
    # already exists
    ahk(notC,['things'],'all','was','finiga')
    
    # count
    ahk(notC,['things'],'all','was','3',1)
    ahk(notC,['things'],'all','was','3',1)
    ahk(notC,['things'],'all','was','3',1)
    # < but not add
    #ahk(notC,['things'],'all','was','3',3)
    
    ahk(notC,'vari','k',1)
    ahk(notC,'vari','k',1)
    ahk(notC,'y','varo',1)
    ahk(notC,'c','all','was','3',1)
    hat('ahk()',{aC,notC})
    
   // hashkv()
    # < an n@3 hook to pipe s through eg hashkv and arrange the results
    $abunch = {}
    $em = (t,s) => abunch[t] = s
    
    $abc = {aye:4,bee:3,cee:2}
    $disc = hashkv(haks(abc).map(k => ['the '+k,"said "+abc[k]]))
    em("remap",{abc,disc})

    em("ark:$v",
        hashkv('ark','$v'))
    # ! string object k
    em("'it' -> {it:1}",
        hashkv('it'))
    em("[[nc&sip,n]+] -> {'0 1 2':n}",
        hashkv([['0 1 2','One'],['0 1 2 1','Two']]))
    em("!N.length -> {}",
        hashkv([]))
    em("'key',{thing:1} -> {key:{thing:1}}",
        hashkv('key',{thing:1}))
        
    hat('hashkv()',abunch)
    abunch = {}
   // < # more type
    
   // # peel(), arq()
    em("one",peel("can"))
    em("two",peel("can,you"))
    em("two.5",peel("can,you:feel"))
    em("three, first : only",peel("the:lunch:tonight,that,was::fiver"))
   
    hat('peel()', abunch)
    abunch = {}
    
    try {
    em("already",
        arq({seeing:{theeing:"is"}},{qk:{seeing:1}}))
    # < catch
    #em("c.seeing!housey",
    #    arq({seeing:"lovely,ness"}, {qk:{seeing:1}}))
    em("put into",
        arq({thanks:3}, {qk:{seeing:1}}))
    em("!peel, put into",
        arq({thanks:"diat"}, {qk:{seeing:1},peely:1}))
    em("peel, put into 2",
        arq({thanks:"figaro,thjin:k"}, {qk:{seeing:1,thanks:1},peely:1}))
    em("peel some, dont put into",
        arq({thanks:"figaro,thjin:k",seeing:"fully:knowing,myself"},
            {qk:{seeing:1},peely:1}))
    em("peel, dont put into",
        arq({thanks:"figaro,thjin:k",seeing:{fully:2,five:5}},
            {qk:{seeing:1,thanks:1},peely:1}))
    
    em("see nothing",
        arq({thanks:"figaro,thjin:k",se:{fully:2,five:5}},
            {qk:{seeing:1},peely:1}))
    em("see nothing qk/$k=dept",
        arq({thanks:"figaro,thjin:k",se:{fully:2,five:5}},
            {qk:{seeing:'abranchof'},peely:1}))
    }
    # we dont expect an error
    catch(er) {
        bunch.an_error = ''+er
    }
    hat('arq()', abunch)
    abunch = {}
    
   // ex()
    $ro = {ela:'borate',ti:3}
    # rata!!!!!!ff!!!!!e!!ssve!!!!!!3!!!!!!!!!
    $la = {fly:1,ti:4,la:4}
    $nd = ex(ro,la)
    hat('ex simple',{ro,la,nd})
    
    
   // # misc() array
    // data
        $Tom = <<''
            Long way going to
            Get my medicine
            Skys the autumn grey of a lonely wren
            
            Piano from a window played
            Gone tomorrow, gone yesterday
            
            I found it in the street
            At first I did not see
            Lying at my feet
            A trampled rose

        $h = hashkv(grep(Tom.split("\n")).map(s => split(s,' ',1)))
        
        
        
        
        
        
        
        $a = haks(h)
    
    # given c, no default c.inc=1
    # < return sliced hash..? already returns sliced arrays
    # < until, (til, aft), after
    #    io etc shall know... til(C) the T.iteration?
    #    and til1, aft1 for the :p/$s<1 maneuvre
    #     also looking for aft(tow)
    # < convert these to joint() the result
    #    once all the /(^\d+) -String "/ and /"\n/ in the patch
    #     can be identified as such
    $yesterday = v => v.includes('yesterday')
    hat('ksaf()',{
        origin: {h,a},
        'on hash': {
            until: ksaf(h,{bow:'Skys'}),
            til: ksaf(h,{bow:'Skys',inc:1}),
            aft: ksaf(h,'Gone'),
            after: ksaf(h,{aft:'Gone'}),
        },
        # < Textl notice ^ and v are mostly same!
        'on array': {
            until: ksaf(a,{bow:'Skys'}),
            til: ksaf(a,{bow:'Skys',inc:1}),
            aft: ksaf(a,'Gone'),
            after: ksaf(a,{aft:'Gone'}),
        },
        'where': {
            "after v~~/yesterday/":
                ksaf(h,{aft:yesterday}),
            "after v~~/yesterday/ til k~~'At'":
                ksaf(ksaf(h,{aft:yesterday}), {bow:'At',inc:1}),
            " same + hash sliced":
                sex({},h, ksaf(ksaf(h,{aft:yesterday}),
                    {bow:'At',inc:1})),
            "after v~~/yesterday/ til v~~/^L/ + hash sliced":
                sex({},h, ksaf(ksaf(h,{aft:yesterday}),
                    {bow:v => v.startsWith('L'),inc:1})),
            'until v~~/indo/':
                ksaf(h,{bow:(v) => v.includes('indo')}),
            'aft k~~/ing/':
                ksaf(h,{aft:(v,k) => k.includes('ing'),inc:2}),
        },
    })
    
    # < the above as range args to grep:
    #    $N = grep /yesterday/../^L/ 
    #    $N = grep ..(/^indo/) # range makes () less-selecting. usu more? <art.
    #    $N = grep ..k~~/ing/ # range makes bare k ok?
    hat('grep()',{
        "Piano": grep((v,k) => k == 'Piano',h),
        "no a": grep(v => !v.match('a'),h),
        "a value": grep('at my feet',h),
        "for truth": grep({la:1,non:0,li:4,fe:0}),
    })
    $aa = a.slice()
    hat('grepout()',{
        "Piano": grepout(aa,'Piano'),
        "is gone": joint(aa),
        "in array": grepout(aa,['At','The','Lying']),
        "are": joint(aa),
        "short|early keys": grepout(aa,(v,i) => hak(v)==1 || i < 3),
        "leaving only": aa
    })
    hat('split()',{
       'no limit': split("3,3,3,3,3,3",','),
       'limit=2': split("3,3,3,3,3,3",',',2),
       'regex': split("3,3,,,,3,,,3,,3,3",/,+/,3),
    })
    hat('flatten()',{
        "doc": flatten([1,[1,2]]),
        "N = z|N": flatten([[1]]),
    })

   // js trivia
    # javascript weirdnesses!
    
    $l = ['1', '2', '3']
    hat('indexOf string!=num',{l,li: l.indexOf(2) ,number_btw:9})
    
    # use before buy!
    l.map(&n{
        use = 3
        $use = n
    })
    # < Plying test output to here,
    #   generating blog with <code>1+1 # 2</code>
    hat('null <>-ier than undefined',{
        null_lt_6: null < 6,
        null_gt_6: null > 6,
        null_gt_neg6: null > -6,
        undef_lt_6: undefined < 6,
        undef_gt_6: undefined > 6,
        undef_gt_neg6: undefined > -6,
    })
    hat('more types',{
        'zero': [
            '' == 0,
            '0' == 0,
            '' == '0',
        ],
        'undef': [
            false == undefined,
            false == null,
            null == undefined,
        ]
    })
    
    # has to be &{} to get arguments
    $lostcint = (s) => aroint([...arguments],':')
    
   // &indo etc
    # < see that M == &indo... &e{ return e } works like 3d grep
    # < &deL for tabless lines from the editor
    #    checks they are peely-types
    if (0) {
        $M = []
        # e** until !y&pack, to the point of eg e:elIntro
        me&indo,e (&ed{
            # an enveloping, at %JRom or so..? see elvoids
            ec&pack and return
            M.push(e)
            d.not = 1
        })
        return M
    }
   
S 4 @Gnome
    $h = A.h.o('Something')
  // reself resync
    $This = me&Names_get,R,'This'
    $Fine = me&Names_get,R,'Fine'
    # uses the REy&main, aka sy&$pi:
    $This = Thisy&This
    $Nine = Cye(['TryNine','-nine'])
    # inflates Ness** from Fine/Ness**
        # isolating Ness < this one
        $stop = 0
        $copiq = {match:&nz{
            n.t == '-Gnome-4' and stop = 1
            stop and return
            return 1
        }}
    me&EsyncThe,Nine,Fine,{copiq}
    !Ninec&Into and throw "!Into"
        # isolating This** < now
        $clintoq = {match: &snz{
            # s:from(This|Eight) n:item(Eight|seven) z:to(Eis|Ei)
            s == This and return n.t.match(/^(Some(thing|act)|brackstract)$/)
            nc&pi != 'seven' and debugger
            # before this step
            return n.t < 4
        }}
    me&EsyncThis,Nine,Fine,{This,clintoq}
    
    # contain %dige, subject to change
    me&fiu,Nine,'The',9
    me&fiu,Nine,'This',9
    # can sometimes see %%next_Ness_title_clue (not after first Run)
    $next = delete Ninec&Into
    $Ness = me&fiu,Nine,'Ness',7
    me&fiu,Ness,next,9
    
    
    h.Bow('reself resync',{Nine},{nl:300})
    
  // diff stack finding
    $a = <<''
        1
         14
          a
         2
          3
          3b
          3c
    
    $b = <<''
        1
         14
          a
         2
          3
          3bc
          3c
    
    # las.t ends up being the R.t of the diff... 
    $N = me&twoCstrings,'diff-stack-finding',b,a
    $diffc = {}
    # may put on modulat $se, to made invisible
    #diffc.se = Cye(['invis',1])
    # no caching
    diffc.el = 2
    $di = me&diffany,R,...N,diffc
    $compComp = &Nt{
        # compress that
        # < Cye() can not drop %z if it was specified in an array:
        $vis = Cye([t||'vis',1])
        viss&z = N.map(n => Cye(n))
        each in viss&z {
            ns&moren && !ns&shortfor and debugger
            delete ns&moren
            ns&string == nc&s and delete ns&string
        }
        return vis
    }
    # < &enL implanting C|N Lines via BQ (for eg %moren, if not deleted)
    h.Womb("diff stack finding",compComp(dis&Comp))
 
 // minor key
  // &Sharg saves the Bowler -Strings with &Stringchew
    $rg = me&Sharg,'$s/Someact/1/Bowler//E/-hat/*(R%String)//R',[This]
    $all = Cye(['sche',1])
    rg.N
        .map(n => me&fiu,all,n.t .sc.z = flatten(ns&M||[]))
    h.Womb("&Stringchew",all)
    
  // < -hat data immediately
    # < look at the Yingulog!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #   first try only, comes back to see 'after'
    #    a couple of times as per %wakeful or so?
    $da = {here:'before'}
    da.stringstract = a
    h.hat("-hat data immediately",da)
    # < 
    #da.here = 'after'
 
 // majorly
  // dome brack
    me.mockR = &acgtt{
        $ver = 1
        $maker = &b{
            $r = Cye([t,333])
            ry&R = r
            # have the previous r
            b and rc&b = b
            rs&ver = ver++
            # have %C that leads back to r
            $C = rs&C = Cye([t,1])
            Cy&R = r
            # have %wou
            me&haja
            return r
        }
        $spawner = &b{
            return &y{
                $r = maker(b)
                y (rs&C,r)
                return spawner(r)
            }
            
        }
        return spawner()
    }
    $wou = &Ct{
        $r = me&R
        r.t == 'Run' and debugger
        $wou = rs&wou
        h.Bow(t,wou)
    }
    h.wou = &acgtCt{
    }
    me&mockR,'art' (&C{
        $h = me&hajasute
        h.ha("Artful:ness")
        wou(C,'see art')
    })
    
    
