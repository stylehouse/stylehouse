# islands
S 1 fetch ghost
    A.h.sixc = 'expect位,first_truest'
    $h = A.h.o('fetch ghost')
    $c = {init:['givefive','Runin'],aft:['mute_synco','AXV']}
    $Fish = me&Fishliver,c
    
    # 3 steps because we await &fetch then &add_script
    # < dont come all the way in here:
    #    GoRun needs a will to do Fishlive, or:
    #     
    Fish.S("alittlestep",&AWVT{
        Wc&iv > 6 and return fi&com,"lotsiv",{W}
        if (Wc&iv == 1) {
            fi&remove_script,'/wjs/Easiness'
        }
        
        fi&YA,"Leopardo" (&A{
            # what we edit, source, uncompiled
            $gh = fi&Ath,A,{of:'ghost',t:'Easiness'}
            # bunch of code in a sub
            $w = fi&Ath,A,{of:'wjs',t:'Easiness',args:'J'}
            # < of:me: as above
            #    except we have compiled s/me/this/g
            #     and stored at $W/1.js
            #   then we call the function with new a me={}
            #   then copy a bunch of them together to form a mind
            #    possibly does patches to individual me.*?
            # > of:Ijs: &add_script, loadI
            #    so P%I is to be got, as A.5%I starts everything else
            #    possibly does patches to individual me.*?
            #!w and return
            $W = fi&Ath,A,{of:'W',t:'Sleigh'}
            !W and return
            $says = dis(w)
            fi&Xsimp,A,{says},{n:w}
            $c = {A, ghosdig:dig(ghs&string), wjsdige:ws&dige}
            fi&com,"Completo",c
        })
        # see &Ring, Piing
        #fi&YAing
        # everyone wants to exist
        fi&com,"Everyone..."
        Wc&iv == 1 and fi&YAtjoinable,A
        fi&elvising_onward
    })
    
S 2 complanet in syncopation
    # the want of a callback to occur within Run time
    #  so we GoRun++, Wc&GoPara ~~ c&e for A:n
    A.h.sixc = 'expect位,first_truest'
    $h = A.h.o('complanet in syncopation')
    $c = {init:['givefive','Runin'],aft:['mute_synco','AXV']}
    $Fish = me&Fishliver,c
    Fish.S("alittlestep",&AWVT{
        A&main = &{
            fi&com,'butterfly'
        }
        $sometime = &t{
            # here are the two wakeysockets
            a&seemingly = {
                t,
                Fish: 4c&live&&'awake',
                Planet: A.5[4].sc.current&&'awake',
            }
        }
        fi&com,"Everyone..."
        $things = {just:1}
        if (Wc&i == 1) {
            sometime("inside")
            fi&yl,0.01 (&y{
                # notice not being awake
                sometime("outside")
                
                if (0) {
                    # < GOING, &complacement will &e_GoRun if needed
                    # slight wake Run with GoPara
                    $yc = {t:"outsidesaying",do:&AWVT{
                        # capturing state of things
                        fi&com,'hadtosay',{things}
                    }}
                    fi&e_GoRun,'outin',yc
                }
                fi&com,'hadtosay',{things}
                
                # change state of things
                things.also = 2
                
                # 4%todo++ leads to next frame
                fi&Yjoin,A,'latchmo'
            })
        }
        else {
            ac(A,'nonfirst iv',{seemed:a&seemingly.t})
        }
        a&Harvel = G&peel,"that,ch"
        Wc&i == 1 and fi&Yjoin,A,'latchmo'
        fi&elvising_onward
        # V, the A:RunGo Sunpitter!
        # <   and Fish.S(&AWVT{ V.tys })
        #   then we may need to adjust &t to find A.5.4 if A.5.4!=.4
        if (Wc&i == 3) {
            # now slightly obfuscated, since syncserve() while live
            #  leads to ^^%JRom%elvoids += e to pack (treeing)
            #$ec = ex({},Wy&current_Run_elvis.c)
            #delete ec.wake
            $N = me&through_packs,Wy&current_Run_elvis
            h.hat('re-sync e:Run',N,{dl:2})
        }
    })
    Fish.S("look again",&AWVT{
    })
    
S 3 formula
    # churning up the formula
    #  uses &Fishliveio, the next &Shx
    A.h.sixc = 'expect位,first_truest'
    $h = A.h.o('formula')
    $c = {init:['givefive','Runin'],aft:['mute_synco','AXV']}
    $Fish = me&Fishliver,c
    Fish.S("alittlestep",&AWVT{
        fi&YA,"Leopardo" (&A{
          // get ghost:Fish
            $io = me&Fishlivioer
            T.iocom = 1
            # so every A&V we see has some
            i anything
            # what we edit, source, uncompiled
            $gh = fi&Ath,A,{of:'ghost',t:'Fish'}
            !gh and return
            # <<<
            # clone P:Fish to n:Fish
            $n = Cye(gh)
            n.sc = tex({},n.sc)
            # < for /$t+=$n to set up arriving &V
            #   deriving a value for $t from $n is n.t
            #    this might be the default behaviour of #$n some places...
            #   name is usu it or the function deriving it...
            #    < $n|$z|$N|$Z should mean different things
            #       /$n dupey insert, /$z once
            #   for now, the way these ark is nice:
            i input/n.t /ns&dige $n
            
            delete T.iocom
            
            # < might sleep here if so far is matching &V
            #   does a hard copy, inc the old $n
            #    for all structure we thence introduce
            
          // pile ch**
            # are not everything
            $z = Cye([n.t,1])
            $lines = ns&string.split("\n")
            me&chunksoflines,z,lines
            # all of them?
            # z/z are the toc?
            # < what's up with the order?
            $N = [z,...zs&chunks]
            N = vsortz(N,h => hs&line)
            
            # make ch of these chunks
            # they include the
            $all = []
            $stack = []
            N .map(&h{
                hs&first_line = lines[hs&line]
            })
            each is N {
                $ind = ss&indent || 0
                # "" from a blank line?
                !ss&first_line and continue
                $up = null
                if (i > 0) {
                    ind += 1
                    $findind = ind
                    while (findind > 0 && !stack[findind-1]) { findind-- }
                    while (hak(stack,findind)) { stack.pop() }
                    up = stack[findind-1]
                }
                !up && 1*(i||ind) and debugger
                # new ch
                $ch = Cye(["ch@"+i,1])
                ch.sc = tex({},s.sc)
                up and ac(up,'z',ch)
                all.push(ch)
                stack[ind] = ch
            }
            $top = all[0]
            
          // bits to know
            $some = grep(h => hs&indent < 3,all)
            some .map(&h{
                i heads/hs&first_line
            })
            # the first one thinks its everything
            # < and it's twice, or is the top one t=Fish?
            me&indo,top (&sd{
                $la = null
                each in ss&z {
                    if (la && ns&line < las&toline) {
                        ac(s,'strange','went all the way to: '+las&toline)
                        las&toline = ns&line -1
                    }
                    la = n
                }
            })
            # decide where to fold
            me&indo,top (&sd{
                ss&lines < 400 and ss&edge = 1
            })
            
            $line_to_ch = &si{
                $test = s => ss&line <= i && ss&toline >= i
                !test(s) and debugger
                ss&edge and return s
                $better = grep(n => test(n), me&ioty,s )[0]
                better and return line_to_ch(better,i)
                return s
            }
            
            $def = /fi\.(\w+) =/
            $use = /fi&(\w+)\b/
            each is lines {
                $m = s.match(def)
                if (m) {
                    $ch = line_to_ch(top,i)
                    ch and ac(ch,'defines',m[1])
                }
            }
            
          // write up
            h.Womb('Heads', me&abTap,'situa',Cye(['situa',1]) (&{
                $i = 1
                me&indo,top (&sd{
                    me&boxcap,'z**#'+i++,1 (&ml{
                        lc&s = 'o'
                        ms&ml = d.d
                        
                        $str = ss&first_line
                        str = str.replace(/^[\s+\/]+/,'')
                        $st = me&tc,'string','G'
                        stc&s = str
                        sts&fs = 33 - Math.min(d.d*5,22)
                        
                        me&tc,"length",'x'+ss&lines,'y'
                        ss&edge and d.nofurther = 1; me&tc,"..."
                        
                        # < if different?
                        ss&indent and me&tc,"Indent" .c.s = ss&indent
                        
                        ss&defines && me&boxcap,'def',2 (&ml{
                            ms&hue = 100
                            map(n => ns&ma = 0.2,
                                t => me&tc,"&"+t,'G' , ss&defines)
                        })
                        
                        ss&strange && me&boxcap,'strange' (&ml{
                            map(t => me&tc,"!?!?"+t,'g' , ss&strange)
                        })
                    })
                })
            }))
            #h.hat("Headings",some,{dl:2})
            
            fi&com,"Completo"
        })
        fi&com,"Everyone..."
        Wc&iv == 1 and fi&YAtjoinable,A
        fi&elvising_onward
        
        T.adj = [
            # one desire to close off boring stuff
            {Ri:'limit:sans:of,toomuch',
            # multiplied over all points it should occur
            N:['&X/of','&b','&V/of']}
        ]
    })
    
S 4 multi YA
    # see that Leopardo@3 can become the Gnome's e:R target
    A.h.sixc = 'expect位,first_truest'
    $h = A.h.o('multi YA')
    $c = {init:['givefive','Runin'],aft:['mute_synco','AXV']}
    $Fish = me&Fishliver,c
    Fish.S("alittlestep",&AWVT{
        fi&YA,"Leopardo" (1,&A{
            $io = me&Fishlivioer
            i initial
        })
        fi&com,"Everyone..."
        Wc&iv == 1 and fi&YAtjoinable,A
        fi&elvising_onward
    })
    Fish.S("recurring",&AWVT{
        $Do = fi&YA,"Downier" (3,&A{
            $io = me&Fishlivioer
            i cons/thing
            i cons/4c&step
        })
        fi&com,"Everytwo..."
        fi&elvising_onward
        fi&Yjoin,Do
        
        h.hat("aloft",W,{dl:3})
    },'resetty')
    
    # < Adj@1,2 have noise the first time
    # <<<
    # we have a chance now to define the new A,me
    #  since we pull in all the code
    # mostly:
    #  < toc each of:ghost
    #     for %Code, into Codap maps
    #     < toggle non-selected cm to %dis:0
    #   
    #   new me collation
    #    me.I_Thing = &{ [mindC+] } for voice:Ring
    #     and something derived from &Ying
    #      which for some reason became the name|type of the A.4...
    #    
    #   @Search, %ting%Gens W:Thy
    #   interpret !me.$function errors, suck subs out
    #   html writer
    #    should escape a lot of code?
    #    A:Display
    
    # < fixup some comment jargon
    # < -Log can probably sleep once @3** picture taken
    
    # < to &com -> This** when async
    #    if we're not 4c&live or 54s&current|thinking (Fish or Planet)
    #     then we can tunnel into Run:$W
    #      which will have been told of the ploy
    #       to ambiently Fishlive, no steps
    #     grab a working &complace about being async
    #      which is really just a -six shooter
    #       engaged for an -Eight, over time-seven
    
    # < electroding between each line, animating the -Difmo...
    # misc:
    # < hat $t should be airtight: allow /, %stuff, -pi in titles
    # < Push fails to reself|DIY?
    # < notice 2GB processes and similar
    # phi = 1.618
    # anyway, the Story goes:
    
    # fi&test_Attention,2
    
    
    # <<<
    
    #  < This** wants a new sense of time: for all -six?
    #     per -six created in a different -seven to the last one
    #     so many -seven*/-six* can be created frantically
    #      yet 1/4-six knows it came right before 2/2-six
    # be %string-wobs
    #  < further The development there (for Thens)
    #     can it be bound to sheer time like This is (will be)
    #     separating %TX change until such is
    
    # < @is: check which of w:The / &honly etc are used anywhere
    # < W storage that $t/(W|J)/$t (or is it I|O?)
    
    # < This->Nine robusticised, two brittles:
    #  try reself if after Push
    #   also if Ness new, reset and RunStep once
    #  < switching h.hat<->h.Bow
    #      requires reset (@JRom tt:reset)
    #     as RE/E pile up in This** ?
    #      for some reason not escaping &forgetRunStep
    #  < adding -Eight, after Push
    #      requires reself (@Fest tt:Leave)
    #     ninec&gobble seems busted
    #      splits news to new Ness
    #     only after Push
    # < cm: C+[ indent 1 space
    # < cm: if-and flipper.
    #    are draggable chunks - gestures mapped
    # < cm: indent within a blob of #
    # < cm: pulling This into Code or vise-versa
    