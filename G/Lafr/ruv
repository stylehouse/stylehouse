# I
# me/io global:
$me = 4c&me;
!me and throw "no me";
$io = me.io;
window.io = io;
window.me = me;
# redisable feta
# < always. relies on Pearch Qup'ing. Foogla doesn't.
me.hacks = &acgt{
    # Peace is redoing the idea of
    # %play enabling meanings in s.sc%ball
    $Be = me.Be;
    # adds A.4/$W via Elvisory/
    delete Be.sc.J;
    # adds ^^%gee via openness[] etc
    delete Be.sc.W;
    # already disabled/broken somehow:
    delete Be.sc.R;
};
me.ruv = &acgt{ return [
    ... me&Peaceness ,

    ... me&Beepingness ,

    ... me&DisplayTwoness ,
    ... me&Rscinsideness,'ruv' ,
    ... me&Ballingness ,
    ... me&Linesingness ,
    ... me&Diffingness ,
    ... me&Slepingness ,
    ... me&Actingness ,
    ... me&Toolingness ,
    
    # notify tinger
    ['Pearch','291',&acgtRs{
        G&way,'Pearch',{R};
    },'ift,D'],
    
    ['Neutrons','291',&acgtRs{
        me&tsc,'beamdap',0,'g'
    },'ift,D'],
    
    # traversee
    ['COmbac','3',&acgtRs{
        $r = me&Rsc,R,'COmbac';
        $Q = rs&Q;
        $s = Qc&s;
        s && !sc&code and me&tsc,'Nocode',0,'B'
        
        me&nu,'s',s;
        me&nu,'Q',Q;
        me&nu,'P',Qs&P;
    },'ift,D'],
]};

# S for an osc pin, bump through segments of the work
me.Srupto = &A,C,G,T,s,t,talk,params{
    s == '' && t == '' and throw "no io"
    A&Srupto and return A&Srupto(...arguments)
    #~Sonly: s, ':', t, '%', talk
    
    A&Sonly && num(s) && s != A&Sonly and return 0
    
    t ||= s;
    
    A&doings ||= {};
    $l = A&doings[t] ||= {};
    l.done and return
    l.done = 1;
    #~sttalk: ki([s,t,talk,params]);
    return 1;
};

# find things from A[1-9].I
G.t = &acgtst{
    typeof s == 'object' and throw "Nevers";
    $D;
    for (var n = 1; n <= 9; n++) {
        $Y = A[n];
        !Y and continue
        $I = Y.I;
        !I and continue
        # container/personality/embryo
        D = I[s];
        # thing/step/nodule/item
        D && t != null and D = D.y.tw[t];
        D and break
    }
    return D;
};

# find things from %Search
#  _ting with proper args
# < for many %Searches, a lighter Q
#    ein() them outoftime
# < i and I will not %Search
# h: me&i,'i','name' .c.code(...)
me.t = &acgtRst{
    !isR(R) and throw "!R"
    isC(s) and $Q = s
    else
    isha(s) and $Q = Cye([t,1,s])
    else {
        t == null and t = s; s = "I"
        $Q = Cye([t,1,{of:s}]);
    }
    
    if (Qc&of == 'i' || Qc&of == 'I') {
        # A.I.* (embryos) are just $of, not $of/$t
        #  Ghost/In/$of is not the I-thing they want,
        #  u might t of:W or of:js from Search
        #   which generates A.I unto the slope
        # A.I.$of(/$t)?
        throw "iI"
    }
    else {
        # %Search
        $Search = me&Rsc,R,'^^Inn';
        !Search and debugger;
        T.asyncQs and Qc&async = &{ T.asyncQs.push(Q) };
        $s = Searchs&_ting(Q,R);
        # we would be async
        return s
    }
};

# function call, named params
#  might throw async, to come back somehow
#  a&ready=0/1 as waiting/ready
#  TuneTimeMachine pushes to 4s&N or so
me.way = &acgtRtry{
    !isR(R) and throw "!R"
    $ar = r || {};
    $cb = y;
    
    # args = 'ar'+tar
    # < remove code_args, argumentation
    $tar = G&ks,ar;
    $args = 'ar';
    tar and args += ','+tar
    
    # the index to an of:wjs
    $Q = G&Cye,[t,'',{of:'wjs',args}];
    
    cb == 'noop' and cb = &{}
    # throw async if not ready
    Qc&async = &{
        typeof cb == 'string' and throw "Cant go async: "+cb

        # Jin should avoid this A for a while
        a&ready = 0;
        # and throw/abort if no callback
        !cb and G&TuneTimeMachine,'w:'+t
    };
    
    # ready leads to retry
    Qc&ready = &{
        # Jin should accept this A again
        a&ready = 1;
        if (!cb) {
            ~>3 no way back?: t, R.t
        }
        elsif (G&arfgunc,cb == "s") {
            # GOING
            # way randomly happens, give return value to cb
            # without A lining up around it (it may do so itself)
            # see G&waylay for use case as delayed call
            $s = G&way,t,ar,'already_async';
            cb(s);
        }
        else {
            # containing a sync G&way call
            # or a way to get the context revisted
            #  eg me&wayel crosses off its waiting list thus
            cb(t,ar,w);
        }
    };
    
    $w = me&t,R,Q;
    if (!w || !wc&code) {
        T.asyncQs && T.asyncQs.includes(Q) and return
        throw "no way: "+Q.t
    }
    
    $argumas = tar.split(',').map(k => ar[k]);
    # see Ban
    # < finding sources
    Gc&B.sc.way = w;
    if (cb) {
        # containing a sync G&way call
        #  or a way to get the w back
        return cb(t,ar,w)
    }
    return wc&code(A,C,G,T,ar,...argumas)
};
# < noop=nottl could Qc&Want_Check=1
# < make it c.code and G&h for a B?
