# Iliation
$R = A.Run
$h = A.h
S 1 Xsim
    # This/-Eight pictures data
    $h = A.h.o('Something')
    $nonA = &t{
        # A container
        #   A lesser than even &Atopleast
        #    we can avoid G&calls (which are A.1^^ searches)
        #     except for the S, so scope $A to a non-sub
        $A = Cye([t||'Fusing',1])
        A.y = A
        return A
    }
    1 and 0
    (&{
    $A = nonA()
    # data container
    #  as opposed to A.c|sc.** directly
    $X = {A}
   // # &Xsim has a funny interface:
    # args:
    #  $X where to put stuff, may be A:
    #  $k may Ac&$k += X, only if given $X=A
    #  $t=['abit'] wraps every s.* with .abit
    #   a bunch of departmenting to jump into at each X|x|office
    #  $s keys to the index
    #   needs at least one
    #  $c what|how to put there
    #  $q unused
    
    #  $k may Ac&$k += X, only if given $X=A
    fi&Xsim,X,'ifnotX',[],{ifnot:3}
    # this one is hosted on Ac&ifnotX
    fi&Xsim,A,'ifnotX',[],{ifnot:4}
    
    #  $t=['abit'] preceeds every s.* with .abit
    # X.extrabit.fun.3=x
    fi&Xsim,X,'X',['extrabit'],{fun:3}
    # this reoccurs at every s.*
    fi&Xsim,X,'X',['extrabit'],{fun:3,joy:3}
    # X.extrabit=x reused as an index hash (hs)
    #  in &Shx we do /word/ -> X.word.1 = x
    fi&Xsim,X,'X',['extrabit',1],{fun:4}
    #  is climbed past (as $hs), no usu x typing (x.up etc)
    fi&Xsim,X,'X',['otherbit',1],{fun:4}
    # ! no s.*, no wrapping
    fi&Xsim,X,'X',['nonbit']
    
    h.hat('funny interface',X)
    
   // c.n
    $A = nonA()
    a&ret = []
    $X = {A}
    $Xsim = &sc{
        # $N = &Xsim
        $N = fi&Xsim,X,0,0,s,c
        a&ret.push(N)
        return N
    }
    
    # X.figarto.1=x empty
    Xsim({figarto:1})
        # X.figarto.3=x has a row! x.z -> A%ret.0
        $n = Cye(['Fusilli',1])
        Xsim({figarto:2},{n})
    
        # rows join indexes
        Xsim({flim:2,flam:2},{n})
        $n = Cye(['Fuzylajj',1])
        Xsim({flim:2,flam:2},{n})

        # A%ret.3: we find all 3 in X/$flim=2
        #  ie s.* neednt have all
        $n = Cye(['Unfuse',1])
        Xsim({flim:2,figarto:2},{n})
    
    # we find the union
    Xsim({flim:2,flam:2})
    
    # s.* neednt have all
    #  ~~ &bracko, inherited to &sustain
    Xsim({flam:2})
    # A%ret.6: s.* order doesnt matter
    Xsim({figarto:2})
    
    # dup $n is stored, deduped on the way out
    #  see &xzand / !M.includes(n)
    Xsim({figarto:2},{n})
    # A%ret.9: it is an object compare
    #  see &xzand / ox.z.includes(n)
    #  so two C:Unfuse now come out
    $n = Cye(['Unfuse',1])
    Xsim({figarto:2},{n})
    
    # queries (or at least !c.n) autovivfy empties
    #  none: yet $fogma=2 = x (/!$n)
    Xsim({fogma:2})
    #  none: $fogma/!$n xzand $figarto/$n
    Xsim({fogma:2,figarto:2})
    # A%ret.12
    Xsim({fogma:2,groova:'to'})
    
    # c.el:8 doesnt autovivify empties
    #  returns null, ~~ &ja
    #   since $grover doesnt exist
    Xsim({fogma:2,grover:'to'},{el:8})
    #  none: since $fogma=2 is merely empty
    Xsim({fogma:2,figarto:2},{el:8})
    # A%ret.15
    #  as above, s.* order doesnt matter
    Xsim({figarto:2,fogma:2},{el:8})
    #  returns null, since $grover doesnt exist
    Xsim({figarto:2,grover:2},{el:8})
    
    h.hat('c.n',X)
    
   // c.long
    # you climb x = x._ for s.*
    #  more spacious space, returning $x not $n+ rows
    $A = nonA()
    $X = {A}
    $Xsim = &sc{
        # $x = &Xsim
        return fi&Xsim,X,0,0,s,pex(c,'long')
    }
    
    $n = Cye(['Unfuse',1])
    Xsim({tog:1,figarto:2},{n})
    $n = Cye(['Fuzylajj',1])
    Xsim({tog:1,flam:2},{n})
    $x = Xsim({tog:1})
    x.aways = 'along'
    $x = Xsim({tog:1,flam:2})
    x.all = 'theway'
    # s.* order matters
    $x = Xsim({flam:2})
    x.norows = 1
    
    # empty, yet indexed
    Xsim(peel('all,the,spaces:3,in,here'))
    
    # c.el:8 doesnt autovivify empties
    #  it will however create an empty spaces:4|5:
    Xsim(peel('all,the,spaces:4,over,there'),'el:8')
    Xsim(peel('all,the,spaces:5,for,layout'),'el:8')
    #  ie it starts when there is no x.further:
    Xsim(peel('all,the,further:6,over,such'),'el:8')
    
    h.hat('c.long',X)
   
   // c.array=1
    # allows indexing objects (~~ &X_s)
    # < benchmark this vs using Cy&uid where possible...?
    #   it greps for them underneath?
    #    is where perl's scalar($obj) == unique address is nice
    $A = nonA()
    $X = {A}
    $Xsim = &scx{
        return fi&Xsim,x||X,0,0,s,pex(c,'long')
    }
    
    $anob = {}
    Xsim({thisward:anob},'array') .once = 1
    # what's inside doesn't matter:
    anob.five = 5
    Xsim({thisward:anob},'array') .twice = 1
    # is different:
    Xsim({thisward:{other:3}},'array') .thrice = 1
    # whole leg is array-stored
    Xsim({elsewhere:anob,for:'it'},'array') .quice = 1
    #  you (eg &Xsomp) may break it down:
    $x = Xsim({elsewhere:anob},'array')
    x.five = 1
        Xsim({now:'stringy'},'',x)
        Xsim({now:'etc'},'',x) .finally = 1
    
    h.hat('c.array',X)
    
   // c.wild|simvx and -anx "noxup"
    # c.wild(card) returns vx for X.such.*=x+ (to &Xsomp)
    #  $vx is $hs (indexy hash (or array)) where .$t=$x
    #   or if it was c.array, .$i=$x
    #    unless you were looking at the refs, which is .$i=$s
    #  only for one &Xsim s.*
    #   though non-wild can occur first (X/$thus)
    # c.simvx returns inflated vx, with only the selected keys in it
    #  usu just one key
    #   < unless WHERE loose, ranges
    #   so &Xsomp can always get a $vx whether c.wild or not
    #    useful for finding the $i for c.array
    #  only one &Xsim s.*
    #   ie you row across high frequency &Xsim
    $A = nonA()
    $X = {A}
    $Xsim = &scx{
        return fi&Xsim,x||X,0,0,s,pex(c,'long')
    }
    Xsim({thus:1,all:'variously'}) .incar = 2
    Xsim({thus:1,all:'muchly'}) .incar = 3
    Xsim({thus:4,all:'suchly'}) .incar = 4
    Xsim({thus:5,all:'suchly'}) .incar = 5
    $vx = Xsim({thus:1,all:1},'wild:all')
    
    # by the way, -anx says noxup when X...x is unnatural:
        # when we get to -anx, at vx.$k=x
        X.thusallwild = vx
        # the .vividity is noxup
        #  .up also, reveals where it thinks it is
        #   terminating the noxup-ness
        #  .etc.3 is not, since it presents as inside the nearest ^^x|X
        Xsim({thus:5,all:'suchly',etc:3}) .inert = 1
        $x = Xsim({thus:5,all:'suchly'})
        X.vividity = x
        # just this far in, it shares .up=X
        $x = Xsim({thus:4})
        X.obscurity = x
        # this far out, it doesnt
        Xsim({shape:4,tango:3}) .inobscurity = x
    
    # c.simvx
    $asim = s => Xsim(s,'array')
    asim({lets:{}})
    asim({lets:{}}) .two = 2
    $lets = {cre:8}
    asim({lets})    .three = 3
    asim({lets:{}}) .four = 4
    # to know the X.lets(s)?.$i
    $vx = Xsim({lets},'array,simvx')
    X.simvx = vx
    
    h.hat('c.wild|simvx',X)
    
    })()
    