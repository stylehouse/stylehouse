# Iliation
$R = A.Run
$h = A.h
    $nonA = &t{
        # A container
        #   A lesser than even &Atopleast
        #    we can avoid G&calls (which are A.1^^ searches)
        #     except for the S, so scope $A to a non-sub
        $A = Cye([t||'Fusing',1])
        A.y = A
        return A
    }
S 1 Xsim
    # This/-Eight pictures data
    $h = A.h.o('Xsim')
    1 and 0
    (&{
    $A = nonA()
    # data container
    #  as opposed to A.c|sc.** directly
    $X = {A}
   // # &Xsim has a funny interface:
    # args:
    #  $X where to put stuff, may be A:
    #  $k may Ac&$k += X, only if given $X=A
    #  $t=['abit'] wraps every s.* with .abit
    #   a bunch of departmenting to jump into at each X|x|office
    #  $s keys to the index
    #   needs at least one
    #  $c what|how to put there
    #  $q unused
    
    #  $k may Ac&$k += X, only if given $X=A
    fi&Xsim,X,'ifnotX',[],{ifnot:3}
    # this one is hosted on Ac&ifnotX
    fi&Xsim,A,'ifnotX',[],{ifnot:4}
    
    #  $t=['abit'] preceeds every s.* with .abit
    # X.extrabit.fun.3=x
    fi&Xsim,X,'X',['extrabit'],{fun:3}
    # this reoccurs at every s.*
    fi&Xsim,X,'X',['extrabit'],{fun:3,joy:3}
    # X.extrabit=x reused as an index hash (hs)
    #  in &Shx we do /word/ -> X.word.1 = x
    fi&Xsim,X,'X',['extrabit',1],{fun:4}
    #  is climbed past (as $hs), no usu x typing (x.up etc)
    fi&Xsim,X,'X',['otherbit',1],{fun:4}
    # ! no s.*, no wrapping
    fi&Xsim,X,'X',['nonbit']
    
    h.hat('funny interface',X)
    
   // c.n
    $A = nonA()
    $X = {A}
    # we throw data into X.*:
    X.ret = a&ret = []
    $Xsim = &sc{
        # $N = &Xsim
        $N = fi&Xsim,X,0,0,s,c
        a&ret.push(N)
        return N
    }
    
    # X.figarto.1=x empty
    Xsim({figarto:1})
        # X.figarto.3=x has a row! x.z -> A%ret.0
        $n = Cye(['Fusilli',1])
        Xsim({figarto:2},{n})
    
        # rows join indexes
        Xsim({flim:2,flam:2},{n})
        $n = Cye(['Fuzylajj',1])
        Xsim({flim:2,flam:2},{n})

        # A%ret.3: we find all 3 in X/$flim=2
        #  ie s.* neednt have all
        $n = Cye(['Unfuse',1])
        Xsim({flim:2,figarto:2},{n})
    
    # we find the union
    Xsim({flim:2,flam:2})
    
    # s.* neednt have all
    #  ~~ &bracko, inherited to &sustain
    Xsim({flam:2})
    # A%ret.6: s.* order doesnt matter
    Xsim({figarto:2})
    
    # dup $n is stored, deduped on the way out
    #  see &xzand / !M.includes(n)
    Xsim({figarto:2},{n})
    # A%ret.9: it is an object compare
    #  see &xzand / ox.z.includes(n)
    #  so two C:Unfuse now come out
    $n = Cye(['Unfuse',1])
    Xsim({figarto:2},{n})
    
    # queries (or at least !c.n) autovivfy empties
    #  none: yet $fogma=2 = x (/!$n)
    Xsim({fogma:2})
    #  none: $fogma/!$n xzand $figarto/$n
    Xsim({fogma:2,figarto:2})
    # A%ret.12
    Xsim({fogma:2,groova:'to'})
    
    # c.el:8 doesnt autovivify empties
    #  returns null, ~~ &ja
    #   since $grover doesnt exist
    Xsim({fogma:2,grover:'to'},{el:8})
    #  none: since $fogma=2 is merely empty
    Xsim({fogma:2,figarto:2},{el:8})
    # A%ret.15
    #  as above, s.* order doesnt matter
    Xsim({figarto:2,fogma:2},{el:8})
    #  returns null, since $grover doesnt exist
    Xsim({figarto:2,grover:2},{el:8})
    
    h.Fez('c.n',X)
    
   // c.long
    # you climb x = x._ for s.*
    #  more spacious space, returning $x not $n+ rows
    $A = nonA()
    $X = {A}
    $Xsim = &sc{
        # $x = &Xsim
        return fi&Xsim,X,0,0,s,pex(c,'long')
    }
    
    # &Xsimp X s c q
    #  does &Xsim c.long with better args
    fi&Xsimp,X,{Basica:'ly',every:'thing'}
    
    $n = Cye(['Unfuse',1])
    Xsim({tog:1,figarto:2},{n})
    $n = Cye(['Fuzylajj',1])
    Xsim({tog:1,flam:2},{n})
    $x = Xsim({tog:1})
    x.aways = 'along'
    $x = Xsim({tog:1,flam:2})
    x.all = 'theway'
    # s.* order matters
    $x = Xsim({flam:2})
    x.norows = 1
    
    # empty, yet indexed
    Xsim(peel('all,the,spaces:3,in,here'))
    
    # c.el:8 doesnt autovivify empties
    #  it will however create an empty spaces:4|5:
    Xsim(peel('all,the,spaces:4,over,there'),'el:8')
    Xsim(peel('all,the,spaces:5,for,layout'),'el:8')
    #  ie it stops when there is no x.further:
    Xsim(peel('all,the,further:6,over,such'),'el:8')
    
    h.Fez('c.long',X)
   
   // c.array=1
    # allows indexing objects (~~ &X_s)
    # < benchmark this vs using Cy&uid where possible...?
    #   it greps for them underneath?
    #    is where perl's scalar($obj) == unique address is nice
    $A = nonA()
    $X = {A}
    $Xsim = &scx{
        return fi&Xsim,x||X,0,0,s,pex(c,'long')
    }
    
    $anob = {}
    Xsim({thisward:anob},'array') .once = 1
    # what's inside doesn't matter:
    anob.five = 5
    Xsim({thisward:anob},'array') .twice = 1
    # is different:
    Xsim({thisward:{other:3}},'array') .thrice = 1
    # whole leg is array-stored
    Xsim({elsewhere:anob,for:'it'},'array') .quice = 1
    #  you (eg &Xsomp) may break it down:
    $x = Xsim({elsewhere:anob},'array')
    x.five = 1
        Xsim({now:'stringy'},'',x)
        Xsim({now:'etc'},'',x) .finally = 1
    
    h.Fez('c.array',X)
    
   // c.wild|simvx and -anx "noxup"
    # c.wild(card) returns vx for X.such.*=x+ (to &Xsomp)
    #  $vx is $hs (indexy hash (or array)) where .$t=$x
    #   or if it was c.array, .$i=$x
    #    unless you were looking at the refs, which is .$i=$s
    #  only for one &Xsim s.*
    #   though non-wild can occur first (X/$thus)
    # c.simvx returns inflated vx, with only the selected keys in it
    #  usu just one key
    #   < unless WHERE loose, ranges
    #   so &Xsomp can always get a $vx whether c.wild or not
    #    useful for finding the $i for c.array
    #  only one &Xsim s.*
    #   ie you row across high frequency &Xsim
    $A = nonA()
    $X = {A}
    $Xsim = &scx{
        return fi&Xsim,x||X,0,0,s,pex(c,'long')
    }
    Xsim({thus:1,all:'variously'}) .incar = 2
    Xsim({thus:1,all:'muchly'}) .incar = 3
    Xsim({thus:4,all:'suchly'}) .incar = 4
    Xsim({thus:5,all:'suchly'}) .incar = 5
    $vx = Xsim({thus:1,all:1},'wild:all')
    
    # by the way, -anx says noxup when X...x is unnatural:
        # when we get to -anx, at vx.$k=x
        X.thusallwild = vx
        # the .vividity is noxup
        #  .up also, reveals where it thinks it is
        #   terminating the noxup-ness
        #  .etc.3 is not, since it presents as inside the nearest ^^x|X
        Xsim({thus:5,all:'suchly',etc:3}) .inert = 1
        $x = Xsim({thus:5,all:'suchly'})
        X.vividity = x
        # just this far in, it shares .up=X
        $x = Xsim({thus:4})
        X.obscurity = x
        # this far out, it doesnt
        Xsim({shape:4,tango:3}) .inobscurity = x
    
    # c.simvx
    $asim = s => Xsim(s,'array')
    asim({lets:{}})
    asim({lets:{}}) .two = 2
    $lets = {cre:8}
    asim({lets})    .three = 3
    asim({lets:{}}) .four = 4
    # to know the X.lets(s)?.$i
    $vx = Xsim({lets},'array,simvx')
    X.simvx = vx
    
    h.Fez('c.wild|simvx',X)
    
    })()

S 2 Xsomp
    # layer above &Xsim:
    #  i: &Xsimp does a normal kind of &Xsim, no rowing
    #  o: &Xsomp does rowing, per /$n, returning [ax+]
    # used by
    #  Fish / Q # originally
    #  &Shx_io # exciting edge of io, rowing
    $h = A.h.o('Xsomp')
    1 and 0
    (&{
   // &Xsimp -> &Xsomp
    $A = nonA('&Xsimp -> &Xsomp')
    haks(peel("Fuzylajj,Dongit,Riding,Wings"))
        .map(t => A.sc[t] = Cye([t,1]))
    $X = {A}
    
    # &Xsimp X s c q
    #  does &Xsim c.long with better args
    #  doesnt do rowing (returns x)
    $Xsimp = (s,c) => fi&Xsimp,X,peel(s),peel(c)
    
    Xsimp("Basica:ly,every:thing",{n:a&Dongit})
    Xsimp("Basica:ly,every:time",{n:a&Riding})
    Xsimp("Basica:va,every:where",{n:a&Dongit})
    # copied from Fus@1 / c.long / c.el
        Xsimp('all,the,spaces:3,in,here')
        # c.el:8 doesnt autovivify empties
        #  it will however create an empty spaces:4|5:
        Xsimp('all,the,spaces:4,over,there','el:8')
        Xsimp('all,the,spaces:5,for,layout','el:8')
        #  ie it stops when there is no x.further:
        Xsimp('all,the,further:6,over,such','el:8')
    
    X.everyevery = fi&Xsomp,X,{Basica:1,every:1}
    
    X.everyevery = fi&Xsomp,X,{Basica:1,every:1}
    X.lyevery = fi&Xsomp,X,{Basica:'ly',every:1}
    # none
    #  creates /$every=way
    X.everynot = fi&Xsomp,X,{Basica:1,every:'way'}
    # needs rows to be there (/$n)
    #  using &Xsimp|&Xsim they are only at the end
    #   we land on x+, which have x/$n+
    X.Basicanot = fi&Xsomp,X,{Basica:5}
    X.allnot = fi&Xsomp,X,peel('all,the,spaces:3,in,here')
    
    h.Fez('&Xsimp -> &Xsomp',X)
   
   // /$n
    # needs rows to be there (/$n)
    #  using &Xsimp|&Xsim they are only at the end
    $A = nonA('/$n')
    haks(peel("Fuzylajj,Dongit,Riding,Wings"))
        .map(t => A.sc[t] = Cye([t,1]))
    $X = {A}
    # &Xsimp for input
    $Xsimp = (s,c) => fi&Xsimp,X,peel(s),peel(c)
    # &Xsomp cant input c.n, since &Xsim c.simvx leaves early
    #  see &Shx_io which splits for i|o
    $Xsomp = (s,c,q) => fi&Xsomp,X,peel(s),peel(c),peel(q)
    Xsimp("every:thing",{n:a&Dongit})
    Xsimp("every:time",{n:a&Riding})
    Xsimp("every:where",{n:a&Riding})
    Xsimp("every:where",{n:a&Dongit})
    # abbreviate ax+
    $res = (t,N) => X[t] = N.map(ax => nex({},ax,'arkx'))
    res('every where',Xsomp("every:where"))
    # does where-/$n-clauses via q.n
    # < c.n could be used since &Xsomp cant input c.n
    res('every n:Riding',Xsomp("every:1",{},{n:a&Riding}))
    
    Xsimp("every:thing,else:ward",{n:a&Dongit})
    Xsimp("every:thing,else:fliv",{n:a&Riding})
    Xsimp("every:where,else:fliv",{n:a&Riding})
    res('elses',     Xsomp("every:1,else:1"))
    res('whereelses',Xsomp("every:where,else:1"))
    
    # c.array for objects
    Xsimp({want:a&Dongit},{n:a&Riding,array:1})
    Xsimp({want:a&Riding},{n:a&Fuzylajj,array:1})
    # &Xsomp doesnt need to know c.array
    res('all wants', Xsomp("want"))
    #  unless it is looking for something...
    res('want of Dongit', Xsomp({want:a&Dongit},'array'))
    res('want of Fuzylajj', Xsomp({want:a&Fuzylajj},'array'))
    res('wants of Fuzylajj', Xsomp("want",'array',{n:a&Fuzylajj}))
    
    # ! this $t fed to &Pii, sensitive to /|%|-pi
    h.Fez('per $n',X)
    
    })()
   
S 3 Shx
    # proto io expr for X, layer above &Xsimp|&Xsomp
    #  not used by &bract_kref, due to slowness
    #   < compile expr to voice
    #  it requires|does /$n all the way down:
    #   ie &Xsimp clutchy,every:thing $n
    #    none: &Shx o clutchy/every
    $h = A.h.o('Shx')
    # interface to allow spaced out calls (wrap me&calls)
    $S = me&Simqis_Shx
    1 and 0
    (&{
   // &Shx
    $A = nonA('Shx')
    haks(peel("Fuzylajj,Dongit,Riding,Wings"))
        .map(t => A.sc[t] = Cye([t,1]))
    $X = {A}
    # results:
    $O = {}
    # setup stuff to read
    # o ... { # returns iterator
    # < even for tiny bits like binding $X
    # < without the decoy $n to make inners' &Shx_isax work
    #   which will dis-join the inner $n? hmm
    #S("o $X $n {",X,a&Dongit) (&{
        S("i $X/$every $n",X,'thing',a&Dongit)
        S("i $X/$every $n",X,'time',a&Riding)
        S("i $X/$every $n",X,'where',a&Riding)
        S("i $X/$every $n",X,'where',a&Dongit)
        S("i $X/$every $n",X,'lunk',a&Riding)
        
        S("i $X/clutchy/$every $n",X,'thing',a&Dongit)
        # < even for binding /$n
        0 && S("i $canbenamedanything {",a&Fuzylajj) (&{
            S("i /clutchy/$every",'lunk')
            S("i /others/$with",'lunk')        
        })
        S("i $X/clutchy/$every $n",X,'lunk',a&Fuzylajj)
        
        S("i $X/others/$with $n",X,'lunk',a&Fuzylajj)
        S("i $X/others/$with $n",X,'lunk',a&Riding)
    #})
    
    $res = &ta{
        $N = O[t] ||= []
        N.push(depeel(tex({},a))+' n:'+a.n.t)
    }
    
    # any every
    S("o $X/every {",X)          (a => res('every',a))
    # such every
    S("o $X/$every {",X,'where') (a => res('every=where',a))
    # deeper
    S("o $X/clutchy {",X)       (a => res('clutchy',a))
    S("o $X/clutchy/every {",X) (a => res('clutchy every',a))
    
    # < joins o ... o ...
    # < should be able to plumb c.N = c.c.N
    #  /clutchy/every/$n that are also /every/$n
    #  big nostalgia vibe ...
    #   was a mysterious glimmer in the thinking around osc somewhere
    #    pin: the thing you get at the end of a long void you can bring back
    #     that can hold fabric together, as complexity is made
    #S("o $X/clutchy/every o $X/every {",X,X) (a => res('$n join',a))
    S("o $X/clutchy/every {",X) (&a{
        # not every:where Dongit, since every=thing|lunk
        #  also not every:lunk Riding
        S("o $X/every {",X) (a => res('join every,n',a))
        
        # to join on $every, not $n: drop ark ax.n
        S("o $X/@!$n/every {",X) (a => res('join every',a))
        
        
        #T.Shxbug = 1
        #S("o $X/every {",X,a.every) (a => res('$every join',a))
    })
    
    
    
    #S()
    
    h.Fez('Shx',{X,O})
    
   // &Sarn
   
    })()

S 4 Q
    # imports from networks
    $h = A.h.o('Q')
    1 and 0
    (&{
    $A = nonA('believeQ')
    $X = {A}
    # < using &believeoQ
    
    })()
    
