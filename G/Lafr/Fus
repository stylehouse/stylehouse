# Iliation
$R = A.Run
$h = A.h
    $nonA = &t{
        # A container
        #   A lesser than even &Atopleast
        #    we can avoid G&calls (which are A.1^^ searches)
        #     except for the S, so scope $A to a non-sub
        $A = Cye([t||'Fusing',1])
        A.y = A
        return A
    }
S 1 Xsim
    # This/-Eight pictures data
    $h = A.h.o('Xsim')
    1 and 0
    (&{
    $A = nonA()
    # data container
    #  as opposed to A.c|sc.** directly
    $X = {A}
   // # &Xsim has a funny interface:
    # args:
    #  $X where to put stuff, may be A:
    #  $k may Ac&$k += X, only if given $X=A
    #  $t=['abit'] wraps every s.* with .abit
    #   a bunch of departmenting to jump into at each X|x|office
    #  $s keys to the index
    #   needs at least one
    #  $c what|how to put there
    #  $q unused
    
    #  $k may Ac&$k += X, only if given $X=A
    fi&Xsim,X,'ifnotX',[],{ifnot:3}
    # this one is hosted on Ac&ifnotX
    fi&Xsim,A,'ifnotX',[],{ifnot:4}
    
    #  $t=['abit'] preceeds every s.* with .abit
    # X.extrabit.fun.3=x
    fi&Xsim,X,'X',['extrabit'],{fun:3}
    # this reoccurs at every s.*
    fi&Xsim,X,'X',['extrabit'],{fun:3,joy:3}
    # X.extrabit=x reused as an index hash (hs)
    #  in &Shx we do /word/ -> X.word.1 = x
    fi&Xsim,X,'X',['extrabit',1],{fun:4}
    #  is climbed past (as $hs), no usu x typing (x.up etc)
    fi&Xsim,X,'X',['otherbit',1],{fun:4}
    # ! no s.*, no wrapping
    fi&Xsim,X,'X',['nonbit']
    
    h.hat('funny interface',X)
    
   // c.n
    $A = nonA()
    $X = {A}
    # we throw data into X.*:
    X.ret = a&ret = []
    $Xsim = &sc{
        # $N = &Xsim
        $N = fi&Xsim,X,0,0,s,c
        a&ret.push(N)
        return N
    }
    
    # X.figarto.1=x empty
    Xsim({figarto:1})
        # X.figarto.3=x has a row! x.z -> A%ret.0
        $n = Cye(['Fusilli',1])
        Xsim({figarto:2},{n})
    
        # rows join indexes
        Xsim({flim:2,flam:2},{n})
        $n = Cye(['Fuzylajj',1])
        Xsim({flim:2,flam:2},{n})

        # A%ret.3: we find all 3 in X/$flim=2
        #  ie s.* neednt have all
        $n = Cye(['Unfuse',1])
        Xsim({flim:2,figarto:2},{n})
    
    # we find the union
    Xsim({flim:2,flam:2})
    
    # s.* neednt have all
    #  ~~ &bracko, inherited to &sustain
    Xsim({flam:2})
    # A%ret.6: s.* order doesnt matter
    Xsim({figarto:2})
    
    # dup $n is stored, deduped on the way out
    #  see &xzand / !M.includes(n)
    Xsim({figarto:2},{n})
    # A%ret.9: it is an object compare
    #  see &xzand / ox.z.includes(n)
    #  so two C:Unfuse now come out
    $n = Cye(['Unfuse',1])
    Xsim({figarto:2},{n})
    
    # queries (or at least !c.n) autovivfy empties
    #  none: yet $fogma=2 = x (/!$n)
    Xsim({fogma:2})
    #  none: $fogma/!$n xzand $figarto/$n
    Xsim({fogma:2,figarto:2})
    # A%ret.12
    Xsim({fogma:2,groova:'to'})
    
    # c.el:8 doesnt autovivify empties
    #  returns null, ~~ &ja
    #   since $grover doesnt exist
    Xsim({fogma:2,grover:'to'},{el:8})
    #  none: since $fogma=2 is merely empty
    Xsim({fogma:2,figarto:2},{el:8})
    # A%ret.15
    #  as above, s.* order doesnt matter
    Xsim({figarto:2,fogma:2},{el:8})
    #  returns null, since $grover doesnt exist
    Xsim({figarto:2,grover:2},{el:8})
    
    h.Fez('c.n',X)
    
   // c.long
    # you climb x = x._ for s.*
    #  more spacious space, returning $x not $n+ rows
    $A = nonA()
    $X = {A}
    $Xsim = &sc{
        # $x = &Xsim
        return fi&Xsim,X,0,0,s,pex(c,'long')
    }
    
    # &Xsimp X s c q
    #  does &Xsim c.long with better args
    fi&Xsimp,X,{Basica:'ly',every:'thing'}
    
    $n = Cye(['Unfuse',1])
    Xsim({tog:1,figarto:2},{n})
    $n = Cye(['Fuzylajj',1])
    Xsim({tog:1,flam:2},{n})
    $x = Xsim({tog:1})
    x.aways = 'along'
    $x = Xsim({tog:1,flam:2})
    x.all = 'theway'
    # s.* order matters
    $x = Xsim({flam:2})
    x.norows = 1
    
    # empty, yet indexed
    Xsim(peel('all,the,spaces:3,in,here'))
    
    # c.el:8 doesnt autovivify empties
    #  it will however create an empty spaces:4|5:
    Xsim(peel('all,the,spaces:4,over,there'),'el:8')
    Xsim(peel('all,the,spaces:5,for,layout'),'el:8')
    #  ie it stops when there is no x.further:
    Xsim(peel('all,the,further:6,over,such'),'el:8')
    
    h.Fez('c.long',X)
   
   // c.array=1
    # allows indexing objects (~~ &X_s)
    # < benchmark this vs using Cy&uid where possible...?
    #   it greps for them underneath?
    #    is where perl's scalar($obj) == unique address is nice
    $A = nonA()
    $X = {A}
    $Xsim = &scx{
        return fi&Xsim,x||X,0,0,s,pex(c,'long')
    }
    
    $anob = {}
    Xsim({thisward:anob},'array') .once = 1
    # what's inside doesn't matter:
    anob.five = 5
    Xsim({thisward:anob},'array') .twice = 1
    # is different:
    Xsim({thisward:{other:3}},'array') .thrice = 1
    # whole leg is array-stored
    Xsim({elsewhere:anob,for:'it'},'array') .quice = 1
    #  you (eg &Xsomp) may break it down:
    $x = Xsim({elsewhere:anob},'array')
    x.five = 1
        Xsim({now:'stringy'},'',x)
        Xsim({now:'etc'},'',x) .finally = 1
    
    h.Fez('c.array',X)
    
   // c.wild|simvx and -anx "noxup"
    # c.wild(card) returns vx for X.such.*=x+ (to &Xsomp)
    #  $vx is $hs (indexy hash (or array)) where .$t=$x
    #   or if it was c.array, .$i=$x
    #    unless you were looking at the refs, which is .$i=$s
    #  only for one &Xsim s.*
    #   though non-wild can occur first (X/$thus)
    # c.simvx returns inflated vx, with only the selected keys in it
    #  usu just one key
    #   < unless WHERE loose, ranges
    #   so &Xsomp can always get a $vx whether c.wild or not
    #    useful for finding the $i for c.array
    #  only one &Xsim s.*
    #   ie you row across high frequency &Xsim
    $A = nonA()
    $X = {A}
    $Xsim = &scx{
        return fi&Xsim,x||X,0,0,s,pex(c,'long')
    }
    Xsim({thus:1,all:'variously'}) .incar = 2
    Xsim({thus:1,all:'muchly'}) .incar = 3
    Xsim({thus:4,all:'suchly'}) .incar = 4
    Xsim({thus:5,all:'suchly'}) .incar = 5
    $vx = Xsim({thus:1,all:1},'wild:all')
    
    # by the way, -anx says noxup when X...x is unnatural:
        # when we get to -anx, at vx.$k=x
        X.thusallwild = vx
        # the .vividity is noxup
        #  .up also, reveals where it thinks it is
        #   terminating the noxup-ness
        #  .etc.3 is not, since it presents as inside the nearest ^^x|X
        Xsim({thus:5,all:'suchly',etc:3}) .inert = 1
        $x = Xsim({thus:5,all:'suchly'})
        X.vividity = x
        # just this far in, it shares .up=X
        $x = Xsim({thus:4})
        X.obscurity = x
        # this far out, it doesnt
        Xsim({shape:4,tango:3}) .inobscurity = x
    
    # c.simvx
    $asim = s => Xsim(s,'array')
    asim({lets:{}})
    asim({lets:{}}) .two = 2
    $lets = {cre:8}
    asim({lets})    .three = 3
    asim({lets:{}}) .four = 4
    # to know the X.lets(s)?.$i
    $vx = Xsim({lets},'array,simvx')
    X.simvx = vx
    
    h.Fez('c.wild|simvx',X)
    
    })()

S 2 Xsomp
    # layer above &Xsim:
    #  i: &Xsimp does a normal kind of &Xsim, no rowing
    #  o: &Xsomp does rowing, per /$n, returning [ax+]
    # used by
    #  Fish / Q # originally
    #  &Shx_io # exciting edge of io, rowing
    $h = A.h.o('Xsomp')
    1 and 0
    (&{
   // &Xsimp -> &Xsomp
    $A = nonA('&Xsimp -> &Xsomp')
    haks(peel("Fuzylajj,Dongit,Riding,Wings"))
        .map(t => A.sc[t] = Cye([t,1]))
    $X = {A}
    
    # &Xsimp X s c q
    #  does &Xsim c.long with better args
    #  doesnt do rowing (returns x)
    $Xsimp = (s,c) => fi&Xsimp,X,peel(s),peel(c)
    
    Xsimp("Basica:ly,every:thing",{n:a&Dongit})
    Xsimp("Basica:ly,every:time",{n:a&Riding})
    Xsimp("Basica:va,every:where",{n:a&Dongit})
    # copied from Fus@1 / c.long / c.el
        Xsimp('all,the,spaces:3,in,here')
        # c.el:8 doesnt autovivify empties
        Xsimp('all,the,spaces:4,over,there','el:8')
        Xsimp('all,the,spaces:5,for,layout','el:8')
        #  ie it stops when there is no x.further:
        Xsimp('all,the,further:6,over,such','el:8')
    
    
    # ax contain .arkx
    X.everyevery_full = fi&Xsomp,X,{Basica:1,every:1}
    $res = &tsc{
        X[t] = fi&Xsomp,X,s,c .map(&a{
            return depeel(tex({},a))
                +' n:'+(a.n?a.n.t:"???")
        })
    }
    res('everyevery',{Basica:1,every:1})
    
    res('lyevery',{Basica:'ly',every:1})
    
    # none
    #  creates /$every=way
    res('everynot',{Basica:1,every:'way'})
    #  c.el=8 doesnt create /$woop
    res('woopnot',{Basica:1,woop:'woop'},{el:8})
    # needs rows to be there (/$n)
    #  using &Xsimp|&Xsim they are only at the end
    #   we land on x+, which have x/$n+
    res('Basicanot',{Basica:5})
    res('allnot',peel('all,the,spaces:3,in,here'))
    
    # c.non - no /$n multiplicity, wanting x
    #  so now this returns the empty x got to
    #  variation: el8 here then doesn't create /$Basica=5/$every=ways
    res('everynot_non',{Basica:1,every:'ways'},{non:1})
    #   el8 /$Basica/$every=waysia doesnt create
    res('everyempty_non_el8',{Basica:1,every:'waysia'},{non:1,el:8})
    #  c.el=8 doesnt create /$veb
    res('vebnot_non_el8',{Basica:1,veb:'waysia'},{non:1,el:8})
    #  creates $Basica=5/$wool (unless c.el=8, as above)
    #  c.non determines only whether they return here:
    res('woolcreates_non',{Basica:1,wool:'wool'},{non:1})
    res('allis_non',peel('all,the,spaces:3,in,here'),{non:1})
    
    
    h.Fez('&Xsimp -> &Xsomp',X)
   
   // /$n
    # needs rows to be there (/$n)
    #  using &Xsimp|&Xsim they are only at the end
    $A = nonA('/$n')
    haks(peel("Fuzylajj,Dongit,Riding,Wings"))
        .map(t => A.sc[t] = Cye([t,1]))
    $X = {A}
    # &Xsimp for input
    $Xsimp = (s,c) => fi&Xsimp,X,peel(s),peel(c)
    # &Xsomp cant input c.n, since &Xsim c.simvx leaves early
    #  see &Shx_io which splits for i|o
    $Xsomp = (s,c,q) => fi&Xsomp,X,peel(s),peel(c),peel(q)
    Xsimp("every:thing",{n:a&Dongit})
    Xsimp("every:time",{n:a&Riding})
    Xsimp("every:where",{n:a&Riding})
    Xsimp("every:where",{n:a&Dongit})
    # abbreviate ax+
    $res = (t,N) => X[t] = N.map(ax => nex({},ax,'arkx'))
    res('every where',Xsomp("every:where"))
    # does where-/$n-clauses via q.n
    # < c.n could be used since &Xsomp cant input c.n
    res('every n:Riding',Xsomp("every:1",{},{n:a&Riding}))
    
    Xsimp("every:thing,else:ward",{n:a&Dongit})
    Xsimp("every:thing,else:fliv",{n:a&Riding})
    Xsimp("every:where,else:fliv",{n:a&Riding})
    res('elses',     Xsomp("every:1,else:1"))
    res('whereelses',Xsomp("every:where,else:1"))
    
    # c.array for objects
    Xsimp({want:a&Dongit},{n:a&Riding,array:1})
    Xsimp({want:a&Riding},{n:a&Fuzylajj,array:1})
    # &Xsomp doesnt need to know c.array
    res('all wants', Xsomp("want"))
    #  unless it is looking for something...
    res('want of Dongit', Xsomp({want:a&Dongit},'array'))
    res('want of Fuzylajj', Xsomp({want:a&Fuzylajj},'array'))
    res('wants of Fuzylajj', Xsomp("want",'array',{n:a&Fuzylajj}))
    
    # ! this $t fed to &Pii, sensitive to /|%|-pi
    h.Fez('per $n',X)
    
    })()
   
S 3 Shx
    # proto io expr for X, layer above &Xsimp|&Xsomp
    #  not used by &bract_kref, due to slowness
    #   < compile expr to voice
    #  it requires|does /$n all the way down:
    #   ie &Xsimp clutchy,every:thing $n
    #    none: &Shx o clutchy/every
    $h = A.h.o('Shx')
    h.sixc = 'expectλ'
    # interface to allow spaced out calls (wrap me&calls)
    $S = me&Simqis_Shx
    1 and 0
    (&{
   // &Shx
    $A = nonA('Shx')
    haks(peel("Fuzylajj,Dongit,Riding,Wings"))
        .map(t => A.sc[t] = Cye([t,1]))
    $X = {A}
    # results:
    $O = {}
    # setup stuff to read
    # o ... { # returns iterator
    # < even for tiny bits like binding $X
    # < without the decoy $n to make inners' &Shx_isax work
    #   which will dis-join the inner $n? hmm
    #S("o $X $n {",X,a&Dongit) (&{
        S("i $X/$every $n",X,'thing',a&Dongit)
        S("i $X/$every $n",X,'time',a&Riding)
        S("i $X/$every $n",X,'where',a&Riding)
        S("i $X/$every $n",X,'where',a&Dongit)
        S("i $X/$every $n",X,'lunk',a&Riding)
        
        S("i $X/clutchy/$every $n",X,'thing',a&Dongit)
        # < even for binding /$n
        0 && S("i $canbenamedanything {",a&Fuzylajj) (&{
            S("i /clutchy/$every",'lunk')
            S("i /others/$with",'lunk')        
        })
        S("i $X/clutchy/$every $n",X,'lunk',a&Fuzylajj)
        
        S("i $X/others/$with $n",X,'lunk',a&Fuzylajj)
        S("i $X/others/$with $n",X,'lunk',a&Riding)
    #})
    
    $res = &ta{
        $N = O[t] ||= []
        N.push(depeel(tex({},a))+' n:'+(a.n?a.n.t:"???"))
    }
    
    # any every
    S("o $X/every {",X)          (a => res('every',a))
    # such every
    S("o $X/$every {",X,'where') (a => res('every=where',a))
    # deeper
    S("o $X/clutchy {",X)       (a => res('clutchy',a))
    S("o $X/clutchy/every {",X) (a => res('clutchy every',a))
    
    h.Fez('Shx',{X,O})
    
   // &Shx joins
    O = {}
    # joins o ... o ...
    #  are only via iteration, not plumbing:
    # < should be able to plumb c.N = c.c.N
    #  /clutchy/every/$n that are also /every/$n
    #  big nostalgia vibe ...
    #   was a mysterious glimmer in the thinking around osc somewhere
    #    pin: the thing you get at the end of a long void you can bring back
    #     that can hold fabric together, as complexity is made
    #S("o $X/clutchy/every o $X/every {",X,X) (a => res('$n join',a))
    S("o $X/clutchy/every {",X) (&a{
        # not every:where Dongit, since every=thing|lunk
        #  also not every:lunk Riding
        S("o $X/every {",X) (a => res('join every,n',a))
        
        # to join on $every, not $n:
        #  drop ark ax.n
        S("o $X/@!$n/every {",X) (a => res('join every',a))
        # < easier chopping up rowing, eg collect (T.ax|a).every here
        
        # to join on $n, not $every:
        #  < drop ark ax.every
        #    binds it again from T.ax. warns of vague &axcompatible
        #S("o $X/@!$every/every {",X) (a => res('join n also',a))
        #  set $every=1, to glob it, /$n follow
        S("o $X/$every {",X,1) (a => res('join n',a))
        
        # to join $n, other arks not common
        #  row has every:lunk and with:lunk
        S("o $X/others/with {",X) (a => res('join n to other columns',a))
    })
    
    # between X
    $V = {A}
    S("o $X/others/with {",X) (&{
        S("o $X/$every {",X,1) (&{
            S("i $V/fing/with/what/every {",V) (a => res('i joined n:Riding',a))
        })
        # < n:Fuzylajj (first row) doesnt have any ^,
        #    which is why these two O.* results appear in reverse
        #   so here it defaults to 1... should knock out the row..?
        S("i $V/every/whatsit {",V) (a => res('i joined from sibling rowing',a))
    })
    
    # not much else to it yet
    
    # < this buncher is lacking
        # < will one day o /believe/...$Q
        # < wants to leave a schema,
        #    so we can glob through $time/...
        #    or if given of:w, find our way out to eg w:Such
        #     ie /$n-matching avoided until the end of the ... pool|bunch
        $oft = {of:'ya'}
        # < &Shx_io / if q.ark
        #    only arks one value from $of, which must be of.of
        # < adjusting expr to: /...$of/such
        #    will make /such/...$of
        #    only one of the &Shx a(pattern,handler) can loop at once
        S("i $V/before/$time/...$of $n {",V,'3.4.5',oft,a&Fuzylajj)
            (a => res('destructured bits',a))
    
    # < when Yinging, X,O,V are each an -Eight
    h.Fez('Shx joins',{O,V})
    
   // &Sarn - io expr as schema
    # &Sarn sets up schema for later &Saturn-ing
    $A = nonA('Sarner')
    $X = {A}
    
    # these have been adjusted to not have -This at path[1],
    #  see &Sarg_Sarn creating This|The duality
    # the Gnome/Thy...-Lab schema is most complex
    #   q.testingmode prevents scheme|compile-time -This|-The
    a&SarnThy = me&Sarn,<<'',[]
        i @Thy/-This/#@Fine-Labine/@-Lab#@n%ThyLab/c&s=@n
    
    # and Cat/Run/This**
    a&SarnRun = me&Sarn,<<'',[]
        i @Run/@-This/-Eight/-seven/**%Ethinging
    
    h.Fez('Sarn',{O:A.sc})
    
    # < &Saturn unfolds a particular s**
    #   may route %%inst - wants to mock &nodei
    #    < all of me.* (I.i.*) should be mockable
    #     < watch what units do|return,
    #       swap them out, iteratively decrease the Dump
    #        ie bisect down to what data the test needs to pass
    #   involving &gfunc, kind of a &voice compositor
     
   
    })()

S 4 Q
    # imports from networks
    $h = A.h.o('Q')
    h.sixc = 'expectλ'
    1 and 0
    (&{
    $A = nonA('believeQ')
   // some Q
    $Q_J = fi&aQ,{of:'w',t:'J'},{src:'localhost:1812',vers:'3.3'}
    $Q_fr = fi&aQ,{of:'w',t:'fr'},{src:'localhost:1812',vers:'3.1'}
    $Q_unbelievable = fi&aQ,{of:'n',t:'J'}
    
    # A&X/...$oft is created by &*oQ
    a&AoQing = {
        J: fi&AoQ,A,Q_J ,
        fr: fi&AoQ,A,Q_fr ,
        # the /...$believe step would be fatal, but is empty
        unbelievable: fi&AoQ,A,Q_unbelievable ,
    }
    
    # &aQ and &Qbel dont do much
    a&formats = {
        # &aQ is only used by A&oftserve() to s|c -> Q.c|sc
        #  see &wantbelieve below, which simply &Xsimp s
        # Fish Q seem to have Q.t == Q.c.t
        aQ: [
            Q_J ,
            Q_fr ,
            Q_unbelievable ,
            fi&aQ,{of:'W',t:'Radio',species:5,any:'thing'},{} ,
        ],
        # &Qbel forms /believe/... stuff
        Qbel: {
            glob: fi&Qbel,0,{} ,
            # only Q with src+version can /believe/
            fr: fi&Qbel,Q_fr ,
        },
    }
    
    h.hat('some Q',A)
    
   // believe
    $A = nonA('having Q')
    $V = A&Client = fi&A
    V.t = 'Client'
    # &aQ sets Qy&A, so lets rebuild
    A&Q_J = fi&aQ,{of:'w',t:'J'},{src:'localhost:1812',vers:'3.3'}
    A&Q_Jask = fi&aQ,{of:'w',t:'J'}
    
    a&AoQ_empty = fi&AoQ,A,A&Q_Jask
    a&AiQ_it = fi&AiQ,A,A&Q_J
    # /...$oft has /$n=A:client from &wantbelieve
    #  ! mistakenly thought it should have &Xsomp c.non=1
    #     and that &Xsomp needing /$n was introduced for &Shx 8297cb0ff89610091
    #      which was done after Stories/Fish stopped working
    #       it might still work... was motivated to Travel (and Story) by Gump
    # nothing yet, due to the above
    a&AoQ_still_empty = fi&AoQ,A,A&Q_Jask
    # a client (asking for ...$oft/)
    # < pile up better
    fi&Xsimp,A,A&Q_Jask.c,{n:V}
    a&AoQ_it = fi&AoQ,A,A&Q_Jask
    
    h.hat('having Q',{A})
    
   // ordering /believe...
    # &Xsomp $n...$n ordering
    #  sort by /believe/$n, where /believe/$suchly/$n
    #   so we can revert to a previous version
    #  for &believeoQ / &Xsomp c.norder / &Naxnorder
    #  lifted from &test_Nxcnorder
    # just x = &Xsimp and &believei|oQ,x
    #  so the lack of /$n=A:client doesnt matter
    $A = nonA('ordering believe...')
    
    $s = {of:'w',t:'leaks'}
    $x = fi&Xsimp,A,s
    $enQ = &s{
        $Q = Cye([s.src+' v'+s.version,1])
        fi&believeiQ,x,s,Q
        return Q
    }
    $got = a&got = {}
    $see = &t{
        got[t] = fi&believeoQ,x
    }
    $Q = enQ({believe:1,src:'1812',version:1})
    see('first')
    enQ({believe:1,src:'1812',version:2})
    see('2nd')
    # variation: must be a new $Q
    0 ? fi&believeiQ,x,Q.c,Q
      : enQ({believe:1,src:'1812',version:1})
    see('first again')
    
    # fail mode:
    $s = fi&Qbel,0,q
    got.without_norder = fi&Xsomp,x,s .map(ax => ax.n) .pop()
    
    h.hat('ordering believe...',{A})
   
   // wantbelieve
    # A** serving /believe/
    # &Ath,A:client,s:$oft,c?,q? is a proto &t
    #  / &wantbelieve climbs, each:
    #     $Qx = i A&X/...$s
    #      ! so you must always spec $s={of,t} in the right order, etc
    #    until:
    #    &believeoQ,Qx returns $a
    #   &believeiQ brings it down
    # returns a.n=$Q if ready
    $A = nonA('wantbelieve')
    A&oftserve = &scqd{
        (a&oftquest||=[]).push({s,c,q,d})
    }
    $V = A&Middle = fi&A
    V.t = 'Middle'
    $Y = A&Client = fi&A,V
    Y.t = 'Client'
    
    # A:Middle|Client refer to A:Client as the asker
    a&notyet = fi&wantbelieve,Y,{of:'w',t:'J'}
    # usu asyncily, it is loaded by A:thinger and etc
    #  A:thinger uses ...$oft/asked/.../$P instead of /believe/
    #    by setting q.believe=asked, &believe*Q etc work with that
    #   which is starting to get into messaging
    #    ie asked == asked remote about it
    # the whole ...$oft:oftx/$n=A:client thing seems a bit loose
    #  perhaps oftx/pull/$n=A:client and oftx/push/$n=A:receiver
    
    A&Q_J = fi&aQ,{of:'w',t:'J'},{src:'localhost:1812',vers:'3.3'}
    a&AiQ_it = fi&AiQ,A,A&Q_J
    
    a&hasitnow = fi&wantbelieve,Y,{of:'w',t:'J'}
    
    
    h.hat('wantbelieve',{A})
    
    
    
    })()
    
S 5 Log
   // intro
    =pod &complace wraps|captures &com|&log statements
     fi&live was the main loop:
      A&step++, ie proto &Sunpit
      $done = &complace,$t='yarrr',$s={A}
       makes -Eight 'A:aname'
       makes -seven, serial-numbered
        # this will want to be $time as usu
       and an initial &com,s,c is made, saying yarrr
       
       also uses:
        &Gstaci (stack-unwindable environment variables)
         helps &com find a -seven to be put into
        &comlesslogs watch for things calling &log as opposed to &com
         and shove them into a &com once &complace done()
      then does:
       inner main loop, eg fi&test_Attention,A&step
       somewhere in there, eg fi&Abelieve:
        &com,$t="Q",$s={el,c:Q.c,sc:Q.sc,belN},$c={}
         $into = &Gstaci finds a -seven
         calls &me_log to find $R for:
          &log,t,s,c makes $D-log
           D.t = $t+'-'+serial per @Ying%Outlog/*
           Dc&s = $t
           sc = says:$t,...$s,(node:Rc&s)?
            is &bracki to D (not ex() to D.sc)
           ex(D.c,$c)
         then A^^^ (what !A.up) shall a&log += $D
          # GOING?
         then me&piLog,D,{into},3
          has some strange E** stitchup, dawn raid, lets forget
          which should be simply -Log now
      we do nothing with Dy&A
     anyway
      &complace will just &openEight
      &com will ++@six-Log
    =cut
    if (0) {
        # there is this #msgs type of log
        # < &c within A:Fish
        #  < Babz name params, also on throw
        #     spacing to degrees of relevance
        #      compare with slope
        $all = map(v => '>'+v+' '+v,
            [0,1,2,3,4,5,6,7,8,9])
        # < Babz keeping this indented (breaks &diffPs_knowsteps)
        #~>1 colours: ...all
    }
    A.h.sixc = 'expectλ,first_truest'
    $hA = A
    # an -Eight for this tests observations
    $h = A.h.o('Log')
    # and an -Eight maker for &complace to use within
    $complaceCt = c => spant( armap((v,k) => cint(k,v),c) )
    $Eighti = c => A.h.o( complaceCt(c) )
    1 and 0
    (&{
    
    
    
   // redo &com
    # < find $h from A^^ to merge these
    fi.complace = &acgttsc{
        # $Ct-Eight, $i++-seven
        # invent $Ct from main bunch of id (s)
        #  &me_log default anyway:
        s ||= {A}
        $into = Eighti(s)
        
        $done_Gstac = me&Gstaci,'-log',into
        #$done_comless = fi&comlesslogs,into
        
        # and this first -log, about &complace itself
        # < notices all Gc&logs/-seven active
        # c is just more stuff to say besides $Ct
        pex(s,c)
        # Dc&muteslaters via -Log/-row compresses
        #  the same A|node appearing on every -log
        $D = fi&com,t,s,{muteslaters:1}
        #me&nu,"complace",{C,This,eight,seven,D}
        return &{
            #done_comless()
            done_Gstac()
        }
    }
    fi.com = &acgttsc{
        s ||= {}
        c ||= {}
        # any -seven-ish thing collecting D-log
        $into = me&Gstaco,'-log'
        # me&log makes a &bracki D-log/%says=msg,etc
        # < will perform better if lazy X-ing,
        #    low ology perhaps not needing it to?
        #   but the &bracki creates an %RX-ability of $k etc...
        $D = fi&me_log,t,s,c
        Dy&A ||= A
        
        # A:least%log
        #  is also 4s&log from inside
        #   where the G&c go (~>3 message: things)
        $Al = me.cbu(A, A => !A.up, A => A.up)
        ac(Al,'log',D)
        Dy&log and throw "hadlog"
        
        !hak(into) and throw "nologinto"
        each ih into {
            h.seqi ||= 0
            h.seqi++
            # our A no further
            h.tys(h.seqi,'Log',D)
        }
    }
    
   // act 1
    # < GOING, now &Atopleast + &test_Attention A**
    $A = nonA('Log')
    $V = A&Middle = fi&A
    V.t = 'Middle'
    $Y = A&Client = fi&A,V
    Y.t = 'Client'
    # just to:
    h.hat("Eighti",map(complaceCt, [{V},{A},{A,with:'some more'}]))
    
    # a type of A** lifetiming going on see Fish&A / &At
    # A:least has no .up (.top is nothing)
    $A = fi&Atopleast
    $Al = A
    # instead of &isAthinger making &oftserve that makes &elvis to %Jrunto
    #  cuts off a bunch of fi&elvis
    # < if 4c&live=1 all the time, we could use 4s&todo += e
    #   which this is pretending to be doing:
    A&oftserve = &scqd{
        (a&oftquest||=[]).push({s,c,q,d})
    }
    #  < This** wants a new sense of time: for all -six?
    #     per -six created in a different -seven to the last one
    #     so many -seven*/-six* can be created frantically
    #      yet 1/4-six knows it came right before 2/2-six
    # be %string-wobs
    #  < further The development there (for Thens)
    #     can it be bound to sheer time like This is (will be)
    #     separating %TX change until such is
    
    # the &complace makes an initial &log
    #  its Dc&muteslaters via -Log/-row compresses:
    #   the same A|node appearing on every later -Log*
    #    # note that -Log* means siblings in a single ^|y&up
    #    #  whereas "for all -six" means */*/-six, any and all #code
    #  $k it something else to watch A mutate
    $done = fi&complace,'yarrr'
    # try first_truest everything
    # <<<
    # fix the Erefc bug
    # -Log %bg
    # &live defines A: Cy&Fish ||= fi&Atopleast,1
    #  where C is a Run/$W, from @Pro, is being A:n
    #   &Yingbal it while @Run is running
    #    y&Fish being in there?
    # so
    #  we pass the same A into these things each time
    #  < should be a variation on that time?
    
    fi&test_Attention,1
    delete a&log
    
    
    # 
    
    # fi&test_Attention,2
    
    
    # ...
    done()
    
    
   // closing act 1
    # < -Ascape
    h.hat('Ascape',{A})
    A = hA
    
    # do o %%Erefc on a recent -log/...
    
    # < climbing funcs.
    #    &Rsci does long paths, but not //E (as opposed to //RE)
    # < This** would have a @log column, where we can find %says=such
    $Rsci2 = &vs{
        # climbs s** if given R
        v = sof(v)
        
        s = s.split('%%')
        $jaa = s [1]
        s = s [0]
        
        # s**-Log//-Log goes into the main &Piing E
        s = s.split('//')
        each in s {
            1 <= i and v = me&REof,v
            $to = me&Rsci,n,{el:8,v}
            !to and return
            v = to
        }
        if (jaa) {
            jaa = jaa.split(" ")
            if (jaa[1]) {
                # eg '%%such 1' to return first value of each
                jaa[1][0] == '1' and $jaac = 1
                # eg '%%such 11' first value on first row
                jaa[1][1] == '1' and $dotheone = 1
            }
            jaa = jaa[0]
            $r = vy&R
            !r and return
            $N = me&jaa,r,jaa,jaac
            # fatal to many|N>1
            dotheone and N = theone(N)
            v = N
        }
        return v
    }
    
    # This context (~~ &supedome) to R:Run
    $oThis = s => Rsci2(R,'This/'+s)
    # the one %%Erefc
    $Erefc = s => oThis(s+'%%Erefc 11')
    $gots = &Erefc,{
        !Erefc and return "MISS"
        $got = Erefc.got
        $so = got.map(g => g.tp + (Erefc.any == g ? " <=" : ""))
        
        # got.Efinder: -six** we climbed from
        #   where the ref is now
        # Erefc.R is .Efinder//R
        
        # Erefc.E -six or ^^, grouping refs
        #      .e is the first -six we climbed through
        # < does .E always go to Ec&uber?
        #   or is it just until we climb s** in lookup
        
        # Erefc.s = the object itself
        
        # got.Efound is the target E, at the end of got.tp
        # got.n is .Efound//R
        #  
        # < got.E always == Erefc.E?
        # g. E**, who we are
        so.unshift( me&Rnodepath,Erefc.R +" =>" )
        return so
    }
    
    $ideally = &Erefc,{
        $got = Erefc.got.slice()
        return map(v => Aof(v),{GOT:got[0].Efound, EXP:got[1].Efound})
        # if .s == A:least == /4|y, move it up     # code io
        $sorted = got.sort(&ab{
            return a.n.y.up == b.n
        })
        $so = sorted.map(g => g.tp + (Erefc.any == g ? " <=" : ""))
        return so
    }
    
    # < %%Erefc on the A:least/5/4/-Log/0/A/4/y
    #   points deeper than it should
    #   sort by a.tp.startsWith(b.tp)
    #    where got.$i.E the same
    #     esp when 1 up|down
    #   was also before:
    #    when the &complace had A:Middle,
    #     it was out-of-time able to see it at:
    #      Log-Eight...A/c/Client/up
    #       which is an odd choice, given ...A/c/Middle is there
    $A44 = Erefc('A:least/5/4//-Log/0/A/4/4')
    $A4y = Erefc('A:least/5/4//-Log/0/A/4/y')
    
    $all = ideally(A4y)
    # < Rc&dl++ on %Cish is just one strategy
    #    runs out of sense when many C** are findable
    # < %ope GOT/y/R/y should negate layout/unkeen !E[up,cv]
    h.Bow(" .y ideally",all,'dl:2')
    $ide = a&six.slice(-1)[0]
    $r = Aof(ide)
    $ides = rc&s
    $ya = me&indo,r (&sd{
        !isC(s) and debugger
        return [sc&d,sc&dl,s.t].join("\t")
    })
    # is only visible as a %*_string)%ball
    idess&depth_map_string = ya
    # < Theing how to string|array until...
    #h.hat(" .y ideally: depth map",ya,'dl:4')
    #h.Bow(" .y ideally: depth map",ya.split("\n"),'dl:4')
    h.fu({ide,ya})
    h.Bow("last log:Ath-not's A.4...",{
        ".4 not bad": gots(A44),
        ".y too deep": gots(A4y),
        " .y Erefc": A4y,
    },'dl:3')
    # < This->Nine brittleness:
    #   switching the above h.hat<->h.Bow requires reset
    #    as RE/E pile up in This** ?
    #     for some reason not escaping &forgetRunStep
    #   causes:
    #    Ness/(-Eight/-seven)+ recursion on Outs
    #      only visible when we Accepting
    #      which we auto-do
    
    
    
    # picture of Erefs
    #  '^' for /aya/ is correct
    #  '^/aya' for /de/ is wrong
    $a = {}
    a.aya = a
    a.de = a
    $b = {a,le:a}
    h.hat("and this is this",b)
    h.hat(" with a later look at",{la:a,loose:a})
    
    # < also the first %%node says '^'
    #  < sometimes. after throw?
    $Run = Erefc('A:least/5/1//-Log/0/node')
    $toRun = oThis('A:least/5/1//-Log/0/node')
    h.hat("and the initial log:yarrr's Erefs to n:Run'",gots(Run))
    
    
    })()
    
