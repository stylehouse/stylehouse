# Iliation
$R = A.Run
$h = A.h
    $nonA = &t{
        # A container
        #   A lesser than even &Atopleast
        #    we can avoid G&calls (which are A.1^^ searches)
        #     except for the S, so scope $A to a non-sub
        $A = Cye([t||'Fusing',1])
        A.y = A
        return A
    }
S 1 Xsim
    # This/-Eight pictures data
    $h = A.h.o('Xsim')
    1 and 0
    (&{
    $A = nonA()
    # data container
    #  as opposed to A.c|sc.** directly
    $X = {A}
   // # &Xsim has a funny interface:
    # args:
    #  $X where to put stuff, may be A:
    #  $k may Ac&$k += X, only if given $X=A
    #  $t=['abit'] wraps every s.* with .abit
    #   a bunch of departmenting to jump into at each X|x|office
    #  $s keys to the index
    #   needs at least one
    #  $c what|how to put there
    #  $q unused
    
    #  $k may Ac&$k += X, only if given $X=A
    fi&Xsim,X,'ifnotX',[],{ifnot:3}
    # this one is hosted on Ac&ifnotX
    fi&Xsim,A,'ifnotX',[],{ifnot:4}
    
    #  $t=['abit'] preceeds every s.* with .abit
    # X.extrabit.fun.3=x
    fi&Xsim,X,'X',['extrabit'],{fun:3}
    # this reoccurs at every s.*
    fi&Xsim,X,'X',['extrabit'],{fun:3,joy:3}
    # X.extrabit=x reused as an index hash (hs)
    #  in &Shx we do /word/ -> X.word.1 = x
    fi&Xsim,X,'X',['extrabit',1],{fun:4}
    #  is climbed past (as $hs), no usu x typing (x.up etc)
    fi&Xsim,X,'X',['otherbit',1],{fun:4}
    # ! no s.*, no wrapping
    fi&Xsim,X,'X',['nonbit']
    
    h.hat('funny interface',X)
    
   // c.n
    $A = nonA()
    $X = {A}
    # we throw data into X.*:
    X.ret = a&ret = []
    $Xsim = &sc{
        # $N = &Xsim
        $N = fi&Xsim,X,0,0,s,c
        a&ret.push(N)
        return N
    }
    
    # X.figarto.1=x empty
    Xsim({figarto:1})
        # X.figarto.3=x has a row! x.z -> A%ret.0
        $n = Cye(['Fusilli',1])
        Xsim({figarto:2},{n})
    
        # rows join indexes
        Xsim({flim:2,flam:2},{n})
        $n = Cye(['Fuzylajj',1])
        Xsim({flim:2,flam:2},{n})

        # A%ret.3: we find all 3 in X/$flim=2
        #  ie s.* neednt have all
        $n = Cye(['Unfuse',1])
        Xsim({flim:2,figarto:2},{n})
    
    # we find the union
    Xsim({flim:2,flam:2})
    
    # s.* neednt have all
    #  ~~ &bracko, inherited to &sustain
    Xsim({flam:2})
    # A%ret.6: s.* order doesnt matter
    Xsim({figarto:2})
    
    # dup $n is stored, deduped on the way out
    #  see &xzand / !M.includes(n)
    Xsim({figarto:2},{n})
    # A%ret.9: it is an object compare
    #  see &xzand / ox.z.includes(n)
    #  so two C:Unfuse now come out
    $n = Cye(['Unfuse',1])
    Xsim({figarto:2},{n})
    
    # queries (or at least !c.n) autovivfy empties
    #  none: yet $fogma=2 = x (/!$n)
    Xsim({fogma:2})
    #  none: $fogma/!$n xzand $figarto/$n
    Xsim({fogma:2,figarto:2})
    # A%ret.12
    Xsim({fogma:2,groova:'to'})
    
    # c.el:8 doesnt autovivify empties
    #  returns null, ~~ &ja
    #   since $grover doesnt exist
    Xsim({fogma:2,grover:'to'},{el:8})
    #  none: since $fogma=2 is merely empty
    Xsim({fogma:2,figarto:2},{el:8})
    # A%ret.15
    #  as above, s.* order doesnt matter
    Xsim({figarto:2,fogma:2},{el:8})
    #  returns null, since $grover doesnt exist
    Xsim({figarto:2,grover:2},{el:8})
    
    h.Fez('c.n',X)
    
   // c.long
    # you climb x = x._ for s.*
    #  more spacious space, returning $x not $n+ rows
    $A = nonA()
    $X = {A}
    $Xsim = &sc{
        # $x = &Xsim
        return fi&Xsim,X,0,0,s,pex(c,'long')
    }
    
    # &Xsimp X s c q
    #  does &Xsim c.long with better args
    fi&Xsimp,X,{Basica:'ly',every:'thing'}
    
    $n = Cye(['Unfuse',1])
    Xsim({tog:1,figarto:2},{n})
    $n = Cye(['Fuzylajj',1])
    Xsim({tog:1,flam:2},{n})
    $x = Xsim({tog:1})
    x.aways = 'along'
    $x = Xsim({tog:1,flam:2})
    x.all = 'theway'
    # s.* order matters
    $x = Xsim({flam:2})
    x.norows = 1
    
    # empty, yet indexed
    Xsim(peel('all,the,spaces:3,in,here'))
    
    # c.el:8 doesnt autovivify empties
    #  it will however create an empty spaces:4|5:
    Xsim(peel('all,the,spaces:4,over,there'),'el:8')
    Xsim(peel('all,the,spaces:5,for,layout'),'el:8')
    #  ie it stops when there is no x.further:
    Xsim(peel('all,the,further:6,over,such'),'el:8')
    
    h.Fez('c.long',X)
   
   // c.array=1
    # allows indexing objects (~~ &X_s)
    # < benchmark this vs using Cy&uid where possible...?
    #   it greps for them underneath?
    #    is where perl's scalar($obj) == unique address is nice
    $A = nonA()
    $X = {A}
    $Xsim = &scx{
        return fi&Xsim,x||X,0,0,s,pex(c,'long')
    }
    
    $anob = {}
    Xsim({thisward:anob},'array') .once = 1
    # what's inside doesn't matter:
    anob.five = 5
    Xsim({thisward:anob},'array') .twice = 1
    # is different:
    Xsim({thisward:{other:3}},'array') .thrice = 1
    # whole leg is array-stored
    Xsim({elsewhere:anob,for:'it'},'array') .quice = 1
    #  you (eg &Xsomp) may break it down:
    $x = Xsim({elsewhere:anob},'array')
    x.five = 1
        Xsim({now:'stringy'},'',x)
        Xsim({now:'etc'},'',x) .finally = 1
    
    h.Fez('c.array',X)
    
   // c.wild|simvx and -anx "noxup"
    # c.wild(card) returns vx for X.such.*=x+ (to &Xsomp)
    #  $vx is $hs (indexy hash (or array)) where .$t=$x
    #   or if it was c.array, .$i=$x
    #    unless you were looking at the refs, which is .$i=$s
    #  only for one &Xsim s.*
    #   though non-wild can occur first (X/$thus)
    # c.simvx returns inflated vx, with only the selected keys in it
    #  usu just one key
    #   < unless WHERE loose, ranges
    #   so &Xsomp can always get a $vx whether c.wild or not
    #    useful for finding the $i for c.array
    #  only one &Xsim s.*
    #   ie you row across high frequency &Xsim
    $A = nonA()
    $X = {A}
    $Xsim = &scx{
        return fi&Xsim,x||X,0,0,s,pex(c,'long')
    }
    Xsim({thus:1,all:'variously'}) .incar = 2
    Xsim({thus:1,all:'muchly'}) .incar = 3
    Xsim({thus:4,all:'suchly'}) .incar = 4
    Xsim({thus:5,all:'suchly'}) .incar = 5
    $vx = Xsim({thus:1,all:1},'wild:all')
    
    # by the way, -anx says noxup when X...x is unnatural:
        # when we get to -anx, at vx.$k=x
        X.thusallwild = vx
        # the .vividity is noxup
        #  .up also, reveals where it thinks it is
        #   terminating the noxup-ness
        #  .etc.3 is not, since it presents as inside the nearest ^^x|X
        Xsim({thus:5,all:'suchly',etc:3}) .inert = 1
        $x = Xsim({thus:5,all:'suchly'})
        X.vividity = x
        # just this far in, it shares .up=X
        $x = Xsim({thus:4})
        X.obscurity = x
        # this far out, it doesnt
        Xsim({shape:4,tango:3}) .inobscurity = x
    
    # c.simvx
    $asim = s => Xsim(s,'array')
    asim({lets:{}})
    asim({lets:{}}) .two = 2
    $lets = {cre:8}
    asim({lets})    .three = 3
    asim({lets:{}}) .four = 4
    # to know the X.lets(s)?.$i
    $vx = Xsim({lets},'array,simvx')
    X.simvx = vx
    
    h.Fez('c.wild|simvx',X)
    
    })()

S 2 Xsomp
    # layer above &Xsim:
    #  i: &Xsimp does a normal kind of &Xsim, no rowing
    #  o: &Xsomp does rowing, per /$n, returning [ax+]
    # used by
    #  Fish / Q # originally
    #  &Shx_io # exciting edge of io, rowing
    $h = A.h.o('Xsomp')
    1 and 0
    (&{
   // &Xsimp -> &Xsomp
    $A = nonA('&Xsimp -> &Xsomp')
    haks(peel("Fuzylajj,Dongit,Riding,Wings"))
        .map(t => A.sc[t] = Cye([t,1]))
    $X = {A}
    
    # &Xsimp X s c q
    #  does &Xsim c.long with better args
    #  doesnt do rowing (returns x)
    $Xsimp = (s,c) => fi&Xsimp,X,peel(s),peel(c)
    
    Xsimp("Basica:ly,every:thing",{n:a&Dongit})
    Xsimp("Basica:ly,every:time",{n:a&Riding})
    Xsimp("Basica:va,every:where",{n:a&Dongit})
    # copied from Fus@1 / c.long / c.el
        Xsimp('all,the,spaces:3,in,here')
        # c.el:8 doesnt autovivify empties
        #  it will however create an empty spaces:4|5:
        Xsimp('all,the,spaces:4,over,there','el:8')
        Xsimp('all,the,spaces:5,for,layout','el:8')
        #  ie it stops when there is no x.further:
        Xsimp('all,the,further:6,over,such','el:8')
    
    
    # ax contain .arkx
    X.everyevery_full = fi&Xsomp,X,{Basica:1,every:1}
    $res = &tsc{
        X[t] = fi&Xsomp,X,s,c .map(&a{
            return depeel(tex({},a))
                +' n:'+(a.n?a.n.t:"???")
        })
    }
    res('everyevery',{Basica:1,every:1})
    
    res('lyevery',{Basica:'ly',every:1})
    
    # none
    #  creates /$every=way
    res('everynot',{Basica:1,every:'way'})
    #  c.el=8 doesnt create /$woop
    res('woopnot',{Basica:1,woop:'woop'},{el:8})
    # needs rows to be there (/$n)
    #  using &Xsimp|&Xsim they are only at the end
    #   we land on x+, which have x/$n+
    res('Basicanot',{Basica:5})
    res('allnot',peel('all,the,spaces:3,in,here'))
    if (0) {
    # c.non - no /$n multiplicity, wanting x
    #  so now this returns the empty x got to
    res('everynot_non',{Basica:1,every:'ways'},{non:1})
    #   $every=waysia is created since /$every already exists
    #  < c.el=8 should avoid it
    res('everyempty_non_el8',{Basica:1,every:'waysia'},{non:1,el:8})
    #  c.el=8 doesnt create /$veb
    res('vebnot_non_el8',{Basica:1,veb:'waysia'},{non:1,el:8})
    }
    #  $every=ways already exists 
    res('everyempty_non_el8',{Basica:1,every:'ways'},{non:1,el:8})
    #  creates $Basica=5/$wool (unless c.el=8)
    #  c.non determines only whether they return here:
    res('woolcreates_non',{Basica:1,wool:'wool'},{non:1})
    res('allis_non',peel('all,the,spaces:3,in,here'),{non:1})
    
    h.Fez('&Xsimp -> &Xsomp',X)
   
   // /$n
    # needs rows to be there (/$n)
    #  using &Xsimp|&Xsim they are only at the end
    $A = nonA('/$n')
    haks(peel("Fuzylajj,Dongit,Riding,Wings"))
        .map(t => A.sc[t] = Cye([t,1]))
    $X = {A}
    # &Xsimp for input
    $Xsimp = (s,c) => fi&Xsimp,X,peel(s),peel(c)
    # &Xsomp cant input c.n, since &Xsim c.simvx leaves early
    #  see &Shx_io which splits for i|o
    $Xsomp = (s,c,q) => fi&Xsomp,X,peel(s),peel(c),peel(q)
    Xsimp("every:thing",{n:a&Dongit})
    Xsimp("every:time",{n:a&Riding})
    Xsimp("every:where",{n:a&Riding})
    Xsimp("every:where",{n:a&Dongit})
    # abbreviate ax+
    $res = (t,N) => X[t] = N.map(ax => nex({},ax,'arkx'))
    res('every where',Xsomp("every:where"))
    # does where-/$n-clauses via q.n
    # < c.n could be used since &Xsomp cant input c.n
    res('every n:Riding',Xsomp("every:1",{},{n:a&Riding}))
    
    Xsimp("every:thing,else:ward",{n:a&Dongit})
    Xsimp("every:thing,else:fliv",{n:a&Riding})
    Xsimp("every:where,else:fliv",{n:a&Riding})
    res('elses',     Xsomp("every:1,else:1"))
    res('whereelses',Xsomp("every:where,else:1"))
    
    # c.array for objects
    Xsimp({want:a&Dongit},{n:a&Riding,array:1})
    Xsimp({want:a&Riding},{n:a&Fuzylajj,array:1})
    # &Xsomp doesnt need to know c.array
    res('all wants', Xsomp("want"))
    #  unless it is looking for something...
    res('want of Dongit', Xsomp({want:a&Dongit},'array'))
    res('want of Fuzylajj', Xsomp({want:a&Fuzylajj},'array'))
    res('wants of Fuzylajj', Xsomp("want",'array',{n:a&Fuzylajj}))
    
    # ! this $t fed to &Pii, sensitive to /|%|-pi
    h.Fez('per $n',X)
    
    })()
   
S 3 Shx
    # proto io expr for X, layer above &Xsimp|&Xsomp
    #  not used by &bract_kref, due to slowness
    #   < compile expr to voice
    #  it requires|does /$n all the way down:
    #   ie &Xsimp clutchy,every:thing $n
    #    none: &Shx o clutchy/every
    $h = A.h.o('Shx')
    h.sixc = 'expectÎ»'
    # interface to allow spaced out calls (wrap me&calls)
    $S = me&Simqis_Shx
    1 and 0
    (&{
   // &Shx
    $A = nonA('Shx')
    haks(peel("Fuzylajj,Dongit,Riding,Wings"))
        .map(t => A.sc[t] = Cye([t,1]))
    $X = {A}
    # results:
    $O = {}
    # setup stuff to read
    # o ... { # returns iterator
    # < even for tiny bits like binding $X
    # < without the decoy $n to make inners' &Shx_isax work
    #   which will dis-join the inner $n? hmm
    #S("o $X $n {",X,a&Dongit) (&{
        S("i $X/$every $n",X,'thing',a&Dongit)
        S("i $X/$every $n",X,'time',a&Riding)
        S("i $X/$every $n",X,'where',a&Riding)
        S("i $X/$every $n",X,'where',a&Dongit)
        S("i $X/$every $n",X,'lunk',a&Riding)
        
        S("i $X/clutchy/$every $n",X,'thing',a&Dongit)
        # < even for binding /$n
        0 && S("i $canbenamedanything {",a&Fuzylajj) (&{
            S("i /clutchy/$every",'lunk')
            S("i /others/$with",'lunk')        
        })
        S("i $X/clutchy/$every $n",X,'lunk',a&Fuzylajj)
        
        S("i $X/others/$with $n",X,'lunk',a&Fuzylajj)
        S("i $X/others/$with $n",X,'lunk',a&Riding)
    #})
    
    $res = &ta{
        $N = O[t] ||= []
        N.push(depeel(tex({},a))+' n:'+(a.n?a.n.t:"???"))
    }
    
    # any every
    S("o $X/every {",X)          (a => res('every',a))
    # such every
    S("o $X/$every {",X,'where') (a => res('every=where',a))
    # deeper
    S("o $X/clutchy {",X)       (a => res('clutchy',a))
    S("o $X/clutchy/every {",X) (a => res('clutchy every',a))
    
    h.Fez('Shx',{X,O})
    
   // &Shx joins
    O = {}
    # joins o ... o ...
    #  are only via iteration, not plumbing:
    # < should be able to plumb c.N = c.c.N
    #  /clutchy/every/$n that are also /every/$n
    #  big nostalgia vibe ...
    #   was a mysterious glimmer in the thinking around osc somewhere
    #    pin: the thing you get at the end of a long void you can bring back
    #     that can hold fabric together, as complexity is made
    #S("o $X/clutchy/every o $X/every {",X,X) (a => res('$n join',a))
    S("o $X/clutchy/every {",X) (&a{
        # not every:where Dongit, since every=thing|lunk
        #  also not every:lunk Riding
        S("o $X/every {",X) (a => res('join every,n',a))
        
        # to join on $every, not $n:
        #  drop ark ax.n
        S("o $X/@!$n/every {",X) (a => res('join every',a))
        # < easier chopping up rowing, eg collect (T.ax|a).every here
        
        # to join on $n, not $every:
        #  < drop ark ax.every
        #    binds it again from T.ax. warns of vague &axcompatible
        #S("o $X/@!$every/every {",X) (a => res('join n also',a))
        #  set $every=1, to glob it, /$n follow
        S("o $X/$every {",X,1) (a => res('join n',a))
        
        # to join $n, other arks not common
        #  row has every:lunk and with:lunk
        S("o $X/others/with {",X) (a => res('join n to other columns',a))
    })
    
    # between X
    $V = {A}
    S("o $X/others/with {",X) (&{
        S("o $X/$every {",X,1) (&{
            S("i $V/fing/with/what/every {",V) (a => res('i joined n:Riding',a))
        })
        # < n:Fuzylajj (first row) doesnt have any ^,
        #    which is why these two O.* results appear in reverse
        #   so here it defaults to 1... should knock out the row..?
        S("i $V/every/whatsit {",V) (a => res('i joined from sibling rowing',a))
    })
    
    # not much else to it yet
    
    # < this buncher is lacking
        # < will one day o /believe/...$Q
        # < wants to leave a schema,
        #    so we can glob through $time/...
        #    or if given of:w, find our way out to eg w:Such
        #     ie /$n-matching avoided until the end of the ... pool|bunch
        $oft = {of:'ya'}
        # < &Shx_io / if q.ark
        #    only arks one value from $of, which must be of.of
        # < adjusting expr to: /...$of/such
        #    will make /such/...$of
        #    only one of the &Shx a(pattern,handler) can loop at once
        S("i $V/before/$time/...$of $n {",V,'3.4.5',oft,a&Fuzylajj)
            (a => res('destructured bits',a))
    
    # < when Yinging, X,O,V are each an -Eight
    h.Fez('Shx joins',{O,V})
    
   // &Sarn - io expr as schema
    # &Sarn sets up schema for later &Saturn-ing
    $A = nonA('Sarner')
    $X = {A}
    
    # these have been adjusted to not have -This at path[1],
    #  see &Sarg_Sarn creating This|The duality
    # the Gnome/Thy...-Lab schema is most complex
    #   q.testingmode prevents scheme|compile-time -This|-The
    a&SarnThy = me&Sarn,<<'',[]
        i @Thy/-This/#@Fine-Labine/@-Lab#@n%ThyLab/c&s=@n
    
    # and Cat/Run/This**
    a&SarnRun = me&Sarn,<<'',[]
        i @Run/@-This/-Eight/-seven/**%Ethinging
    
    h.Fez('Sarn',{O:A.sc})
    
    # < &Saturn unfolds a particular s**
    #   may route %%inst - wants to mock &nodei
    #    < all of me.* (I.i.*) should be mockable
    #     < watch what units do|return,
    #       swap them out, iteratively decrease the Dump
    #        ie bisect down to what data the test needs to pass
    #   involving &gfunc, kind of a &voice compositor
     
   
    })()

S 4 Q
    # imports from networks
    $h = A.h.o('Q')
    1 and 0
    (&{
    $A = nonA('believeQ')
   // some Q
    $Q_J = fi&aQ,{of:'w',t:'J'},{src:'localhost:1812',vers:'3.3'}
    $Q_fr = fi&aQ,{of:'w',t:'fr'},{src:'localhost:1812',vers:'3.1'}
    $Q_unbelievable = fi&aQ,{of:'n',t:'J'}
    
    # A&X/...$oft is created by &*oQ
    a&AoQing = {
        J: fi&AoQ,A,Q_J ,
        fr: fi&AoQ,A,Q_fr ,
        # the /...$believe step would be fatal, but is empty
        unbelievable: fi&AoQ,A,Q_unbelievable ,
    }
    
    # &aQ and &Qbel dont do much
    a&formats = {
        # &aQ is only used by A&oftserve() to s|c -> Q.c|sc
        #  see &wantbelieve below, which simply &Xsimp s
        # Fish Q seem to have Q.t == Q.c.t
        aQ: [
            Q_J ,
            Q_fr ,
            Q_unbelievable ,
            fi&aQ,{of:'W',t:'Radio',species:5,any:'thing'},{} ,
        ],
        # &Qbel forms /believe/... stuff
        Qbel: {
            glob: fi&Qbel,0,{} ,
            # only Q with src+version can /believe/
            fr: fi&Qbel,Q_fr ,
        },
    }
        
    h.hat('some Q',A)
    
   // believe
    $A = nonA('having Q')
    # &aQ sets Qy&A
    a&Q_J = fi&aQ,{of:'w',t:'J'},{src:'localhost:1812',vers:'3.3'}
    a&believe_it = fi&AiQ,A,a&Q_J
    a&Q_Jask = fi&aQ,{of:'w',t:'J'}
    # < /...$oft not needing /$n
    #   got steamrolled for &Shx 8297cb0ff89610091
    #  < test it is at the end of each &Xsomp s
    #  < check all instances of &Xsomp
    #debugger
    a&believeoQ_it = fi&AoQ,A,a&Q_Jask
    
    
    h.hat('having Q',{A})
    
    # &Ath,A:client,s:$oft,c?,q? is a proto &t
    #  / &wantbelieve climbs, each:
    #     $Qx = i A&X/...$s
    #      ! so you must always spec $s={of,t} in the right order, etc
    #    until:
    #    &believeoQ,Qx returns $a
    #   &believeiQ brings it down
    # returns a.n=$Q if ready
    
    
    # < using &believeoQ
    
    
    
    })()
    
