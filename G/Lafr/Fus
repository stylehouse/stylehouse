# Iliation!
$R = A.Run
$h = A.h
    $nonA = &t{
        # A container
        #   A lesser than even &Atopleast
        #    we can avoid G&calls (which are A.1^^ searches)
        #     except for the S, so scope $A to a non-sub
        $A = Cye([t||'Fusing',1])
        A.y = A
        return A
    }
S 1 Xsim
    # This/-Eight pictures data
    $h = A.h.o('Xsim')
    1 and 0
    (&{
    $A = nonA()
    # data container
    #  as opposed to A.c|sc.** directly
    $X = {A}
   // # &Xsim has a funny interface:
    # args:
    #  $X where to put stuff, may be A:
    #  $k may Ac&$k += X, only if given $X=A
    #  $t=['abit'] wraps every s.* with .abit
    #   a bunch of departmenting to jump into at each X|x|office
    #  $s keys to the index
    #   needs at least one
    #  $c what|how to put there
    #  $q unused
    
    #  $k may Ac&$k += X, only if given $X=A
    fi&Xsim,X,'ifnotX',[],{ifnot:3}
    # this one is hosted on Ac&ifnotX
    fi&Xsim,A,'ifnotX',[],{ifnot:4}
    
    #  $t=['abit'] preceeds every s.* with .abit
    # X.extrabit.fun.3=x
    fi&Xsim,X,'X',['extrabit'],{fun:3}
    # this reoccurs at every s.*
    fi&Xsim,X,'X',['extrabit'],{fun:3,joy:3}
    # X.extrabit=x reused as an index hash (hs)
    #  in &Shx we do /word/ -> X.word.1 = x
    fi&Xsim,X,'X',['extrabit',1],{fun:4}
    #  is climbed past (as $hs), no usu x typing (x.up etc)
    fi&Xsim,X,'X',['otherbit',1],{fun:4}
    # ! no s.*, no wrapping
    fi&Xsim,X,'X',['nonbit']
    
    h.hat('funny interface',X)
    
   // c.n
    $A = nonA()
    $X = {A}
    # we throw data into X.*:
    X.ret = a&ret = []
    $Xsim = &sc{
        # $N = &Xsim
        $N = fi&Xsim,X,0,0,s,c
        a&ret.push(N)
        return N
    }
    
    # X.figarto.1=x empty
    Xsim({figarto:1})
        # X.figarto.3=x has a row! x.z -> A%ret.0
        $n = Cye(['Fusilli',1])
        Xsim({figarto:2},{n})
    
        # rows join indexes
        Xsim({flim:2,flam:2},{n})
        $n = Cye(['Fuzylajj',1])
        Xsim({flim:2,flam:2},{n})

        # A%ret.3: we find all 3 in X/$flim=2
        #  ie s.* neednt have all
        $n = Cye(['Unfuse',1])
        Xsim({flim:2,figarto:2},{n})
    
    # we find the union
    Xsim({flim:2,flam:2})
    
    # s.* neednt have all
    #  ~~ &bracko, inherited to &sustain
    Xsim({flam:2})
    # A%ret.6: s.* order doesnt matter
    Xsim({figarto:2})
    
    # dup $n is stored, deduped on the way out
    #  see &xzand / !M.includes(n)
    Xsim({figarto:2},{n})
    # A%ret.9: it is an object compare
    #  see &xzand / ox.z.includes(n)
    #  so two C:Unfuse now come out
    $n = Cye(['Unfuse',1])
    Xsim({figarto:2},{n})
    
    # queries (or at least !c.n) autovivfy empties
    #  none: yet $fogma=2 = x (/!$n)
    Xsim({fogma:2})
    #  none: $fogma/!$n xzand $figarto/$n
    Xsim({fogma:2,figarto:2})
    # A%ret.12
    Xsim({fogma:2,groova:'to'})
    
    # c.el:8 doesnt autovivify empties
    #  returns null, ~~ &ja
    #   since $grover doesnt exist
    Xsim({fogma:2,grover:'to'},{el:8})
    #  none: since $fogma=2 is merely empty
    Xsim({fogma:2,figarto:2},{el:8})
    # A%ret.15
    #  as above, s.* order doesnt matter
    Xsim({figarto:2,fogma:2},{el:8})
    #  returns null, since $grover doesnt exist
    Xsim({figarto:2,grover:2},{el:8})
    
    h.Fez('c.n',X)
    
   // c.long
    # you climb x = x._ for s.*
    #  more spacious space, returning $x not $n+ rows
    $A = nonA()
    $X = {A}
    $Xsim = &sc{
        # $x = &Xsim
        return fi&Xsim,X,0,0,s,pex(c,'long')
    }
    
    # &Xsimp X s c q
    #  does &Xsim c.long with better args
    fi&Xsimp,X,{Basica:'ly',every:'thing'}
    
    $n = Cye(['Unfuse',1])
    Xsim({tog:1,figarto:2},{n})
    $n = Cye(['Fuzylajj',1])
    Xsim({tog:1,flam:2},{n})
    $x = Xsim({tog:1})
    x.aways = 'along'
    $x = Xsim({tog:1,flam:2})
    x.all = 'theway'
    # s.* order matters
    $x = Xsim({flam:2})
    x.norows = 1
    
    # empty, yet indexed
    Xsim(peel('all,the,spaces:3,in,here'))
    
    # c.el:8 doesnt autovivify empties
    #  it will however create an empty spaces:4|5:
    Xsim(peel('all,the,spaces:4,over,there'),'el:8')
    Xsim(peel('all,the,spaces:5,for,layout'),'el:8')
    #  ie it stops when there is no x.further:
    Xsim(peel('all,the,further:6,over,such'),'el:8')
    
    h.Fez('c.long',X)
   
   // c.array=1
    # allows indexing objects (~~ &X_s)
    # < benchmark this vs using Cy&uid where possible...?
    #   it greps for them underneath?
    #    is where perl's scalar($obj) == unique address is nice
    $A = nonA()
    $X = {A}
    $Xsim = &scx{
        return fi&Xsim,x||X,0,0,s,pex(c,'long')
    }
    
    $anob = {}
    Xsim({thisward:anob},'array') .once = 1
    # what's inside doesn't matter:
    anob.five = 5
    Xsim({thisward:anob},'array') .twice = 1
    # is different:
    Xsim({thisward:{other:3}},'array') .thrice = 1
    # whole leg is array-stored
    Xsim({elsewhere:anob,for:'it'},'array') .quice = 1
    #  you (eg &Xsomp) may break it down:
    $x = Xsim({elsewhere:anob},'array')
    x.five = 1
        Xsim({now:'stringy'},'',x)
        Xsim({now:'etc'},'',x) .finally = 1
    
    h.Fez('c.array',X)
    
   // c.wild|simvx and -anx "noxup"
    # c.wild(card) returns vx for X.such.*=x+ (to &Xsomp)
    #  $vx is $hs (indexy hash (or array)) where .$t=$x
    #   or if it was c.array, .$i=$x
    #    unless you were looking at the refs, which is .$i=$s
    #  only for one &Xsim s.*
    #   though non-wild can occur first (X/$thus)
    # c.simvx returns inflated vx, with only the selected keys in it
    #  usu just one key
    #   < unless WHERE loose, ranges
    #   so &Xsomp can always get a $vx whether c.wild or not
    #    useful for finding the $i for c.array
    #  only one &Xsim s.*
    #   ie you row across high frequency &Xsim
    $A = nonA()
    $X = {A}
    $Xsim = &scx{
        return fi&Xsim,x||X,0,0,s,pex(c,'long')
    }
    Xsim({thus:1,all:'variously'}) .incar = 2
    Xsim({thus:1,all:'muchly'}) .incar = 3
    Xsim({thus:4,all:'suchly'}) .incar = 4
    Xsim({thus:5,all:'suchly'}) .incar = 5
    $vx = Xsim({thus:1,all:1},'wild:all')
    
    # by the way, -anx says noxup when X...x is unnatural:
        # when we get to -anx, at vx.$k=x
        X.thusallwild = vx
        # the .vividity is noxup
        #  .up also, reveals where it thinks it is
        #   terminating the noxup-ness
        #  .etc.3 is not, since it presents as inside the nearest ^^x|X
        Xsim({thus:5,all:'suchly',etc:3}) .inert = 1
        $x = Xsim({thus:5,all:'suchly'})
        X.vividity = x
        # just this far in, it shares .up=X
        $x = Xsim({thus:4})
        X.obscurity = x
        # this far out, it doesnt
        Xsim({shape:4,tango:3}) .inobscurity = x
    
    # c.simvx
    $asim = s => Xsim(s,'array')
    asim({lets:{}})
    asim({lets:{}}) .two = 2
    $lets = {cre:8}
    asim({lets})    .three = 3
    asim({lets:{}}) .four = 4
    # to know the X.lets(s)?.$i
    $vx = Xsim({lets},'array,simvx')
    X.simvx = vx
    
    h.Fez('c.wild|simvx',X)
    
    })()

S 2 Xsomp
    # layer above &Xsim:
    #  i: &Xsimp does a normal kind of &Xsim, no rowing
    #  o: &Xsomp does rowing, per /$n, returning [ax+]
    # used by
    #  Fish / Q # originally
    #  &Shx_io # exciting edge of io, rowing
    $h = A.h.o('Xsomp')
    1 and 0
    (&{
   // &Xsimp -> &Xsomp
    $A = nonA('&Xsimp -> &Xsomp')
    haks(peel("Fuzylajj,Dongit,Riding,Wings"))
        .map(t => A.sc[t] = Cye([t,1]))
    $X = {A}
    
    # &Xsimp X s c q
    #  does &Xsim c.long with better args
    #  doesnt do rowing (returns x)
    $Xsimp = (s,c) => fi&Xsimp,X,peel(s),peel(c)
    
    Xsimp("Basica:ly,every:thing",{n:a&Dongit})
    Xsimp("Basica:ly,every:time",{n:a&Riding})
    Xsimp("Basica:va,every:where",{n:a&Dongit})
    # copied from Fus@1 / c.long / c.el
        Xsimp('all,the,spaces:3,in,here')
        # c.el:8 doesnt autovivify empties
        Xsimp('all,the,spaces:4,over,there','el:8')
        Xsimp('all,the,spaces:5,for,layout','el:8')
        #  ie it stops when there is no x.further:
        Xsimp('all,the,further:6,over,such','el:8')
    
    
    # ax contain .arkx
    X.everyevery_full = fi&Xsomp,X,{Basica:1,every:1}
    $res = &tsc{
        X[t] = fi&Xsomp,X,s,c .map(&a{
            return depeel(tex({},a))
                +' n:'+(a.n?a.n.t:"???")
        })
    }
    res('everyevery',{Basica:1,every:1})
    
    res('lyevery',{Basica:'ly',every:1})
    
    # none
    #  creates /$every=way
    res('everynot',{Basica:1,every:'way'})
    #  c.el=8 doesnt create /$woop
    res('woopnot',{Basica:1,woop:'woop'},{el:8})
    # needs rows to be there (/$n)
    #  using &Xsimp|&Xsim they are only at the end
    #   we land on x+, which have x/$n+
    res('Basicanot',{Basica:5})
    res('allnot',peel('all,the,spaces:3,in,here'))
    
    # c.non - no /$n multiplicity, wanting x
    #  so now this returns the empty x got to
    #  variation: el8 here then doesn't create /$Basica=5/$every=ways
    res('everynot_non',{Basica:1,every:'ways'},{non:1})
    #   el8 /$Basica/$every=waysia doesnt create
    res('everyempty_non_el8',{Basica:1,every:'waysia'},{non:1,el:8})
    #  c.el=8 doesnt create /$veb
    res('vebnot_non_el8',{Basica:1,veb:'waysia'},{non:1,el:8})
    #  creates $Basica=5/$wool (unless c.el=8, as above)
    #  c.non determines only whether they return here:
    res('woolcreates_non',{Basica:1,wool:'wool'},{non:1})
    res('allis_non',peel('all,the,spaces:3,in,here'),{non:1})
    
    
    h.Fez('&Xsimp -> &Xsomp',X)
   
   // /$n
    # needs rows to be there (/$n)
    #  using &Xsimp|&Xsim they are only at the end
    $A = nonA('/$n')
    haks(peel("Fuzylajj,Dongit,Riding,Wings"))
        .map(t => A.sc[t] = Cye([t,1]))
    $X = {A}
    # &Xsimp for input
    $Xsimp = (s,c) => fi&Xsimp,X,peel(s),peel(c)
    # &Xsomp cant input c.n, since &Xsim c.simvx leaves early
    #  see &Shx_io which splits for i|o
    $Xsomp = (s,c,q) => fi&Xsomp,X,peel(s),peel(c),peel(q)
    Xsimp("every:thing",{n:a&Dongit})
    Xsimp("every:time",{n:a&Riding})
    Xsimp("every:where",{n:a&Riding})
    Xsimp("every:where",{n:a&Dongit})
    # abbreviate ax+
    $res = (t,N) => X[t] = N.map(ax => nex({},ax,'arkx'))
    res('every where',Xsomp("every:where"))
    # does where-/$n-clauses via q.n
    # < c.n could be used since &Xsomp cant input c.n
    res('every n:Riding',Xsomp("every:1",{},{n:a&Riding}))
    
    Xsimp("every:thing,else:ward",{n:a&Dongit})
    Xsimp("every:thing,else:fliv",{n:a&Riding})
    Xsimp("every:where,else:fliv",{n:a&Riding})
    res('elses',     Xsomp("every:1,else:1"))
    res('whereelses',Xsomp("every:where,else:1"))
    
    # c.array for objects
    Xsimp({want:a&Dongit},{n:a&Riding,array:1})
    Xsimp({want:a&Riding},{n:a&Fuzylajj,array:1})
    # &Xsomp doesnt need to know c.array
    res('all wants', Xsomp("want"))
    #  unless it is looking for something...
    res('want of Dongit', Xsomp({want:a&Dongit},'array'))
    res('want of Fuzylajj', Xsomp({want:a&Fuzylajj},'array'))
    res('wants of Fuzylajj', Xsomp("want",'array',{n:a&Fuzylajj}))
    
    # ! this $t fed to &Pii, sensitive to /|%|-pi
    h.Fez('per $n',X)
    
    })()
   
S 3 Shx
    # proto io expr for X, layer above &Xsimp|&Xsomp
    #  not used by &bract_kref, due to slowness
    #   < compile expr to voice
    #  it requires|does /$n all the way down:
    #   ie &Xsimp clutchy,every:thing $n
    #    none: &Shx o clutchy/every
    $h = A.h.o('Shx')
    h.sixc = 'expectλ'
    # interface to allow spaced out calls (wrap me&calls)
    $S = me&Simqis_Shx
    1 and 0
    (&{
    
   // &Shx
    $A = nonA('Shx')
    haks(peel("Fuzylajj,Dongit,Riding,Wings"))
        .map(t => A.sc[t] = Cye([t,1]))
    $X = {A}
    # results:
    $O = {}
    # setup stuff to read
    # o ... { # returns iterator
    # < even for tiny bits like binding $X
    # < without the decoy $n to make inners' &Shx_isax work
    #   which will dis-join the inner $n? hmm
    #S("o $X $n {",X,a&Dongit) (&{
        S("i $X/$every $n",X,'thing',a&Dongit)
        S("i $X/$every $n",X,'time',a&Riding)
        S("i $X/$every $n",X,'where',a&Riding)
        S("i $X/$every $n",X,'where',a&Dongit)
        S("i $X/$every $n",X,'lunk',a&Riding)
        
        S("i $X/clutchy/$every $n",X,'thing',a&Dongit)
        # < even for binding /$n
        0 && S("i $canbenamedanything {",a&Fuzylajj) (&{
            S("i /clutchy/$every",'lunk')
            S("i /others/$with",'lunk')        
        })
        S("i $X/clutchy/$every $n",X,'lunk',a&Fuzylajj)
        
        S("i $X/others/$with $n",X,'lunk',a&Fuzylajj)
        S("i $X/others/$with $n",X,'lunk',a&Riding)
    #})
    
    $res = &ta{
        $N = O[t] ||= []
        N.push(depeel(tex({},a))+' n:'+(a.n?a.n.t:"???"))
    }
    
    # any every
    S("o $X/every {",X)          (a => res('every',a))
    # such every
    S("o $X/$every {",X,'where') (a => res('every=where',a))
    # deeper
    S("o $X/clutchy {",X)       (a => res('clutchy',a))
    S("o $X/clutchy/every {",X) (a => res('clutchy every',a))
    
    h.Fez('Shx',{X,O})
    
   // &Shx joins
    O = {}
    # joins o ... o ...
    #  are only via iteration, not plumbing:
    # < should be able to plumb c.N = c.c.N
    #  /clutchy/every/$n that are also /every/$n
    #  big nostalgia vibe ...
    #   was a mysterious glimmer in the thinking around osc somewhere
    #    pin: the thing you get at the end of a long void you can bring back
    #     that can hold fabric together, as complexity is made
    #S("o $X/clutchy/every o $X/every {",X,X) (a => res('$n join',a))
    S("o $X/clutchy/every {",X) (&a{
        # not every:where Dongit, since every=thing|lunk
        #  also not every:lunk Riding
        S("o $X/every {",X) (a => res('join every,n',a))
        
        # to join on $every, not $n:
        #  drop ark ax.n
        S("o $X/@!$n/every {",X) (a => res('join every',a))
        # < easier chopping up rowing, eg collect (T.ax|a).every here
        
        # to join on $n, not $every:
        #  < drop ark ax.every
        #    binds it again from T.ax. warns of vague &axcompatible
        #S("o $X/@!$every/every {",X) (a => res('join n also',a))
        #  set $every=1, to glob it, /$n follow
        S("o $X/$every {",X,1) (a => res('join n',a))
        
        # to join $n, other arks not common
        #  row has every:lunk and with:lunk
        S("o $X/others/with {",X) (a => res('join n to other columns',a))
    })
    
    # between X
    $V = {A}
    S("o $X/others/with {",X) (&{
        S("o $X/$every {",X,1) (&{
            S("i $V/fing/with/what/every {",V) (a => res('i joined n:Riding',a))
        })
        # < n:Fuzylajj (first row) doesnt have any ^,
        #    which is why these two O.* results appear in reverse
        #   so here it defaults to 1... should knock out the row..?
        S("i $V/every/whatsit {",V) (a => res('i joined from sibling rowing',a))
    })
    
    # not much else to it yet
    
    # < this buncher is lacking
        # < will one day o /believe/...$Q
        # < wants to leave a schema,
        #    so we can glob through $time/...
        #    or if given of:w, find our way out to eg w:Such
        #     ie /$n-matching avoided until the end of the ... pool|bunch
        $oft = {of:'ya'}
        # < &Shx_io / if q.ark
        #    only arks one value from $of, which must be of.of
        # < adjusting expr to: /...$of/such
        #    will make /such/...$of
        #    only one of the &Shx a(pattern,handler) can loop at once
        S("i $V/before/$time/...$of $n {",V,'3.4.5',oft,a&Fuzylajj)
            (a => res('destructured bits',a))
    
    # < when Yinging, X,O,V are each an -Eight
    h.Fez('Shx joins',{O,V})
    
   // &Sarn - io expr as schema
    # &Sarn sets up schema for later &Saturn-ing
    $A = nonA('Sarner')
    $X = {A}
    
    # these have been adjusted to not have -This at path[1],
    #  see &Sarg_Sarn creating This|The duality
    # the Gnome/Thy...-Lab schema is most complex
    #   q.testingmode prevents scheme|compile-time -This|-The
    a&SarnThy = me&Sarn,<<'',[]
        i @Thy/-This/#@Fine-Labine/@-Lab#@n%ThyLab/c&s=@n
    
    # and Cat/Run/This**
    a&SarnRun = me&Sarn,<<'',[]
        i @Run/@-This/-Eight/-seven/**%Ethinging
    
    h.Fez('Sarn',{O:A.sc})
    
    # < &Saturn unfolds a particular s**
    #   may route %%inst - wants to mock &nodei
    #    < all of me.* (I.i.*) should be mockable
    #     < watch what units do|return,
    #       swap them out, iteratively decrease the Dump
    #        ie bisect down to what data the test needs to pass
    #   involving &gfunc, kind of a &voice compositor
     
   
    })()

S 4 Q
    # imports from networks
    $h = A.h.o('Q')
    h.sixc = 'expectλ'
    1 and 0
    (&{
    $A = nonA('believeQ')
   // some Q
    $Q_J = fi&aQ,{of:'w',t:'J'},{src:'localhost:1812',vers:'3.3'}
    $Q_fr = fi&aQ,{of:'w',t:'fr'},{src:'localhost:1812',vers:'3.1'}
    $Q_unbelievable = fi&aQ,{of:'n',t:'J'}
    
    # A&X/...$oft is created by &*oQ
    a&AoQing = {
        J: fi&AoQ,A,Q_J ,
        fr: fi&AoQ,A,Q_fr ,
        # the /...$believe step would be fatal, but is empty
        unbelievable: fi&AoQ,A,Q_unbelievable ,
    }
    
    # &aQ and &Qbel dont do much
    a&formats = {
        # &aQ is only used by A&oftserve() to s|c -> Q.c|sc
        #  see &wantbelieve below, which simply &Xsimp s
        # Fish Q seem to have Q.t == Q.c.t
        aQ: [
            Q_J ,
            Q_fr ,
            Q_unbelievable ,
            fi&aQ,{of:'W',t:'Radio',species:5,any:'thing'},{} ,
        ],
        # &Qbel forms /believe/... stuff
        Qbel: {
            glob: fi&Qbel,0,{} ,
            # only Q with src+version can /believe/
            fr: fi&Qbel,Q_fr ,
        },
    }
    
    h.hat('some Q',A)
    
   // believe
    $A = nonA('having Q')
    $V = A&Client = fi&A
    V.t = 'Client'
    # &aQ sets Qy&A, so lets rebuild
    A&Q_J = fi&aQ,{of:'w',t:'J'},{src:'localhost:1812',vers:'3.3'}
    A&Q_Jask = fi&aQ,{of:'w',t:'J'}
    
    a&AoQ_empty = fi&AoQ,A,A&Q_Jask
    a&AiQ_it = fi&AiQ,A,A&Q_J
    # /...$oft has /$n=A:client from &wantbelieve
    #  ! mistakenly thought it should have &Xsomp c.non=1
    #     and that &Xsomp needing /$n was introduced for &Shx 8297cb0ff89610091
    #      which was done after Stories/Fish stopped working
    #       it might still work... was motivated to Travel (and Story) by Gump
    # nothing yet, due to the above
    a&AoQ_still_empty = fi&AoQ,A,A&Q_Jask
    # a client (asking for ...$oft/)
    # < pile up better
    fi&Xsimp,A,A&Q_Jask.c,{n:V}
    a&AoQ_it = fi&AoQ,A,A&Q_Jask
    
    h.hat('having Q',{A})
    
   // ordering /believe...
    # &Xsomp $n...$n ordering
    #  sort by /believe/$n, where /believe/$suchly/$n
    #   so we can revert to a previous version
    #  for &believeoQ / &Xsomp c.norder / &Naxnorder
    #  lifted from &test_Nxcnorder
    # just x = &Xsimp and &believei|oQ,x
    #  so the lack of /$n=A:client doesnt matter
    $A = nonA('ordering believe...')
    
    $s = {of:'w',t:'leaks'}
    $x = fi&Xsimp,A,s
    $enQ = &s{
        $Q = Cye([s.src+' v'+s.version,1])
        fi&believeiQ,x,s,Q
        return Q
    }
    $got = a&got = {}
    $see = &t{
        got[t] = fi&believeoQ,x
    }
    $Q = enQ({believe:1,src:'1812',version:1})
    see('first')
    enQ({believe:1,src:'1812',version:2})
    see('2nd')
    # variation: must be a new $Q
    0 ? fi&believeiQ,x,Q.c,Q
      : enQ({believe:1,src:'1812',version:1})
    see('first again')
    
    # fail mode:
    $s = fi&Qbel,0,q
    got.without_norder = fi&Xsomp,x,s .map(ax => ax.n) .pop()
    
    h.hat('ordering believe...',{A})
   
   // wantbelieve
    # A** serving /believe/
    # &Ath,A:client,s:$oft,c?,q? is a proto &t
    #  / &wantbelieve climbs, each:
    #     $Qx = i A&X/...$s
    #      ! so you must always spec $s={of,t} in the right order, etc
    #    until:
    #    &believeoQ,Qx returns $a
    #   &believeiQ brings it down
    # returns a.n=$Q if ready
    $A = nonA('wantbelieve')
    A&oftserve = &scqd{
        (a&oftquest||=[]).push({s,c,q,d})
    }
    $V = A&Middle = fi&A
    V.t = 'Middle'
    $Y = A&Client = fi&A,V
    Y.t = 'Client'
    
    # A:Middle|Client refer to A:Client as the asker
    a&notyet = fi&wantbelieve,Y,{of:'w',t:'J'}
    # usu asyncily, it is loaded by A:thinger and etc
    #  A:thinger uses ...$oft/asked/.../$P instead of /believe/
    #    by setting q.believe=asked, &believe*Q etc work with that
    #   which is starting to get into messaging
    #    ie asked == asked remote about it
    # the whole ...$oft:oftx/$n=A:client thing seems a bit loose
    #  perhaps oftx/pull/$n=A:client and oftx/push/$n=A:receiver
    
    A&Q_J = fi&aQ,{of:'w',t:'J'},{src:'localhost:1812',vers:'3.3'}
    a&AiQ_it = fi&AiQ,A,A&Q_J
    
    a&hasitnow = fi&wantbelieve,Y,{of:'w',t:'J'}
    
    
    h.hat('wantbelieve',{A})
    
    
    
    })()
    
S 5 Log
    # look at &com working, and a bit of &At
    #  drawn from the first step of:
    =pod fi&test_Attention
     fi&live was the main loop:
      A&step++, ie proto &Sunpit
      then calls fi&test_Attention:
       various &com are logged, eg fi&Abelieve
       # still searching for its identity as a test
       we come back when things are ready?
       tests thing-getting down to the soft-wire? or @Inc?
      
    =cut
    =pod &complace wraps|captures &com|&log statements
     see w:Fish / Story
     fi&live was the main loop:
      A&step++, ie proto &Sunpit
      $done = &complace,$t='yarrr',$s={A}
       makes -Eight 'A:aname'
       makes -seven, serial-numbered
        # this will want to be $time as usu
       and an initial &com,s,c is made, saying yarrr
       # GONER features wrt &complace:
        &Gstaci (stack-unwindable environment variables)
         helps &com find a -seven to be put into
          not A^^c&complace dependent, but is sync
        &comlesslogs watch for things calling &log as opposed to &com
         and shove them into a &com once &complace done()
      then does:
       inner main loop, eg fi&test_Attention,A&step
       various &com are logged, eg fi&Abelieve:
        &com,$t="Q",$s={el,c:Q.c,sc:Q.sc,belN},$c={}
         see w:Fish / Story
         it makes a -log
          &log,t,s,c makes $D-log
           D.t = $t+'-'+serial per @Ying%Outlog/*
           Dc&s = $t
           sc = says:$t,...$s,(node:Rc&s)?
            is &bracki to D (not ex() to D.sc)
           ex(D.c,$c)
         input to This/-Eight...-Log
          maybe many, per A^^c&complace found
      we do nothing with Dy&A
     anyway
      &complace will just &openEight
      &com will ++@six-Log
    =cut
    A.h.sixc = 'expectλ,first_truest'
    $hA = A
    $h = A.h.o('Log')
    
    # < avail through A.h.o
    # This context (~~ &supedome) to R:Run
    $oThis = s => me&Risc,R,'This/'+s
    # the one %%Erefc
    $Erefc = s => oThis(s+'%%Erefc 11')
    
  // 0.9 &Ay test with sketch of &com -log -> This...-Log
    # each &complace opens an -Eight for &com to i *-Eight...-Log
    #    #code: the "to" in this sentence is necessary or it means:
    #    #  during &com doing i ..., a &complace is opened
    # on init, found ^^c&complanet
    #    patches inner **/c&complaces through to it
    #     so it neednt always be via A^^
    1 and 0
    (&{
    $A = fi&Atopleast
    A.4 = A
    A.1 = A
    # imagine this is This**
    #  which you i via A^^c&complanet()
    #  via A^^&complace() which deals -Eights
    # < what happens to empty -Eights?
    4c&This = {}
    4c&complanet = &Vt{
        # Vc&complace becoming
        $Eight = 4c&This[t] ||= []
        return Eight
    }
    
   // place comment
    # this is &complace setting up on an A
    $place = &At{
        $p = me&Ayu,A,'',{c:'complanet'}
        !p and debugger
        if (pc&complace && !pc&complanet) {
            # < proxy our -Eights through a &complace ?
            #   via g.news/Eight/$D
            #    ie pile up intention to write things down
            #   it does the further ^^ ?
        }
        
        # this is &openEight, or A.h.o
        $Eight = pc&complanet(A,t)
        
        Ac&complace = &VdDg{
            # tell of planet/place/$D
            # sync message into This**
            Eight.push(D.t)
            
            ahk(g,['placed'],A)
            # no more complaces need to be told
            # < depends on the message's freak-factor
            A.4 == A and g.satisfied ||= spant('on',t,A.t)
            V != A and debugger
            # < return the -Log for this -log
            #   it may have %RX for us
            return Cye([slant(t,D.t),1])
        }
    }
    # is &com, -> &complace(D,g)
    $comment = &t{
        # -log
        $D = Cye([t,1])
        $g = {}
        
        $Ayg = me&Ay,A,'^^..1^^',{c:'complace'} (&sd{

            $Log = sc&complace(s,d,D,g)
            ahk(g,['vented'],Log.t)

            # when no more &complace is sought
            g.satisfied and d.not = 'done'
        })
        # &openEight i serialises dup six.t += i++
        h.hat('Ay climber',{Ayg,g,This:4c&This},'dl:2')
    }
   // land
    A = fi&Atsomewhere,A,'Corn'
        A.3 = A.1 = A
        place(A,'at the top')
        A = fi&Atsomewhere,A,'field'
        place(A,'unseen')
    
        A = fi&Atsomewhere,A,'Space'
        # the previous different .1, not necessarily .3
        A.2 = A.up
        A.3 = A.1 = A
        place(A,'onSpace')
        A = fi&Atsomewhere,A,'ship'
        A = fi&Atsomewhere,A,'see'
        place(A,'onsee')
        A = fi&Atsomewhere,A.up,'remark'
        place(A,'onremark')
        # < visit immediacy
        A = fi&Atsomewhere,A,'da'
        place(A,'onda')
    
    comment("TheD")
    comment("Another")
    })()
  
  // 1
    
    $Fish = me&Fishliver
    Fish(&AV{
        # sample these this once
        A&oftserve = &scqd{
            (a&oftquest||=[]).push({s,c,q,d})
        }
        fi&test_Attention,A&step
    })
    
    # < mark these -Eight skip? is a -Lab quality immersed in Ness**.c
  // 1.1 Erefc_siblingity
    # see &Ereflookup / so prefer closer... unless in a continuous blob
    # o %%Erefc on a recent -Log/...
    #  was pointing deeper than it should, looks like less up
    h = A.h.o('Erefc_siblingity')
    
    $gots = &Erefc,{
        !Erefc and return "MISS"
        $got = Erefc.got
        $so = got.map(g => g.tp + (Erefc.any == g ? " <=" : ""))
        # see &Eref* / =Erefc
        # g.* E**, who we are at either end
        so.unshift( me&Rnodepath,Erefc.R +" =>" )
        return so
    }
    
    # related? sporatic yarrr%%node Eref '^' ?
        # < the first %%node says '^'
        #  < sometimes. after throw midway somewhere?
        $Runc = Erefc('A:least/5/1//-Log/0/node')
        h.hat("and the initial log:yarrr's Erefs to n:Run'",gots(Runc))
 
    # %%Erefc on the A:least/5/4/-Log/0/A/4/4
    # GONE, -vat doesnt look into A.4 anymore: 3f5e9259ed86d5
    Erefc('A:least/5/4//-Log/0/A/4/4') and debugger
    #  a reconstruction follows
    if (0) {
        #    it points to        5/3/-Log/0/A/4
        #     last sighting of A:least
        #    /c|sc - point to    5/1/-Log/0/A/c|sc
        #     only time A:least is open
        #    /4 - points back to '^'
        #    /y - points might point to /4 instead of just '^'
        #     deeper than it should, looks like less up
        #     see &Ereflookup / so prefer closer... unless in a continuous blob
        #   was also before:
        #    when the &complace had A:Middle,
        #     it was out-of-time able to see it at:
        #      Log-Eight...A/c/Client/up
        #       which is an odd choice, given ...A/c/Middle is there
        $A44 = Erefc('A:least/5/4//-Log/0/A/4/4')
        # I am
        $A4y = Erefc('A:least/5/4//-Log/0/A/4/y')

        # can see Ec&b sometimes
        ahk(A4y,'distanced',tax({},A4y,'E,e'))
        h.Bow("last log:Ath-not's A.4...",{
            ".4 not bad": gots(A44),
            ".y was too deep": gots(A4y),
            " .y Erefc, E|e distanced": A4y,
        },'dl:3')

        me&dumpadepthmap
    }
    # a simple picture of Erefs
        #  '^' for /aya/ is correct
        #  '^/aya' for /de/ is wrong
        $a = {}
        a.aya = a
        a.de = a
        $b = {a,le:a}
        h.hat("and this is this",b)
        h.hat(" with a later look at",{la:a,loose:a})
   
S 6 Ath
    # $W = &Ath, a &t prototype
    #  simulate async A&oftserve to /believe/ in things
    A.h.sixc = 'expectλ,first_truest'
    $h = A.h.o('Ath')
    $Fish = me&Fishliver
    # based on &test_Attention, with less noise
    $oft = c => pex({of:'w',t:'reandom'},c)
    Fish("only more+loading",&AV{
        # for the fi&Athinger elvising handler to work in
        $Ag = A&thinger = fi&Atsomewhere,A,'loading'
        # the client
        $Am = fi&Atsomewhere,A,'more'
        # busy up for the -anA styling
        #  these dont show %Ctitle because
        #   &Topping_2 mutes that if %toomuch%indim
        Am.flup = Ag
        Am.moto = Am
        #$got = fi&Ath,Am,oft()
    })
    me&AhWombmod,-1
   // Eref: 0 1/y/4=up
    # lets have a closer look at those refs
    # not these, that were misctoy%impl where r=0:
    $va = me&oThis,R ('Ath/6/only more+loading//-hat/0 1')
    $look = me&ioty,va .map(&e{ return {e,r:ey&R} })
    h.hat("0 1 4=up were qua.impl", look, 'dl:1')
    
    # onto /y/(4|up)
    $two = map(
        (v,t) => me&oThis,R ('Ath/6/only more+loading//-hat/0 1/y/'+t,'Eref'),
        peel('4,up')
    )
    $gots = &Erefc,{
        !Erefc and return "MISS"
        $got = Erefc.got
        $so = got.map(g => g.tp + (Erefc.any == g ? " <=" : ""))
        # see &Eref* / =Erefc
        # g.* E**, who we are at either end
        so.unshift( me&Rnodepath,Erefc.R +" =>" )
        return so
    }
    h.hat("0 1 y 4=up Erefs", map(Erefc => gots(Erefc), two))
    h.Fez("0 1 y up Erefc", two.up)
    # here's the 4 R, seen by the up Eref
    #  &Rlimiti_ref_lookfor is weighing up Erefc.got/* 
    #  see: note we only r%$magicword += n the first
    #   in this case %%limit,Erefc,toomuch triggers r%limit += n
    #    < brack should be more easily visible
    #       opening -Bet click:ref-sym:♲ works
    #    < and all these things should be in -seven+
    #       for this sidetrack,  0 0/y, then these things
    #  it also has %asfollows,
    #   so &Eref_goodpishow checks for famous self-compromising Rsc
    h.Fez("0 1 y up Erefc.self.n", two.up.self.n)
    
   // D**: 0 1/y
    # < //-hat/0 1/y/up should Eref //-hat/0 again
    #    over //-hat/0 1/y/4
    $e = me&oThis,R ('Ath/6/only more+loading//-hat/0 1/y')
    
    #    $t = Epy&thing ||= Cye([Ep.t,2])
    #    me&Linets,t,e,d
    
    # a lot of RX/ignore/* == TX/t/match/*
    h.Fez("0 1 y itself", e)
    h.hat("0 1 y normal are qua.impl", me&ioty,e .map(&e{ return {e,r:ey&R} }), 'dl:1')
    
    # < hat $t should be airtight: allow /, %stuff, -pi in titles
    # < Push fails to reself|DIY?
    # < notice 2GB processes and similar
    # phi = 1.618
    # anyway, the Story goes:
    
    # fi&test_Attention,2
    
    
    # <<<
    
    #  < This** wants a new sense of time: for all -six?
    #     per -six created in a different -seven to the last one
    #     so many -seven*/-six* can be created frantically
    #      yet 1/4-six knows it came right before 2/2-six
    # be %string-wobs
    #  < further The development there (for Thens)
    #     can it be bound to sheer time like This is (will be)
    #     separating %TX change until such is
    
    # < @is: check which of w:The / &honly etc are used anywhere
    # < W storage that $t/(W|J)/$t (or is it I|O?)
    
    # < This->Nine robusticised, two brittles:
    #  try reself if after Push
    #   also if Ness new, reset and RunStep once
    #  < switching h.hat<->h.Bow
    #      requires reset (@JRom tt:reset)
    #     as RE/E pile up in This** ?
    #      for some reason not escaping &forgetRunStep
    #  < adding -Eight, after Push
    #      requires reself (@Fest tt:Leave)
    #     ninec&gobble seems busted
    #      splits news to new Ness
    #     only after Push
    # < cm: C+[ indent 1 space
    # < cm: if-and flipper
    # < cm: indent within a blob of #
    # < cm: pulling This into Code or vise-versa
    
    
