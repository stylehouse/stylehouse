# A emixer!!!!3131!!!
$fi = self.fi ||= {}
# &Xio uses mediums and with i|o|etc
fi.Xios ||= {}
 
 // The Fish
    =pod
     see also 'future of sleep: Doming'
      A:n arrive, $At with $Ct
       maintaining a path to things
        through osc - which may rename|route them
         eg e:more@BakedGoods -> e:again@Bakery
      A:J hold A, wait completion
       in J&X, the last 5-min|30 changes hang in $At+$sip etc,
        including (up to 15?) A for the future
        these might redo from $C pointers
         discarding unfinished A each time, until done sync
          eg so A.4 &t loads can get back to it,
           yet having fresh A:n experience when ready
        wanting to merge together e**?
        may be mutex if changing same data
         same data: probably grouped by $n
         return to senders to ffwd if ~situation since e
       
       they A.1.up = A.2, a parallel A fall
       the up-most A to est A.1 = someJ is JA, usu A:n c&J|W
        osc puts J%top = C&A:n
       so:
        &t of=res,t=thing
         comes from a $dome, etc of some J&X..$A
       giving us pointers to relive for new &t input
        (opo. more &t input, an interation)
       causing osc to zip things together efficiently
      
      so using this to trace &t
       sidenote: species of &t:
         &Jt t=given looks around A^^<3, also of:J ($Jt?), or die
          roughly equivalent to &Jx, with a name patchbay
       what you &t (&Ath)
        must relay onto A.1-5 if from|to A.5
        eg 1c&X/$dome/$Ct/$pip+$At/..$t/$A
         $dome|$Ct may none-many, any order
          $dome is basically a C that melts
           merging insides to outsides
          $Ct name C we can focus on, merge into $dome
           climbing through A:n with c&e is like %tunneling
            but they can also ~wake up on the way
            so we may be able to re-A:n deeply
             with an early copy of the C
             or simply by the enclosing Y:n regenerating many A:n,
              which we then focus on a $Ct of
               as e:points do now:
                for a trail of $Ct-ish up to the last J
                 or was it last W? think so. not very fine
                R are a lot more controlled,
                 their "early copy of the C" are &reaw R.sc gk
                  to copy from a completed R to a new one
            the A:n**
             coming together, recycled or new
             ~wake up to do tractioning
              eg updating group tallies when A:n/** added to
             which leads into osc
              which reapplies the same theories
         $pip+$At tries to get to an A
          may be for interests sake
           which turns out to be important for debug
          may be warn if changing
           perhaps we dont understand what we are doing
            eg bunch of the A we want to use didnt turn up in Y&X.aye
            and should dev more $dome-ish A-separation
          usu redo deepest .../$Ct**
           may be taught to find $Ct/...$etc**,
           supposing its pipe to osc is usable
            ie we may use the ground for nothing but namespace
             taking no further work
              unless you are the particular $etc
             then patch everything into
              a directed reimagining (osc)
        
        usu redo deepest .../$Ct**
          then re-$dome
           may have A:n process to carry on,
            which would be able to osc%defer
          which leads into osc
           which reapplies the same theories
           re-osc 1
        
        osc%defer
          A:n** unable to complete
           may be piled up as such
           on a micro-version osc
            to make a package of %%wants etc
            to keep winding up and eventually having completed
            to try to make happen with another potential osc somewhere
          "happen with"
           is an important nature of the osc
           harvested inputs can be gone through
           in patterns across multiple osc
           as suggested by io exp:
            eg i my/$work y { &embed,$yin,$yang }:work
               o some/:yin o the/:yang
             can have osc doing the lowlevels in tandem,
              may stop|explode at one of the $yang,
               and everything can save there
                noting a cursor in exp to resume from
                 another, linear|next-ward type of A:n** chasing
                 could have either end not support that cursor
                  and simulate the selection with doming sense
                   avoiding extra &embed and recycling the previous $work,
                    supposing an entire i my/... must happen
                     ie no recoverable state to continue
                    eg things doing in the garden
                     eventually need doing again
               since osc can control itself
                and make recipes for that control
                 to satisfy having unfinished work
        
        so 1c&X/$dome/$Ct/$pip+$At/..$t/$A
         are the parts we can redo
         pick a $target to tunnel to
          usu a C
           tending to redo all the A within a C
            is what people will expect
          deepers would %ein to capture our e:tention specifically
           eg overlay controls are $Ct-arranged and qua-inducing
            affecting other $C|A.** they would know about
             so we could go watch the information arrive at the place
             eg how %Te-ing a %dl (depth limit), applied at a high level
              should cut the stack of cards a certain way
               something we want to study as sequencing $n...
         and do everything from there
         continuing osc
          to bring together the arts
          
         you may get pointing to a part of an A&ip: $pip
          hopefully stablising under your $target=C
           ie determinite
          or able to be selected for rewind|continue|forkability
           eg realising $At=only as %Te affects them all,
            in place, the A seek the point of themselves to redo
             eg A have $dome in stages along a transform
              so if it then knows $dome, they may be pointable
               since $dome implies forkability around it...
              yet tending to redo all the A within a C
               is what people will expect
          $At clashing after $pip..$t match is warn?
           being indeterminite
           perhaps decomposing too far how to Act
            needing things brought on by an enclosing activity
             which we tunneled through
           should show up while building e-able processes
            and the missing links must be included somehow
            eg as $dome pipe, which may take from the V-layer
             
           clue potential lack of $dome-ish around A** things
            ie pushing bamboo into a system wobbly at the edge
           as if redoing a part of thing to generate it,
            maybe missing separation of what-is to a specific us
            so as to make cannonical domings
            for a cannonical doming of 
      
      V
          V-layer
           refers to the entire network of X at time-1
            that it made and finished the last time
           for recycling sleeping things from
            finding yourselves in
            transfiguring X-networked truth systems
          V is the X&A&b&X
            ie it is the space your A&b is in
           their new life (X) builds up
           eventually supplanting it somewhere as "now" (1s&top&A&X etc)
            which immediately becomes "then" (A&V to you) when you redo
           has more or less of the same stuff as X now

          V below here in this write means osc,
           an agent of history collapsing down to a point
           a book keeper
           the outward relating A:n&X into A:osc&X
            A:n&V was only beginning to suspect
           confuse
            should The Fish be <>< ?
        
      The Fish:
          begin, middle, end acts:
           A1 reads many
           V  relates things back to one
           A2 writes many

          being able to patch bits of A1 through V,
           causing osc to zip things together efficiently
            by knowing the occasional border-crossing:
             eg $n:something%%nearby=$n:other
            or bounding into domes into processes:
             eg all %of=such -> W:of encoder
           domes in, domes out
           giving them three chances to sleep:
             (sleep = avoid unnecessary processing)
            A1 - may be the same
            V  - may be only changing what we ignore
            A2 - may be the same
          anyway,
           we would then have taken that input
           and produced no new output
       
       A I did - usu another tail, making A:n**
       V there is - matter affected
       A that was - matter effected
        eg lv-mode of .js encoding
         with wholly replacing C%of that changed
          < say which previous versions it replaces
            so catching up from lv1, when you see lv45
            can skip intermediate patching that was redone since
             if eg changing mostly the same C%of over and over
              can be lv1+lv45
              or maybe if C:other%of was changing too,
               lv1+lv33+lv45
                lv33 having the latest version of C:other%of
             these fugues of shapely dynamism
              reveal ideal page boundaries
               to be imposed after the fact,
               to make a log break into bursts of activity
      
       it takes input
       figures out what to do
       outputs what is
       
      anyway
        no I, only fi
        serve &t
          which means:
           lineating some A, that keep looking the thing up
           telling other A when thing changes
           whole loop of that, using only things in here...
        output benice:
         a list of A in Cit...
        S
    =cut
   
 // f
    self.isA = &A{
        return A && A.c && A.sc
            && (A.y && A.y.A == A || A.y == A)
    }
    self.isJ = &J{
        return isA(J) && J.1 == J
    }
    self.mustC = &s{
        !isC(s) and throw "!C"
        return s
    }
    # < hakv() value changer, hakk() key changer
    #$disc = hashkv(haks(c).map(k => [k,dis(s[k])]))
    # < rename ksaf ksat?
    # all values set to 1
    self.allone = &sc{
        !isob(s) and throw "allone!hash"
        c and throw "< ksaf"
        return hashkv(haks(s))
    }
    # < make uniq()
    self.uniqe = &Nc{
        c ||= {}
        isfu(c) and c.y = c
        c.map and c.y = c.map
        arrefs(c)
        each iv N {
            $bit = c.y ? c.y (v) : v
            c.addref(bit,v)
        }
        # 
        # in order of appearance
        # {bit:[v+]+} - must iskeyish(bit)
        return c.map ? hashkv(c.ref.map((l,i) => [c.refs[i],l]))
            # [[v+]+]
            : c.all ? c.ref
            # reduced to first: [v+]
            : c.ref.map(l => l[0])
    }
    # see 'arrefs'
    # organise many v by bit (may be object)
    self.arrefs = &c{
        c ||= {}
        c.ref = []
        c.refs = []
        c.addref = &bit,v{
            $mi = c.refs.indexOf(bit)
            mi < 0 and $first = 1; mi = c.refs.push(bit)-1
            $l = c.ref[mi] ||= []
            l.push(v)
            return first
        }
        c.maprefs = &y{
            c.ref.map((l,i) => y(c.refs[i],l))
        }
        return c
    }
 
// A
 
 // &A
    =pod
     just creation
     whatever it takes to load the rest of the fish
      there is a microfish inside:
       &Xsim co prototype &Xio
        to merge when both testable
     plenty of let go
     runny types of A|C
     &A create+wind?
       if too other to wind
        create to merge later (e)
       
       
       
       widely used self|othering portal:
         A self|other creation|winding
          self - inside the A we are now (V)
          other - outside V**/A or V.1 == A.1
          creation - spawn A
          winding - which &voice to c.ov
         &voices separately?
         args are ...
          &A,Y,{ov:3} - wind another
          &A,{ov:3} - wind self
          &A,{import:1},{ov:3} - wind self
           and acquire A.sc.import?
          &A,3,{t:'floor'} - wind self
           and acquire A&t = $mind_to_voice
          &A,C,'n' - create Cy&A, A&t = 'n'
    =cut
  // &A
    fi.A = &acgtV{
        V ||= A
        !isA(V) and throw "!A"
        $A = ex({},V)
        A.y = A
        A.up = V
        A.c = {}
        A.sc = {}
        
        # incremental
        A&ip = [...(Vc&ip||[])]
        Vc&ipi ||= 0
        A&ip.push(Vc&ipi++)
        A&sip = A&ip.join(' ')
        
        return A
    }
    # make A and arrive $At
    fi.Atsomewhere = &acgtAt{
        A = fi&At,t
        !A.up.up and ac(A.up,'z',A)
        fi&Ariv,{}
        return A
    }
   
  // etc, &J
    fi.Atopleast = &acgt{
        $Y = A
        $A = {t:'top',c:{},sc:{}}
        if (Y) {
            A.7 = Y.7
            #A.4 = Y.4
        }
        A.y = A
        A.top = A
        
        $A = fi&At,'least'
        delete A.up
        A&X = {A}
        # it would usually 
        A&again = &{
            A&V = A&X
            A&X = {A}
        }
        return A
    }
    fi.AtopJ = &acgtAt{
        # make J:Four
        $J = fi&At,t||'Four'
        
        J.1 = J.2 = J.3 = J.4 = J
        A.1 = A.2 = A.3 = A.4 = J
        return J
    }
    
    fi.AtJ = &acgtAt{
        # acquire J:Four...J:$t
        $J = fi&At,t||'Three'
        # have A needing? commit
        return J
    }
   
  // &At, &Ariv, &had Xsim
    # as above with c -> A.t, A.c.*
    # < pronounced acgtivic. extra intellectual suffixualism
    fi.At = &acgtVc{
        !isA(V) and c = V; V = null
        $A = fi&A,V
        isst(c) and c = {t:c}
        c.t and A.t = delete c.t
        ex(A.c,c)
        A&X = {A}
        return A
    }
    # Ac&b = old life
    fi.Ariv = &acgtc{
        $b = fi&had,pex(c,{At:A.t}),{n:A}
        !b and return
        A&b = b
        !bc&X and return
        # V(iew) meaning readonly
        #  may be limiting a plumbed actual last A&X
        #  also may many potential b
        #   waiting for further match
        A&V = bc&X
    }
    # i Y&X/$At/$n:A
    # o Y&V/$At/$n:b
    # < and the plurality of before+now
    #   b may not match only on sequence
    fi.had = &acgtsc{
        $Y = A.up
        
        $Neu =
        fi&Xsim,Y,'X',[],s,c
        fi&Xsim,A,'X',['had'],s,c
        $Nld =
        fi&Xsim,Y,'V',[],s,{}
        
        $sequence = Neu.length - 1
        $b = Nld[sequence]
        return b
    }
  
 // &Xsim - proto &Xio
  
  // Q
   // Q id
    =pod
     $Q made by oftserve(), see Attention
      usu wants (to become) A/$oft/believe/...$Q
      structure mirrors around
      $P (on A:loading) are similar to $Q
       use &AoQ etc, separate into $Q when ready
     they &elvis -> &Athinger
     /asked/...$P requests, decodes, sec
     /believe/...$Q turns up -> &Athinging -> &Aredo
     
     Q becomes a P somewhere if not Proofed enough
     P could carry out a push
     P spread|specifate when +$version, they spread to:
       havex/asked/$src(/$P)/$version(/$P)
     
      P|Q might be only beginning, partly filled out
       P for pieces of speech transmitting
        they may appear from websockets
       Q the whole speech bubble
        interpolation of what was said
     
     &AoQ/&believeoQ
      gets you the latest Q
      given another Q to model eg $oft, 
       havex/believe(/$Q)/$src(/$Q)/$version(/$Q)
        to order $Q over any $src|$version
         certainly over any $version
          so branches ($src) can revert etc
        we are always adding them to the end of a list
         ie always having the latest+best info
          < may not be right, needs a strategy build
            about this phenomenon of last-is-all
      
      and any /$P or /$Q list limits to 10?
     
    =cut
    # &Ath,s,c -> &aQ,s,c -> Q{c:s,sc:c}
    fi.aQ = &acgtcs{
        $Q = Cye([c.t||'?',1,c,s])
        Qy&A = A
        return Q
    }
    # the /believe/... index, wildcard or from Q
    # believe may be another word, eg /asked/...$P
    fi.Qbel = &acgtQq{
        q ||= {}
        $bel = {}
        # /believe|asked/
        bel[q.believe||'believe'] = 1
        # /$src/
        bel.src = Q ? Qs&src : 1
        !bel.src and throw "Q!%src"
        if (!q.novers) {
            # /$version/
            bel.version = Q ? fi&Qversion,Q : 1
            !bel.version and throw "Q!version"
        }
        return bel
    }
    # derive a $version
    fi.Qversion = &acgtQ{
        return Qs&vers||Qs&dige
    }
    # see what Q can find, down /asked|believe/...
    #  which it may be already, unless gaining eg $version
    #   they would have their previous namespace on Ps&O (once)
    fi.Qubsist = &acgtAQq{
        # for A:loading, ensure an $oft/$n, for &AoQ/&Xsomp to join off
        # for A:least** this is an A:n from &Ath/&wantbelieve
        $fore = fi&Xsimp,A,Q.c
        !hak(fore.z) and fi&Xsimp,A,Q.c,{n:A}
        
        $QN = fi&AoQ,A,Q,q
        $O
        QN.map(&r{
            r.n != A and debugger
            O and debugger
            $bel = r.N.slice(-1)[0]
            bel and O = bel.n
        })
        return O
    }
   
   // Q io
    fi.AoQ = &acgtAQq{
        q ||= {}
        $oftN = fi&Xsomp,A,Q.c,{},q
        # < shades of uniq() by .n
        #   they may|not have believe/...
        #   no telling which of/t/n were there
        #    before|after of/t/believe/... was attached
        #     might x/$near:n/believe
        #      a x/$n-aligned map of other places with /$n
        #      which would reveal that one of these was async
        oftN = uniqe(oftN, xc => xc.n)
        # < notice if uniq by r.x
        # if we dont uniq by r.n,
        #  we find the same /believe... for each (two) of/t/n
        oftN.map(&xc,{
            # if got via &Ath, these xc.n=Q
            xc.N = fi&believeoQ,xc.x,0,{rows:1},q
        })
        return oftN
    }
    # o /believe.../$Q
    # look up believe/src/version/$Q
    # sort by believe/$Q, usu return latest one
    # see Attendance: 'to order $Q over any $src|$version'
    fi.believeoQ = &acgtxscq{
        q ||= {}
        s ||= fi&Qbel,0,q
        c ||= {}
        # wildcarding hash slice, usu believe:1 anyway
        $first = hashkv(haks(s)[0])
        
        fi&bug,'bel-somp' and $un = fi&ibug,'somp'
            $N = fi&Xsomp,x,s,{norder:first}
        un && un()
        
        c.rows and return N
        $xc = N.pop()
        c.row and return xc
        # Q
        return xc.n
    }
    
    fi.AiQ = &acgtAQq{
        q ||= {}
        # wantedness /$of+$t
        $oftx = fi&Xsimp,A,Q.c,{},q
        # become latest /believe/.../$Q
        $belx = fi&believeiQ,oftx,0,Q,q
    }
    # i /believe/$Q/.../$Q
    fi.believeiQ = &acgtxsQq{
        q ||= {}
        s ||= fi&Qbel,Q,q
        if (hak(s) > 1) {
            # i /believe/$Q - asserts overall ordering
            $first = sex({},s,haks(s)[0])
            fi&Xsimp,x,first,{n:Q}
        }
        # i /believe.../$Q 
        return fi&Xsimp,x,s,{n:Q}
    }
   
  // Xsomp middle
    # 1-spheres in X..
    fi.Xsimp = &acgtXscq{
        c ||= {}
        # X..x..x..x is long,
        #  X..x + X..x + X..x is wide
        c.long = 1
        # without t=[], X.$k as each s.$k
        $x = fi&Xsim,X,'X',[],s,c,q
        return x
    }
    # rowing arks, returns [r+]
    #  simpler (no arrefs, qas...) prototype of Xio
    # < rename xc r, have r.sc for arkv, rc&io=o
    fi.Xsomp = &acgtXscq{
        # shared by &Xsim, which does many s simple for each bit of s.*
        c ||= {}
        # &Xsim returns vx form, containing $v globbed
        # see also c.wild per s.*, also causes this form if so
        c.simvx = 1
        c.long = 1
        q ||= {}
        $N = isar(X) ? X : [X]
        $arkN = [{}]
        $ks = haks(s)
        while (ks.length) {
            $k = ks.shift()
            $v = s [k]
            v == 1 and c.wild = k
            else delete c.wild
            $M = []
            $arkM = []
            each ix N {
                $arks = arkN[i]
                !arks and debugger
                # each possible x continued along path
                fi&bug,'somp' and debugger
                # vx/$t=$k|$ref/x
                $vx = fi&Xsim,x,'X',[],hashkv(k,v),c,q
                # < may not?
                !vx and continue
                # &Xsim c.wild shortcut-returns: vx/$v/$x
                # vx form provides values along the &Xsomp s path
                if (!c.wild && !c.simvx) {
                    debugger
                    # < GOING
                    # a specific thing was provided to &Xsim
                    # meaning it returned only x, not v/x
                    #  so we figure what v would have been,
                    # < &Xsim return type more like &Xsomp
                    $ref = x[k+'s']
                    if (ref) {
                        # make v the index of thing
                        $vi = ref.indexOf(v)
                        vi < 0 and debugger
                        v = vi
                    }
                    # must be keyish v
                    vx = hashkv(v,vx)
                }
                # always X|x.$k(.$v=$x)+
                each v,inx vx {
                    # < rename arkv ax
                    # < enforce /$n-having along paths at ks.length
                    #   see q.n, multi-&Xsomp fi&xzand
                    # ark acquires k:v
                    $arkv = ex({},arks)
                    # arks (columns) statement unique
                    hak(arkv,k) and debugger
                    # vx doesn't convey its index amongst all $v here:
                    $ref = inx[k+'s']
                    if (ref) {
                        # refs sequenced deduplicatively, see &Xsim c.array
                        !num(v) and debugger
                        arkv[k+'_i'] = v
                        arkv[k] = ref[v]
                    }
                    else {
                        arkv[k] = v
                    }
                    # also each x on the way
                    arkv.arkx = ex({},arks.arkx||{})
                    arkv.arkx[k] = inx
                    M.push(inx)
                    arkM.push(arkv)
                }
            }
            # tos become froms
            N = M
            arkN = arkM
            !N.length and return []
        }
        
        # arks + final x from eg x/$src/$version(/$n)?
        $M = []
        each ix N {
            # < rename arkv ax
            $arkx = arkN[i]
            !arkx and debugger
            each in x.z {
                # last &Xsomp $s-hop
                # a b c
                # z x y
                # a multi-&Xsomp fi&xzand
                #  to &Xsomp within a &Xsomp per-$n iteration
                #   when you have a $n:step,
                #   then &Xsomp $step/$ref, meaning refs from $n
                # see &brackstract &Xsomp -log/$k=step/$ref
                q.n && n != q.n and continue
                # eg {src,version,n,x}+
                $xc = ex({},arkx,{n,x})
                M.push(xc)
            }
        }
        N = M
        
        # order the single expanse of rows
        c.norder and N = fi&Nxcnorder,N,c
        
        return N
    }
    # order a single expanse of rows
    #  higher(/$n)/$over/$other/$n (over turns out to mean later)
    # < rename xc r, so Nr?
    fi.Nxcnorder = &acgtNc{
        !c.norder and throw "!c.norder"
        $M = []
        # each believe (xords) has many /... (xordz)
        $xords = []
        $xordz = []
        each kv c.norder {
            each i,xc N {
                $xord = xc.arkx[k]
                !xord and continue
                $xi = xords.indexOf(xord)
                xi < 0 and xi = xords.push(xord)
                xordz[xi] ||= []
                xordz[xi].push(xc)
            }
        }
        !hak(xords) and throw "!norder"
        each ix xords {
            # in the order of believe/$n
            
            $norder = (x.z||[]).slice().reverse()
            $xcorder = (xordz[i]||[]).slice().reverse()
            $inside = []
            each in norder {
                each i,xc xcorder {
                    # suck out believe/.../$n rows
                    xc.n != n and continue
                    inside.push(xc)
                }
            }
            # starts from the end|newest, which matter more
            each i,xc inside {
                M.includes(xc) and throw "test multiple q.norder.*"
                M.unshift(xc)
            }
        }
        # any not in believe/$n, meaning very historic?
        #  see $n...$n gc
        N.filter(xc => !M.includes(xc)).reverse()
            .map(xc => M.unshift(xc))
        return M
    }
    
  // Xsim back
    # 2-sphere, in k='X', named|after t=[...]
    fi.XfromA = &acgtXk{
        X = X.c[k] ||= {A:X}
        return X
    }
    fi.Xsim = &acgtXktscq{
        isA(X) and X = fi&XfromA,X,k
        c ||= {}
        $N = []
        $lak = haks(s).slice(-1)[0]
        each kv s {
            
            $ok = c.array || typeof v == 'string' || typeof v == 'number'
            !ok and throw "Xsim!string:",k,s,c
            # long builds x..x
            $hs = c.long && x || X
            $ux = hs
            # t keys X.[ex.tra.lev.els]...$s/
            each il t {
                hs = hs[l] ||= {}
            }
            # X|x.had is usually here, is arks for &qis:
            #  to make it seem: x.had.have = {k,v}
            #   grepping for $n in: x.had.have.k.v=x
            #q and hs[k] = v; continue
            $vs = hs[k] ||= (c.array ? [] : {})
            # everything mode happens to be in vx form, see &Xsomp
            c.wild == k and return vs
            # otherwise $v will have to be indexed
            # < el:8 not creating empties
            if (c.array) {
                # lifted from &qis xq.array
                # index values in an array
                $refs = hs[k+'s'] ||= []
                $vi = refs.indexOf(v)
                vi < 0 and vi = refs.push(v)-1
                v = vi
            }
            $x = vs[v] ||= {}
            x.z ||= []
            x.up ||= ux
            x.up != ux and throw "xup!X"
            if (c.simvx) {
                lak != k and throw "vx form limited to 1 &Xsim s.*"
                return hashkv(v,x)
            }
            # long puts only the final ..x/$n
            c.long && lak != k and continue
            c.n and x.z.push(c.n)
            N.push(x)
        }
        c.long && N.length > 1 and debugger
        c.long and return N[0]
        # $n:A at everything we s.*
        # < used for brack
        return fi&xzand,N
    }
    # union /$n (x.z=[$n+])
    fi.xzand = &acgtN{
        $M = []
        each ix N {
            each ii,v x.z {
                others: if ('others') {
                    each iii,xn N {
                        !xn.z.includes(v) and break others
                    }
                    # in all the others
                    !M.includes(v) and M.push(v)
                }
            }
            # its in all the others
        }
        return M
    }
 
 // < Attention
    =pod
     o A/$oft/believe/$Q
      Q may be more specific ie /$src/$version/$Q
        such qualified Q will never change, except:
         to be marked %ood={src,version} ?
          if it loses the /believe/$Q spot
           if Q made into W maps, leading users
           they would ask for latest Q+src
           and consider the %ood version
            which was the next thing to happen
            in the situation we were interested in
         to re-decode Qc&s=C**
     
     imports across slope
      i A.up/$oft/$n=A - the want of $oft
      i A/$oft/believe/.../$Q - believed from A.up
     
     atop the slope is creation by A:loading
      5/$oft/asked/.../$P - proofs from peers
      5/$oft/believe/.../$Q - fully ready items
       could say nothing, Ps&el=9?
       are put into A:least
        since A:loading isnt on the &Ath climb
     
     see Q id
     see Coffle '#I'
    =cut
   // &Ath front
    fi.Ath = &acgtAscq{
        c ||= {}
        q ||= {}
        $xc = fi&wantbelieve,A,s,c,q
        
        if (!xc) {
            fi&com,"Ath-not",{s,c,q}
        }
        else {
            # have the answer
            A&Athx = xc
            $Q = xc.n
            !isC(Q) and debugger
            fi&com,"Ath",{s,c,q,Q}
            return Q
        }
    }
    # over sloper $d (dip)
    # < rebuild inside out in &Ath, with me.cby()?
    fi.wantbelieve = &acgtAscqd{
        c ||= {}
        q ||= {}
        d ||= {}
        $n = d.A || A
        d.A = A
        # s is a Q.c.* set, eg $of+$t ($oft)
        #  init. Qx has only demand for a Q:
        # dup i /$n, next lower|est A:n**
        $Qx = fi&Xsimp,A,s,{n}
        # < uniq map of $ofts etc at X.th.'of+t'/$n=Qx
        #    then you could X.of.*.t.*=Qx join it
        
        # /believe/... as a wildcard
        # q.believe='anything' makes /anything/
        #  may be /contentions/ or so? locking in Qx space
        $beliefs = fi&Qbel,0,q
        $wants = ex({},beliefs)
        # c may specify some ...
        # < ifs, wheres
        # < T belief-lockin may reuse V/.../believe...
        sex(wants,c,beliefs)
        # o /believe/...[-1]/$Q
        #  later greater
        $xc = fi&believeoQ,Qx,wants,{row:1}
        if (!xc) {
            # go further upwards
            A.up and xc = fi&wantbelieve,A.up,s,c,q,{A,d}
            else {
                # gateway, or sync read (as A:P) eg localStorage
                xc = Ac&oftserve(s,c,q,d)
            }
            if (xc && !q.cas) {
                # thing brung
                # threading back down to ..A:n
                # /believe/... pseudo-xc returned
                #  towed in by the resyncing A:more
                # es is xc is a rowing, what we would have
                $es = sex({},xc,beliefs)
                $Q = xc.n
                es.x = fi&believeiQ,Qx,es,Q
                es.n = Q
                xc = es
            }
        }
        return xc
    }
    fi.isAthinger = &acgt{
        # try get something
        A&oftserve = &scqd{
            # is &Ath,s,c,q after d climb
            $Ac = {}
            $Qs = {}
            if (hak(c)) {
                # c.* divides &Athinger batches, might .el
                Ac = ex({},c)
                # c.* might also be believables, eg spec $version
                tax(Qs,Ac,fi&Qbel,0,q)
            }
            # Q to find P(roof), then be $Q
            $Q = fi&aQ,s,Qs
            fi&elvis,{fi:'Athinger',A,N:[Q],c:Ac}
        }
    }
   
   // Attendance as &elvising handlers
    =pod
     as &elvising handlers
      N merge for same c, see &emergible
      no use of c yet?
       it could have cv|ov, prioritise lower per A
     
     so far much driven to|by Q from &Ath:
     so A:most &Ath A:least &oftserve... A:loading
      then comes back in reverse
     
     &Athinger,A,N[Q->P],c
      P lifecycle before Q
      based on Q, about forming a Q
       
     &Amess,A,N[P],c
      making requests|responses for a thing
       &oftserve may send requests sync
        or via 4s&todo[], which is like:
       or
        some xhr.done() -> G.and[C] -> G.tick()
      
     &Athinging,A,N[Q],c
      make $R lv about ~Q over A**
       c&n=A**
       c&el=8 above ~
       c&el=6 with ~ as %QN=[Q+] affected
        < %QN mirror %ON=[O+] we last believed
          the bubble no longer being spoken
      to &Aredo
       c&el=7 once %QN effected and A commit
        which might release a bunch more ~Q on top of this
     
     &Aredo,A,N[R],c
      $R-edo sessions, big messy rollouts
       each thing, here and there and down the slope
        for a src-connected differable pipe thinging
       that can wander through A:n** applying itself
        being stretched with news before completion
         and present that as loop hazard, etc
      chase ~Q
      in t edges
      # 6
      redo A** 
       just sorta do() each one
        they &Ath, get new Q, etc
       or
        figure out what to dome
         which is just more A**
         that you may divide ~ into
          eg rebuild only the affected Textl chunks
       c&el=7 once %QN effected and A commit
      # 7
      more ~Q
       can happen, merges $R**
        c&el=6<-7 should do the trick
        and %QN|%ON can have multiple revisions of a $Q
         these might be empty so far or not
         the A might want to pick them up
          eg blog|chat scrollback
         the Q might have some way of extending somewhere
          eg %species=3, the last 15 bits of tree: %1,4,5,7?
             %species=7, rotating lv pileup
              %species=8 in both directions
        %ON[Q] may be mocked up
         based on W.5 customs tickets
          eg could begin a %Compiling** with &Aredo from @Gump
      # 8
      so $R**
       is doing A**
        prefering to start+finish things, allowing more ~Q
         where one thing (eg W:SourceMush) completes
          and may push more ~Q to integrate in our travels
         before getting to W:Together, etc
      
         
     
     nearing &elvising:
      go via G.click[0][e+] for fast callback
      also G.click[8] for slow checkup
    =cut
    fi._P = &acgtANc{
        # arrival at various /$P, present an other:
        # /asked/$P - <3 and while waiting
        #   locking P from other interactions til response?
        #  asking any $src already
        # /asked/$src/$P - 2 considers who to ask
        #  asking $src already
        # /asked/$src/$version/$P - 3
        #  is exactly who we purport to become
        #   are we rewinding a branch or something?
        # etc
        #  eg. /show/$time/$P can cursor through %time etc
        #   collecting that distribution
        #   to|from C
        
        # < doing &Athinger, as minds:
        #    as a few types of being merged together
        #   with emergent websocketism, etc.
    }
    fi._S = &acgtANc{
    }
    # on A.4/A:loading, Q seed P to be /asked/ about
    # < multiple P per Q, as in agreement
    fi.Athinger = &acgtANc{
        A&thinger and A = A&thinger
        $Y = A.up
        each iP N {
            # P before Q
            $q = {believe:'asked'}
            # we can push+pull, usu pull:
            # request P +%src
            # response P +%version,string
            #  may keep P-ing for stages of decoding, search...
            #   relating them to each other somehow
            #  finally resolve to an s.P=$P, which becomes:
            # believe -> Q %string,P,src,version
            # ask for it, keep receiving it
            
            if (Py&cv <= 0.1) {
                # < Qc&el and other knowns not for /$oft?
                Ps&string != null and 'isapush'
            }
            elsif (Py&cv == 0.3) {
                # on the response side
                # may be done without %string (/wjs/)
                if (Ps&string != null) {
                    # < a %digs may be supplied via http header etc
                    #   is the version of the source that compiled to this
                    #    ie /ghost/ %dige are /w/ %digs,
                    #     /w/ having compiled and argumented to %dige
                    $dige = dig(Ps&string)
                    Ps&dige != null && Ps&dige != dige and debugger
                    Ps&dige = dige
                    # < decode, get wjs script|function?
                    Ps&act ||= 'decode'
                }
            }
            
            # arrive $P
            # < spool on /asked/$P while asking (cv 3-6)
            #   and centrally at A/t_asked/$oft/$P ?
            Ps&src ||= '1812'
            # the ... acquires $version when possible, eg once +%string
            fi&Qversion,P == null and q.novers = 1
            
            # on itself, a clone of P at the end of last time
            $O = Ps&O
            # in namespace (in A:loading/$oft/asked/.../$P)
            # may On == P
            $On = fi&Qubsist,A,P,q
            if (O) {
                # O clone of P before
                if (!On) {
                    # new naming, as O is
                    # P acquires eg $version
                    Py&cv < 0.3 and debugger
                }
                else {
                    # same naming
                }
            }
            else {
                Py&cv > 0.1 and debugger
                if (!On) {
                    # new P
                }
                else {
                    # new P finds P already
                    #  done or in progress
                    #   want to know it has &elvising active
                    #  rarely happens?
                    #   only while keeping on &t-ing same things prior to async
                    #    then once a /believe/...Q, no &Athinger-ing is required
                    #    ie we are de-duping oftserve(s), until it caches a Q
                    fi&com,"DupP",{On}
                    # drops elvising of P?
                    return
                }
            }
            
            if (On && On != P) {
                $kd = hakd(On.sc,P.sc)
                hak(kd) and fi&com,"OnP",{kd}
                # < same naming sans that we want to push,
                #   we can send trees only, reuse the objects, a la git
            }
            if (O) {
                # what was set by an async handler prior to &elvising back here
                $kd = hakd(O.sc,P.sc)
                hak(kd) and fi&com,"OP",{kd}
            }
            
            On != P and fi&AiQ,A,P,q
            
            if (Py&cv == 0.1) {
                fi&elvis,{fi:'Amess',A,N:[P],c:{}}
            }
            elsif (Py&cv == 0.3) {
                q.novers and debugger
                # -> Q
                $Q = Cye([P.t,1])
                ex(Q.c,P.c)
                each kv P.sc {
                    !isob(v) and Q.sc[k] = v
                }
                sex(Q.sc,P.sc,'Live')
                Qs&P = P
                fi&elvis,{fi:'Abelieve',A,N:[Q],c:{}}
            }
            
            # a clone of P at the end of each time
            Ps&O = Cye(P)
            # < -P prototype S ways with an A:P voice
            $PN = fi&AoQ,A,P,q
            fi&com,"Asked",{PN,P}
        }
    }
    # A:loading messaging
    # < proxy to @Aearch
    # &elvis must be coming back to %Cat sometimes
    fi.Amess = &acgtANc{
        # ! this must not be a for (each) loop, or we ack the same later
        N.map(&P{
            # sent
            Py&cv = 0.2
            $back = &{
                # receive callbacks
                Py&cv = 0.3
                Ps&string = P.t[0] == 'r' ? "yardial" : '3 * 3'
                fi&elvis,{fi:'Athinger',A,N:[P],c:{}}
            }
            0 and back(); return
            $ack = fi&syncopation,{P}
            $delay = 0.3
            P.t[0] == 'r' and delay -= 0.1
            fi&yl,delay (&{ack(back)})
        })
    }  
    # A:loading, Q gathering into /believe/
    fi.Abelieve = &acgtANc{
        A&thinger and A = A&thinger
        $Y = A.up
        each iQ N {
            
            $O = fi&Qubsist,A,Q
            if (O) {
                # can prevent creating identical .../$Q
                #  check ~ Q.sc.* other than src+version
                if (heq(O.sc,Q.sc)) {
                    fi&com,"Qsame",{c:Q.c,sc:Q.sc}
                    return
                }
                else {
                    debugger
                }
            }

            # i A:loading/$of+$t/believe/.../$Q
            fi&AiQ,A,Q

            # o A:least may clue el2|3|8-ness
            # may have current /believe/ of all A:least**
            #  < they gc, domily
            #    recompositing X from X, de-row by inA
            $oftN = fi&AoQ,Y,Q
            $belN = flatten(oftN.map(xc => xc.N))
            # < decide el:8 when Q =~ belN/Q
            $el = !hak(belN) ? 2 : 3
            fi&com,"Q",{el,c:Q.c,sc:Q.sc,belN}

            # i A:least, where it will be believed
            fi&AiQ,Y,Q

            # constitutes a state change for all consuming Q
            fi&elvis,{fi:'Athinging',A:Y,N:[Q],c:{}}
            # and we are called in to update things whenever
        }
    }
    # aft A:loading, on A.4 heading to A:n** for ~Q
    # < almost an &indo user
    fi.Athinging = &acgtVNc{
        c ||= {}
        c.d ||= 1
        # avoids V loops
        c.refs || arrefs(c)
        # starting with V=A.4, finding V/V
        # < J: are A.3, with Q for any A they are working on
        $M = []
        fi&Xsomp,V,{At:1} .map(&r,eye{
            $n = r.n
            $lv = Cye([n.t,1,{n}])
            # < brack reduction: %%V,Vn,Q,Qwas +
            $into = arrefs()
            each iQ N {
                !Qc&of || !Qs&dige and throw "Athinging!Q"
                # < io left outer join
                # wanting of/t, grouping by n
                $oftN = fi&AoQ,n,Q
                !hak(oftN) and continue
                
                
                each i,oft oftN {
                    $n = oft.n
                    
                    # oft may !/believe/ yet, wrt Q el<3?
                    # assuming only latest /believe/ is in use
                    # < J: recreating and merging A|X
                    $la = oft.N.slice(-1)[0]
                    if (la) {
                        $Qwas = la.n
                        heq(Qwas.sc,Q.sc) and continue
                    }
                    
                    into.addref(n,Q)
                }
                #$belN = oftN.map(xc => xc.N.slice(-1)[0])
                #me&zu,"Mightbe"+eye,{r,n:r.n,oftN,belN,Q}
            }
            into.maprefs(&n,QN{
                # they might be for V or V/V
                $lvn = n == r.n ? lv : Cye([n.t,1,{n}])
                lvn != lv and ac(lv,'z',lvn)
                QN = uniqe(QN)
                lvns&QN = QN
                lvc&el ||= 8
                lvnc&el = 6
            })
            lvc&el and M.push(lv)
        })
        c.d > 1 and return M
        each i,lv M {
            me&ioty,lv .map(&lvn,{
                $M = fi&Athinging,lvnc&n,lvns&QN,ex({},c,{d:c.d+1})
                M.map(lvnn => ac(lvn,'z',lvnn))
            })
        }
        # these might be Vc&repeat()-able
        # el:6 should wake fully
        # el:7 are above el:6, slep any inputs from an el:6?
        # el:8 probably dont wake
        #fi&com,"Thinging",{Q}
        me&nu,"Athinging",{V,N,M}
    }
   
   // Elvis
    # i 4%todo/...
    fi.elvis = &acgtc{
        c.fi and e = Cye([c.fi,8,c])
        else {
            throw "whate"
        }
        ac(A.4,'todo',e)
        !4c&live and fi&wantfour,e
    }
    # o 4%todo/*
    # called outside anything
    # < A:elvisings transacts off do() we finish
    #   errors|more-async cause a traffic jam
    fi.elvising = &acgt{
        $N = a&todo || []
        fi&emergible,N
        $began = N.slice()
        $known = N.slice()
        each ie began {
            # < mergible ec&N amongst c.*+c.c.*-same
            if (ec&fi) {
                # {fi:'Athinging',A:Y,N:[Q],c:{}}
                fi&com,'elvising',{e}
                $args = haks(e.c).slice(1).map(k => e.c[k])
                fi[ec&fi](A,C,G,T, ...args)
            }
            else {
                throw "what todo", c
            }
            if (hak(N) > hak(known)) {
                # this e emits more todo/e
                # before or after the rest of what we're doing?
                $neu = N.filter(n => !known.includes(n))
                es&spawns and debugger
                es&spawns = neu
                known.push(...neu)
            }
        }
        $finished = grepout(N,n => began.includes(n))
        !hak(N) and fi&com,'8-still'
    }
    # merge ec&N when ec&*, ec&c.*, etc same
    fi.emergible = &acgtN{
        $fiz = uniqe(N,{map:n => nc&fi})
        $nonNcc = &c{
            $fc = ex({},c)
            !fc.N || !fc.c and return
            delete fc.N
            delete fc.c
            return fc
        }
        $merged = []
        each fit,z fiz {
            $f = z[0]
            $fc = nonNcc(f.c)
            !fc and continue
            each in z {
                i *= 1
                !i and continue
                $nc = nonNcc(n.c)
                $not = !nc
                    || !heq(nc,fc) || !heq(nc&c,fc&c)
                    || !heq(n.y,f.y) || !heq(n.sc,f.sc)
                not and continue
                merged.push(n)
                fc&N.push(...nc&N)
            }
        }
        #me&nu,"Fiz",{N,merged}
        grepout(N,merged)
    }
   
   // &syncopation
    # < fit most delays into &syncopation
    fi.yl = &acgt,seconds{
        return &y{ return G&delay,seconds,y }
    }
    # the requestIdleCallback stream
    #  and other things
    fi.syncopation = &acgtsc{
        # A + s identifies where+what
        c == 'draw' and 'or requestAnimationFrame'
        c ||= {timeout:5}
        c.began = Gtime()
        c.timeout and c.timeout = c.timeout + Gtime()
        c.n ||= A
        $name = A.t+"'s "+joint(haks(s))
        $later = Cye([name,8,c,s])
        # < A.4 should linger %Cat on this %plan
        #  < involving A.4/A.3/A:loading and /asked/$P
        ac(A.4,'synco',later)
        laters&waiting = 1
        # called in async time, see &Amess
        # < which we may not want to suddenly &elvis from
        return &y{
            laterc&do = y
            laterc&ready = Gtime()
            !laters&waiting and throw "notwaiting", later
            $ok = delete laters&waiting
            # to get all "loading's P", then engage them all
            $others = 4s&synco.filter(l => l.t == later.t && l != later)
            if (hak(others.filter(l => ls&waiting))) {
                laters&pending = 1
                return
            }
            
            # we are resolving one or more waits
            $com_done = fi&complace,'syncopation',{A}
            $all = [...others.filter(l => ls&pending),later]
            # if these &elvis, a plan
            # < as one big+individual B, try-catch
            #  < going into Atime just to go into Atime
            $done = fi&poolfour,later
            each il all {
                lc&do()
                delete ls&pending
                delete lc&timeout
                lc&done = Gtime()
            }
            # convert many ^ &elvis into one wake:R%Cat
            $pts = joint(all.map(l => ls&P.t))
            # < timings of all (like DevTools Network)
            fi&com,'re-live:',ex(hashkv(later.t,'x'+hak(all)),{pts})
            done()
            com_done()
        }
    }
    # get 4's attention
    fi.wantfour = &acgte{
        $N = 4c&forfour
        # when 4 is not awake,
        #  something must catch todo++ to -> me&elvis
        !N and throw "no poolfour"
        N.push(e)
    }
    fi.poolfour = &acgtl{
        $f = A.4
        $ol = 4c&forfourvor
        ol and throw "double poolfour",{l,ol}
        !l and throw "!object"
        4c&forfourvor = l
        4c&forfour = []
        return &{
            delete 4c&forfourvor
            $N = delete 4c&forfour
            !hak(N) and fi&com,"pool!elvis",{l}
            # one wake:R%Cat, from whereever hopefully
            $R = Cy&R
            $wake = fc&otherer
            !R || !wake and debugger; return
            A = fc&otherA
            me&elvis,R,'re-live',{wake}
        }
    }
   
   // Travel
    # catchable expr and debugger
    #  shows how $t/$n may dedup by sequence
    
    fi.ibug = &acgtti{
        G.bugs ||= {}
        i ||= 1
        G.bugs[t] = i
        return &{
            $still = G.bugs[t]
            still and throw "bug!catch", t, {still,i}
        }
    }
    
    fi.bug = &acgtt{
        G.bugs ||= {}
        !G.bugs[t] and return
        G.bugs[t]--
        !G.bugs[t] and return 1
    }
   
 // &pio: %TX %RX
      =pod what did -log know ♦
        < arrive $k, $v, etc into -log%X
          simultaneously:
          matching in eg -eight%TX above it
          
          %TX/$k/match/$Tt
           ie ^ matched, ^ introduced
            %TX xq:/match
             tells of potential %TX/.../match
             that o %TX/... can result in /match/$Tt
          
          a match may:
           
           exp simply as %TX/$k
            eg $TX/$k=onerarething
            eg %TX/$ref
           
           exp fuzzily %TX/for/k/$where
             might clue on xq:/$k/ about /for/k
            iterator meta, partitioning for $k
            may augment our params for &qis in &Xio middle
             or serve x through the &qis calls in &Xio backend
              may not create any real &qis climbing
            basically &qis to|from different structures
             eg $v=3.14159
              rounding numbers into $v_1sf=3, $v_2sf=3.1
             a %wtm "what this means" in rowing
              rowing grows meta for exp working out
               distant eg which things are el2ing in an i
             
             instead of &qis simply climbing paths
              eg $k starting with a capital letter
               is not something we can index into %TX/$k
               %wtm $k=Name -> %TX/k_parts/$case=upper = x
                that may x/match/$Tt
                and as we -> %RX, we would fill this out again,
                 putting the raw /$k somewhere too?
           
           need more %TX/$k etc to match also
            eg %%usual,thing,nesses
            finding any finds $Tt which shows others
           
           create some more %TX here|other places
            here = on the matching -log
            or for some -Eight, or 
             not whoever shows it this $Tt
            all the where exp has legs, puts feet down
            see 'given to -log%TX'
           
           be noticed missing upon -seven,
            or when a sequence otherwise seems to occur
             see 'resolve $n'
          
          # is really /$match=$Tt=aq.t/$n=aq, aq isC
          #  so i %RX/$matched=aq.t/$n=aq
          #   then each %RX...aq%TX enters the search path
          #  otherwise we would be compiling %RX.TX per arrive
          a match:
           tries to join a /match/$Tt:
            %TX/$k/match/$Tt = aq
            %TX/match/$Tt = aq
             aq/exp/$k shows what $Tt put -> %TX/$k
              inc more freestanding complexity inside
              usu anding them all to completely match $Tt:
             aq/exp/for/k/$gt=4/match/$Tt/$weight=2
              /for/k because 'exp fuzzily' cannot index /$k/
               $gt is a type of $where, binding to $k
                expressed from /for/k
                # < compile from ioish: /$k>4/$Tt+2
               $Tt may be this aq or another,
                that we (this aq) contribute $weight=2 to matching
             aq/and|or/$Tt
              this aq is such a groupability of those $Tt
               # is this about the meaning of Higher Order Perl's T?
              is a type of $where, see above, binding passed through:
               aq/exp/for/k/and/($gt=4|$lt=7)
             aq/$offset|$limit
              see arq/$ttl
             aq/potential/*
              becomes arq/* on match into %RX:
           
          describes into %RX its claim
            once significant enough
            # arriving at a locale of limited but extensible exp
            so
            -log%X/$k + -seven%TX/($k/)?match/$Tt = aq
             ->
            -log%RX/($k/)?match/$Tt = arq
             pile of activated aq/potential
             
             arq/$aq goes back
             arq/do/... hooks Effect rowing, -log, etc
             arq/$sc=qua might Effect -log%ope, like &togcon
             arq/then/$A=-seven/TX/... given to -log%TX/...
              then/$to/$dosomething/...
               identifies a bunch more %TX/* and where to put it
               projecting -log%TX, or -seven%TX, etc
              eg to seek the first -log%piece after -log%capsule
               -eight%TX/$k=capsule/match/$Tt = aq
               -> arq/$A=-seven/TX/$k=piece ->
               -seven%TX/$k=piece/match/$Tt = aq2 
               -> arq2/$ttl=1 for only the first
                  only in this -seven (can put higher)
                  < may (not)? match on the -log already matching
              
              is it so simple? no:
               all %TX are readonly?
               must we project %TX over %RX somewhere we A,
                scoped domily to the process doing the matching
                 our grasp, which may disconnect,
                  the projected %TX revoked
                rowing -seven coop rowing many -log
               reading from %TX within|out of our grasp
                within: because our This... has such a history to us
                out: of This... itself, as someone elses grasp
               afterall,
                how will we revoke %TX/* to stop matching?
                 say aq/not?
                and how to track aq/$ttl etc winding down:
             
             arq/$ttl
              # this may become more of a time-to-live,
              #  now like sql's limit (and offset?)
              arq on -log%RX, must coop with others
               via a scoping %RX:
               /$to ||= %RX of whoever %TX it
                usu domily to our whole This-time
               eg aq/$ttl=5/$to=-seven allows 5 matches per -seven%RX
              exhausts the matching of aq/$ttl
               eg -seven%RX/match/$coop=ttl/$Tt = -log%RX...arq 
                are the others
                 also group by arq/$aq/$ttl we have
                not all are inside the limit? they arq/not?
               amongst them, be inside the limit
                or arq/not, cancels the $Tt
              when limit satisfied
               may revoke aq by the %TX
                if possible, by %RX serving it
                eg the projection of the %capsule,%piece eg above
               or inject %TX (over %RX)
                to simply /$ignore=aq, bans it?
                
             arq/$ttl must be in -seven%RX, This%TX is readonly
             viewed in composite from %TX+ + %TX+<-%RX+
             
          $Tt being
            all $Tt should fully qualify from This,
             which they compile in reference to
              unique name
            autonamed by things we click that compose them
            or what the test assertion says + its exp
          
      =cut
   // &[ETR]Xsim
    # adapt to &Xsim...
    #  expects A, give it E, as in R:$pi%E
    fi.EXsim = &acgtEscq{
        c ||= {}
        $X = E.c[c.Xcgk||'X'] ||= {A:E}
        # deeply multiple s.*
        c.long ||= 1
        # always expect refs
        c.array == null and c.array = 1
        # arg 2,3 do nothing since X is X
        return fi&Xsim,X,'X',[],s,c,q
    }
    # adapt to E%TX|%RX
    fi.TXsim = &acgtEscq{
        c ||= {}
        c.Xcgk ||= 'TX'
        return fi&EXsim,E,s,c,q
    }
    fi.RXsim = &acgtEscq{
        c ||= {}
        c.Xcgk ||= 'RX'
        # hashy indexes
        c.array = 0
        return fi&EXsim,E,s,c,q
    }
   // &TXi, etc
    fi.getTXatE = &acgtE{
        $N = []
        # hosted here
        Ec&TX and N.push(Ec&TX)
        # matching here
        fi&RXglob,E,'matched'
            .map(aq => aqc&TX && N.push(aqc&TX))
        return N
    }
    # (E|aq)%TX/$Xc/match/$n=aq
    #  make aq matchable on E
    fi.TXi = &acgtEts,qua{
        $aq = isst(t) ? Cye([t,3]) : t
        !isC(aq) and debugger
        !hak(s) and debugger
        # E%TX/$t=le
        $x = fi&TXsim,E,s
        # /$match/$n=aq
        fi&Xsim,x,'x',[],{match:aq.t},{n:aq}
        qua == 1 and qua = {ope:1}
        qua and aqs&qua = qua
        return aq
    }
    # E%RX/matched/$n=aq
    #  aq received into E%RX
    fi.RXi = &acgtEt{
        $x = fi&RXsim,E,{matched:t.t},{n:t}
        return x
    }
    # E%RX/$k=*/$n, eg all /matched/
    fi.RXglob = &acgtEk{
        $X = Ec&RX
        !X and return []
        return fi&Xglob,X,k
    }
    # hash index only
    # < glob mode in &Xsim...
    fi.Xglob = &acgtXk{
        $index = X[k]
        !index and return []
        $N = []
        each tx index {
            hak(x.z) > 1 and throw "dup Tt",t,X
            each i,aq x.z {
                N.push(aq)
            }
        }
        return N
    }
    
    
   // &pio
    # E%X writeup attracts E^^%TX to E%RX !
    # < aq, a product of -Bat, reporting there
    #   consequent ignores may indicate...
    fi.pio = &acgtEscq{
        # writing stuff down
        each ark,v s {
            fi&EXsim,E,hashkv(ark,v),{n:E}
        }
        
        # triggering awareness
        $Tc = fi&TX_awareness,E,s
        $M = Tc.M
        !hak(M) and return []
        
        # knock out any any $ignore
        # < aq%upon decide where to $ignore|$ttl,
        #    limits to one on the TXing E,
        #    one per branch on a RXing E
        #    might be a field effect, E search-around
        # < bit vague... see aq/$offset|$limit
        $ignored = []
        each i,aq M {
            # must be in the TXing E
            aqs&per and 'per such slope'
            $n = Tc.M_E[i]
            # see if it is ignored
            $x = fi&RXsim,n,{ignore:aq.t},{}
            (x.z||[]).includes(aq) and ignored.push(aq)
            else {
                # quantify one or many
                aqs&forall and continue
                # make RX/ignore/
                fi&RXsim,n,{ignore:aq.t},{n:aq}
            }
        }
        grepout(M,ignored)
        
        each i,aq M {
            # E%RX/matched/$n=aq, so aq%TX for further
            fi&RXi,E,aq
        }
        
        return M
    }
    # [aq+] from E^^^ matching s
    fi.TX_awareness = &acgtEscq{
        $N = me.cby(E,E => Ec&top).reverse()
        # rowing, or arq+
        # make a little table, almost brack
        $Tc = {}
        $M = Tc.M = []
        Tc.M_E = []
        each in N {
            $search = fi&getTXatE,n
            each ii,TX search {
                $matches = fi&TX_matches,TX,s
                each ii,aq matches {
                    if (aqs&also) {
                        # < more AND expr for the same E 
                        #    currently you must RX furthers
                        #   aq would check you matched its entire expr

                        # must TX from ^E if dl=1
                        aqs&also.dl && aqs&also.dl != i and continue
                    }
                    M.push(aq)
                    Tc.M_E.push(n)
                }

            }
        }
        
        # now we have all aq
        # < with rowing-ness to $Tt via &Xsomp?
        #   with transmitor n and transmission aq
        return Tc
    }
    # [aq+] matching s={t} in TX
    fi.TX_matches = &acgtXs{
        $N = []
        $TX = X
        each ark,v s {
            # would have some of these indexes
            # < matching string appearing in ark|v|t|etc
            $fora = TX.for && TX.for[ark]
            if (fora) {
                # < (/$where)?/$Tt
                #   may wildcard the v of this ark

            }
            !TX[ark] and continue
            # all refs
            $arks = ark+'s'
            !TX[arks] and debugger
            $vi = TX[arks].indexOf(v)
            vi < 0 and continue
            $atch = TX[ark][vi]
            # has a bunch of matches
            N.push(... fi&Xglob,atch,'match' )
        }
        return N
    }
   
// live
 
  // itself!
    fi.live = &acgtJs,ar{
        
        $Y = A
        $R = fi&R
        !R and throw "OHNO"
        $x = me&Jx,R
        # Viewboats - one -seven per R allowed
        $el2 = x.ro('el2') || Rs&el2itive
        el2 and delete Cy&Fish
        # hang At off the Jrunto %%C
        Rs&nlist = [Rc&s]
        
        A =
        Cy&Fish ||= fi&Atopleast,1
        
        A&step ||= 0
        A&step++
        A&step == 1 and fi&ibug,'Firstlog'
        A&otherer = xc&Jrunto
        A&otherA = Y
        
        A&live = 1
        $done = fi&complace,'yarrr',{A}
        
        # < hang our A-system on Y, so it b
        #   1s&hold keeps %Cat waiting?
        # < &elvis must be coming back to %Cat sometimes
        #   more ephemeral than &Zeve
        #    which %dome=%plan leaving whereever
        #    only works in-Y (&nodee)
        #fi&test_Yingong,Y,J,s,ar
        
        fi&test_Attention,A&step
        #fi&test_Nxcnorder
        
        # callbacks happen outside:
        delete A&live
        
        =pod flushable state
        4%synco %done -> &log
        4%log -> Story/This/$Ct-eight
        < bisecting runtime with diffs of this
        
        have the -eights of this %Cat
         for $W (%%C) or A:Fish (Cy&Fish)
         in here, @Gome or @Story
          whoever is upstreamest
         &Effect open $W the current
         launch Story slightly, fully
        
        Fish swims through the facts that form its body
         things it later calls mind
        =cut
        
        done()
        
        # &zu attaches to CyR-space, above Y of Cat
        # < use $Ati - sequence having $At path
        $Atw = hashkv([A,...(As&z||[])].map(n => [nc&sip,n]))
        #me&zu,"Aump",Atw
        #As&log.map((n,i) => me&zu,"Log:"+i,n .sc.rowish = 1 )
        
        n abovst  s:vefge
        n tassely 3 s:brackets
        n soilesoezc 3 s:brackets
    }
  
  // < Pi: -seven read into another
   # various envelopes, see Story %FishEight
   #  &complace engages This../-seven
   
   // pi doc
    =pod &pii
     is less futuristic than R'The'
     &pii $s c.t|pi
      must create s-$pi?/z-$pi, winds to 1
      has insphere at eg zy&$pi=$E
       so it is a layer at that point, pathily
        whereas R'The' makes a child
     
     &piiing $s c.ov
      winds up the mind of the pi
      redo 6 and up
     
     &pio E {like}
      sets of {k,v}, {i}, {pi} to E%X
       if -vat etc may {is:'C'}
      identify self, matching E^^^%TX
      things introgressed, see %TX %RX
     
     < -log may check ss&z/*%* are still
       when the next -seven @7,
        data dumps that progress through time
      usu want to capture exactly as it was
      hoistable data sense, selectively el:2, reuse y&thing
      wants them in X.
     
    =cut
      
   // Nine - bunchers of -eight
    # potentially hosting T outspheres,
    #  so that -eight%dige can usually save loading the eights
    fi.pi_This =
    me.piThis = &acgtscq{
        return me&Sopi,s,'This',c,q ({
            1: &Ecq{
                Ec&top = 1
                c.nopiinto = 1
                fi&piinto,E,c
            },
            7: &Ecq{
                # hows it going
                me&tc,"Hows",'B'
            }
        })
    }
   // -eight%string/-seven/-Log
    # these have R%ball s for storable of E
    fi.pi_Eight =
    me.piEight = &acgtscq{
        return me&Sopi,s,'Eight',c,q ({
            1: &Ecq{
                fi&intoR,E,c
                fi&piinto,E,c
            },
            7: &Ecq{
                # compress the entirety
                # < linking to sevens? T outspheres
                $d = {compLines: &DdC{
                    $t = Cy&thing
                    if (t) {
                        if (ty&cv >= 0.2) {
                            # stops, %string trusted
                            !ts&string and throw "!string"
                            d.nofurther = 1
                            return me&unfixstring,ts&string
                        }
                        else {
                            # %string made here
                            d.for_string = &CdN{
                                ts&string = N.join("\n")+"\n"
                                ts&dige = dig(ts&string)
                                # and percolated to the out-C
                                Cy&C and sex(Cy&C.sc,t.sc,'string,dige')
                            }
                        }
                    }
                    # upper Ec&cv vanishes
                    delete Dc&cv
                    delete Dc&X
                }}
                me&Linets,s,E,d
            }
        })
    }
    fi.pi_seven =
    me.piSeven = &acgtscq{
        return me&Sopi,s,'seven',c,q ({
            1: &Ecq{
                c.piinto_sequines = 1
                fi&intoR,E,c
                fi&piinto,E,c
                # < for a Cy&thing here
                $t = Ey&thing ||= Cye([E.t,1])
            },
            7: &Ecq{
                #me&Effect,s,E,'Ignored','Ignored,ope:0'
                #me&foraneight,R,s,E
                each il Es&z {
                    $z = ly&C
                    zy&log != l and debugger
                    me&piLog,z,{},7
                }
            },
        })
    }
   // -Log%string
    fi.pi_log =
    me.piLog = &acgtscq{
        # being in this Seven
        return me&Sopi,s,'log',c,q ({
            1: &Ecq{
                # has some c.into=[-seven]
                #  E.t = i++ there
                c.piinto_sequines = 1
                fi&piinto,E,c
                # mentions being a -seven, E.t
                
            },
            2: &Ecq{
                # D/$row have .sc that mostly define it
                # < first one %%says, -ology shall labelise
                # < stream ss&z -> /rows/$n
                #   permutations of /rows/$k/$v
                #   subsets of X/$k|$v etc, which include Dy|c&*
                #    or X/$nk/..., rows implying many sc
                #   and X/$At|$Ct having all reachable A, C
                #    pose about A|C in rows - what talk about
                #    relative to A|C in D.y|c - where talk from
                
                # i E/-row/-vat o s/$n%*
                each in ss&z {
                    $row = fi&pii,E,{t:i,pi:'row',n}
                }
                # pointism begins to Xi, Xo
                #  some pointerisms wait til -vat has qua
                #   can -vat/** and put changes to Display
                # &Sopi E** tugging -row + -vat
                #  -row tends not to appear (Display)
                #    and pointers through it: -log/$k
                #    which may specify into -log/{c|y|$rowi}/$k
                #    since -log/* implies any numbers
                1
            },
            # takes details (while in &com)
            # < replace &dopi with -vat@3
            3: &Ecq{
                # known items to give -n, trust .t unique
                c.nlist ||= fi&getat,'nlist'
                # storable encoding
                $t = Ey&thing ||= Cye([E.t,2])
                # -n for things as pathed from thing in the node list
                $comp_log = fi&comp_log,['log','row','n']
                $d = {compLines: &DdC{
                    Cy&D = D
                    #Cc&pi == 'row' && fi&bug,'Firstlog' and debugger
                    me&dopi,D,d,C,c
                    Cc&pi = Dc&pi
                    delete Dc&cv
                    #comp_log(D,d,C)
                } }
                me&Linets,t,E,d
            },
            6: &Ecq{
                if (E.t == 4) {
                    $la = me&tcl,'log','1y'
                    las&FishElvising = 1
                    me&tc,la,s.t,'b'
                    each in ss&z {
                        ns&says and me&tcl,la,ns&says,'g'
                    }
                    $N = me.cby(E,E => Ec&top)
                    me&nu,'Louge+'+E.t,{s,E,c,q,N}
                }
            },
            7: &Ecq{
                $R = fi&R
                
                $bc = delete Ec&brackology
                bc = ex2({D:s,ology:{appears:1}},bc)
                $br = me&pibrackology,R,E,bc
                $ol = me&yology,br
                ols&pa = 0.2
                # sorts before four
                # < start early to take place, load D when ...
                oly&cv = 0.317
                ols&dis = 1
            },
        })
    }
   // -Log/-row/-vat
    fi.pi_row = &acgtscq{
        return me&Sopi,s,'row',c,q ({
            1: &Ecq{
                $n = Ey&n
                # the row number is a brittle pointer
                #c.piinto_sequines = 1
                #fi&piinto,E,c
                
                each kv n.sc {
                    $vat = fi&pii,E,{t:k,pi:'vat',s:v}
                    # puts s-row/s-vat
                    ss&z.push(vat)
                }
            },
            2: &Ecq{
                # E/-vat@1.t are better pointers
                # E/-vat@1.c.s may also string match,
                #  suggested to
            }
        })
    }
    fi.pi_vat = &acgtscq{
        return me&Sopi,s,'vat',c,q ({
            1: &Ecq{
                #fi&pio,E,{k:E.t,v:Ec&s}
                
                # has more types,
                #  sees C.*.*
                #  dives data til C (or d.d == 9)
            }
        })
    }
   
     
   // &piinto
    # pi on R:$pi (**-seven) usu &piinto the R above
    fi.intoR = &acgtEc{
        $R = fi&R
        $p = Ry&up
        $z = pc&s
        c.into = [z]
    }
    # 1: rearrange Ey&up (before &tapepi)
    # < notice (&pio) being eg a -seven, E.t
    fi.piinto = &acgtEc{
        # up was eg D-log, what E-log comes from
        Ey&C ||= Ey&up
        c.nopiinto and return
        c.intoR and fi&intoR,E,c
        # we change Ey&up
        !hak(c.into) and throw "nowhere to put",E
        each in c.into {
            0 < i and throw "multi up"
            $En = fi&getpi,n
            !En and throw "Must have -pi up"
            if (c.piinto_sequines) {
                # eg E-log put into usu one n-seven
                # the first gives E.t=sequence number
                E.t = Ens&z.length+""
            }
            # En-seven/E-log
            Ey&up = En
            Ens&z.push(E)
            # not for En-eight
            nc&nopiinto and continue
            # put in the outsphere, not via y&$pi
            ns&z.push(Ey&C)
        }
    }
   // &pii new
    # E(s) means sy&$pi == E, both c&pi==$pi
    #  the E is the pi, the s talks it outside
    # s -> E: s%FishEight has sc&pi="Eight", so sy&Eight=E
    fi.getpi = &acgts{
        !sc&pi and throw "c!pi"
        $E = s.y [sc&pi]
        !E and throw "un1"
        return E
    }
    # i E|s/#$t-$pi:z for E(s)/+Z(z)
    #  two spheres: E/Z, s
    #   Zy&up == z, zy&up == s
    # s may be E, so zy&up == E
    #  nesting E/z, not in s/**
    fi.pii = &acgtscq{
        c.t == null and throw "!c.t"
        c.pi == null and throw "!c.pi"
        q ||= {}
        $E = fi&getpi,s
        $z = me&fiu,s,c.t,2
        
        hak(c,'n') and zy&n = mustC(c.n)
        hak(c,'s') and zc&s = c.s
        zc&pi = c.pi
        
        c.ov ||= 1
        fi&piing,z,c,q
        q.meish and fi&tapepi,z
        
        return z
    }
    # < adds it to a tape somewhere y&up...
    fi.tapepi = &acgtsq{
        # may once for a batch
        q ||= {}
        $to = me.cbu(s,s => sc&top)
        !to and debugger
        
        $up = sy&up
        # < and where on the tape from sy&up
        #   earlier neigh etc
        toc&N.includes(s) and debugger
        toc&N.push(s)
        
    }
   // &piing continue
    # < wind through that tape
    fi.piing = &acgtscq{
        # may others first, ideally get back to:
        return me&Sopiing,s,c,q
    }
    # adapt to a fi.pi_routine
    me.Sopiing = &acgtscq{
        $pi = c.pi || sc&pi
        !pi and debugger
        $y = fi['pi_'+pi]
        !y and y = me['pi'+pi]; q.meish = 1
        return y (A,C,G,T,s,c,q)
    }
    # pushing interested
    me.Sopi = &acgtstcq{
        num(q) and c.ov = q; q = {}
        num(c) and c = {ov:c}
        c ||= {}
        c.ov ||= 9
        $negate = c.ov < 0
        negate and c.ov *= -1
        c.ov = scaf(c.ov)
        
        c.ov > 0.1 and c.el ||= 3
        $E = c.E || me&Api,s,t,c
        negate and Ec&cv = c.ov - 0.001
        E.y [Ec&pi] = E
        sc&pi ||= Ec&pi
        sy&n and Ey&n = sy&n
        
        q = peel(q)
        
        return &h{
            each ky h {
                $cv = scaf(k)
                cv < 0.6 && Ec&cv >= cv and continue
                c.ov < cv and break
                y (E,c,q)
                Ec&cv = cv
            }
            return E
        }
    }
    
  // Story 
      =pod log ♦
       < -log**  should refer to earlier things they were like
         inc (C) things mentioned on previous -log
          still being as described
         so eg long rowings can say only what columns changed
       
       &complace engages -seven++
       &com+ each:
        -log..-vat fully
         have -eight/-seven/-log/-row/-vat** to:
        
        < arrive $k, $v, etc into -log%X
          simultaneously:
          matching in eg -eight%TX above it
          see %TX %RX
        
        < ology from -vat data
           compress the 'says' label
           detect the lots of node:Jrunto
            mute unless different
          draw ope down
          ref reappear
           pointed to
            which is implied for -n, which is implied
          >
           and el:3 ~ since last -vat
          %string reappear
           esp on the -row%string
            independent of -log sequence number...
           and el:3 ~ from it
            ie a particular number changing
       &complace finishes
        active -eight
         if all -seven ok early, no:
        -seven draw &brackology
         &slabeline may use -vat
        # < sort by This/*/-seven/Dc&fe_time
       
       pi that announces names for itself
        drawing things on the ground
        as -ology from -vat
       
       Te togcon tool
        baked into patterns to watch for
        see which are used, -log... they get
         were projected from some Nine/Eight/Seven
        spot them changing, patchsquidge
       
       $tid++
      =cut
   // f
    # lookup R^^%nlist
    fi.getat = &acgtk{
        $R = fi&R
        return me&Rsc,R,k
    }
    # expect -log/-row/-n
    #  leaves not even the top one
    #   ie you are expecting -these
    fi.comp_log = &acgtN{
        return &DdC{
            $i = d.d*1-1
            !N[i] and return
            $s = C
            while (i >= 0 && s) {
                # Dc&pi copied back to Cc&pi, so deleted show
                N[i] != sc&pi and return
                s = sy&up
                i --
            }
            delete Dc&pi
        }
    }
    # < impose what we expect
    fi.decomp_log = &acgtN{
        return &DdC{
            Dc&pi and return
            $i = d.d*1-1
            $pi = N[i]
            !pi and return
            $s = D
            while (i >= 0 && s) {
                # things above should be set by now
                $Dnopi = s == D && !sc&pi
                !Dnopi && N[i] != sc&pi and return
                s = sy&up
                i --
            }
            Dc&pi = pi
        }
    }
   // Story doc: com, point, save, modify
      =pod state
       $Ct-eight are about an object,
         eg $Ct = v1%SummerCat/*%%C
         or $Ct = %%C..$A, which may reset faster
         or anything, related ^^%%C
        they were a %Page,
         now relate to a things identity
         could still be Page-like if for an item with that duration
         autonamed for being $Stori/$Ct
          as it could $Stori/$Ct, 'realise $n' etc
         and contains many -seven
          times it encloses many -log
           which may have turned into -gate or so
           details on the time itself contained therein
        
        $Ct**
         many This/$Ct-eight, of varying types
          they contain times (-seven)
           which contain -log (or -gate etc)
          
          all $Ct** ref conserve
           and refer to each other
           a -vat might check C.*.*.* for $Ct**-pointable refs
           to collect where such $Ct** object is talked of
            maybe rumours in appendix to $Ct
            
          $Ct** brings time to other $Ct** it sees
           for $Ct** objects, but also $Ct itself
           eg the Stori/MainPlotLine
            points to various $Ct** as they appear,
             -seven for -seven
            and may wander into Stori/SubPlot (-seven for -eight)
            can jump into the next Stori/Action (-seven to &enPlot)
             is importo hairy business, slep
             choosing when|what to wake before the Action
              ie are the inputs to Action available
               or have they probably changed, needing &middle
         
         some of them are in time with each other
          time itself, the %Page has been very linear
         all about relating that $Ct to an object within
          might mention eg %Asip change on -seven
           talk of %Asip would subnet from a $Ct**
           to draw an -eight across many A-lives
           
        so
         we will autoname $Ct, $Ct/-seven, etc
         usu + from here down:
         $Ct is the v1%SummerCat/*%%C
          which is approximately A:Fish re lifecycling
         -seven per A&live (R%Jrunto) or &syncopation
          insideness we can capture &log for
          -log -> -seven -> This/$Ct
          which can notice haps, pack hooks
         the what-is-going-on
         
        A:Fish &Yinge
         -log@3 in &com
         This..-seven@7 per A&live 
         A:Fish schedules next attention as an A.4
         a &waits_8 urgency+etc sum
          plans to elvis places, over time and etc
          prior|not to &elvising 4s&todo
           which should be fairly pronto
            eg before &settle gets far
          can be put off etc.
         
         we shall carefully auto e:re-live it,
          repelling into time, usu per &elvising
         
         having the %%wants (A-redo) data for A.4=Fish
          is probably beneath the noise floor of %Jproto
           which deals with each $W and their $e
           not the noise of a $W stuttering to completion
          requiring that %Jproto hasnt been bumped
           so we are continuing for the $W
         however
         could &Zeve -> %Jproto
          %Jproto reasoning on the branching attendance
          similar T-rooming as Story/Plot
           %plan++ over $Ct**++
           they both notice haps, pack hooks
           lurk That/$Ct** with reactance
          it would usu lead back to re-live $Ct some more
           while capturing|replaying any entire -seven
            supposing J commit, A wind etc
         yet
          it will probably be a bunch of the same gear
          %Jproto follows an open-to-input Plot happening
           with fewer moving parts
        
        so Story/This/$Ct-eight/
         many $Ct
          as we go redo-ing
          show different runtimes, lives
          group by $t, %SummerCat ($t+$tid)
         
         $Cat/$A etc also a grouper
          since we can el2 A:Fish
          wanting to check Fish/A:suchatest works
          it can hang up anything as a -log,
           which can turn into an -Atest, dump anything
         
         into the This/$id = $Cat(/$A) etc space go bits of $Stori
          the $id names an -eight 
          the -seven named by %time it occurred
          both imply 'realise $n'
          $Stori/$id-eight/-seven%time
         
         be into Story, allow distraction
          share a potential %%want:R%Jrunto
          it would &Zeve its &Yingate state to %Jproto
          which others eg Story &Effect C shapes, eg pause-at
          ie any point inc. having a %%waits can become %Jproto
         with a business it can sublate
      =cut
   // Story &com
    fi.Acom = &acgtAsc{ return fi&com,s,c }
    fi.com = &acgttsc{
        
        s ||= {}
        c ||= {}
        # any -seven-ish thing collecting D-log
        $into = me&Gstaco,'-log'
        # me&log makes a &bracki D-log/%says=msg,etc
        $D = fi&me_log,t,s,c
        Dy&A ||= A
        
        # A:least%log
        #  is also 4s&log from inside
        #   where the G&c go (~>3 message: things)
        $Al = me.cbu(A, A => !A.up, A => A.up)
        ac(Al,'log',D)
        Dy&log and throw "hadlog"
        
        !hak(into) and throw "nologinto"
        
        # -log + -vat, details in the moment
        me&piLog,D,{into},3
        
        return D
    }
   // Story &complace detail
    fi.me_log = &acgttsc{
        $R = fi&R
        # &log makes &bracki: D-log/$n.sc<-s
        #  D open to more /$n-rows
        #  < which should refresh -log@3
        #   < implying the @2-3 must stream parts
        #  D%X/$k etc could go deeper
        #   into sc.*.*, as -vat/** dives
        #   we could have a -vat without %string
        #    grips on the noise
        #   the way it decides to capture A
        #    making patterns, recognising, how to respond
        #    come together to match+do things we're looking for
        #    should compile into most &ha-ish moments
        $D = me&log,R,t,s,c
        # also, &log|&Outlog sets:
        #  Dc&pi ||= 'log'
        #  Dc&fe_time
        #  Dy&inside = -gate of R%Ying
        #  Dy&Ying=R%Ying
        #  Dy&R if not R%Ying
        return D
    }
    # -seven (time) envelope, grows an -eight
    #  a place to send &com, inc the first one
    #  they may happen inside each other, etc
    fi.complace = &acgtsc{
        # $Ct-eight, $i++-seven
        $seven = fi&new_seven,c
        # put for &com into
        $done_Gstac = me&Gstaci,'-log',seven
        $done_comless = fi&comlesslogs,seven
        # and this first -log
        # < notices all Gc&logs/-seven active
        $D = fi&com,s,c
        #me&nu,"complace",{C,This,eight,seven,D}
        return &{
            done_comless()
            done_Gstac()
        }
    }
    # R:-eight/R:-seven created
    fi.new_seven = &acgtc{
        $R = fi&R
        !Rs&Jrunto and throw "!Jrunto"
        $z = Rc&s
        $This = zy&balein('This','FishThis')
        # z -eight
        $Ct = fi&complaceCt,c
        eight = Thisy&balein(Ct,'FishEight')
        
        # z -seven
        $i = hak(eights&z)
        $seven = eighty&balein('sev'+i,'FishSeven')
        $Run = me.cbu(R,'Jrunto')
        !Run and debugger
        ac(Run,'newsevens',seven)
        return seven
    }
    # name -eight by &complace c.*, eg c.A -> "A:"+A.t
    fi.complaceCt = &acgtc{
        # < with context, realise $n to dup names:
        #   i This/Ct/$k/$v/$n:-eight
        $k = haks(c)[0]
        $v = c[k]
        !isC(v) and throw "!C"
        $Ct = k+':'+v.t
        return Ct
    }
    # watch for things calling &log as opposed to &com
    # < and the ''~message: not,a,tion' -> 4s&log
    fi.comlesslogs = &acgts{
        $Outlog = me&theOutlog,R
        $Di = Outlog.length
        return &{
            $since = Outlog.slice(Di)
            $miss = since.filter(D => !Dy&log || !ss&z.includes(D))
            !hak(miss) and return
            # < intersperse
            me&nu,"Uncom",{s,miss}
            fi&com,"non-com-logs",{miss}
        }
    }
   // test, R
    # get R%Jrunto, or %Yingbal?
    #  can %Yingbal be made a node, so we can &nodei into the Fish?
    fi.R = &acgt{
        # they will go Cy&A.1
        # A.7 = Y
        $R = Cy&R
        !R and debugger
        return R
    }
    # see what R%tunnel=e is, for proto ein
    fi.eis = &acgtc{
        c.R ||= fi&R
        $e = me&Dtunneling,c.R
        !e and return
        c.t && c.t != e.t and return
        return 1
    }
    # to script for many A, getting A = particulars
    fi.Adoer = &acgtY{
        # < switching A etc with B on any &h:
        #   Babz: fi&Thing,A:Al,la,ca
        #    -> G.h(A,C,G,T,{t:'Thing',A:Al},la,ca)
        Y ||= A
        return &{
            # start each call with the A from &Adoer
            A = Y
            each in arguments {
                isA(n) and A = n
                else
                isar(n) and $a = fi[n[0]](A,C,G,T, ...n.slice(1))
                else
                isfu(n) and $a = n(A)
                else
                debugger
                # assumes any A returned from that
                isA(a) and A = a; a = null
            }
            return A
        }
    }
   
   // R This/*/*
    # attach Jrunto/This
    # < on Story or %%C
    fi.Storier = &acgt{
        # %%C has y&R%Jrunto
        $DC = C
 
 
 
 
 
        $R = fi&R
        !Rs&Jrunto and throw "!Jrunto"
        # Rc&s != %%C
        $s = Rc&s
        $Thi = 
        sy&balein('This','FishThis')
        return Thi
    }
    # on %Jproto only
    fi.Rdropbales = &acgt{
        $R = fi&R
        $z = Rc&s
        $ba = zy&bales
        each tc ba {
            delete z.y [t]
            me&ioty,z .filter(s => s.t == t)
                .map(&s{
                    i $z/-$s
                    s.y.tv = []
                    s.sc.z = []
                })
        }
        delete zy&bales
        
        # drop history (keeps Display**)
        $V = Rc&V
        V.x = {}
        # fresh Cy&Fish this time
        Rs&el2itive = 1
    }
    // bales
        # context of R:This|Eight|Seven
        fi.balein = &acgtsc{
            # s may be t?
            c = peel(c)
            $R = fi&R
            $z = Rc&s
            # is s=C|Ct, c->Rsc
            $cwas = ex({},c)
            # get ordering, create others before s
            !Rs&Balesd and fi&Rbales
            # everything we &balein gets to wake
            c.wakeful = 1

            $ba = zy&bales ||= {}
            s = fi&baleinr,R,s,c
            ba [s.t] = cwas
            # Jrunto must &Rbales, in case nobody &complace's
            c.eph and z.y [s.t] = s
            ss&z ||= []
            return s
        }
        fi.baleinr = &acgtRsc{
            !isR(R) and throw "baleinr!R"
            $spec = isst(s) ? [s] : [s.t,s]
            $r = me&bal,...spec,c
            $s = rc&s
            if (!Rc&N.includes(sy&R)) {
                # they get sy&R @293
                me&Ring,R,{und:r,ov:0.295}
            }
            return s
        }
        fi.Rbales = &acgt{
            $R = fi&R
            Rs&Balesd and return
            $z = Rc&s
            $ba = zy&bales ||= {}
            each tc ba {
                # z/s
                # this appears to be a tv, via &input?
                #$s = me&fiu,z,t,8
                $cvs = zy&tv && zy&tv[t]
                $s = cvs && cvs[haks(cvs)[0]]
                # zy&This=s)%eph
                s ||= z.y [t]
                !s and continue
                #debugger
                fi&baleinr,R,s,c
            }
            Rs&Balesd = 1
        }
   
   // test_Yingong
    fi.inR = &acgtR{
        Ry&R and R = Ry&R
        !isR(R) and throw "!R"
        $C = Rs&C
        !C and throw "R!C"
        return y => y (C,R)
    }
    fi.test_Yingong = &acgtYJs,ar{
        # the C persists, until Jproto el2 it: tog:'!'
        $theC = C
        # we have only to hang our A-system on it
        # also:
        # Js&hold will stop Jproto concluding the plan,
        #  while we have waitors
        
        # %of, %Zeve is all go.
        # < the block-quotey n should work at any indent
        A&lemonge = 1
        
        # Yc&N is the Yingmind
        # limb (is made in|y&Y=) Y:Yardiale@01
        #  it must cv=3 to y&up to C, for &Yingbal
        # &Yingbal also requires A=Y, for &Timethe (unrelated)
        $R = Cy&R
        $A = Y
        $limb = Cy&yar = me&Yong,R,C,'Yardiale',{zip:1},1;
        me&Yingbal,'%yar',limb
        me&Yong,R,limb,{},9
        
        $limbo
        $limbo = me&fiu,limb,'Yord'
        fi&inR,Cy&bal (&CR{
            $D = Cye(['stuff',1])
            $Do = me&fiu,D,"Do"
            me&fiu,Do,"Doingss"
            
            #s = me&Yong,R,limbo,'osc',{D:D}
            me&nu,"Inside",{theC,Y,limb,limbo,s}
        })
        
        #ens&latop = Js&top
        
        s&numbering ||= 0
        $eye = s&numbering ++
        Js&hold = eye < 4
    }
    
   // test_Attention
    # roll b->A
    # rota A->b
    # ~Q
    fi.test_Attention = &acgts{
        $oft = &{ return {of:'w',t:'reandom'} }
        if (s == 1) {
            A.4 = A
            $Ag = A&thinger = fi&Atsomewhere,A,'loading'

            $Am1 = fi&Atsomewhere,A,'more'
            # V<-X
            Ac&again()
            $Am2 = A&more = fi&Atsomewhere,A,'more'
            $Am = fi&Atsomewhere,A,'more'
            $Ae = fi&Atsomewhere,Am,'even'
            $Au = fi&Atsomewhere,A,'unrelated'

            fi&isAthinger

            $got = fi&Ath,Am2,oft()
            #$got = fi&Ath,Am,oft()
            # < ! put one line further down and it doesnt work
            $got = fi&Ath,Am2,ex(oft(),{t:'klum'})
            $got = fi&Ath,Ae,oft()
            got and throw "got first"

            fi&elvising

            fi&elvising
        }
        elsif (s == 2) {
            fi&elvising

            fi&elvising

            fi&elvising
            
            # supposing ^ wakes A:more:
            $Am2 = A&more
            $got = fi&Ath,Am2,oft()
            $got = fi&Ath,Am2,oft()
            $got = fi&Ath,Am2,ex(oft(),{t:'klum'})

            Am2s&goat = got
        }
        elsif (s == 3) {
            
        }
        
        #$Am = fi&Atsomewhere,A,'more'
        # < look at awaiting of+t, group by $At|$sip
        
        #fi&Athinger,Ag,[{of:'w',t:'random',string:'changesing'}]
        
    }
   // littler tests
    # &Xsomp $n...$n ordering
    fi.test_Nxcnorder = &acgt{
        A = fi&Atsomewhere,A,'test_Nxcnorder'
        
        $s = {of:'w',t:'leaks'}
        $x = fi&Xsimp,A,s
        $enQ = &s{
            $Q = Cye([s.src+' v'+s.version,1])
            fi&believeiQ,x,s,Q
            return Q
        }
        $got = a&got = {}
        $see = &t{
            got[t] = fi&believeoQ,x
        }
        enQ({believe:1,src:'1812',version:1})
        see('first')
        enQ({believe:1,src:'1812',version:2})
        see('2nd')
        enQ({believe:1,src:'1812',version:1})
        see('first again')
        
        return A
    }
    # < little functions
    fi.test_Pictures = &acgt{
        $i = 5
        $c = exts({},'sit','t')
        c.oth = 1
        #4s&Bthing = Gc&B
        #4s&Bthing = eny(c)
        #u Dealap
        # < see I change
        #4s&Athing = A
        #As&selfpin = me&t,R,{of:'wjs',args:'ar,J,s'},'Fish'
        #As&selfpin = me&t,R,{of:'wjs',args:'flonk,J,s'},'Fish'
        #while (i--)
        #    ~>5 Fiseh: 3
        #fi&a,{fuselage:3}
    }
    # < &Gstac_reset
    fi.test_Gstac = &acgts{
        $ja = Cs&jabla ||= Cye(['Jable',1])
        if (!jas&did) {
            debugger
            $done_Gstac = me&Gstaci,'-log',ja
            jas&did = 1
            # < somehow expect this, for instant comeback
            throw "should undo the stack"
        }
        else {
            $ol = me&Gstaco,'-log'
            me&nu,"stac:-log",ol
        }
        
    }

// X

   =pod
    the new X
     space for spaces of matter (its2)
     forming over and against any other|prior experience
     
     each X is for an A: X.A=A, A&X=X
     < merge X into A?
     < make X C, X -> X.sc, X.Xq -> X.c?
     
     a beach where traces hang up ways in
      a photographic field where A can know itself,
       at any level between A(.*)+ and A/C, even A/type/C
       and any moment, supposing indexing includes $moment
        or you would simply make another X
      with individual fronds of X.*
       networks of types and measures,
        in an expanse intersected by a curve
     
     A loads X with things approaching C
      X/$t = x, x.z/$C (aka X|x/$n), C.t=$t
       is a simple load of things for J
       x.z can handle dupes, see 'ressur concluded'
        other indexes|slope should be found to separate them:
        X/$n orders the X/$t
       that C might have no meaningful C.t, etc
        be just C.sc, eg &brackX for X.k.$gk...
        separatable by other lateralism:
       having extra coordinates for the same C|refs|etc in X...
        the X/$t produces A/C tuples
        may share C with various X.*.... producing:
         legs of twinning:
          e wanting C/$partofC/connects:to/C:D/because
         you may specify these, as i|o things
          so you are notified|involved
           as soon as X notices rows come into that view
          and thence &ha|&n, even &increment
           may see if they start|have|stop involvement in whatever
            creating the memory of a search for fitting a formula
            which would be the ultimate thing to optimise
         so it decides to write various things about it,
          including was-something-e-wanted
         
     so they attach C,
      any ways they want
      then start walking around it
      assuming things it didnt see arent there, see 'ressur concluded'
     to X, which is also attaching to itself:
     
     A tends to have identifiables (At path) anywhere it spreads out:
       Aip - subnets repeating
       At - path (mind+Ct)
      along with its own X
       to arrive X into X&A.up&X (upward)
        so it acquires X.V, the supposed last version of this X
        as resolved by At+Aip, etc
       see 'A@1 scans itself'
       X|x.had should know its xqt+ark:v in X|x.up
        having 
        too much to copy index, eg:
           X.up.At.$At = x
            x/$n = A = X.A = X.had.aye.At.$At = x
          tho it allows every x to know every other x
           all &qis per &Xio ($n-tering)
           would be a strange case of sequencing by /$n
        just:
           X.up.At.$At = x
            x/$n = A = X.A = X.had.aye.At = $At
          having to go X.up(.V)? yourself
           and &Xio o:aye {At}
     
     and X.* in general index A/**:
      X/$At: A:a/A:b
      X/$oAt: met other A:c
       &h-like calls with A:a may have eg &ha,C(y&A:b)
        we see b as other
         could be A:b and C.**A:a
        A:a|b&ip relates some time and space
        which thing goes into the other,
         how they slope etc. all might matter
       extra how|when|why indexing may pile up here:
        X.iAt.ha.$At.z/A for where &ha,C came from, etc
       in a few steps,
        A:a may other A:b for its own ends
        and|or|which-is become elvised, imposed into there asap
        depending on what function is crossing what lines, etc
      A..A eg A%dome is a self
     
    so
     it can put away like &brackX,
      for multiple n%*
      while noticing refs anywhere already
       thistimes, esp something duplicating
        esp becoming complete in some way (-group) of:
       thattimes, have recyclables
        have goners eventually:
        can be 'ressur concluded' at some point
         trad match t+i @17, see &arriveRbitX
          %Te only match t, so all i are the same to it
          %Te want to accept pointerbits
           and get named (Te.t) more elabourately
           per thing we need to separate
            the arrival of qua to
           we may be able to say C:Thing/-suchapi
            cutting down on At-ness between C...$pi
            expecting any|one|many -suchapi with any name
             or some name, qua besides c&pi='suchapi'
              and not, etc. an assertion.
            delivered from any point in the slope,
             where it makes sense, is grouped...
             drops into the was-implied section of %Te/** growth
           which is the compression
            of X back into C, basically
            the 'I want this and that somewhere in here'
            from sparse tendrils of implication 
            into the tidiest job sheet possible
          
       we may be doing only some of the channel
        which should re-emerge in perfect sequence...
        they will partition by ny&act=T.act,
         see 'ressur concluded', other lateralism
         and &twlic etc, does list gapality
       
       see 'resolve $n'
        
     it is used to find e-pointers
      which is often about deducing how simple it can be:
      &CX: X.t for t-path (the J..C..), having C
      &brackX:
        finding pointers to rows is new
         we tend to &brackstill the overall k:v concat
          while it is considered one big undivisible instant
          then group rows into C when it moments, eg -brackology
           from here we could generate a better-typed likeness for:
        
        could match as simple as &ja,'such,had,keys'
         might have to be all the keys (of a class)
         or be pattern matches that &voice
          &voice climbs trees of mind (the EXPR)
           while climbing chunks of the world
           the basic do sub depending on values loop
           it should walk out over X, measuring distances...
          pattern matches for &voice being transportable
          they would be pointer composing
         or match row cloned from such a row &Xout,$row
         or any other lateralism:
          row from|haswayto a certain A
           eg $dome, or Aip|At bits
           or n-ward to brack without coordinates, from a:
           or u-ward to them -> -groupology get names (in C)
            of the Km.t, having Kmc&rows
          any other X-ing the r is in
          match cloning (&ha,$n,...) from such a row, eg in V.rowrefs
           currently the only way to drop recycled domebits
            when they regenerate
            to have the osc C consistently in memory
           similar to row from certain A
         they could all be turning into an &Xout,{...},{...}
          that Te would instruct
        
        conversely, 'ressur concluded':
         the row might el:9 when these things go unmatched
         resolving the set of seemingly coming+going things
          to changes to their insides,
           when supposed together by homology|similarity:
           it may just have a key changing, becoming el:3
          to minimise overall change given extra expression and context
           things can be told apart by lateral inquiry:
            thing from same dome (A), that D^^A of ours
           or in|through-row|n-ward C having uniqueness
            compared to others in the ambigroup
        
        and be able to notice|react when it next &ha
        
        may adjust their names?
        
    &a-pprehending brack leading into:
        as the X grows it becomes a V
         &ja|&za read each
         parts of V could be
          virtually
           read from many sources, eg &t
           appearing in X already
          actually
           prepared, eg %dome
           preplanted in X already
         by the time
         then parts of X are parts of V
    
        &Kmish
         D&X -> D/** of Km, Kn starting at Dc&brackin
           can now read xq for structures
          they would be via
        %singletter
         elvis that undoes the last input character,
          before inputting another
          so anywhere the meaning of that letter went,
           must be retracted, redone with the new one
           meaning catching the first letter type event,
            multiple times (el2,el3+)
           the oscillator decides to i,-i based on o
          smudge over time to sing
   =cut
  // frontends
   =pod
   lang has instances of cultures at levels
   they share s,c,q
    q mostly, which talks of the whole trip:
    
    use: &ha|&ja|... sc,shade,mix
     perspectives, for most local expressions of truthseeking
     configures probably one:
    front: &a A,s,c,q||={}
     handles that family of types doing what they do
     make many calls, each get it takes
     to something like:
      &Xio,{i:'brack',X||=A},s,c,q
       each spec q.Xio|Xq.t, source X|A
       may change s,c,q completely
       each &Xio translates to:
    middle: &bracki X,s,c,q
     defining with each &qas, climbing them 
      each $n first, then $k|v...
      we can assert|check index is how we expect (down to a point)
     and climbing whatever it needs
    back:
     &qis,X,o,s,c,x <- many $s,$c travel x|X
      read+write X..x as per $xt, with $s, for $c
      s.sc bind params
      s,c new at backend|micro
       re an op on $xq (the index)
      o.xq|Xq...
      o.s|c|q were middle|macro level
       < o.c|q might hook by $xt to ex &qis..c, etc
      are individual to the $xt
   
   the theme of everything taking s,c,q (y,c,sc reversed)
    they may compile as they cross each layer, esp middle
     s.. is likely to be iterated by the middle,
     c+q are likely
      search|thing (what, reality)
       what we implant+excavate
      configurance (how to)
       io spec, complex WHERE, etc
      question
       shared over all layers,
        per use or at least frontend lifecycle
        < track each other over time
          frontend doesnt know what use it is for
          unless they are &h calls (G.h(acgt...)) which G&B...
       may make arbitrary lowlevelations
        may be copying (translating) to another X|x
        may el:9 everything at the backend
        may want to check all X/$n.sc same asap
         see 'the q.still variation'
       limit|replace certain x, who knows what.
    
    leads you to describe the thing you are in
    X is life+death crossing over, once matured
   =cut
  
  // &t
    =pod
        &t
         write search down - Qish as brack c
         find any things (rows) matching c
          go for the smallest set as the one
         write what we read, inc nothing
          do things to get, keep thing
         reads a thing!
     
     //   for &t - little X:parts relativity
          see X:new/$reks
          
          < intro to &clusp?
           def 'u some' -> A.1/u/some
            as a batch (until 'n using..' or &clusp)
            we mix up a %J:
             tv sort|replace $C** as usu
             named by joint(uN,'+'), source list
              cached at $sNorm=A.5/u/some+Normal, lent to others
            $sNorm can have W:Normal dependency
             that we want to make sense of through backroomish &t
            we mix them together like a %J
             also fully state any $of different to u:Normal
          
          X:anI underlaps:
           X:someu has some $n W:some
           X:Normalu has underlapping $n W:Normal
           &clusp
            mix them into
             C:some+Normal/$of**
              re-use C:Normal/$of
               trust that mind will not be tampered
               C refs would be different if changed within:
                sub-mind having been oscillated
                 or loaded from <script>
              new C:$of** if mixing
               because in &voice, we $ofs&z=[D+] around
                expecting lowlevel integrity of C** hardwirings,
                 < unify &voice iterators as X, later
                   swathes $of=common/%sc=rare could be indexed, jumped over
             X:sNu/$of
              knows all /$of
               re-use switches -> X:Normalu/$of/**
               new also has /$of/** 
              to become X:anI:
           X:anI/$of
            if re-use
             rowing switches -> X:Normalu/$of**
             x.Xorm? into the same /$of-ness there
            etc
           so
            first $of from X:anI (then X:Normalu)
             while &t at A**.I=X:anI (climbing slope)
          
          X:whicheverI @Search:
           having X:best, X:maybe, X:sorta
            for three grades of stuff
           goes for the first /$of found
            so eg X:best/$of would be a coherent bunch
             which may mean being mixed with Normal/$of 
          
          &t, while at A**.I=X:anI
           can find each $of from X:someu|Normalu
            ie without having to re-C everything from X:Normalu to X:anI
            see 'X:anI underlaps'
            &T changing a mind, pulls it closer
           
           A.5/u/Normal is W:Normal and Normal.js?
            or some u:some left as a cache
           A.5/n/Normal also,
            is our attempts to push|pull things
            the who|what we want them to be, etc
           
           5/u searches W:u/*
           5/n searches W:*
            may
             push W:u/Normal
              so 5/u gets it
             push W:Anything
              so 5/n gets it
           
           from a distance|angle
            n means production
            u means consumption
     
    =cut
    # Tthing that can wait for it various ways
    # c.modes of async
    fi.t = &acgtsc{
        # s,c may be $of,$t or 'I',$t
        isst(s) && !c and s = {of:I,t:s}
        s = exts({},s,'of')
        c = exts({},c,'t')
        c.t != null and s.t = delete c.t
        # s{of,t} c{el:2}
        $I = A.I || A.1.I || A.4.I
        $q = {}
        $N = fi&Xio,{i:'quest',X:I},s,c,q
    }
    # Itivity of s+c
    # s is Qish quest - look for a thing
    # c can el:9, el:2...
    fi.Xios.quest ||= {}
    fi.Xios.quest.i = &acgtXscq{
        fi&qas,X,q,'k'
        each kv s {
            # the keys
            $kx = me&X_t,X,k,n,'k'
            # have their values via unique id
            me&X_s,kx,v,n,'ref'
            
        }
    }
    fi.Xios.quest.o = &acgtXscq{
    }
  
  // way
    # throw if no

  // apprehend (&ha, &ja...)
   =pod brackio
    do as &bracki|o do
      we create a new $n picturing:
      s.s|shade|mix
      s.s=C might be cloned,
       %%dome and all the usual effects
      n.c knows of other stuff:
       row is recycled
       was entered by some A...
        there is an inside, &ha while Dome is 3
        must be siphoned into the self sometimes
        instruments producing brack when acted on
         other bracks below the line
    
    mere Ds&z=[$n+] (and &brackX) becomes:
     
     X/$n and X/$k|v|ks
     
     X/$n = xn - ground everything else
      an index for $n itself,
       that also for x.z/$n, out there
        these two 'for' resolve $n to each other
         usu effortless|already done
          as in &bracki rows causing all the x
           they are positing the x as inhabited
          or a part of your process
         maybe coming,
          or partly out of control
          esp if working from analogue distances
           of beyond one X|A etc
          like we put things in the big A.c
           to make them famous
           a kind of nobility is supposed,
            creating a wave of negation out there
      
      join X/$n from x/$n
       to get its sequence, and more:
       
       X/$n/$ks may exist
        or
       X/$ks can be made to look like it
        with $n-clausation
         being $ks/$n but sorting $n/$ks
       
       on the two /$n senses:
       
       X/$n is X.n[vi]=xn, uniques $n, type='s'
       x/$n is x.z[i]=$n, dupey $n, type=~'z'
       interesting. to write:
        x.z/$n, we def mean the latter
        x/$n, may join x.z/$n to X/$n
         or maybe,
          x.n[vi]=xxn ?
      
      any x/$n should also be in X/$n
       (for both those /$n senses)
      you join X/$n to get its sequence
       any X/$n/... are also there, indexed per $n
       
       X/$n/$k or $n-clausation slomo
        vis. X/$n = xn, xn/$k
        basic premise:
         having $n*, wanting $k*
         may be specified or wide open
        exists:
         xn/$k = xnk
          a copy of what it contributes
          xnk != xk (X/$k)
          might even link:
           xnk.xorm=xk (with other $n)
           to get to X/$k
           see 'x.Xorm'
          at least clues $k index
         X/$k = xk
          knowing already some xnk.z/$n
           amongst others in xk.z/$n
        else:
         simply grep $n in X.k..xk.z/$n
         so:
          it always works
          see 'X/$n/$answer already written down'
        so:
         we carry the $k from xn to X
          or the $n from|to any x.z/$n
       
       X/$n:spec/$k/$n
        $n:spec could be found in X/$n
         or we might grep $n in X/$k.z/$n
        either way some lowlevels appear
         its position in:
          X/$n - where to get to the row before, etc
          X/$k - keys defined by any node in order
          X/$k.z/$n - nodes defining keys in order
        so:
         we can always get more|less $n|$k|etc
         and join that rowsense somehow
         use whatever X.** mechanisms
        solving:
         eg X/$n:spec -> xn && xn.k
          means we can xn/$k = xnk
          carry the $k: X/$k = xk
           xk.z/$n:other
            $n:other having any particular $k that $n:spec had
            sorted by $k
             $n duping would be avoided,
             < rowsmush would squish blobs to fit things between
          swimming
           around to wider|narrower spaces
           how to traction one view on another
        
       about: parallel spaces and subselecting
        x is posited as inhabited by various $n
         x.z/$n specifically found it
         
        can always find an index to|from $n
         simply looking at any x.z/$n
         and applying it to other x.z/$n
        
        ie, having the X/$n/$answer already written down
         or falling back to grep for it
          or even invoke &answer to generate it
           modulating an index full of answers
            waiting to be needed
            lazy evaluation
        
            note on X|x/$n sequencing getting mingled:
                     because xn groups by $n
                      X/$n -> X.n[$nsi] = xn # per unique $n
                      x -> x.z[$i] = $n (not xz) # dupey, all &a...$n
                     sequence loss into X/$n:
                      n1, n2, n1 -> xn1(x2), xn2
                     restorable by join to something in order:
                      o X.z/$n o xn.z/$n
                       X.z=[$n+] every &qis c$n ever
                      see conflating of which $n
                      and unlocking assuredness
                       about the vectors
                     
                     X.perience/$n of its own order
                     X.z/$n ordered by time of &qis (supposable?)
                     X/$n once per $n, in order of appearance
                      order might impose to X.n but not X.nv (refers)
                       from X:old->X:new
                     #   s/ns/nv/ for plurality of n values
                     
                     eg
                     X/$k/$n out there can find their X/$n/$ks
                      $n being the join around X.**
                       ie $n cluster at found x
                        many x join many x/$n, out and back
                        x/$n finds $n finding x 
                     X/$k/$n/$ks
                      may work for notation
                       from a $k*s $n*s $ks
                       knowing to join by $n back to:
                     X/$ks where $n
                      X/$n/$ks might clue|copy a lead on $ks bits
                      or take X/$ks and grep for .z/$n
                     easy.
                     
                     waves of X..x come as per $n
                     
                     how much of what is an artifact of iteration
                      and how to de-warp it when per-somethinging
                       what to take as now
                        in the midst of the machine that changes
                        ie might want everyones %colours
                         to make a palatable difference
                     
                /note
     
      exact X/$n coming around again is to el:3?
    
    < dev
     < &bracko as usual.
      not for the moment needing to:
     < io paths
      the boundary / crosses may be:
      s.N/$n - an array of $n
      x/$n - the rows with something at x
      x/$n/$k -  joins to X/$k by $n
      $n+$k may be specified or wide open
       ie cause where as well as select
       they are notated like bind params
        say what index|column to join to
         since it is no longer always 'z' (tv climbing)
      < brack has $u%n = $n hierarchies, sorta
        would be $n:lower/$u:higher
    
    also:
      the q.still variation on any middle:
       &Xio:i:brack s.N/$n q.still=1
        we would pass all our rows
         to refresh the index,
          either in place or by making X:diff
         like &brackstill, simple as for speed?
          each X/$n (row) remembers the many {k,v} it had
          each $n again:
           resolving $n is easy (ref)
           alt xq.i(...) makes list of new {k,v}
           if cha,
            T.whack out of &bracki to:
       &Xio:i:brack s.N/$n q.still=2
        checks bunch of $n for re-read
   //    resolving $n is easy (ref), or: (+ X/$ks name pooling)
         starting with more specific X/$ks (name pooling)
          expressions
           shared by many|one $n
           there is usu a way to refer to an exact $n
            eg '%part=4'
             smooth variety of %part across $n is interesting
              the i X/$k/$v would notice
               having many x.z/$n last few of its x were .z.length==1
               conflating the possibility of using $ks
            eg '%%what,it,is', whole + ordered
             # sorting by $k may detect renames amongst a few 
            # probably conflating:
            eg '%%what,it,is...', parts (ordered but not /^/)
            eg '%what,is', parts (ordered?)
            eg '%', having sc at all
            eg '%%', being brack, as wild space blends with C
            and more expressions
             eg '%%what,it,is..' is leading into is (and whole)
            anything &brackology can make string
           anyway
            generates many X/$ks per $n
             a bunch of usuals,
              like t, t+cv, and see below
             until finding with no ambiguity
              X/$ks.z.length == 1
             finally give up with:
              X/$ks='%%same,things'/[8] -> sequenced
              X/$ks='[8] %%same,things'/[0]
               like footnotes
                and a multitude|point controller (%Cit) to you
               extra nametagging
                from an alien language
                 since our closest $ks is still ambiguous
                 and our $n-sequence within it
        so X:old
        emerging new in X:diff (partly?)
         with X/$n|k|v|ks like X:old
          since X:diff being q.$moded from some middle,
           we end up with their structure+order through &qis
         each X/$n** fully like X:old
        the create as
        we notice things,
         sooner or later (resolving $n)
         makes X:diff/$el=1-3,9/$n|sc|k|v probably
         maybe X:diff/$alterity measures
        so we can have little X:parts
         putting hypothetica, structure embeds
          on branches
        
        sequencing $n across things
         &qis $n is a dome
          with &qis $ks|etc before the next &qis $n
         &qis can be
          reading|writing any other index
           with each $n|$ks it is given
           ie in a loop that may be dimensioning around,
            middle|back could tail call
             and other &voice lateralism
           as neighbours (particularly in sequence) arrive:
            o $n:new/$ks o $n:old/$ks
             not knowing $n:old at first
              join by X:old/$ks
              which $n:old can be found in relation to,
               ie select $n/$ks from $ks/$n
                sort by X:old/$n
              making sizups:
            i $pairs/$n:new/$n:old
             as in '. appears to be the new .'
              then fill out
            i $similar/$pairs/$metrics
             each degree $similar (sort|dividable)
              per $pairs,
               specifically $metrics
            would make picking most similar pairs,
             satisfying all X:new/$n
            see resolving $n
        
   //    resolving $n
           eg X:diff.finds/$n:new/$n:old/$ks|$k
            these are our neighbours|similars
            all new $n,
             having $ks|$k
             remember old $ks|$k
             leading to pluralities of $n it could be
             all lining up ok
             by being the most ideal:
              sort by homology of $k|etc,
               making (maybe many) guesses at $n/$n
                maybe many shouldnt happen if you $tv:n
             if maybe many
              each $n/$n guess
               weighs into $n/weigh/$n/**
                incubates strategies for
                $n being the future of $n
                which itself gets measured for complexity
                 of $k etc change
                 it making $n/$el=9/$k microbits etc
                  like the A:diff miles below this indentation
                  but already wrapped in individuation (one $n/$n)
                 so it is easy to draw it out,
                 producing X.** with a shape
                and places motile plans for changing what was (lv)
                 where sequence is a big clue, re el:8
                  and a bunch of impressions of sequence
                   might be looming around
                   like reading a random list (A:new),
                    noisily remembered from A:old
                    notice groups of loose|tight sequence
                    and when their order|direction changes
                    see 'have their $n in the others gappy order'
                 where order changes:
                  putting new at old
                   notice $n before|after $n factfluctuation
                   12, 23, 34, continuity buildup is good
                    would conduce when a $k is moving between $n
                     otherwise that ^
                     would have the $n swapping histories
                     to remain with $k-continuity
                  < &T substraction, break down into ...
                  sequence materialising somewhere
                   at &a q.seq=$seq
                    is seq eventually X.seq?
                    is it $seq/$X/$n?
                     each $X:old|new
                      have their $n in the others gappy order?
                       then x.n.$i to X:new.n.$i
                       form groups from pairs of $n in the same order
                        by simple x.n.$i+1 to X:new.n.$i+1
                         having the $i from $n, to put $i in X:new.n
                        ie $n:oldy&nexty&future == $n:new
                      might form $m - groups of $n in an order
                       suppose $n could mean bunch of $n:
                     
                     may calculate some facts: (see 'weigh')
                      $n/$fore:n or $n/$aft:n
                       $n < $n or $n > $n, list-wise
                      $n/hops/$n
                       $n crossing $n might happen|matter
                      $n/$distance/$n
                       looking for small distance
                       consider magnitude of fluctuation of distance
                       are we spraying pixels between bulbs?
                      $n/van/$n
                       neighbour change (lost|became $distance=1)
                       named for summer travels aspect
                      $n/neigh/$n
                       the nearest in any direction
                      for lazy:
                       evaluation, when io calls for it
                       calc for continuous groups $m
                        rather than $n
                       divisibility is a big thing
                       more $m in|amongst|over other $m:
                        given an error margin to group by
                         cell dividing before the error margin slopes right off
                          lum per $n
                     
                     delimiting bunches of $n (lv)
                      with the few $n we mention
                      could move the lot around
                      eg lv el:6...el:8
                       finding the $n for el:6 that begins it,
                        until the $n for el:8 being after it
                       new 'position implied'
                        usu after last el:8 etc
                        may nc&from=$xpath|$ks
                         which may be a part of lv** we are yet to wake
                         may correspondingly el:9 over there,
                          if further|slopier than some amount
                          this is like being introduced as from somewhere
                          that somewhere able to answer for your leaving
                      eg lv el:4
                       renamey, non-moving
                        eg X.$tv:n, changing an n.t or ny&cv
                       old 'position implied'
                        usu after last el:8 etc
                        may nc&renamed=$tv|$ks stringifiable
                         then we could move as well,
                          to the 'position implied'
                      so:
                       el:6 + el:4 (move and rename)
                       and making a 'position implied'
                        that resets or changes direction,
                        could be as simple as:
                         el:8 moves pointer back to that:
                         we el:4, el:8 to where it goes,
                          el:6 it there with that new name
                        each thing should rename only once
                         per parent el:8, which can be inflated
                          to get smooth layouts of sets of change
                  
              sort $n/$n guess
               at some point
               with weigh in it
                inc what has happened to the order
                lv-friendly cursoring or not could be fast to compute?
               should be most intelligent to each $n
               anything not perfectly divisible|reasoned should &T 
               
               and having already done that for the last $n,
                so sequencing may reacquire itself
                  q.seq also connected to $dome, Dome
                   so we can continue it
                   so could be super-&a
                  so:
                   < array diffs with moveless or identity economy
                   < Xio.lv $C $N alluded to
            
            so: ref easy, name(s)...
              finding $n usu same ref easy,
               may have to find ny&up=$n by the time X:old
               they can be checked while held in a dome etc
               they get lost every time they exists
               have to know a unique name for them
                perhaps X/$ks - a pile of autogen names for nodes
                 they could divide themselves by adding to their names
                  ~ what &brackology is supposed to display a field of
                 they could easily find themselves apart,
                  with a sequence number after envelope
               yet like linear sequences,
                would call a stream of them wanderable
               anyway
               we probably have x.z=$n still,
               or resolve $ks to an $n
                < or go by homology,
                 another dimension of similarities in deeper ..x sprung?
                 or sequence conservation
            also:
             resolving $n with a namechange is a big deal:
              must be preserved carefully across many X
               eg X:new/$reks
                recent|most-likely $ks that changed
                translating pointers of X:old
                 for e running late, get el:4 round trip, retry
                low priority
            
   //    rand + sum resolving $n
         rand
          from revoked imagination of:
           $h = a hypothetical /$n x
            they might h&commit at the end
            to be revealed at the end:
             soundscape of z|zh
              electric and gas
              the point the letter changes
               pronounces boundaries as sound disconuity
                whose country imports these
                 who takes the art home
          
          see X:new/$reks
          
          X:specialeffects extend:
            it could be bound to rewriting wholer chunks
             eg X:anI serving each $of from several index
            it could make an interspersal only
             pulling up facts on how they change order
          
          X:selfscape
            many of its parts taken together
            correlate to parts of other
            wide angle lense on morphology
          
          if you needed more name
           (unique stringable discernment of eg $n)
            see resolving $n
           and those names could include X** pointers,
            but dont|cant include X.n.$i,
           no enough entropy in X.**
            you would &T up the intensity of $n** -> X.**
              growing projections inside $n, of local types
              engaging possible introspection|expansion
             their detailings would all be subject to process etc
              being actual occasions
                    
               to split atoms by whatever is keyish()
                eg '%same,things:C' using X/$k=things$visC
                 providing the bool isC() to draw -brack@101
               # with a note on sequencing, X&ip
               
              cant find any index to 
               might be played upon in the chat room
                ie things you create similar to otherses,
                 appearing mergey with both codes trying to patch in
            
         sum resolving $n
          usu find one $n:old for each $n:new
           everything is lost and reappears
            cant trust /$n sequence
           X/$ks may do this if keys arent moving
            $ks has a few codified names for the thing (strings)
           X/$k|v can find+sort $n with most in common
          based simply on the ideal name for a thing
           $n == $n:old most ideal, native
           the enclosing X:osc/$n you are likely to encounter
          
         finding a match for $n
          happens while we ...
          try reasonable combinations of old<->new $n
          then pick the least X:diff-icult
            having its 
             for $n, as we have probably limited,
              find X:old/$n by X:both/$ks or etc
             then A:diff/$n arrives, where it always was
               ~ bless
               along with A:diff/$n/$was,
                about knowing a previous version of itself
            
            genera standards and 
            this pressumes light into places
             to be passing qualities between $n in its conscious mode
              the seeming cellular exchanges of %these
               and their depths and approximate shapes
               play identity swaps
              vectorial qualia like things
               make infinite fields of X:diff for C
          some spaces will have things to reset
           when boundary conditions on the k,v etc
      
   //    X:diff - proper &brackstill
         we have an X:old rebuilding to X:diff for $n**
           re-indexing C users might have altered
            you should e C alterations
             esp if A far away (like they notice)
            usu Dome_7 do so
             warn when cha surprise
              brack rows not supposd to change?
            everything should use a thing that X|A interacts
            ie you osc in remote things,
             change them,
             have changes returned
          
         compare thing for key|value of X.**
          making the standard X:diff
         alt xq.i(...) finds and compares X/$n|$k
          see resolving $n
          compares may be expressed with X.variations
           sets of meaning
            like &a Xq.t='brackdiff'
          X/$el=2/$ks
           meaning it got a name unique to it
          X/$el=3/$ks
           one of its names changed
          X/$el=3/$k
           one of its keys changed
            maybe independent, if renaming sc.*, to:
          X/$el=1/$v
           one of its values changed
          X/$el=9/$k
           vanishing keys, must have a values disappear?
          X/$el=9/$n
           vanishing $n
           X/$el=9/...
            has everything it had
          
         
          X:diff.* might become X:new
           at the end:
            backend replication of X.**
            grouped by $n
             making X:new/** come out in sequence
             though it is mostly X:old
           or even when you o for it
            X:new/$search/$Xpath = X:old|diff
            X:new entirely outsourcing content:
             X:old = entirely
             X:diff = the updates
           
   =cut
    # &ha el:1, &ja el:7 (this-time), &za|da el:8 (the-time)
    # &da should emit nearly lv
    # < &bracki|&bracko
    fi.a = &acgtscq{
        # may be &a,sc,c?,el
        s = peel(s)
        num(c) and c = {el:c}
        c = peel(c)
        num(q) and c.el = q; q = null
        q = peel(q)
        c.el ||= 1
        
        # s can be a row, pipelined
        isC(s) and s = {src:s}
        else
        # exts s as sc unless stated (+ others...)
        !s.sc and s = {sc:s}
        
        # s.sc ||= s.src.sc
        
        c.el <3 and fi&apprehension_1,s,c,q
        elsif (c.el == 3) {
            # < el:3 could src=$n, sc=changes?
            #   or with s.src|sc to change, s.new|diff|gone=sc
        }
        elsif (c.el > 6) {
            # looking for something
            q.rowt = 'looking'
        }
        else {
            # < el:9 would disaffect|disconnect u|n
            #   the pipe would know how fast different patches dry up
            #    if they hold water by sheer existence, etc
            #    output of a computation fading away
        }
        
        # have a row, even for questions
        $n = s.n = Cye([q.rowt||'abrack',1])
        n.sc = s.sc || {}
        
        # row pipelined around
        s.src and ny&up = s.src
        ny&brack = A
        # < does anything ny&R?
        ny&A = A
        T.act and ny&act = T.act
        
        c.el <3 and fi&apprehension_2,s,c,q
        
        # enter|rummage
        # < fi&oi,s,c,q ({i:brack}) develop a query with multiple mediums
        #   s,c,q making waves of conversions, for arks deduced from pi
        #   these are sc,c,y of course
        c.el <3 and fi&Xio,{i:'brack'},s,c,q; return n
        else fi&Xio,{o:'brack'},s,c,q; return q.N
    }
   // s.* for &a
    # < rename a_i_1, etc?
    fi.apprehension_1 = &acgtscq{
        s.shade && isst(s.shade) and s.shade = peel(s.shade)
        s.mix && isst(s.mix) and s.mix = peel(s.mix)
        
        if (s.src) {
            $src = s.src
            if (!s.sc) {
                $sc = s.sc = ex({},src.sc)
                # < retransmit only such classes of sc
                $mix = s.mix
                if (c.noeto || mix && mix.nodeial) {
                    mix and delete mix.nodeial
                    delete sc.efrom; delete sc.eto
                }
            }
            else {
                # < el:3 could src=$n, sc=changes?
                #   or with s.src|sc to change, s.new|diff|gone=sc
                throw "src+sc"
            }
        }
        
        q.rowt ||= 'apprehension'
    }
    fi.apprehension_2 = &acgtscq{
        $n = s.n
        # mix mix -> n.sc
        each kv s.mix {
            n.sc[k] = v
        }
        # mix shade -> n.sc for a while
        s.shade || s.src and me&brackshade,n,s.shade,s.src
        # < el:2 makes its %%dome not expect redo,
        #    can replace it into there, certainly if el:3
        #     curently only if s.src'd from a c&recycled one:
                # < indexes enough to conclude that it's that
        ns&dome and me&dome_bracki,j,n
    }
   
   // Xi brack
    # index n by n%*
    #  X/k/ref(s) enumerate columns and their values
    # ongoingly to index N-news into X
    fi.Xios.brack ||= {}
    fi.Xios.brack.i = &acgtXscq{
        # binds to q.Xt
        $qas = fi&qas,X,s,c,q
        
        # z all rows, in order
        $Xn = qas('n','z')
        
        # each .sc.$gk as a name had
        $Xk = qas('k','t')
         # all via different xo are to the same xo-space?
         $Xv = qas('v','s',{via:[Xk]})
        
        # < inflating an A with millions of 'string'.length
        $N = s.N
        N ||= s.n && [s.n]
        !N and throw 'brackin?'
        each in N {
            Xn.i({n},{n})
            each kv n.sc {
                # the keys
                $kx = Xk.i({k},{n})
                #$kx = me&X_t,X,k,n,'k'
                # have their values via unique id
                $vx = Xv.i({v},{n},kx)
                #me&X_s,kx,v,n,'v'
            }
            # all our t x.z/$n anded might lead us to similar sets
            # so will s, earlier use might get to know about later
            X.z && X.z.length > 1000 and throw "Giant brack",s
        }
        return X
    }
   // Xo brack
    =pod
     e
    =cut
    fi.Xios.brack.o = &acgtXscq{
        # s.n - u-ward, what has this as n
        # s.u - n-ward, what has this as u
        # are two types of row-row linkage,
        #  that don't require the row to know %%n anymore?
        
        
    }
  
  // &Xio for &Xio for $Xqt
    # {i|o:$Xqt...}:q {thing} {how} {}:q
    # could be any medium|indexing (Xqt)
    # per direction (write+read) (Xio)
    fi.Xio = &acgtescq{
        
        # q.Xio|Xq.t <- e = {i:'brack'} || 'brack'
        typeof e == 'string' and e = {i:e}
        !e.Xio and e.Xio = haks(e)[0]; e.Xq = e[e.Xio]
        isst(e.Xq) and e.Xq = {t:e.Xq}
        q ||= {}
        # q.Xq already may know a previous &Xio
        
        $X = delete e.X
        # < Babz
        #X ||= delete e.A
        X ||= A
        
        # become A&X
        isA(X) and X = Xc&X ||= {A:X}
        
        # < ac q.allXio.$Xqt
        ex2(q,e)
        
        # know medium by name Xq.t (a=brack,t=quest,etc)
        $Xqf = fi.Xios[q.Xq.t]
        !Xqf and throw "!Xqt:"+q.Xq.t
        # of the ways  at the ground (i|o|etc)
        $Xqfio = Xqf[e.Xio]
        !Xqfio and throw "!Xio:"+q.Xq.t+"."+e.Xio
        # s is the unknown, used
        # c is mostly talking to the medium
        #   may c.where, c.sort etc
        # < q.Xq becomes the ongoing structure
        # q.* talks lower-level storage mechanics
        #  c.where compiled for xt-matching
        #   maybe sorting|weighting also
        #  q.for.t={el:9} should delete the X.t.*.z/$n?
        #   you should provide deletes about * + $n,
        #    over an interface that can receive el:6 (moves) etc
        return Xqfio (A,C,G,T,X,s,c,q)
    }
  
  // &qas enters|uses an X schematic for &Xio for $Xqt
   =pod &qas,...context -> qas(..schema) -> qis(..bits)
     ' entering an X schematic
     when the thing is as vague as it gets
     windows of noise manager
     traces of unique identity are named:
    X.Xq.$t = Xq
     Xq knows about ways into X:
    Xq.has.$k = xq
     xq describes index at X.$k
     xq.depth ||= 1, eg X.k.$scgk = x
     explicit notice of plurals
       eg X.ref refers to X.refs
      and other contrivances|hierarchies
     so we can find all $n in an X
      for generalised what-is-here
     and it may stage|re-stage changes
      el:2 or el:3 modes
     
     X itself is universal,
      names, keys and values (&X_refer) index between X..x
      many of them at once
      may converge on the same x.z.* via many paths
       < changing the set of columns per coherent set (&brackology2)
         tree-like thing, adding y&... walking
      puts its self-knowledge under X.Xq
       < once X is C, X.sc=X, X.c=X.Xq?
         so any X.c.*.has are Xq, else other c.*?
         then X.sc.t|y|c|sc.* are about some C.sc.* existing
          without isC(X.sc), since isC(X)
          so we can have C-like indexes
         since any keys, including C nks,
          can be used as the something
          the only place to not mistake 
          and X.sc wouldnt be mistaken for a CX can then know X.y|c|sc without being mistaken
      may have hooks, input handlers
       could affect anything, starting from X
        to get to the voicings
       notice them in X.*:
        X.ih=C for &nodei etc instructions
         how to clone|construct given C
        X.e (or y&A&X&e-ward from anywhere)
         est. elvising here
          &n may autovivify them
          eg bringing %ope etc
          can pointer to un-A|C-ed space,
           using whatever X.* the thing is in,
           leading through many layers of X
         staging changes to things
         is 
     Xq  per high level indexing org (Xq)
     xq  per index at X.*, how to get to x
     x   at the end of the index,
       having a bunch of values pile up there
     
     guide to X..x, and what x.z is, etc
      < conflict with structure|names already there,
        separate A to forward rename
     
     
      devolved to limbs they used to work with
      fear & greed controlling the world
      escaping the reality through intoxicating substances
      the main audience is 18-29 year olds
      so they can get involved in the projects
      an eye opener
      a situation with a way out
      to set up an animation studio
      low key independent 
     '
   =cut
    # est org at X.Xq.$Xqt = Xq
    #   for highlevel $stru-cture sharing (Xq)
    #  Xq.has.$k = xq, about X.$k
    # returns an xq creator with Xq context
    #  
    #  observe|comply to parameters of the index
    
    fi.qas = &acgtXscq{
        X.Xq ||= {}
        !q.Xq.t and throw "!q.Xq.t"
        $Xq = X.Xq[q.Xq.t] ||= {}
        Xq.t = q.Xq.t
        Xq.has ||= {}
        # < Xq beyond just {t:'brack',has:...}
        hak(q.Xq) > 1 and throw "&qas...q.Xq.* instruction"
        q.Xq = Xq
        Xq.up = X
        # may bump into e pointers from here
        # A.1.Te%catch.A.Xqt[Xq.t]
        #  which we would then go and find out more about
        #  every time we begin to ... at X space
        # pointering Te to things begins with the Xq we found it in
        #  probably finds the attachment type satisfied
        #   by a higher level connection|trigger than Xqt
        #    eg &ha would Te%catch.h.ha = Tq
        #     Tq then has indexing matching $n
        #   be used to notice how many whats are going on
        return &hue{
            # already inside Xq.t, eg 'brack'
            #  h.t -> u.t, X.$xqt base name for index bits
            #  u.t -> u.type, &X_$type index building function
            # both are required
            isst(h) and h = {t:h}
            isst(u) and u = {type:u}
            # hu are cq, for Xq+xq
            u.t && h.t and debugger
            u.t = delete h.t
            !u.t and throw "qas()!u.t"
            !u.type and throw "qas()!u.type"
            
            # some culture|habit can org there
            Xq.has ||= {}
            $xq = Xq.has[u.t] ||= {}
            xq.Xq && xq.Xq != Xq and debugger
            xq.t && xq.t != u.t and debugger
            xq.Xq = Xq
            xq.up = X
            # < find same xq.t amongst Xq.t
            # < hook up data smush patterns|memory for these *->u->xq
            
            # xq.type may be known, may compose many?
            # isfu(is) made more complex if %Te wants
            $is = fi.xqtypes[u.type]
            is and ex(u,is)
            
            # e more for xq
            if (e)
                ex(u,peel(e))
            
            # array merging, for Xq.via
            # < immutables: mex() q.ek, etc
            mex(xq,u)
            mex(Xq,h)
            
            # compute how it is
            # xq.sc - ordered hash of arks,
            #  to qis() s.sc, which may then be out of order
            isst(xq.sc) and xq.sc = peel(xq.sc)
            # xq.N - list of arks
            xq.N and xq.sc = hashkv(xq.N)
            # usual depth of one, must be keyed by xq.t
            xq.sc ||= hashkv(xq.t)
            xq.d = hak(xq.sc)
            !xq.d and throw "no size for xq:"+xq.t
            
            # value entry
            # at Xq+xq, micro to the &Xint|out s|c|q
            $o = {Xq,xq,s,c,q}
            xq.i = &scx{
                return fi&qis,X,o,s,c,x
            }
            
            return xq
        }
    }
    
    # what can be known about fi.Xf.t|s|z
    #  mix xq.* for xq.type
    #  xq.hashy|array - index material
    #   length of ^ based on:
    #  xq.sc - what qis(s.$k) (arks) to want
    #   default s[xq.t], eg s.t=$t
    #  xq.refers
    fi.xqtypes ||= {}
    fi.xqtypes.t = {hashy:1}
    fi.xqtypes.s = {array:1,refers:1}
    fi.xqtypes.z = {array:1,selfin:'multix'}
    
  //  &qis climbs X for $s for $xq, doing $c
    =pod qis(..bits)
      write or read (autovivificatorialy)
        X.$someindex ||= x += $n
       leading to x, another|inside X via $someindex
       x remembering what indexes it is in?
        joins|varies by x.z/r,
         the members being added to x locatable space
      
      similar to io.input()
      
         supplied arks as s.sc is io usual
          doing without the odd one should work
          having the index in a few shapes
          so a row can have gaps, wildcarded at x|X
           eg S Rhythm o $had/$hadnt/$has, when we can find had and has
            since X space isnt singular,
             we may be climbing two structures towards each other
              as in KnowThee
              where nesting io expressions (in|from eg S o ...)
              pull things towards each other for zapping to bits
               in X:Rhythm (re-selecting)
                X for rows forming,
                finding x (real or wild, here or there)
                 for some vectors of climb+exp
                having vectors of Xspaces involved
                  and other qualities like %mot, %may:el2
                of the solving branches
                of many parallel X..x (via loop, on $q?)
                 in rows,
                  which is expected to perceive 4d
                  X:Rhythm joining x:Match to maybe x:Found
                   it having no $hadnt x:Found ranks in x:Match
                    not-iterating, unless e handler for:
                     the few io exp in an S exp make a schema
                     it may have a sub-S to handle low-matches
                     or simply &nodei %%may:el2 for simple
                     or emit %mot:2 across that S exp of schema,
                      to whatever is almost connected to a possible $hadnt
                       leading to more possible %mot:2 desirees
                     so the S exp
                      made of io exp
                       arks|thingnesses are from params or other io exp
                       and how they relate. thus, networking
              
              X:Rhythm
               keeps track of any warp,
                such would slow the process for e introbility
                sorting by well-sorted-ness usually,
                 and what that sorting is
                as it makes X.. -> rows for io
                a process similar to:
               some x could include other x
                alt .. of X..x
                 perhaps into|with an other X|A|J also,
                 bringing an X into a %mot-or
                shuffling the fronds:
               
               X..$xy/$x connects another X..$x to there
                ie xy.z/$x, as opposed to $n
                 meta X.xqy[xy.t] = $xo
                  $xo informing of:
                   $xy having $x separating from its origin
                   how $xy differs to a normal $x
                   ie xo.zis='x' means xy.z/$x
                    all x having z index to the real item
                    might involve replacing all [old_x+] with [new_x+]
                   < have|index where clauses for the found $x(.z/$n, etc)
                 and|or:
                 meta X.xepart..$xo,$xy,$x for more complex vec
                  $xo must track places $x propagates into $xy
                   could be along X..$xy.. somehow
                  could leave the X|A|J
                   with &e facilitating wiring to versions, downstreaming
                   very any-pointey:
                    could be relating to multiple others
                     with ways in between, leading out, etc ad inf
                 so
                 you can call in your X.xqy mind if you detect any of that
                  eg to simply delete downstream x-propagations
                   may slow to examine X..$xy
                   an xy may contain weighty evidence etc
                
                seems usey for condensing %Te pointers to those x
                 by ..xy, tussled until consistent
                 knowing xy.xq is how we coord our selection of it,
                 xy.up=X=x.up
                 x.xq is how they coord themselves,
                  which we would get interested in
                 might have some traces of processes involved, why not.
                  they may be findable via x they leave around...
                 eg
                 so X.t.$t = x, x.z/$n
                  is primary (C.t index)
                  the x.up=X and x.xq describes X..x
                 so X.allx.$i = $xy, xy.z/$x = X.t.$t
                  following an x entails el:9 when+how etc
                   by some protocols gathering on x by xq
                    the various "collecting", "breakdown-of" set order
                   and being able to restate those chunks of spacetime,
                    through the time+name system
                    from the X perspective,
                     and across the network with other objects (&Supe*)
                      that are making %mot:2 etc
                     tracing its will to do anything.
                  complementary legs
                 so X.allX.$Xi.allx.$xi (two xq.type=s) also
                  for X knowing another X contains x
                   X&A and x&A can slope around
                   how to follow through time,
                    X living longer than x it knows about
                  the downstreams could be pointed to,
                   given a storable climbing-X|A exp,
                   with snapshots, many-X-shaped diff making...
                 
                 these could point further, have more index(s):
                  many X.** include various properties to X
                   eg having rows to include at some distance into X
                    eg x:wild, hops multitudes across gaps
                   eg do hooks, where|when they are located
                    their locationing becoming more specific
                   eg alternative views through schemas
                    of rows rearranged from main thing of X.*
                    very one-many spaces
                  constellations of X.**, cluster to put separate:
                   relatings to rowlegness|reason|positions
                    of more of these X.** structures
                     eg X.leg/t/$t/$xb.ness/'rowleg'/$xc
                      leg specifies eg the rowleg-ness, for row-smush
                       is for X.t/$t/$xa, has all the intent in $xc
                        which may not include any r (smush-config)
                       just to inflate to $xb gets us $xa,
                        $xb.reason, simple or complex: to $n:D joining this
                        $xb.positions of $xc involved, maybe classes in between
                        $xb.voicing of anything climbable with &voice
                        $xb.ioing of A&op - should from A:S climb into
                         the io exp and any state a downstream io might pry
                    so, having those qualities on a thing,
                     generated by the matching in io
                     that relates to where|how the match happens
                    and indexing some of them,
                     splitting up by desired uniqueness
                      usually to speed up or compress information
                  to become notions of light (x.r+)
                   travelling through space (X..x)
                   to be retracted from a downstream, eg X:Rhythmatics
                    at the &Xout el:9 level?
                     hooks would bring it up
                  
                waves become nested:
                 short lists of $very/$specific/$mediation/$before/$thing
                 become long lists of $vague/$pile/$thing
                   X.fqdn>2name>1name
                    verbosities for calling uniq items by attributes
                   X.tv>tw, tv>z
                    for which index can deduplicate others
                 
                 correlating variations on the path:
                  to thing, x.z/$n
                   $n (row) may be in many x
                    per its traces of stuff in Xspace
                  to complement,
                   eg X.align.abc.ac looking at Xspaces (rowspace?) to align
                    X.abc is a longer trip than X.ac
                     X.ac..x might talk about X.a that are binding to X.c,
                      with x.$clue for finding X.a|c,
                       selecting within them and imposing anything to u|n there
                       an ongoing theme, this ^
                     X.abc could be that relating through time?
                      has an as-time and through-time element|X-ness:
                       having proxima (types of nearness, quantified)
                       modulating, graph labeling over local extent
                     adding dimensions|layers of X perceiving X+
                   that there is a meaning possible
                    to be believed in
                    eg X.dome[r%dome].z/$n partitions $n elsewhere
                     making groupable how they are available through X.*
                     by aft-X..x filtering of x.z
                     this maybe-$n, ever-$x awareness
                      must line up with:
                       eg expecting to find history for structures
                        we have started taking apart or replacing
                        ie at what point do your limbs dreams
                         stop getting implanted in the over-limb
                   being equated|aligned and
                    what it is to mean is a whole other X
                  X..x being varying lengths
                   and qualities to A
                   bunches of it being grabbed at:
                  %dome recycles $whole X and replaces a $part of it
                   the old $part going somewhat offline
                    via our A and its new X perspective on what is at $whole
                    only available in certain senses once dome begins,
                     to those wanting to remember what it was
                   pushing stitched up X:$whole
                    A harvester
                   < generalise from per-n%dome
                     eg x** cursoring any areas of X.** we are to re-get
                     a where clause
                   $whole is like a git tree
                   its index contains all $parts
                   some being supplanted by newer $parts
                    existence of newer $parts comes via A
                     usu r%dome specifies which ..$parts are being stated into
                     having previous $whole..$parts to work from
                     being able to CRUD individual $parts..$part
                      as in lv, yet X.**-arbitrarily
                    being able or willing to CRUD X:
                     redo $whole for $parts (new X..x hashes)
                     delete $whole/$parts (X.. tidied)
                    depending on mergibility (Dome@3)
                   you must figure that by some x.z/$n being %domed 
                    and knowing its a certain X..x from before,
                     possibly amongst a set of dupes (hak(x.z)>1)
                      that arent duping anymore (due to sleepy processing)
                     what gets you into sleepy processing
                      ie C-pointing $part to adjust
                      must also say only that $part of $parts changes
                       more developing needed when T.dup
                       may be A:e to a name that is now a plurality
                       convention to leave the first one,
                        or does name@1 split into name@11,name@12
                   anyway, can redo parts of X..
                    for given pointer|ranges,
                     which become|avoid ambiguity
                 that seems to be including space we can re-include...
                 and when|how to propagate &Xout el:9
              
              the bits being the found things between X..x
               always broken down by thingnesses we can string up
               at the end of each rigid geometry thinger X..x
                x is coorded already, is itself, how it is coorded
                x.up = X
                x.X = x.top = X
                 a degree of slope (climb x.top)
                x.xq = xq = X.Xq.*.has.$xqt
                 xq.Xq = Xq = X.Xq.$Xqt
                 are the &Xstru and &Xthe x was created in
                 include some more index
                x.z are things here [r+]
                 these may provide an insider r&A?&X to mount r/*
                 eg J, having a commit X + X it might build + etc 
                  things may keep rowing from inside and out
                   forming with each other a diff pattern
                   might be T-d apart and together
                x.* (knowing x.Qt)
                are things in an x coordinated as above,
                 as distinct from ways to 
             we may %mot to el:2 the $hadnt
            
            x:had.wild.not = x:wild
             x:wild knowing pa.t=hadnt is not found
              track other x:wild from other $had (multix)
             onwards:
              x:wild.xs = [x:has]
           
           x..x:wild are things that break the type system of x
            yet include further Xspace anyway
            x:wild.t usu null|undef, may error code, have qua
             relatively against match for some reason,
              < indexed by reason, eg X.not_quite_sc.$scgk.$dist
                with the amount off.
                 these could be el-ish,
                  may compute from from several sc|etc
                   so it seems some y() -> ..x-positions
                    form the registers
                 or quanta, distance between
                to search for a blip of sound with such size|qua
                which we may then transcend the problem with,
                 by fading into another sound in the same key, etc
             how you can keep going is interesting
              usu relates to an el:2-ability being inferred
              what is needed to create, %feature magnets
             usu negate iteration through S o ...
              yet it may have a sense for whats going on
              S seeds the ways into creation
           to be able to have rows joining to rows,
            aligning or guessing through the index
          
         the thing arrives
               it could be stated as an emptiness (el:5?)
            which you mix into rows X
            at wildcarded X|x, row  the gap to yonder columns
             and mix in x as x-row selection,
              meta that the column 
           that you classify your way into,
            and mergeselect your way out of
           might often return the nearest selection to something
    =cut
    # context: Xk.i({t},{n})
    #  s.sc.$key=$value, along X..x, only ark usu xq.t
    #  c.n is what to est there
    # off the end of $x if provided
    #  is s.x, separate since s.* scooped into s.sc.*
    fi.qis = &acgtXoscx{
        $xq = o.xq
        s ||= {}
        c ||= {}
        # s.N might be either if array
        isar(s) and s = {N:s}
        else
        isar(c) and s.N = c; c = {}
        else
        # scoops s.* into s.sc.* if vague
        !s.N && !s.sc and s = {sc:s}
        # s.x = x to x..x
        x and s.x = x
        # s gets us there, c arrives with...
        
        $depth = xq.d
        $keys = xq.N || haks(xq.sc)
        s.N && s.N.length != keys.length and throw "key length"
        
        # while xq belongs to X,
        #  our notion of Xspace (where to build X.*)
        #  is subject to starting at $x,
        #   and xq.via.includes(x.xq)
        if (s.x) {
            $x = s.x
            !x.xq || !x.z and throw "s.x !x"
            !xq.via.includes(x.xq) and throw "s.x not via "+xq.t,{x,xq}
            $Xspace = x
        }
        else {
            $Xspace = X
        }
        # by name
        $index = Xspace[xq.t] ||= xq.array ? [] : {}
        $nx = index
        # the housing thinks everything is a key
        each ik keys {
            xq.N && s.N and $key = s.N[i]
            else
            s.sc and $key = s.sc[k]
            else {
                throw "qis() s.* vague", s
            }
            if (xq.array) {
                # arrefs: array allows keying by values, may uniquely
                $value = key
                nx != index and throw "array d>1"
                # mirror eg xq.t='ref'
                #  X.ref[vi]=x <-> X.refs[vi]=s
                $refst = oneor(xq,'refers', xq.t+'s')
                $refs = Xspace[refst] ||= []
                # corresponding array to hold x per value
                # < should probably index={refs[v+]<->ref[x+]}
                #   other array schemes|tools might live there
                $is = refs.indexOf(value)
                if (xq.refers && is >= 0) {
                    # uniquely, find same x
                    $vi = is
                }
                else {
                    # repeat, new x
                    $vi = refs.push(value)-1
                }
                $nex = nx[vi] ||= {}
                nx = nex
                
                # link many x by value
                if (is >= 0 && is < vi) {
                    $ox = nx[is]
                    # share array of same-valued x
                    # usu must join X.** with point-nested pointers
                    x.multix =
                    ox.multix ||= [ox]
                    x.multix.push(x)
                }
            }
            else {
                # may travel multiple layers of hashes
                !iskeyish(key) and throw "keying !string"
                $nex = nx[key] ||= {}
            }
            typeof nex != 'object' and throw "X{!object", {xq,i,key,keys,nx,nex}
            nx = nex
        }
        
        $x = nx
        # always:
        x.z ||= []
        x.up && x.up != Xspace and throw "x.up ~"
        x.xq && x.xq != xq and throw "x.xq ~"
        # < x.top? of a group of dimensiona
        x.up = Xspace
        x.xq = xq
        # < run into each other
        xq.lastq = q
        
        # magic relationising atoms (C)
        c.n and x.z.push(c.n)
        else {
            throw "no qis c to put"
        }
        
        # some x.t.$t.x.t.$t, which is 2* d=1
        #  carry on from x nowish, while playing loop with others
        #  indexing for things connected in this way and others
        #  here is where we climb X..x*..X between As
        #  and need to hang up a line to be able to call them back
        #  ie the self|other task
        return x
    }

# < see Bscape
A.1.t == 'Fish' and fi&live,J,s,ar

!A&lemonge and return
lemonge: %of:tails
  $here = 'lies'
  n here  $s:here %fs:20,hs:396

