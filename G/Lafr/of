// %of -> I.$of...
=pod
    how code compiles
    see Jay / Swim, which does the rest:
    you basically elvis $of(c&W=of)/*%of
     locally emobodying a W:$of with w:of
     and your result is the compiled same
    then you may store your bunch of them as a .js etc
    is basically compile time
     < if we were to load I from W (as &u does)
       we could use this again to do runtime init
       besides the underlying c&code = eval c&s
        on A:load (completes Q)
     < does /*<-%of mean group by %of? something needs to
    
=cut
each in s&z {
    $D = Cye(n);
    # server talks enj(n), dige here are for nc&s only
    # < put in osc, so Doming n->O, simpler than:
    #     before n <-> n&yDy&O <-> n&yO after
    #   and knowing what t come from what C
    Dy&n = n
    T.nN.push(D);
    Dc&of and continue
    
    me&ioty,D .length and throw "z", D
    !ny&toLines and throw "!lines", n
    
    # origin meta
    # < string part of &slabeline as blob geometry etc
    #  < its length|lines|dige parts as grouped other sc
    #   < io etc knowing %linecount etc may be there or made
    Ds&dige = dig(Dc&s);
    Ds&strinoge = Dc&s.split("\n").length
    
    $digl = dig(ny&toLines);
    $X = (1s&mem ||= {});
    $s = X[digl];
    if (s == null) {
        $Q = Cye([D.t,1,{of:'JaBabz',args:digl}]);
        $R;
        me.cby(n,&s{
            sy&R and return R = sy&R
        })
        !R and throw "canfindR"
        Qs&ghost = ny&toLines;
        ~>4 of-codes: J.t, D.t
        $w = me&t,R,Q;
        w and s = X[digl] = wc&s
    }
    if (s != null) {
        #~>4 of-coded: J.t, D.t
        Dc&s = "function (A,C,G,T,s) {\n"+s;
        !Dc&s.endsWith("\n") and Dc&s += "\n"
        Dc&s += "}\n";
        Ds&digs = dig(s);
        Dc&of = ns&of;
    }
    else {
        ac(A,'waits',D)
    }
}
# < osc grandiose waiting lang
a&waits and throw "async W:of", a&waits
=spec
The-ish
 -Bat
  < rename -The?
  < -Bat style Xc (necessary locators)
      include &X_possible
      click to wildcard things:
   < -Bat can move anywhere up to The (to refer to all Eight)
       eg dragging E0:-brackios up there
        should point to all -Eight**/-seven**/-brackios
         or nearby -sevens, etc
        and the -brackios/... -Eel might also:
    < wildcard things in Xc
       esp if amongst -Array
       it can probably switch to Xc.pi
      know how many would be selected if it was wildcarded
    < same &ifc form as &voice
 path
   local
    ^9:5/RiceDay 9 into the Pot//-brackios/whole/RiceDay%wou/4/sc/sustain/n/y/act
     one -brackios looking into another
     always goes up to -seven:5
     could:
      ^^-six"RiceDay 9 into the Pot"//-...4//%%Pot/...
       -six"cantitle" <= -six:cantitle
        esp if !&Lines_types.good_k safe for :$v expr
        this could take over diag style of C|J|A...
         T'not' could describe the impulse on it now
         A:such becomes A"such"
         '' => machiney property, not .t
         "" => human meaning, generally, ie .t
        perhaps W:pic/@known'suchness terms'
         @known could be a join to descriptions here
         showing pictures about 'suchness terms'
       //- <= //-brackios
        
        
        # some object-expr mean :$v is .t, eg C:eg
        #  further into arg-ish expr space
        #   which is steepest for /$such:later
       first ... <= /whole/"$1%wou"/
        ref-from ^-brackios knows 
       second ... <= sustain/n/y/act
        is the same as the ref-from
 ref
   < when looking at %%sustain at different times
     notice when ref revisits change hash|values
    < I.$of.$t.$cv mixer, iterator
      with join to others if not mixed
       as in A.1.I and A.n.I (RX for voicing for some bit of ground)
       and its only that you were doing A:n for J that A.1.I is set

&sustrain
  < &sustrain gang @Into ->
    see 'the related types it bursts into'
  < text parsing with &sustrain
    Aip for inf-anywhere-postable chunks**/bits**
     bits = EXPR | expr # javascript | stylehouse
    get some of the jsBabz over here,
     to watch the string change per rule
     could diff each time =~ matches even
     end up with list of rules it uses (BQ, $var, s&k etc)
     map where lines were added
      not many rules change the number of lines? each does...
      so any wjs diff can show mostly w
    so
     would end up with something openable
     -Text, in w:Text
      is therefore a big deal, like:
       < -The? not -Bat
       < -Story, which if empty will try to make up a story from around
       < -Travel
      < do we Line="\t-Travel" if Travel-Travel?
  
  &sustrain gang #spec
   going somewhere beautiful
    subjobbies, parallels
    together in &sustrain { t:y(i,v,a) + }
    
     the y start calling back,
     and should i(s,v,c,q) to germ new sustain
     or just return when they fail
      with a.pur() or not
       origin or here perspective?
       &hajasute could lend the &sustrain perspective
        to any h act
      
     write on n%Feature async
      writing on each other
      the subjob gives|winds quality
      %%sustain.ns&* == %%sustain,*
      attend
     
     each y
      calls i(...) for itself
       can be false|el10 overall (!v)
      then
       .such(...) abilities
        coulds, woulds, shoulds
         planting more y - something that can state + OK
        supposing they are per v
         or per whatever is rows tumbling through &sustrain
     
     so abilities could be per $t y(i,v,a)
      or per i(s,v,c,q) - fullfillment of that
       $v at the other side
      or per i(...).more(about that)
      
     
     when can n=%%sustain... be written on?
      has a %%rec traction
       
     
     they seem like the step controller for &supetime
      which has very proto that
     and almost a time-dimension sort-navigator for voice
   
    the related types it bursts into:
     nowernodewant
     await poise
      demand RunSteps for elIntro/%Steps/*
    may
     be translated to Ying | supe
     nodewant: &wants      | a.pur(...wants:n)
     await ?: &wants later | a.pur(...await:opportune)
     put stuff for RunSteps
      which has the way that is changing
       a knows how to get @Run to happen if @Inc doesnt
        potentially conscious operators all the way down
    
Inc|Pro|Run
  Inc: the A:load-ing bay, does @Intro
  Pro: provisions A** questing, &Ying_waits
  Run: does A** winding
  possibly the top level callback space
  they seem to use some basic %%Go to engage each other
  
  < @Ply of other This** may clue how to time around
     where the dependencies are
      eg any Eref pointed must be there
       perhaps the pointers might &t at some selfed thing
        then referencing from &t onward on the -Ness
         -Ness would have to -Lab that &t must be around
  
   < and hire @Pro to RunStep too
     bunch of &sustrain, valley apart
     the GStep %%Go -> PStep
      GStep ref $S to Fine/*
      PStep|@Pro grants time to &Sunpit|@Run++
       later one trip through &Sunpit
        as A:n, for eg w:Tut
       may take one (asyncing) or more (Esyncing) A:n
        as Step doability is interspersed with @Run++
        even when io iterating, might @Run++ somewhere per row
      and so,
      @Pro > @Run, gives it time
      @Run++ can occur as per hire,
       eg let it do this|that C a whole bunch
       is a much tighter loop
        going from 2 extra Ying trips per @Run++ to none
       see Aip|time about how Run++ can be arbitrary
        not always per Ying wake
        the runloop could be a while

all very %%Go, #spec
    @Intro and @Gnome have e:elIntro->&diffPs thinking
     @Intro for getting it to the first nodes
     @Gnome for sequencing the change into:
     @Inc then also, takes the change, and as always:
     @Pro thinks about what it could mean
      in some non-lossy way, with @Gnome mediation possible
     @Run takes something to believe now
    so
     @Gnome RunStep > @Pro RunStep
    %%Go valleys
     are they -Effect that do Y:Easy to arrive?
     and you are -Effected by the grant
     is a long term elvis
    -Effect elsewhere eg RunningStep wants a oncer
   is
    &Effect Go:gs,...
     gs = &sustain,...
      place for its own meta, relations
     both ... depend on where in:
   Story/Thingo
    Gump realises $t ood, hires:
    Gnome checks Story/$t, hires:
    Travel makes $t/@Cat and ... by dialectic
   
   a lot
   
   of that dialectic
   is ask-compulsiveness
    eg waiting for -Lab to ready before @Run
     so they might %%Go into @Run/The the first time
    eg letting @Story catch up now
     new kind of sanity check
     allowing reality to diffuse over there for a while
    or just letting it go for it
    as in winding or cranking up A&ov
     which in &Sunpit is some sort of Aip
   is ask
    its hirer knows
     eg poise, may be now
     eg nodewant, and then poise?
   
    gang - bunch of names that get known
     eg @Cat(/*), @Gnome(/*) via Names
     eg &sustrain c.$t+

A
 fits all the concepts to it
 I should know most of A
  or reality is thinning out, certs weaken

io
  a few grammars for classifying to a prototype to use
  like self-confidence for the computer language
  uses the universality of hierarchy
   ability to join disparate realities
  
  expr space
   flavours of loading up parameters:
   X/$suchindex=$someval
    bind $someval
    X climbs $suchindex
    Name this @suchindex
     may then be joined to later X/$suchindex
      but not later
   X/$suchindex:something
    bind $suchindex
     perhaps we know it is not a lexical at compile
    Name this @something
   X/@something
    
     perhaps derived from where the ark is sourced,
      ie the next example, where X/@something
     may be derived as the ark, ie X/@such
      may know how to index @such items, ie X/$nin=@such
       $nin <= $nodes_within
   C/@something
    joins C/* to those items
   C/$suchindex=$somewhere
    implying C//X/$suchindex=$somewhere
    the /$suchindex= gives it away?
   C/$item:something
    bind $item
    Name this @something
    normal
   
   and for &h calls:
     # the &h may be compiled out, as in me&directly
   &suchfunc,$item:something
    # was meaning bind $something as 'item'
    for I.i.suchfunc to interpret
     may 
   &suchfunc,$item=something
    set string
   fat&suchfunc
    fatal suchfunc, is I.fat.suchfunc
    as such, the&calls are for I.the@1
     &voice may know of calls via I.i.calls@6 etc
      # 6 looks like an o(utput) and an i(nput)
      #  an om+shape maker
   &suchfunc $item=$la
    named parameter for &suchfunc perspective
    is more futuristic, allows further expr:
     $item.aspect=$la
      and then breaking down a huge missing part of code:
   nesting lines within each other
    logic wants to cluster
   
   !bind $item
    eg in:
     C/$item=something
     &suchfunc,$item=something
    the $item is on the &suchfunc end
    forces code(ers) not knowing arg order,
     to space things out more
    
     esp in the looser sense
   they
    dont bind $item, that is just the expression for giving something to 
  
  tricks
   $eC = o ... # buy lexical
   o e)%C # implies s**->R** change
   o ... or return # does that
     similar to avoiding further expr once empty

codes
 spec
  what this is
   indents matter
    may indented thusly
     refers to some potential of the former
    thenceward lines elabourate
     on the matter it is in
    perhaps is something we are not sure about yet
     a possible feature, maybe outlandish
     may break the language (truth) around it
    
   cleverness of the expr
    should stay at some low level
    be as supersensible as the situation wants
    yet be available from general sense
     eg the previous 7-chunk =~ /matter/
      # orthogonal awareness, perhaps of itself
       btw (another orthogonal, out of codes / spec)
        -chunk can have a diag|expr style of its own:
         the number in front means yay many lines (geo)
         pi in front, number is either:
          Aip:chunk: -chunk@3.24.2
           may climb slope to @3
            or @3 may be a geometry (lang dependent)
   
   refers to itself
    spec / refers / spec is where we are now
     if the latter 'spec wants to be longer'
    see &suchfunc / if $n
     approximate chunk of &suchfunc to look at
   
   terse <= large implied expr
    a compression
    also, a todo item:
    < D encoding could be made of these
   thing => its properties
    an expansion
    < compiler as nested these
       ie take meaning => in,forms  =>  action => of,forms
       opportuning into certain definable idealisms
        deep within meaning (of some complicated expression)
       eg detect specific dialect|feature and adjust the how
        eg $thing = o suchness
         needs to pick ays&thing|s out of suchness
          suchness may itself be io, &Sharg, etc
           eg &Sharg would add .N[0] to pluck result
   
   marks a frontier:
    all the beyond of which is <
   <<<
 drugs
  stuff people have written on various drugs
   some of which can describe quite clearly
    how to build the universe etc
    handy knowledge to have
  -> trippy visuals
   the universaliser
 stylehouse
  raku -> raku
 stylehut
  what raku compiles -> js
  superset of:
 styleshed
  what &JaBabz compiles -> js
  mostly compatible with &CoBabbler ( -> perl)
trifecta
 lum
  dim the light of the mind
   is a good way. see Huxley / reducing valve
  turning down|up the intensity of information
  here|there|how
 cyc
  global winding through Cy&* topics etc
   highly educational background effigies that
 fig
  pronounced "effigy"
  background processes sync with your foreground
  foreground being Story/*
   eg wandering through Codo**,
    linked code showing in fig:is
=cut
