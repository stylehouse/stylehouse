// %of -> I.$of...
=pod
    how code compiles
    see Jay / Swim, which does the rest:
    you basically elvis $of(c&W=of)/*%of
     locally emobodying a W:$of with w:of
     and your result is the compiled same
    then you may store your bunch of them as a .js etc
    is basically compile time
     < if we were to load I from W (as &u does)
       we could use this again to do runtime init
       besides the underlying c&code = eval c&s
        on A:load (completes Q)
     < does /*<-%of mean group by %of? something needs to
    
=cut
each in s&z {
    $D = Cye(n);
    # server talks enj(n), dige here are for nc&s only
    # < put in osc, so Doming n->O, simpler than:
    #     before n <-> n&yDy&O <-> n&yO after
    #   and knowing what t come from what C
    Dy&n = n
    T.nN.push(D);
    Dc&of and continue
    
    me&ioty,D .length and throw "z", D
    !ny&toLines and throw "!lines", n
    
    # origin meta
    # < string part of &slabeline as blob geometry etc
    #  < its length|lines|dige parts as grouped other sc
    #   < io etc knowing %linecount etc may be there or made
    Ds&dige = dig(Dc&s);
    Ds&strinoge = Dc&s.split("\n").length
    
    $digl = dig(ny&toLines);
    $X = (1s&mem ||= {});
    $s = X[digl];
    if (s == null) {
        $Q = Cye([D.t,1,{of:'JaBabz',args:digl}]);
        $R;
        me.cby(n,&s{
            sy&R and return R = sy&R
        })
        !R and throw "canfindR"
        Qs&ghost = ny&toLines;
        ~>4 of-codes: J.t, D.t
        $w = me&t,R,Q;
        w and s = X[digl] = wc&s
    }
    if (s != null) {
        #~>4 of-coded: J.t, D.t
        Dc&s = "function (A,C,G,T,s) {\n"+s;
        !Dc&s.endsWith("\n") and Dc&s += "\n"
        Dc&s += "}\n";
        Ds&digs = dig(s);
        Dc&of = ns&of;
    }
    else {
        ac(A,'waits',D)
    }
}
# < osc grandiose waiting lang
a&waits and throw "async W:of", a&waits
=spec
The-ish
 -Bat
  < rename -The?
  < -Bat style Xc (necessary locators)
      include &X_possible
      click to wildcard things:
   < -Bat can move anywhere up to The (to refer to all Eight)
       eg dragging E0:-brackios up there
        should point to all -Eight**/-seven**/-brackios
         or nearby -sevens, etc
        and the -brackios/... -Eel might also:
    < wildcard things in Xc
       esp if amongst -Array
       it can probably switch to Xc.pi
      know how many would be selected if it was wildcarded
    < same &ifc form as &voice
 ref
   < when looking at %%sustain at different times
     notice when ref revisits change hash|values
    < I.$of.$t.$cv mixer, iterator
      with join to others if not mixed
       as in A.1.I and A.n.I (RX for voicing for some bit of ground)
       and its only that you were doing A:n for J that A.1.I is set

&sustrain
  < &sustrain gang @Into ->
    see 'the related types it bursts into'
  < text parsing with &sustrain
    Aip for inf-anywhere-postable chunks**/bits**
     bits = EXPR | expr # javascript | stylehouse
    get some of the jsBabz over here,
     to watch the string change per rule
     could diff each time =~ matches even
     end up with list of rules it uses (BQ, $var, s&k etc)
     map where lines were added
      not many rules change the number of lines? each does...
      so any wjs diff can show mostly w
    so
     would end up with something openable
     -Text, in w:Text
      is therefore a big deal, like:
       < -The? not -Bat
       < -Story, which if empty will try to make up a story from around
       < -Travel
      < do we Line="\t-Travel" if Travel-Travel?
  
  &sustrain gang #spec
   going somewhere beautiful
    subjobbies, parallels
    together in &sustrain { t:y(i,v,a) + }
    
     the y start calling back,
     and should i(s,v,c,q) to germ new sustain
     or just return when they fail
      with a.pur() or not
       origin or here perspective?
       &hajasute could lend the &sustrain perspective
        to any h act
      
     write on n%Feature async
      writing on each other
      the subjob gives|winds quality
      %%sustain.ns&* == %%sustain,*
      attend
     
     each y
      calls i(...) for itself
       can be false|el10 overall (!v)
      then
       .such(...) abilities
        coulds, woulds, shoulds
         planting more y - something that can state + OK
        supposing they are per v
         or per whatever is rows tumbling through &sustrain
     
     so abilities could be per $t y(i,v,a)
      or per i(s,v,c,q) - fullfillment of that
       $v at the other side
      or per i(...).more(about that)
      
     
     when can n=%%sustain... be written on?
      has a %%rec traction
       
     
     they seem like the step controller for &supetime
      which has very proto that
     and almost a time-dimension sort-navigator for voice
   
    the related types it bursts into:
     nowernodewant
     await poise
      demand RunSteps for elIntro/%Steps/*
    may
     be translated to Ying | supe
     nodewant: &wants      | a.pur(...wants:n)
     await ?: &wants later | a.pur(...await:opportune)
     put stuff for RunSteps
      which has the way that is changing
       a knows how to get @Run to happen if @Inc doesnt
        potentially conscious operators all the way down
    
Inc|Pro|Run
  Inc: the A:load-ing bay, does @Intro
  Pro: provisions A** questing, &Ying_waits
  Run: does A** winding
  possibly the top level callback space
  they seem to use some basic %%Go to engage each other
  
  < @Ply of other This** may clue how to time around
     where the dependencies are
      eg any Eref pointed must be there
       perhaps the pointers might &t at some selfed thing
        then referencing from &t onward on the -Ness
         -Ness would have to -Lab that &t must be around
  
   < and hire @Pro to RunStep too
     bunch of &sustrain, valley apart
     the GStep %%Go -> PStep
      GStep ref $S to Fine/*
      PStep|@Pro grants time to &Sunpit|@Run++
       later one trip through &Sunpit
        as A:n, for eg w:Tut
       may take one (asyncing) or more (Esyncing) A:n
        as Step doability is interspersed with @Run++
        even when io iterating, might @Run++ somewhere per row
      and so,
      @Pro > @Run, gives it time
      @Run++ can occur as per hire,
       eg let it do this|that C a whole bunch
       is a much tighter loop
        going from 2 extra Ying trips per @Run++ to none
       see Aip|time about how Run++ can be arbitrary
        not always per Ying wake
        the runloop could be a while

all very %%Go, #spec
    @Intro and @Gnome have e:elIntro->&diffPs thinking
     @Intro for getting it to the first nodes
     @Gnome for sequencing the change into:
     @Inc then also, takes the change, and as always:
     @Pro thinks about what it could mean
      in some non-lossy way, with @Gnome mediation possible
     @Run takes something to believe now
    so
     @Gnome RunStep > @Pro RunStep
    %%Go valleys
     are they -Effect that do Y:Easy to arrive?
     and you are -Effected by the grant
     is a long term elvis
    -Effect elsewhere eg RunningStep wants a oncer
   is
    &Effect Go:gs,...
     gs = &sustain,...
      place for its own meta, relations
     both ... depend on where in:
   Story/Thingo
    Gump realises $t ood, hires:
    Gnome checks Story/$t, hires:
    Travel makes $t/@Cat and ... by dialectic
   
   a lot
   
   of that dialectic
   is ask-compulsiveness
    eg waiting for -Lab to ready before @Run
     so they might %%Go into @Run/The the first time
    eg letting @Story catch up now
     new kind of sanity check
     allowing reality to diffuse over there for a while
    or just letting it go for it
    as in winding or cranking up A&ov
     which in &Sunpit is some sort of Aip
   is ask
    its hirer knows
     eg poise, may be now
     eg nodewant, and then poise?
   
    gang - bunch of names that get known
     eg @Cat(/*), @Gnome(/*) via Names
     eg &sustrain c.$t+

io
  a few grammars for classifying to a prototype to use
  
  tricks
   $eC = o ... # buy lexical
   o e)%C # implies s**->R** change
   o ... or return # does that
     similar to avoiding further expr once empty

=cut
