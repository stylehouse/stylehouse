// %of -> I.$of...
=pod
    how code compiles
    see Jay / Swim, which does the rest:
    you basically elvis $of(c&W=of)/*%of
     locally emobodying a W:$of with w:of
     and your result is the compiled same
    then you may store your bunch of them as a .js etc
    is basically compile time
     < if we were to load I from W (as &u does)
       we could use this again to do runtime init
       besides the underlying c&code = eval c&s
        on A:load (completes Q)
     < does /*<-%of mean group by %of? something needs to
    
=cut
each in s&z {
    $D = Cye(n);
    # server talks enj(n), dige here are for nc&s only
    # < put in osc, so Doming n->O, simpler than:
    #     before n <-> n&yDy&O <-> n&yO after
    #   and knowing what t come from what C
    Dy&n = n
    T.nN.push(D);
    Dc&of and continue
    
    me&ioty,D .length and throw "z", D
    !ny&toLines and throw "!lines", n
    
    # origin meta
    # < string part of &slabeline as blob geometry etc
    #  < its length|lines|dige parts as grouped other sc
    #   < io etc knowing %linecount etc may be there or made
    Ds&dige = dig(Dc&s);
    Ds&strinoge = Dc&s.split("\n").length
    
    $digl = dig(ny&toLines);
    $X = (1s&mem ||= {});
    $s = X[digl];
    if (s == null) {
        $Q = Cye([D.t,1,{of:'JaBabz',args:digl}]);
        $R;
        me.cby(n,&s{
            sy&R and return R = sy&R
        })
        !R and throw "canfindR"
        Qs&ghost = ny&toLines;
        ~>4 of-codes: J.t, D.t
        $w = me&t,R,Q;
        w and s = X[digl] = wc&s
    }
    if (s != null) {
        #~>4 of-coded: J.t, D.t
        Dc&s = "function (A,C,G,T,s) {\n"+s;
        !Dc&s.endsWith("\n") and Dc&s += "\n"
        Dc&s += "}\n";
        Ds&digs = dig(s);
        Dc&of = ns&of;
    }
    else {
        ac(A,'waits',D)
    }
}
# < osc grandiose waiting lang
a&waits and throw "async W:of", a&waits
